// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformfvNative(uint program, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[160])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[160])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformfv(uint program, int location, float* @params)
		{
			GetUniformfvNative(program, location, @params);
		}

		public static void GetUniformfv(uint program, int location, out float @params)
		{
			float pparams;
			GetUniformfvNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformfv(uint program, int location, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetUniformfvNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformivNative(uint program, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[161])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[161])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformiv(uint program, int location, int* @params)
		{
			GetUniformivNative(program, location, @params);
		}

		public static void GetUniformiv(uint program, int location, out int @params)
		{
			int pparams;
			GetUniformivNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformiv(uint program, int location, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetUniformivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformuivNative(uint program, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[162])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[162])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformuiv(uint program, int location, uint* @params)
		{
			GetUniformuivNative(program, location, @params);
		}

		public static void GetUniformuiv(uint program, int location, out uint @params)
		{
			uint pparams;
			GetUniformuivNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformuiv(uint program, int location, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetUniformuivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIivNative(uint index, GLVertexAttribEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, int*, void>)funcTable[163])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[163])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, int* @params)
		{
			GetVertexAttribIivNative(index, pname, @params);
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, out int @params)
		{
			int pparams;
			GetVertexAttribIivNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribIivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIuivNative(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, uint*, void>)funcTable[164])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[164])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			GetVertexAttribIuivNative(index, pname, @params);
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, out uint @params)
		{
			uint pparams;
			GetVertexAttribIuivNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetVertexAttribIuivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[165])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[165])(index, pname, (nint)pointer);
			#endif
		}

		public static void GetVertexAttribPointerv(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[166])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[166])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvNative(index, pname, @params);
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[167])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[167])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvNative(index, pname, @params);
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, out float @params)
		{
			float pparams;
			GetVertexAttribfvNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetVertexAttribfvNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[168])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[168])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivNative(index, pname, @params);
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, out int @params)
		{
			int pparams;
			GetVertexAttribivNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HintNative(GLHintTarget target, GLHintMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[169])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[169])(target, mode);
			#endif
		}

		public static void Hint(GLHintTarget target, GLHintMode mode)
		{
			HintNative(target, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[170])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[170])(buffer);
			#endif
		}

		public static bool IsBuffer(uint buffer)
		{
			byte ret = IsBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnabledNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[171])(cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[171])(cap);
			#endif
		}

		public static bool IsEnabled(GLEnableCap cap)
		{
			byte ret = IsEnabledNative(cap);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnablediNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[172])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[172])(target, index);
			#endif
		}

		public static bool IsEnabledi(GLEnableCap target, uint index)
		{
			byte ret = IsEnablediNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFramebufferNative(uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[173])(framebuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[173])(framebuffer);
			#endif
		}

		public static bool IsFramebuffer(uint framebuffer)
		{
			byte ret = IsFramebufferNative(framebuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[174])(program);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[174])(program);
			#endif
		}

		public static bool IsProgram(uint program)
		{
			byte ret = IsProgramNative(program);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQueryNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[175])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[175])(id);
			#endif
		}

		public static bool IsQuery(uint id)
		{
			byte ret = IsQueryNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsRenderbufferNative(uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[176])(renderbuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[176])(renderbuffer);
			#endif
		}

		public static bool IsRenderbuffer(uint renderbuffer)
		{
			byte ret = IsRenderbufferNative(renderbuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSamplerNative(uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[177])(sampler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[177])(sampler);
			#endif
		}

		public static bool IsSampler(uint sampler)
		{
			byte ret = IsSamplerNative(sampler);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[178])(shader);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[178])(shader);
			#endif
		}

		public static bool IsShader(uint shader)
		{
			byte ret = IsShaderNative(shader);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[179])(sync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[179])(sync);
			#endif
		}

		public static bool IsSync(GLSync sync)
		{
			byte ret = IsSyncNative(sync);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[180])(texture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[180])(texture);
			#endif
		}

		public static bool IsTexture(uint texture)
		{
			byte ret = IsTextureNative(texture);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[181])(array);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[181])(array);
			#endif
		}

		public static bool IsVertexArray(uint array)
		{
			byte ret = IsVertexArrayNative(array);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineWidthNative(float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[182])(width);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[182])(width);
			#endif
		}

		public static void LineWidth(float width)
		{
			LineWidthNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LinkProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[183])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[183])(program);
			#endif
		}

		public static void LinkProgram(uint program)
		{
			LinkProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogicOpNative(GLLogicOp opcode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[184])(opcode);
			#else
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[184])(opcode);
			#endif
		}

		public static void LogicOp(GLLogicOp opcode)
		{
			LogicOpNative(opcode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferNative(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, void*>)funcTable[185])(target, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, nint>)funcTable[185])(target, access);
			#endif
		}

		public static void* MapBuffer(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			void* ret = MapBufferNative(target, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferRangeNative(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, void*>)funcTable[186])(target, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, nint>)funcTable[186])(target, offset, length, access);
			#endif
		}

		public static void* MapBufferRange(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapBufferRangeNative(target, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysNative(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, int*, int, void>)funcTable[187])(mode, first, count, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, void>)funcTable[187])(mode, (nint)first, (nint)count, drawcount);
			#endif
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			MultiDrawArraysNative(mode, first, count, drawcount);
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, ref int first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, Span<int> count, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, ref int count, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, Span<int> count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				fixed (int* pcount1 = count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, ref int first, ref int count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				fixed (int* pcount1 = &count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, void>)funcTable[188])(mode, count, type, indices, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, void>)funcTable[188])(mode, (nint)count, type, (nint)indices, drawcount);
			#endif
		}

		public static void MultiDrawElements(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			MultiDrawElementsNative(mode, count, type, indices, drawcount);
		}

		public static void MultiDrawElements(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		public static void MultiDrawElements(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsBaseVertexNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, int*, void>)funcTable[189])(mode, count, type, indices, drawcount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, nint, void>)funcTable[189])(mode, (nint)count, type, (nint)indices, drawcount, (nint)basevertex);
			#endif
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, basevertex);
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pbasevertex0 = basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pbasevertex0 = &basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pcount0 = count)
			{
				fixed (int* pbasevertex1 = basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (int* pbasevertex1 = &basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelStorefNative(GLPixelStoreParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[190])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[190])(pname, param);
			#endif
		}

		public static void PixelStoref(GLPixelStoreParameter pname, float param)
		{
			PixelStorefNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelStoreiNative(GLPixelStoreParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[191])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[191])(pname, param);
			#endif
		}

		public static void PixelStorei(GLPixelStoreParameter pname, int param)
		{
			PixelStoreiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterfNative(GLPointParameterNameARB pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[192])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[192])(pname, param);
			#endif
		}

		public static void PointParameterf(GLPointParameterNameARB pname, float param)
		{
			PointParameterfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterfvNative(GLPointParameterNameARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float*, void>)funcTable[193])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[193])(pname, (nint)@params);
			#endif
		}

		public static void PointParameterfv(GLPointParameterNameARB pname, float* @params)
		{
			PointParameterfvNative(pname, @params);
		}

		public static void PointParameterfv(GLPointParameterNameARB pname, out float @params)
		{
			float pparams;
			PointParameterfvNative(pname, &pparams);
			@params = pparams;
		}

		public static void PointParameterfv(GLPointParameterNameARB pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				PointParameterfvNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameteriNative(GLPointParameterNameARB pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[194])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[194])(pname, param);
			#endif
		}

		public static void PointParameteri(GLPointParameterNameARB pname, int param)
		{
			PointParameteriNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterivNative(GLPointParameterNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int*, void>)funcTable[195])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[195])(pname, (nint)@params);
			#endif
		}

		public static void PointParameteriv(GLPointParameterNameARB pname, int* @params)
		{
			PointParameterivNative(pname, @params);
		}

		public static void PointParameteriv(GLPointParameterNameARB pname, out int @params)
		{
			int pparams;
			PointParameterivNative(pname, &pparams);
			@params = pparams;
		}

		public static void PointParameteriv(GLPointParameterNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				PointParameterivNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointSizeNative(float size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[196])(size);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[196])(size);
			#endif
		}

		public static void PointSize(float size)
		{
			PointSizeNative(size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonModeNative(GLTriangleFace face, GLPolygonMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[197])(face, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[197])(face, mode);
			#endif
		}

		public static void PolygonMode(GLTriangleFace face, GLPolygonMode mode)
		{
			PolygonModeNative(face, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonOffsetNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[198])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[198])(factor, units);
			#endif
		}

		public static void PolygonOffset(float factor, float units)
		{
			PolygonOffsetNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PrimitiveRestartIndexNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[199])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[199])(index);
			#endif
		}

		public static void PrimitiveRestartIndex(uint index)
		{
			PrimitiveRestartIndexNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProvokingVertexNative(GLVertexProvokingMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexProvokingMode, void>)funcTable[200])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexProvokingMode, void>)funcTable[200])(mode);
			#endif
		}

		public static void ProvokingVertex(GLVertexProvokingMode mode)
		{
			ProvokingVertexNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QueryCounterNative(uint id, GLQueryCounterTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryCounterTarget, void>)funcTable[201])(id, target);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryCounterTarget, void>)funcTable[201])(id, target);
			#endif
		}

		public static void QueryCounter(uint id, GLQueryCounterTarget target)
		{
			QueryCounterNative(id, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadBufferNative(GLReadBufferMode src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, void>)funcTable[202])(src);
			#else
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, void>)funcTable[202])(src);
			#endif
		}

		public static void ReadBuffer(GLReadBufferMode src)
		{
			ReadBufferNative(src);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadPixelsNative(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[203])(x, y, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[203])(x, y, width, height, format, type, (nint)pixels);
			#endif
		}

		public static void ReadPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			ReadPixelsNative(x, y, width, height, format, type, pixels);
		}

		public static void ReadPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			ReadPixelsNative(x, y, width, height, format, type, (void*)pixels);
		}

		public static void ReadPixels<TPixels>(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				ReadPixelsNative(x, y, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderbufferStorageNative(GLRenderbufferTarget target, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLInternalFormat, int, int, void>)funcTable[204])(target, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLInternalFormat, int, int, void>)funcTable[204])(target, internalformat, width, height);
			#endif
		}

		public static void RenderbufferStorage(GLRenderbufferTarget target, GLInternalFormat internalformat, int width, int height)
		{
			RenderbufferStorageNative(target, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderbufferStorageMultisampleNative(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[205])(target, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[205])(target, samples, internalformat, width, height);
			#endif
		}

		public static void RenderbufferStorageMultisample(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			RenderbufferStorageMultisampleNative(target, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SampleCoverageNative(float value, bool invert)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, byte, void>)funcTable[206])(value, *((byte*)(&invert)));
			#else
			((delegate* unmanaged[Cdecl]<float, byte, void>)funcTable[206])(value, *((byte*)(&invert)));
			#endif
		}

		public static void SampleCoverage(float value, bool invert)
		{
			SampleCoverageNative(value, invert);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SampleMaskiNative(uint maskNumber, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[207])(maskNumber, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[207])(maskNumber, mask);
			#endif
		}

		public static void SampleMaski(uint maskNumber, uint mask)
		{
			SampleMaskiNative(maskNumber, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameterIivNative(uint sampler, GLSamplerParameterI pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[208])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[208])(sampler, pname, (nint)param);
			#endif
		}

		public static void SamplerParameterIiv(uint sampler, GLSamplerParameterI pname, int* param)
		{
			SamplerParameterIivNative(sampler, pname, param);
		}

		public static void SamplerParameterIiv(uint sampler, GLSamplerParameterI pname, out int param)
		{
			int pparam;
			SamplerParameterIivNative(sampler, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameterIuivNative(uint sampler, GLSamplerParameterI pname, uint* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[209])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[209])(sampler, pname, (nint)param);
			#endif
		}

		public static void SamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, uint* param)
		{
			SamplerParameterIuivNative(sampler, pname, param);
		}

		public static void SamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, out uint param)
		{
			uint pparam;
			SamplerParameterIuivNative(sampler, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameterfNative(uint sampler, GLSamplerParameterF pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float, void>)funcTable[210])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float, void>)funcTable[210])(sampler, pname, param);
			#endif
		}

		public static void SamplerParameterf(uint sampler, GLSamplerParameterF pname, float param)
		{
			SamplerParameterfNative(sampler, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameterfvNative(uint sampler, GLSamplerParameterF pname, float* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float*, void>)funcTable[211])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, nint, void>)funcTable[211])(sampler, pname, (nint)param);
			#endif
		}

		public static void SamplerParameterfv(uint sampler, GLSamplerParameterF pname, float* param)
		{
			SamplerParameterfvNative(sampler, pname, param);
		}

		public static void SamplerParameterfv(uint sampler, GLSamplerParameterF pname, out float param)
		{
			float pparam;
			SamplerParameterfvNative(sampler, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameteriNative(uint sampler, GLSamplerParameterI pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int, void>)funcTable[212])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int, void>)funcTable[212])(sampler, pname, param);
			#endif
		}

		public static void SamplerParameteri(uint sampler, GLSamplerParameterI pname, int param)
		{
			SamplerParameteriNative(sampler, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameterivNative(uint sampler, GLSamplerParameterI pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[213])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[213])(sampler, pname, (nint)param);
			#endif
		}

		public static void SamplerParameteriv(uint sampler, GLSamplerParameterI pname, int* param)
		{
			SamplerParameterivNative(sampler, pname, param);
		}

		public static void SamplerParameteriv(uint sampler, GLSamplerParameterI pname, out int param)
		{
			int pparam;
			SamplerParameterivNative(sampler, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[214])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[214])(x, y, width, height);
			#endif
		}

		public static void Scissor(int x, int y, int width, int height)
		{
			ScissorNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShaderSourceNative(uint shader, int count, byte** str, int* length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, int*, void>)funcTable[215])(shader, count, str, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[215])(shader, count, (nint)str, (nint)length);
			#endif
		}

		public static void ShaderSource(uint shader, int count, byte** str, int* length)
		{
			ShaderSourceNative(shader, count, str, length);
		}

		public static void ShaderSource(uint shader, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShaderSourceNative(shader, 1, &pStr0, &pStrSize0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ShaderSource(uint shader, string[] sources)
		{
			byte** pStrArray0 = null;
			int* pStrArraySizes0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(sources) + sources.Length * sizeof(int);
			if (sources != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArraySizes0 = (int*)Utils.Alloc<int>(sources.Length);
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArraySizesStack0 = stackalloc byte[sources.Length * sizeof(int)];
					pStrArraySizes0 = (int*)pStrArraySizesStack0;
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < sources.Length; i++)
			{
				pStrArraySizes0[i] = Utils.GetByteCountUTF8(sources[i]);
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(sources[i]);
			}
			ShaderSourceNative(shader, sources.Length, pStrArray0, pStrArraySizes0);
			for (int i = 0; i < sources.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
				Utils.Free(pStrArraySizes0);
			}
		}

		public static void ShaderSource(uint shader, int count, byte** str, Span<int> length)
		{
			fixed (int* plength0 = length)
			{
				ShaderSourceNative(shader, count, str, plength0);
			}
		}

		public static void ShaderSource(uint shader, int count, byte** str, ref int length)
		{
			fixed (int* plength0 = &length)
			{
				ShaderSourceNative(shader, count, str, plength0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFuncNative(GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[216])(func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[216])(func, reference, mask);
			#endif
		}

		public static void StencilFunc(GLStencilFunction func, int reference, uint mask)
		{
			StencilFuncNative(func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFuncSeparateNative(GLTriangleFace face, GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilFunction, int, uint, void>)funcTable[217])(face, func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilFunction, int, uint, void>)funcTable[217])(face, func, reference, mask);
			#endif
		}

		public static void StencilFuncSeparate(GLTriangleFace face, GLStencilFunction func, int reference, uint mask)
		{
			StencilFuncSeparateNative(face, func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[218])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[218])(mask);
			#endif
		}

		public static void StencilMask(uint mask)
		{
			StencilMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilMaskSeparateNative(GLTriangleFace face, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, uint, void>)funcTable[219])(face, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, uint, void>)funcTable[219])(face, mask);
			#endif
		}

		public static void StencilMaskSeparate(GLTriangleFace face, uint mask)
		{
			StencilMaskSeparateNative(face, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilOpNative(GLStencilOp fail, GLStencilOp zfail, GLStencilOp zpass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[220])(fail, zfail, zpass);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[220])(fail, zfail, zpass);
			#endif
		}

		public static void StencilOp(GLStencilOp fail, GLStencilOp zfail, GLStencilOp zpass)
		{
			StencilOpNative(fail, zfail, zpass);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilOpSeparateNative(GLTriangleFace face, GLStencilOp sfail, GLStencilOp dpfail, GLStencilOp dppass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[221])(face, sfail, dpfail, dppass);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[221])(face, sfail, dpfail, dppass);
			#endif
		}

		public static void StencilOpSeparate(GLTriangleFace face, GLStencilOp sfail, GLStencilOp dpfail, GLStencilOp dppass)
		{
			StencilOpSeparateNative(face, sfail, dpfail, dppass);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexBufferNative(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[222])(target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[222])(target, internalformat, buffer);
			#endif
		}

		public static void TexBuffer(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			TexBufferNative(target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[223])(target, level, internalformat, width, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[223])(target, level, internalformat, width, border, format, type, (nint)pixels);
			#endif
		}

		public static void TexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexImage1DNative(target, level, internalformat, width, border, format, type, pixels);
		}

		public static void TexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexImage1DNative(target, level, internalformat, width, border, format, type, (void*)pixels);
		}

		public static void TexImage1D<TPixels>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexImage1DNative(target, level, internalformat, width, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[224])(target, level, internalformat, width, height, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[224])(target, level, internalformat, width, height, border, format, type, (nint)pixels);
			#endif
		}

		public static void TexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexImage2DNative(target, level, internalformat, width, height, border, format, type, pixels);
		}

		public static void TexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexImage2DNative(target, level, internalformat, width, height, border, format, type, (void*)pixels);
		}

		public static void TexImage2D<TPixels>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexImage2DNative(target, level, internalformat, width, height, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexImage2DMultisampleNative(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, byte, void>)funcTable[225])(target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, byte, void>)funcTable[225])(target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		public static void TexImage2DMultisample(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			TexImage2DMultisampleNative(target, samples, internalformat, width, height, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexImage3DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[226])(target, level, internalformat, width, height, depth, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[226])(target, level, internalformat, width, height, depth, border, format, type, (nint)pixels);
			#endif
		}

		public static void TexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexImage3DNative(target, level, internalformat, width, height, depth, border, format, type, pixels);
		}

		public static void TexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexImage3DNative(target, level, internalformat, width, height, depth, border, format, type, (void*)pixels);
		}

		public static void TexImage3D<TPixels>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexImage3DNative(target, level, internalformat, width, height, depth, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexImage3DMultisampleNative(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, byte, void>)funcTable[227])(target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, byte, void>)funcTable[227])(target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		public static void TexImage3DMultisample(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			TexImage3DMultisampleNative(target, samples, internalformat, width, height, depth, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterIivNative(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[228])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[228])(target, pname, (nint)@params);
			#endif
		}

		public static void TexParameterIiv(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TexParameterIivNative(target, pname, @params);
		}

		public static void TexParameterIiv(GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			TexParameterIivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void TexParameterIiv(GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TexParameterIivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterIuivNative(GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[229])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[229])(target, pname, (nint)@params);
			#endif
		}

		public static void TexParameterIuiv(GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			TexParameterIuivNative(target, pname, @params);
		}

		public static void TexParameterIuiv(GLTextureTarget target, GLTextureParameterName pname, out uint @params)
		{
			uint pparams;
			TexParameterIuivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void TexParameterIuiv(GLTextureTarget target, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				TexParameterIuivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterfNative(GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, float, void>)funcTable[230])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, float, void>)funcTable[230])(target, pname, param);
			#endif
		}

		public static void TexParameterf(GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			TexParameterfNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterfvNative(GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, float*, void>)funcTable[231])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[231])(target, pname, (nint)@params);
			#endif
		}

		public static void TexParameterfv(GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			TexParameterfvNative(target, pname, @params);
		}

		public static void TexParameterfv(GLTextureTarget target, GLTextureParameterName pname, out float @params)
		{
			float pparams;
			TexParameterfvNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void TexParameterfv(GLTextureTarget target, GLTextureParameterName pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				TexParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameteriNative(GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int, void>)funcTable[232])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int, void>)funcTable[232])(target, pname, param);
			#endif
		}

		public static void TexParameteri(GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			TexParameteriNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterivNative(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[233])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[233])(target, pname, (nint)@params);
			#endif
		}

		public static void TexParameteriv(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TexParameterivNative(target, pname, @params);
		}

		public static void TexParameteriv(GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			TexParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void TexParameteriv(GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TexParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[234])(target, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[234])(target, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		public static void TexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage1DNative(target, level, xoffset, width, format, type, pixels);
		}

		public static void TexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage1DNative(target, level, xoffset, width, format, type, (void*)pixels);
		}

		public static void TexSubImage1D<TPixels>(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage1DNative(target, level, xoffset, width, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[235])(target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[235])(target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		public static void TexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		public static void TexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
		}

		public static void TexSubImage2D<TPixels>(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[236])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[236])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		public static void TexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		public static void TexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
		}

		public static void TexSubImage3D<TPixels>(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformFeedbackVaryingsNative(uint program, int count, byte** varyings, GLTransformFeedbackBufferMode bufferMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, GLTransformFeedbackBufferMode, void>)funcTable[237])(program, count, varyings, bufferMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, GLTransformFeedbackBufferMode, void>)funcTable[237])(program, count, (nint)varyings, bufferMode);
			#endif
		}

		public static void TransformFeedbackVaryings(uint program, int count, byte** varyings, GLTransformFeedbackBufferMode bufferMode)
		{
			TransformFeedbackVaryingsNative(program, count, varyings, bufferMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1fNative(int location, float v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[238])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[238])(location, v0);
			#endif
		}

		public static void Uniform1f(int location, float v0)
		{
			Uniform1fNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[239])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[239])(location, count, (nint)value);
			#endif
		}

		public static void Uniform1fv(int location, int count, float* value)
		{
			Uniform1fvNative(location, count, value);
		}

		public static void Uniform1fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform1fvNative(location, count, pvalue0);
			}
		}

		public static void Uniform1fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform1fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1iNative(int location, int v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[240])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[240])(location, v0);
			#endif
		}

		public static void Uniform1i(int location, int v0)
		{
			Uniform1iNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[241])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[241])(location, count, (nint)value);
			#endif
		}

		public static void Uniform1iv(int location, int count, int* value)
		{
			Uniform1ivNative(location, count, value);
		}

		public static void Uniform1iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform1ivNative(location, count, pvalue0);
			}
		}

		public static void Uniform1iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform1ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1uiNative(int location, uint v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, void>)funcTable[242])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, void>)funcTable[242])(location, v0);
			#endif
		}

		public static void Uniform1ui(int location, uint v0)
		{
			Uniform1uiNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[243])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[243])(location, count, (nint)value);
			#endif
		}

		public static void Uniform1uiv(int location, int count, uint* value)
		{
			Uniform1uivNative(location, count, value);
		}

		public static void Uniform1uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform1uivNative(location, count, pvalue0);
			}
		}

		public static void Uniform1uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform1uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2fNative(int location, float v0, float v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[244])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[244])(location, v0, v1);
			#endif
		}

		public static void Uniform2f(int location, float v0, float v1)
		{
			Uniform2fNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[245])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[245])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2fv(int location, int count, float* value)
		{
			Uniform2fvNative(location, count, value);
		}

		public static void Uniform2fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform2fvNative(location, count, pvalue0);
			}
		}

		public static void Uniform2fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform2fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2iNative(int location, int v0, int v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[246])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[246])(location, v0, v1);
			#endif
		}

		public static void Uniform2i(int location, int v0, int v1)
		{
			Uniform2iNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[247])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[247])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2iv(int location, int count, int* value)
		{
			Uniform2ivNative(location, count, value);
		}

		public static void Uniform2iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform2ivNative(location, count, pvalue0);
			}
		}

		public static void Uniform2iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform2ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2uiNative(int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[248])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[248])(location, v0, v1);
			#endif
		}

		public static void Uniform2ui(int location, uint v0, uint v1)
		{
			Uniform2uiNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[249])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[249])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2uiv(int location, int count, uint* value)
		{
			Uniform2uivNative(location, count, value);
		}

		public static void Uniform2uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform2uivNative(location, count, pvalue0);
			}
		}

		public static void Uniform2uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform2uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3fNative(int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[250])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[250])(location, v0, v1, v2);
			#endif
		}

		public static void Uniform3f(int location, float v0, float v1, float v2)
		{
			Uniform3fNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[251])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[251])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3fv(int location, int count, float* value)
		{
			Uniform3fvNative(location, count, value);
		}

		public static void Uniform3fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		public static void Uniform3fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3iNative(int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[252])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[252])(location, v0, v1, v2);
			#endif
		}

		public static void Uniform3i(int location, int v0, int v1, int v2)
		{
			Uniform3iNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[253])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[253])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3iv(int location, int count, int* value)
		{
			Uniform3ivNative(location, count, value);
		}

		public static void Uniform3iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		public static void Uniform3iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3uiNative(int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[254])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[254])(location, v0, v1, v2);
			#endif
		}

		public static void Uniform3ui(int location, uint v0, uint v1, uint v2)
		{
			Uniform3uiNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[255])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[255])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3uiv(int location, int count, uint* value)
		{
			Uniform3uivNative(location, count, value);
		}

		public static void Uniform3uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform3uivNative(location, count, pvalue0);
			}
		}

		public static void Uniform3uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform3uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4fNative(int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[256])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[256])(location, v0, v1, v2, v3);
			#endif
		}

		public static void Uniform4f(int location, float v0, float v1, float v2, float v3)
		{
			Uniform4fNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[257])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[257])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4fv(int location, int count, float* value)
		{
			Uniform4fvNative(location, count, value);
		}

		public static void Uniform4fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		public static void Uniform4fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4iNative(int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[258])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[258])(location, v0, v1, v2, v3);
			#endif
		}

		public static void Uniform4i(int location, int v0, int v1, int v2, int v3)
		{
			Uniform4iNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[259])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[259])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4iv(int location, int count, int* value)
		{
			Uniform4ivNative(location, count, value);
		}

		public static void Uniform4iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		public static void Uniform4iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4uiNative(int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[260])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[260])(location, v0, v1, v2, v3);
			#endif
		}

		public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3)
		{
			Uniform4uiNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[261])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[261])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4uiv(int location, int count, uint* value)
		{
			Uniform4uivNative(location, count, value);
		}

		public static void Uniform4uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform4uivNative(location, count, pvalue0);
			}
		}

		public static void Uniform4uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform4uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformBlockBindingNative(uint program, uint uniformBlockIndex, uint uniformBlockBinding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[262])(program, uniformBlockIndex, uniformBlockBinding);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[262])(program, uniformBlockIndex, uniformBlockBinding);
			#endif
		}

		public static void UniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding)
		{
			UniformBlockBindingNative(program, uniformBlockIndex, uniformBlockBinding);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[263])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[263])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[264])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[264])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix2x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x3fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix2x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix2x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[265])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[265])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix2x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x4fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix2x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix2x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[266])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[266])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[267])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[267])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix3x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x2fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix3x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix3x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[268])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[268])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix3x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x4fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix3x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix3x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[269])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[269])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[270])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[270])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix4x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x2fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix4x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix4x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[271])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[271])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void UniformMatrix4x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x3fvNative(location, count, transpose, value);
		}

		public static void UniformMatrix4x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		public static void UniformMatrix4x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnmapBufferNative(GLBufferTargetARB target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[272])(target);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[272])(target);
			#endif
		}

		public static bool UnmapBuffer(GLBufferTargetARB target)
		{
			byte ret = UnmapBufferNative(target);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[273])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[273])(program);
			#endif
		}

		public static void UseProgram(uint program)
		{
			UseProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ValidateProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[274])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[274])(program);
			#endif
		}

		public static void ValidateProgram(uint program)
		{
			ValidateProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1dNative(uint index, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[275])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[275])(index, x);
			#endif
		}

		public static void VertexAttrib1d(uint index, double x)
		{
			VertexAttrib1dNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[276])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[276])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib1dv(uint index, double* v)
		{
			VertexAttrib1dvNative(index, v);
		}

		public static void VertexAttrib1dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		public static void VertexAttrib1dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1fNative(uint index, float x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[277])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[277])(index, x);
			#endif
		}

		public static void VertexAttrib1f(uint index, float x)
		{
			VertexAttrib1fNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[278])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[278])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib1fv(uint index, float* v)
		{
			VertexAttrib1fvNative(index, v);
		}

		public static void VertexAttrib1fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		public static void VertexAttrib1fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1sNative(uint index, short x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[279])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[279])(index, x);
			#endif
		}

		public static void VertexAttrib1s(uint index, short x)
		{
			VertexAttrib1sNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[280])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[280])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib1sv(uint index, short* v)
		{
			VertexAttrib1svNative(index, v);
		}

		public static void VertexAttrib1sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		public static void VertexAttrib1sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2dNative(uint index, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[281])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[281])(index, x, y);
			#endif
		}

		public static void VertexAttrib2d(uint index, double x, double y)
		{
			VertexAttrib2dNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[282])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[282])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib2dv(uint index, double* v)
		{
			VertexAttrib2dvNative(index, v);
		}

		public static void VertexAttrib2dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		public static void VertexAttrib2dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2fNative(uint index, float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[283])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[283])(index, x, y);
			#endif
		}

		public static void VertexAttrib2f(uint index, float x, float y)
		{
			VertexAttrib2fNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[284])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[284])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib2fv(uint index, float* v)
		{
			VertexAttrib2fvNative(index, v);
		}

		public static void VertexAttrib2fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		public static void VertexAttrib2fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2sNative(uint index, short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[285])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[285])(index, x, y);
			#endif
		}

		public static void VertexAttrib2s(uint index, short x, short y)
		{
			VertexAttrib2sNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[286])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[286])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib2sv(uint index, short* v)
		{
			VertexAttrib2svNative(index, v);
		}

		public static void VertexAttrib2sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		public static void VertexAttrib2sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3dNative(uint index, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[287])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[287])(index, x, y, z);
			#endif
		}

		public static void VertexAttrib3d(uint index, double x, double y, double z)
		{
			VertexAttrib3dNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[288])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[288])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib3dv(uint index, double* v)
		{
			VertexAttrib3dvNative(index, v);
		}

		public static void VertexAttrib3dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		public static void VertexAttrib3dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3fNative(uint index, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[289])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[289])(index, x, y, z);
			#endif
		}

		public static void VertexAttrib3f(uint index, float x, float y, float z)
		{
			VertexAttrib3fNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[290])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[290])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib3fv(uint index, float* v)
		{
			VertexAttrib3fvNative(index, v);
		}

		public static void VertexAttrib3fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		public static void VertexAttrib3fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3sNative(uint index, short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[291])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[291])(index, x, y, z);
			#endif
		}

		public static void VertexAttrib3s(uint index, short x, short y, short z)
		{
			VertexAttrib3sNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[292])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[292])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib3sv(uint index, short* v)
		{
			VertexAttrib3svNative(index, v);
		}

		public static void VertexAttrib3sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		public static void VertexAttrib3sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NbvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[293])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[293])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4Nbv(uint index, sbyte* v)
		{
			VertexAttrib4NbvNative(index, v);
		}

		public static void VertexAttrib4Nbv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		public static void VertexAttrib4Nbv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[294])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[294])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4Niv(uint index, int* v)
		{
			VertexAttrib4NivNative(index, v);
		}

		public static void VertexAttrib4Niv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		public static void VertexAttrib4Niv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NsvNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[295])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[295])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4Nsv(uint index, short* v)
		{
			VertexAttrib4NsvNative(index, v);
		}

		public static void VertexAttrib4Nsv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		public static void VertexAttrib4Nsv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NubNative(uint index, bool x, bool y, bool z, bool w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[296])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[296])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#endif
		}

		public static void VertexAttrib4Nub(uint index, bool x, bool y, bool z, bool w)
		{
			VertexAttrib4NubNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[297])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[297])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4Nubv(uint index, byte* v)
		{
			VertexAttrib4NubvNative(index, v);
		}

		public static void VertexAttrib4Nubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4NubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void VertexAttrib4Nubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		public static void VertexAttrib4Nubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NuivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[298])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[298])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4Nuiv(uint index, uint* v)
		{
			VertexAttrib4NuivNative(index, v);
		}

		public static void VertexAttrib4Nuiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		public static void VertexAttrib4Nuiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NusvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[299])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[299])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4Nusv(uint index, ushort* v)
		{
			VertexAttrib4NusvNative(index, v);
		}

		public static void VertexAttrib4Nusv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}

		public static void VertexAttrib4Nusv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4bvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[300])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[300])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4bv(uint index, sbyte* v)
		{
			VertexAttrib4bvNative(index, v);
		}

		public static void VertexAttrib4bv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttrib4bvNative(index, pv0);
			}
		}

		public static void VertexAttrib4bv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttrib4bvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4dNative(uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[301])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[301])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttrib4d(uint index, double x, double y, double z, double w)
		{
			VertexAttrib4dNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[302])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[302])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4dv(uint index, double* v)
		{
			VertexAttrib4dvNative(index, v);
		}

		public static void VertexAttrib4dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib4dvNative(index, pv0);
			}
		}

		public static void VertexAttrib4dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib4dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4fNative(uint index, float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[303])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[303])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttrib4f(uint index, float x, float y, float z, float w)
		{
			VertexAttrib4fNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[304])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[304])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4fv(uint index, float* v)
		{
			VertexAttrib4fvNative(index, v);
		}

		public static void VertexAttrib4fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		public static void VertexAttrib4fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[305])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[305])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4iv(uint index, int* v)
		{
			VertexAttrib4ivNative(index, v);
		}

		public static void VertexAttrib4iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		public static void VertexAttrib4iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4sNative(uint index, short x, short y, short z, short w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[306])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[306])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttrib4s(uint index, short x, short y, short z, short w)
		{
			VertexAttrib4sNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[307])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[307])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4sv(uint index, short* v)
		{
			VertexAttrib4svNative(index, v);
		}

		public static void VertexAttrib4sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		public static void VertexAttrib4sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4ubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[308])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[308])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4ubv(uint index, byte* v)
		{
			VertexAttrib4ubvNative(index, v);
		}

		public static void VertexAttrib4ubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4ubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void VertexAttrib4ubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		public static void VertexAttrib4ubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[309])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[309])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4uiv(uint index, uint* v)
		{
			VertexAttrib4uivNative(index, v);
		}

		public static void VertexAttrib4uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		public static void VertexAttrib4uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4usvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[310])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[310])(index, (nint)v);
			#endif
		}

		public static void VertexAttrib4usv(uint index, ushort* v)
		{
			VertexAttrib4usvNative(index, v);
		}

		public static void VertexAttrib4usv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		public static void VertexAttrib4usv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribDivisorNative(uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[311])(index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[311])(index, divisor);
			#endif
		}

		public static void VertexAttribDivisor(uint index, uint divisor)
		{
			VertexAttribDivisorNative(index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1iNative(uint index, int x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[312])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[312])(index, x);
			#endif
		}

		public static void VertexAttribI1i(uint index, int x)
		{
			VertexAttribI1iNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[313])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[313])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI1iv(uint index, int* v)
		{
			VertexAttribI1ivNative(index, v);
		}

		public static void VertexAttribI1iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI1ivNative(index, pv0);
			}
		}

		public static void VertexAttribI1iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI1ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1uiNative(uint index, uint x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[314])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[314])(index, x);
			#endif
		}

		public static void VertexAttribI1ui(uint index, uint x)
		{
			VertexAttribI1uiNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[315])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[315])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI1uiv(uint index, uint* v)
		{
			VertexAttribI1uivNative(index, v);
		}

		public static void VertexAttribI1uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI1uivNative(index, pv0);
			}
		}

		public static void VertexAttribI1uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI1uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2iNative(uint index, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[316])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[316])(index, x, y);
			#endif
		}

		public static void VertexAttribI2i(uint index, int x, int y)
		{
			VertexAttribI2iNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[317])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[317])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI2iv(uint index, int* v)
		{
			VertexAttribI2ivNative(index, v);
		}

		public static void VertexAttribI2iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI2ivNative(index, pv0);
			}
		}

		public static void VertexAttribI2iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI2ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2uiNative(uint index, uint x, uint y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[318])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[318])(index, x, y);
			#endif
		}

		public static void VertexAttribI2ui(uint index, uint x, uint y)
		{
			VertexAttribI2uiNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[319])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[319])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI2uiv(uint index, uint* v)
		{
			VertexAttribI2uivNative(index, v);
		}

		public static void VertexAttribI2uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI2uivNative(index, pv0);
			}
		}

		public static void VertexAttribI2uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI2uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3iNative(uint index, int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[320])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[320])(index, x, y, z);
			#endif
		}

		public static void VertexAttribI3i(uint index, int x, int y, int z)
		{
			VertexAttribI3iNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[321])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[321])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI3iv(uint index, int* v)
		{
			VertexAttribI3ivNative(index, v);
		}

		public static void VertexAttribI3iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI3ivNative(index, pv0);
			}
		}

		public static void VertexAttribI3iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI3ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3uiNative(uint index, uint x, uint y, uint z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[322])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[322])(index, x, y, z);
			#endif
		}

		public static void VertexAttribI3ui(uint index, uint x, uint y, uint z)
		{
			VertexAttribI3uiNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[323])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[323])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI3uiv(uint index, uint* v)
		{
			VertexAttribI3uivNative(index, v);
		}

		public static void VertexAttribI3uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI3uivNative(index, pv0);
			}
		}

		public static void VertexAttribI3uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI3uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4bvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[324])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[324])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4bv(uint index, sbyte* v)
		{
			VertexAttribI4bvNative(index, v);
		}

		public static void VertexAttribI4bv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttribI4bvNative(index, pv0);
			}
		}

		public static void VertexAttribI4bv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttribI4bvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4iNative(uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[325])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[325])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttribI4i(uint index, int x, int y, int z, int w)
		{
			VertexAttribI4iNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[326])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[326])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4iv(uint index, int* v)
		{
			VertexAttribI4ivNative(index, v);
		}

		public static void VertexAttribI4iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI4ivNative(index, pv0);
			}
		}

		public static void VertexAttribI4iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI4ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[327])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[327])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4sv(uint index, short* v)
		{
			VertexAttribI4svNative(index, v);
		}

		public static void VertexAttribI4sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttribI4svNative(index, pv0);
			}
		}

		public static void VertexAttribI4sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttribI4svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4ubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[328])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[328])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4ubv(uint index, byte* v)
		{
			VertexAttribI4ubvNative(index, v);
		}

		public static void VertexAttribI4ubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttribI4ubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void VertexAttribI4ubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttribI4ubvNative(index, pv0);
			}
		}

		public static void VertexAttribI4ubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttribI4ubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4uiNative(uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[329])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[329])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w)
		{
			VertexAttribI4uiNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[330])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[330])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4uiv(uint index, uint* v)
		{
			VertexAttribI4uivNative(index, v);
		}

		public static void VertexAttribI4uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI4uivNative(index, pv0);
			}
		}

		public static void VertexAttribI4uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI4uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4usvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[331])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[331])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4usv(uint index, ushort* v)
		{
			VertexAttribI4usvNative(index, v);
		}

		public static void VertexAttribI4usv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttribI4usvNative(index, pv0);
			}
		}

		public static void VertexAttribI4usv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttribI4usvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribIPointerNative(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, void*, void>)funcTable[332])(index, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, nint, void>)funcTable[332])(index, size, type, stride, (nint)pointer);
			#endif
		}

		public static void VertexAttribIPointer(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			VertexAttribIPointerNative(index, size, type, stride, pointer);
		}

		public static void VertexAttribIPointer(uint index, int size, GLVertexAttribIType type, int stride, nint pointer)
		{
			VertexAttribIPointerNative(index, size, type, stride, (void*)pointer);
		}

		public static void VertexAttribIPointer<TPointer>(uint index, int size, GLVertexAttribIType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribIPointerNative(index, size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP1uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[333])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[333])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		public static void VertexAttribP1ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP1uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP1uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[334])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[334])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		public static void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP1uivNative(index, type, normalized, value);
		}

		public static void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP1uivNative(index, type, normalized, pvalue0);
			}
		}

		public static void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP1uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP2uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[335])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[335])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		public static void VertexAttribP2ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP2uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP2uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[336])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[336])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		public static void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP2uivNative(index, type, normalized, value);
		}

		public static void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP2uivNative(index, type, normalized, pvalue0);
			}
		}

		public static void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP2uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP3uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[337])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[337])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		public static void VertexAttribP3ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP3uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP3uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[338])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[338])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		public static void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP3uivNative(index, type, normalized, value);
		}

		public static void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP3uivNative(index, type, normalized, pvalue0);
			}
		}

		public static void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP3uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP4uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[339])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[339])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		public static void VertexAttribP4ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP4uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP4uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[340])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[340])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		public static void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP4uivNative(index, type, normalized, value);
		}

		public static void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP4uivNative(index, type, normalized, pvalue0);
			}
		}

		public static void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP4uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribPointerNative(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, void*, void>)funcTable[341])(index, size, type, *((byte*)(&normalized)), stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[341])(index, size, type, *((byte*)(&normalized)), stride, (nint)pointer);
			#endif
		}

		public static void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, pointer);
		}

		public static void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, (void*)pointer);
		}

		public static void VertexAttribPointer<TPointer>(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribPointerNative(index, size, type, normalized, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[342])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[342])(x, y, width, height);
			#endif
		}

		public static void Viewport(int x, int y, int width, int height)
		{
			ViewportNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitSyncNative(GLSync sync, GLSyncBehaviorFlags flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncBehaviorFlags, ulong, void>)funcTable[343])(sync, flags, timeout);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncBehaviorFlags, ulong, void>)funcTable[343])(sync, flags, timeout);
			#endif
		}

		public static void WaitSync(GLSync sync, GLSyncBehaviorFlags flags, ulong timeout)
		{
			WaitSyncNative(sync, flags, timeout);
		}

	}
}
