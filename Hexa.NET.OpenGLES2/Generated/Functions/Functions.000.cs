// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES
{
	public static unsafe partial class GL
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveShaderProgramNative(uint pipeline, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#endif
		}

		public static void ActiveShaderProgram(uint pipeline, uint program)
		{
			ActiveShaderProgramNative(pipeline, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#endif
		}

		public static void ActiveTexture(GLTextureUnit texture)
		{
			ActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlphaFuncNative(GLAlphaFunction func, float reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#endif
		}

		public static void AlphaFunc(GLAlphaFunction func, float reference)
		{
			AlphaFuncNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlphaFuncxNative(GLAlphaFunction func, int reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[3])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[3])(func, reference);
			#endif
		}

		public static void AlphaFuncx(GLAlphaFunction func, int reference)
		{
			AlphaFuncxNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AttachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[4])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[4])(program, shader);
			#endif
		}

		public static void AttachShader(uint program, uint shader)
		{
			AttachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginConditionalRenderNative(uint id, GLConditionalRenderMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#endif
		}

		public static void BeginConditionalRender(uint id, GLConditionalRenderMode mode)
		{
			BeginConditionalRenderNative(id, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryNative(GLQueryTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[6])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[6])(target, id);
			#endif
		}

		public static void BeginQuery(GLQueryTarget target, uint id)
		{
			BeginQueryNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryIndexedNative(GLQueryTarget target, uint index, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[7])(target, index, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[7])(target, index, id);
			#endif
		}

		public static void BeginQueryIndexed(GLQueryTarget target, uint index, uint id)
		{
			BeginQueryIndexedNative(target, index, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginTransformFeedbackNative(GLPrimitiveType primitiveMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#endif
		}

		public static void BeginTransformFeedback(GLPrimitiveType primitiveMode)
		{
			BeginTransformFeedbackNative(primitiveMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindAttribLocationNative(uint program, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[9])(program, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[9])(program, index, (nint)name);
			#endif
		}

		public static void BindAttribLocation(uint program, uint index, byte* name)
		{
			BindAttribLocationNative(program, index, name);
		}

		public static void BindAttribLocation(uint program, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindAttribLocationNative(program, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindAttribLocation(uint program, uint index, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		public static void BindAttribLocation(uint program, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferNative(GLBufferTargetARB target, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[10])(target, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[10])(target, buffer);
			#endif
		}

		public static void BindBuffer(GLBufferTargetARB target, uint buffer)
		{
			BindBufferNative(target, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferBaseNative(GLBufferTargetARB target, uint index, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[11])(target, index, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[11])(target, index, buffer);
			#endif
		}

		public static void BindBufferBase(GLBufferTargetARB target, uint index, uint buffer)
		{
			BindBufferBaseNative(target, index, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferRangeNative(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#endif
		}

		public static void BindBufferRange(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			BindBufferRangeNative(target, index, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBuffersBaseNative(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, void>)funcTable[13])(target, first, count, buffers);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, void>)funcTable[13])(target, first, count, (nint)buffers);
			#endif
		}

		public static void BindBuffersBase(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			BindBuffersBaseNative(target, first, count, buffers);
		}

		public static void BindBuffersBase(GLBufferTargetARB target, uint first, int count, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersBaseNative(target, first, count, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBuffersRangeNative(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, nint*, nint*, void>)funcTable[14])(target, first, count, buffers, offsets, sizes);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, nint, nint, void>)funcTable[14])(target, first, count, (nint)buffers, (nint)offsets, (nint)sizes);
			#endif
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			BindBuffersRangeNative(target, first, count, buffers, offsets, sizes);
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersRangeNative(target, first, count, pbuffers0, offsets, sizes);
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, nint* sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindBuffersRangeNative(target, first, count, buffers, poffsets0, sizes);
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, sizes);
				}
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, ref nint sizes)
		{
			fixed (nint* psizes0 = &sizes)
			{
				BindBuffersRangeNative(target, first, count, buffers, offsets, psizes0);
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, offsets, psizes1);
				}
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, ref nint sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, buffers, poffsets0, psizes1);
				}
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (nint* psizes2 = &sizes)
					{
						BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, psizes2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationNative(uint program, uint color, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[15])(program, color, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[15])(program, color, (nint)name);
			#endif
		}

		public static void BindFragDataLocation(uint program, uint color, byte* name)
		{
			BindFragDataLocationNative(program, color, name);
		}

		public static void BindFragDataLocation(uint program, uint color, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationNative(program, color, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindFragDataLocation(uint program, uint color, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationNative(program, color, pname0);
			}
		}

		public static void BindFragDataLocation(uint program, uint color, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationNative(program, color, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationIndexedNative(uint program, uint colorNumber, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, byte*, void>)funcTable[16])(program, colorNumber, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, void>)funcTable[16])(program, colorNumber, index, (nint)name);
			#endif
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, byte* name)
		{
			BindFragDataLocationIndexedNative(program, colorNumber, index, name);
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationIndexedNative(program, colorNumber, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFramebufferNative(GLFramebufferTarget target, uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[17])(target, framebuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[17])(target, framebuffer);
			#endif
		}

		public static void BindFramebuffer(GLFramebufferTarget target, uint framebuffer)
		{
			BindFramebufferNative(target, framebuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindImageTextureNative(uint unit, uint texture, int level, byte layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[18])(unit, texture, level, layered, layer, access, format);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[18])(unit, texture, level, layered, layer, access, format);
			#endif
		}

		public static void BindImageTexture(uint unit, uint texture, int level, byte layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			BindImageTextureNative(unit, texture, level, layered, layer, access, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindImageTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[19])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[19])(first, count, (nint)textures);
			#endif
		}

		public static void BindImageTextures(uint first, int count, uint* textures)
		{
			BindImageTexturesNative(first, count, textures);
		}

		public static void BindImageTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindImageTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[20])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[20])(pipeline);
			#endif
		}

		public static void BindProgramPipeline(uint pipeline)
		{
			BindProgramPipelineNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindRenderbufferNative(GLRenderbufferTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[21])(target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[21])(target, renderbuffer);
			#endif
		}

		public static void BindRenderbuffer(GLRenderbufferTarget target, uint renderbuffer)
		{
			BindRenderbufferNative(target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindSamplerNative(uint unit, uint sampler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[22])(unit, sampler);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[22])(unit, sampler);
			#endif
		}

		public static void BindSampler(uint unit, uint sampler)
		{
			BindSamplerNative(unit, sampler);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindSamplersNative(uint first, int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[23])(first, count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[23])(first, count, (nint)samplers);
			#endif
		}

		public static void BindSamplers(uint first, int count, uint* samplers)
		{
			BindSamplersNative(first, count, samplers);
		}

		public static void BindSamplers(uint first, int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				BindSamplersNative(first, count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTextureNative(GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[24])(target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[24])(target, texture);
			#endif
		}

		public static void BindTexture(GLTextureTarget target, uint texture)
		{
			BindTextureNative(target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTextureUnitNative(uint unit, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[25])(unit, texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[25])(unit, texture);
			#endif
		}

		public static void BindTextureUnit(uint unit, uint texture)
		{
			BindTextureUnitNative(unit, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[26])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[26])(first, count, (nint)textures);
			#endif
		}

		public static void BindTextures(uint first, int count, uint* textures)
		{
			BindTexturesNative(first, count, textures);
		}

		public static void BindTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTransformFeedbackNative(GLBindTransformFeedbackTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[27])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[27])(target, id);
			#endif
		}

		public static void BindTransformFeedback(GLBindTransformFeedbackTarget target, uint id)
		{
			BindTransformFeedbackNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[28])(array);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[28])(array);
			#endif
		}

		public static void BindVertexArray(uint array)
		{
			BindVertexArrayNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexBufferNative(uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[29])(bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[29])(bindingindex, buffer, offset, stride);
			#endif
		}

		public static void BindVertexBuffer(uint bindingindex, uint buffer, nint offset, int stride)
		{
			BindVertexBufferNative(bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexBuffersNative(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, nint*, int*, void>)funcTable[30])(first, count, buffers, offsets, strides);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, nint, void>)funcTable[30])(first, count, (nint)buffers, (nint)offsets, (nint)strides);
			#endif
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			BindVertexBuffersNative(first, count, buffers, offsets, strides);
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindVertexBuffersNative(first, count, pbuffers0, offsets, strides);
			}
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, int* strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindVertexBuffersNative(first, count, buffers, poffsets0, strides);
			}
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindVertexBuffersNative(first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, ref int strides)
		{
			fixed (int* pstrides0 = &strides)
			{
				BindVertexBuffersNative(first, count, buffers, offsets, pstrides0);
			}
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, ref int strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (int* pstrides2 = &strides)
					{
						BindVertexBuffersNative(first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[31])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[31])(red, green, blue, alpha);
			#endif
		}

		public static void BlendColor(float red, float green, float blue, float alpha)
		{
			BlendColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[32])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[32])(mode);
			#endif
		}

		public static void BlendEquation(GLBlendEquationModeEXT mode)
		{
			BlendEquationNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateNative(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[33])(modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[33])(modeRGB, modeAlpha);
			#endif
		}

		public static void BlendEquationSeparate(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateNative(modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateiNative(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[34])(buf, modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[34])(buf, modeRGB, modeAlpha);
			#endif
		}

		public static void BlendEquationSeparatei(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateiNative(buf, modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationiNative(uint buf, GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[35])(buf, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[35])(buf, mode);
			#endif
		}

		public static void BlendEquationi(uint buf, GLBlendEquationModeEXT mode)
		{
			BlendEquationiNative(buf, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncNative(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[36])(sfactor, dfactor);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[36])(sfactor, dfactor);
			#endif
		}

		public static void BlendFunc(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			BlendFuncNative(sfactor, dfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateNative(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[37])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[37])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#endif
		}

		public static void BlendFuncSeparate(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			BlendFuncSeparateNative(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateiNative(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[38])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[38])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#endif
		}

		public static void BlendFuncSeparatei(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			BlendFuncSeparateiNative(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFunciNative(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(buf, src, dst);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(buf, src, dst);
			#endif
		}

		public static void BlendFunci(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			BlendFunciNative(buf, src, dst);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[40])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[40])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitNamedFramebufferNative(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitNamedFramebufferNative(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferDataNative(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, void*, GLBufferUsageARB, void>)funcTable[42])(target, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLBufferUsageARB, void>)funcTable[42])(target, size, (nint)data, usage);
			#endif
		}

		public static void BufferData(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			BufferDataNative(target, size, data, usage);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageNative(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, void*, GLBufferStorageMask, void>)funcTable[43])(target, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, GLBufferStorageMask, void>)funcTable[43])(target, size, (nint)data, flags);
			#endif
		}

		public static void BufferStorage(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			BufferStorageNative(target, size, data, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[44])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[44])(target, offset, size, (nint)data);
			#endif
		}

		public static void BufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			BufferSubDataNative(target, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckFramebufferStatusNative(GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[45])(target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[45])(target);
			#endif
		}

		public static GLEnum CheckFramebufferStatus(GLFramebufferTarget target)
		{
			GLEnum ret = CheckFramebufferStatusNative(target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckNamedFramebufferStatusNative(uint framebuffer, GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[46])(framebuffer, target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[46])(framebuffer, target);
			#endif
		}

		public static GLEnum CheckNamedFramebufferStatus(uint framebuffer, GLFramebufferTarget target)
		{
			GLEnum ret = CheckNamedFramebufferStatusNative(framebuffer, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClampColorNative(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[47])(target, clamp);
			#else
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[47])(target, clamp);
			#endif
		}

		public static void ClampColor(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			ClampColorNative(target, clamp);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(GLClearBufferMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[48])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[48])(mask);
			#endif
		}

		public static void Clear(GLClearBufferMask mask)
		{
			ClearNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferDataNative(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[49])(target, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[49])(target, internalformat, format, type, (nint)data);
			#endif
		}

		public static void ClearBufferData(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferDataNative(target, internalformat, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferSubDataNative(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[50])(target, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[50])(target, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		public static void ClearBufferSubData(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferSubDataNative(target, internalformat, offset, size, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferfiNative(GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float, int, void>)funcTable[51])(buffer, drawbuffer, depth, stencil);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float, int, void>)funcTable[51])(buffer, drawbuffer, depth, stencil);
			#endif
		}

		public static void ClearBufferfi(GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			ClearBufferfiNative(buffer, drawbuffer, depth, stencil);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferfvNative(GLBuffer buffer, int drawbuffer, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float*, void>)funcTable[52])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[52])(buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearBufferfv(GLBuffer buffer, int drawbuffer, float* value)
		{
			ClearBufferfvNative(buffer, drawbuffer, value);
		}

		public static void ClearBufferfv(GLBuffer buffer, int drawbuffer, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ClearBufferfvNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferivNative(GLBuffer buffer, int drawbuffer, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, int*, void>)funcTable[53])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[53])(buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearBufferiv(GLBuffer buffer, int drawbuffer, int* value)
		{
			ClearBufferivNative(buffer, drawbuffer, value);
		}

		public static void ClearBufferiv(GLBuffer buffer, int drawbuffer, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ClearBufferivNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferuivNative(GLBuffer buffer, int drawbuffer, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, uint*, void>)funcTable[54])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[54])(buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearBufferuiv(GLBuffer buffer, int drawbuffer, uint* value)
		{
			ClearBufferuivNative(buffer, drawbuffer, value);
		}

		public static void ClearBufferuiv(GLBuffer buffer, int drawbuffer, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ClearBufferuivNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[55])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[55])(red, green, blue, alpha);
			#endif
		}

		public static void ClearColor(float red, float green, float blue, float alpha)
		{
			ClearColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorxNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[56])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[56])(red, green, blue, alpha);
			#endif
		}

		public static void ClearColorx(int red, int green, int blue, int alpha)
		{
			ClearColorxNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthNative(double depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[57])(depth);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[57])(depth);
			#endif
		}

		public static void ClearDepth(double depth)
		{
			ClearDepthNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthfNative(float d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[58])(d);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[58])(d);
			#endif
		}

		public static void ClearDepthf(float d)
		{
			ClearDepthfNative(d);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthxNative(int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[59])(depth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[59])(depth);
			#endif
		}

		public static void ClearDepthx(int depth)
		{
			ClearDepthxNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferDataNative(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[60])(buffer, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[60])(buffer, internalformat, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferData(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferDataNative(buffer, internalformat, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferSubDataNative(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[61])(buffer, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[61])(buffer, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferSubData(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferfiNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[62])(framebuffer, buffer, drawbuffer, depth, stencil);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[62])(framebuffer, buffer, drawbuffer, depth, stencil);
			#endif
		}

		public static void ClearNamedFramebufferfi(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			ClearNamedFramebufferfiNative(framebuffer, buffer, drawbuffer, depth, stencil);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferfvNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float*, void>)funcTable[63])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[63])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, value);
		}

		public static void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, int*, void>)funcTable[64])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[64])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, value);
		}

		public static void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferuivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, uint*, void>)funcTable[65])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[65])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, value);
		}

		public static void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearStencilNative(int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[66])(s);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[66])(s);
			#endif
		}

		public static void ClearStencil(int s)
		{
			ClearStencilNative(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexImageNative(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[67])(texture, level, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[67])(texture, level, format, type, (nint)data);
			#endif
		}

		public static void ClearTexImage(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexImageNative(texture, level, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[68])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[68])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)data);
			#endif
		}

		public static void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[69])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[69])(texture);
			#endif
		}

		public static void ClientActiveTexture(GLTextureUnit texture)
		{
			ClientActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum ClientWaitSyncNative(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[70])(sync, flags, timeout);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[70])(sync, flags, timeout);
			#endif
		}

		public static GLEnum ClientWaitSync(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			GLEnum ret = ClientWaitSyncNative(sync, flags, timeout);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipControlNative(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[71])(origin, depth);
			#else
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[71])(origin, depth);
			#endif
		}

		public static void ClipControl(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			ClipControlNative(origin, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipPlanefNative(GLClipPlaneName p, float* eqn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, float*, void>)funcTable[72])(p, eqn);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[72])(p, (nint)eqn);
			#endif
		}

		public static void ClipPlanef(GLClipPlaneName p, float* eqn)
		{
			ClipPlanefNative(p, eqn);
		}

		public static void ClipPlanef(GLClipPlaneName p, ref float eqn)
		{
			fixed (float* peqn0 = &eqn)
			{
				ClipPlanefNative(p, peqn0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipPlanexNative(GLClipPlaneName plane, int* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, int*, void>)funcTable[73])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[73])(plane, (nint)equation);
			#endif
		}

		public static void ClipPlanex(GLClipPlaneName plane, int* equation)
		{
			ClipPlanexNative(plane, equation);
		}

		public static void ClipPlanex(GLClipPlaneName plane, ref int equation)
		{
			fixed (int* pequation0 = &equation)
			{
				ClipPlanexNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4fNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[74])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[74])(red, green, blue, alpha);
			#endif
		}

		public static void Color4f(float red, float green, float blue, float alpha)
		{
			Color4fNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4ubNative(byte red, byte green, byte blue, byte alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[75])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[75])(red, green, blue, alpha);
			#endif
		}

		public static void Color4ub(byte red, byte green, byte blue, byte alpha)
		{
			Color4ubNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4xNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[76])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[76])(red, green, blue, alpha);
			#endif
		}

		public static void Color4x(int red, int green, int blue, int alpha)
		{
			Color4xNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaskNative(byte red, byte green, byte blue, byte alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[77])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[77])(red, green, blue, alpha);
			#endif
		}

		public static void ColorMask(byte red, byte green, byte blue, byte alpha)
		{
			ColorMaskNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaskiNative(uint index, byte r, byte g, byte b, byte a)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[78])(index, r, g, b, a);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[78])(index, r, g, b, a);
			#endif
		}

		public static void ColorMaski(uint index, byte r, byte g, byte b, byte a)
		{
			ColorMaskiNative(index, r, g, b, a);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorPointerNative(int size, GLColorPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void*, void>)funcTable[79])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, nint, void>)funcTable[79])(size, type, stride, (nint)pointer);
			#endif
		}

		public static void ColorPointer(int size, GLColorPointerType type, int stride, void* pointer)
		{
			ColorPointerNative(size, type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[80])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[80])(shader);
			#endif
		}

		public static void CompileShader(uint shader)
		{
			CompileShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[81])(target, level, internalformat, width, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[81])(target, level, internalformat, width, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[82])(target, level, internalformat, width, height, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[82])(target, level, internalformat, width, height, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage3DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[83])(target, level, internalformat, width, height, depth, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[83])(target, level, internalformat, width, height, depth, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[84])(target, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[84])(target, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[85])(target, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[85])(target, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[86])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[86])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage1DNative(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, void*, void>)funcTable[87])(texture, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, nint, void>)funcTable[87])(texture, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[88])(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[88])(texture, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[89])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[89])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyBufferSubDataNative(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[90])(readTarget, writeTarget, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[90])(readTarget, writeTarget, readOffset, writeOffset, size);
			#endif
		}

		public static void CopyBufferSubData(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			CopyBufferSubDataNative(readTarget, writeTarget, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyImageSubDataNative(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[91])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[91])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#endif
		}

		public static void CopyImageSubData(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			CopyImageSubDataNative(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyNamedBufferSubDataNative(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[92])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[92])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#endif
		}

		public static void CopyNamedBufferSubData(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			CopyNamedBufferSubDataNative(readBuffer, writeBuffer, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[93])(target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[93])(target, level, internalformat, x, y, width, border);
			#endif
		}

		public static void CopyTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTexImage1DNative(target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[94])(target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[94])(target, level, internalformat, x, y, width, height, border);
			#endif
		}

		public static void CopyTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTexImage2DNative(target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[95])(target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[95])(target, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyTexSubImage1D(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTexSubImage1DNative(target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[96])(target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[96])(target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage2DNative(target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[97])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[97])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage1DNative(uint texture, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[98])(texture, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[98])(texture, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width)
		{
			CopyTextureSubImage1DNative(texture, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[99])(texture, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[99])(texture, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage2DNative(texture, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[100])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[100])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[101])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[101])(n, (nint)buffers);
			#endif
		}

		public static void CreateBuffers(int n, uint* buffers)
		{
			CreateBuffersNative(n, buffers);
		}

		public static void CreateBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				CreateBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[102])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[102])(n, (nint)framebuffers);
			#endif
		}

		public static void CreateFramebuffers(int n, uint* framebuffers)
		{
			CreateFramebuffersNative(n, framebuffers);
		}

		public static void CreateFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				CreateFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateProgramNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[103])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[103])();
			#endif
		}

		public static uint CreateProgram()
		{
			uint ret = CreateProgramNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[104])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[104])(n, (nint)pipelines);
			#endif
		}

		public static void CreateProgramPipelines(int n, uint* pipelines)
		{
			CreateProgramPipelinesNative(n, pipelines);
		}

		public static void CreateProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				CreateProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateQueriesNative(GLQueryTarget target, int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, uint*, void>)funcTable[105])(target, n, ids);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, nint, void>)funcTable[105])(target, n, (nint)ids);
			#endif
		}

		public static void CreateQueries(GLQueryTarget target, int n, uint* ids)
		{
			CreateQueriesNative(target, n, ids);
		}

		public static void CreateQueries(GLQueryTarget target, int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateQueriesNative(target, n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[106])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[106])(n, (nint)renderbuffers);
			#endif
		}

		public static void CreateRenderbuffers(int n, uint* renderbuffers)
		{
			CreateRenderbuffersNative(n, renderbuffers);
		}

		public static void CreateRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				CreateRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateSamplersNative(int n, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[107])(n, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[107])(n, (nint)samplers);
			#endif
		}

		public static void CreateSamplers(int n, uint* samplers)
		{
			CreateSamplersNative(n, samplers);
		}

		public static void CreateSamplers(int n, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				CreateSamplersNative(n, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderNative(GLShaderType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[108])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[108])(type);
			#endif
		}

		public static uint CreateShader(GLShaderType type)
		{
			uint ret = CreateShaderNative(type);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderProgramvNative(GLShaderType type, int count, byte** strings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, int, byte**, uint>)funcTable[109])(type, count, strings);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, uint>)funcTable[109])(type, count, (nint)strings);
			#endif
		}

		public static uint CreateShaderProgramv(GLShaderType type, int count, byte** strings)
		{
			uint ret = CreateShaderProgramvNative(type, count, strings);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateTexturesNative(GLTextureTarget target, int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, uint*, void>)funcTable[110])(target, n, textures);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[110])(target, n, (nint)textures);
			#endif
		}

		public static void CreateTextures(GLTextureTarget target, int n, uint* textures)
		{
			CreateTexturesNative(target, n, textures);
		}

		public static void CreateTextures(GLTextureTarget target, int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				CreateTexturesNative(target, n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[111])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[111])(n, (nint)ids);
			#endif
		}

		public static void CreateTransformFeedbacks(int n, uint* ids)
		{
			CreateTransformFeedbacksNative(n, ids);
		}

		public static void CreateTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[112])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[112])(n, (nint)arrays);
			#endif
		}

		public static void CreateVertexArrays(int n, uint* arrays)
		{
			CreateVertexArraysNative(n, arrays);
		}

		public static void CreateVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CullFaceNative(GLTriangleFace mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[113])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[113])(mode);
			#endif
		}

		public static void CullFace(GLTriangleFace mode)
		{
			CullFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageCallbackNative(GLDebugProc callback, void* userParam)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[114])((void*)Utils.GetFunctionPointerForDelegate(callback), userParam);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[114])(Utils.GetFunctionPointerForDelegate(callback), (nint)userParam);
			#endif
		}

		public static void DebugMessageCallback(GLDebugProc callback, void* userParam)
		{
			DebugMessageCallbackNative(callback, userParam);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageControlNative(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, uint*, byte, void>)funcTable[115])(source, type, severity, count, ids, enabled);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, nint, byte, void>)funcTable[115])(source, type, severity, count, (nint)ids, enabled);
			#endif
		}

		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, byte enabled)
		{
			DebugMessageControlNative(source, type, severity, count, ids, enabled);
		}

		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, ref uint ids, byte enabled)
		{
			fixed (uint* pids0 = &ids)
			{
				DebugMessageControlNative(source, type, severity, count, pids0, enabled);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageInsertNative(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, byte*, void>)funcTable[116])(source, type, id, severity, length, buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, nint, void>)funcTable[116])(source, type, id, severity, length, (nint)buf);
			#endif
		}

		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			DebugMessageInsertNative(source, type, id, severity, length, buf);
		}

		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugMessageInsertNative(source, type, id, severity, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, ReadOnlySpan<byte> buf)
		{
			fixed (byte* pbuf0 = buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, ref byte buf)
		{
			fixed (byte* pbuf0 = &buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[117])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[117])(n, (nint)buffers);
			#endif
		}

		public static void DeleteBuffers(int n, uint* buffers)
		{
			DeleteBuffersNative(n, buffers);
		}

		public static void DeleteBuffer(uint buffer)
		{
			DeleteBuffersNative(1, &buffer);
		}

		public static void DeleteBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[118])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[118])(n, (nint)framebuffers);
			#endif
		}

		public static void DeleteFramebuffers(int n, uint* framebuffers)
		{
			DeleteFramebuffersNative(n, framebuffers);
		}

		public static void DeleteFramebuffer(uint framebuffer)
		{
			DeleteFramebuffersNative(1, &framebuffer);
		}

		public static void DeleteFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[119])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[119])(program);
			#endif
		}

		public static void DeleteProgram(uint program)
		{
			DeleteProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[120])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[120])(n, (nint)pipelines);
			#endif
		}

		public static void DeleteProgramPipelines(int n, uint* pipelines)
		{
			DeleteProgramPipelinesNative(n, pipelines);
		}

		public static void DeleteProgramPipeline(uint pipeline)
		{
			DeleteProgramPipelinesNative(1, &pipeline);
		}

		public static void DeleteProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[121])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[121])(n, (nint)ids);
			#endif
		}

		public static void DeleteQueries(int n, uint* ids)
		{
			DeleteQueriesNative(n, ids);
		}

		public static void DeleteQuerie(uint id)
		{
			DeleteQueriesNative(1, &id);
		}

		public static void DeleteQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[122])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[122])(n, (nint)renderbuffers);
			#endif
		}

		public static void DeleteRenderbuffers(int n, uint* renderbuffers)
		{
			DeleteRenderbuffersNative(n, renderbuffers);
		}

		public static void DeleteRenderbuffer(uint renderbuffer)
		{
			DeleteRenderbuffersNative(1, &renderbuffer);
		}

		public static void DeleteRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[123])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[123])(count, (nint)samplers);
			#endif
		}

		public static void DeleteSamplers(int count, uint* samplers)
		{
			DeleteSamplersNative(count, samplers);
		}

		public static void DeleteSampler(uint sampler)
		{
			DeleteSamplersNative(1, &sampler);
		}

		public static void DeleteSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[124])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[124])(shader);
			#endif
		}

		public static void DeleteShader(uint shader)
		{
			DeleteShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[125])(sync);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[125])(sync);
			#endif
		}

		public static void DeleteSync(GLSync sync)
		{
			DeleteSyncNative(sync);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[126])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[126])(n, (nint)textures);
			#endif
		}

		public static void DeleteTextures(int n, uint* textures)
		{
			DeleteTexturesNative(n, textures);
		}

		public static void DeleteTexture(uint texture)
		{
			DeleteTexturesNative(1, &texture);
		}

		public static void DeleteTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[127])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[127])(n, (nint)ids);
			#endif
		}

		public static void DeleteTransformFeedbacks(int n, uint* ids)
		{
			DeleteTransformFeedbacksNative(n, ids);
		}

		public static void DeleteTransformFeedback(uint id)
		{
			DeleteTransformFeedbacksNative(1, &id);
		}

		public static void DeleteTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[128])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[128])(n, (nint)arrays);
			#endif
		}

		public static void DeleteVertexArrays(int n, uint* arrays)
		{
			DeleteVertexArraysNative(n, arrays);
		}

		public static void DeleteVertexArray(uint array)
		{
			DeleteVertexArraysNative(1, &array);
		}

		public static void DeleteVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthFuncNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[129])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[129])(func);
			#endif
		}

		public static void DepthFunc(GLDepthFunction func)
		{
			DepthFuncNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthMaskNative(byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[130])(flag);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[130])(flag);
			#endif
		}

		public static void DepthMask(byte flag)
		{
			DepthMaskNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeNative(double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[131])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[131])(n, f);
			#endif
		}

		public static void DepthRange(double n, double f)
		{
			DepthRangeNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeArrayvNative(uint first, int count, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[132])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[132])(first, count, (nint)v);
			#endif
		}

		public static void DepthRangeArrayv(uint first, int count, double* v)
		{
			DepthRangeArrayvNative(first, count, v);
		}

		public static void DepthRangeArrayv(uint first, int count, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeIndexedNative(uint index, double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[133])(index, n, f);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[133])(index, n, f);
			#endif
		}

		public static void DepthRangeIndexed(uint index, double n, double f)
		{
			DepthRangeIndexedNative(index, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangefNative(float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[134])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[134])(n, f);
			#endif
		}

		public static void DepthRangef(float n, float f)
		{
			DepthRangefNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangexNative(int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[135])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[135])(n, f);
			#endif
		}

		public static void DepthRangex(int n, int f)
		{
			DepthRangexNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[136])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[136])(program, shader);
			#endif
		}

		public static void DetachShader(uint program, uint shader)
		{
			DetachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[137])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[137])(cap);
			#endif
		}

		public static void Disable(GLEnableCap cap)
		{
			DisableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[138])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[138])(array);
			#endif
		}

		public static void DisableClientState(GLEnableCap array)
		{
			DisableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[139])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[139])(vaobj, index);
			#endif
		}

		public static void DisableVertexArrayAttrib(uint vaobj, uint index)
		{
			DisableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[140])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[140])(index);
			#endif
		}

		public static void DisableVertexAttribArray(uint index)
		{
			DisableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableiNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[141])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[141])(target, index);
			#endif
		}

		public static void Disablei(GLEnableCap target, uint index)
		{
			DisableiNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeNative(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[142])(numGroupsX, numGroupsY, numGroupsZ);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[142])(numGroupsX, numGroupsY, numGroupsZ);
			#endif
		}

		public static void DispatchCompute(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			DispatchComputeNative(numGroupsX, numGroupsY, numGroupsZ);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeIndirectNative(nint indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[143])(indirect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[143])(indirect);
			#endif
		}

		public static void DispatchComputeIndirect(nint indirect)
		{
			DispatchComputeIndirectNative(indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysNative(GLPrimitiveType mode, int first, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[144])(mode, first, count);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[144])(mode, first, count);
			#endif
		}

		public static void DrawArrays(GLPrimitiveType mode, int first, int count)
		{
			DrawArraysNative(mode, first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysIndirectNative(GLPrimitiveType mode, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, void>)funcTable[145])(mode, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, void>)funcTable[145])(mode, (nint)indirect);
			#endif
		}

		public static void DrawArraysIndirect(GLPrimitiveType mode, void* indirect)
		{
			DrawArraysIndirectNative(mode, indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedNative(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[146])(mode, first, count, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[146])(mode, first, count, instancecount);
			#endif
		}

		public static void DrawArraysInstanced(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			DrawArraysInstancedNative(mode, first, count, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedBaseInstanceNative(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[147])(mode, first, count, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[147])(mode, first, count, instancecount, baseinstance);
			#endif
		}

		public static void DrawArraysInstancedBaseInstance(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			DrawArraysInstancedBaseInstanceNative(mode, first, count, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBufferNative(GLDrawBufferMode buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[148])(buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[148])(buf);
			#endif
		}

		public static void DrawBuffer(GLDrawBufferMode buf)
		{
			DrawBufferNative(buf);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersNative(int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[149])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[149])(n, bufs);
			#endif
		}

		public static void DrawBuffers(int n, GLDrawBufferMode bufs)
		{
			DrawBuffersNative(n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, void>)funcTable[150])(mode, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, void>)funcTable[150])(mode, count, type, (nint)indices);
			#endif
		}

		public static void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			DrawElementsNative(mode, count, type, indices);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[151])(mode, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[151])(mode, count, type, (nint)indices, basevertex);
			#endif
		}

		public static void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, indices, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsIndirectNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, void>)funcTable[152])(mode, type, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, void>)funcTable[152])(mode, type, (nint)indirect);
			#endif
		}

		public static void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			DrawElementsIndirectNative(mode, type, indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[153])(mode, count, type, indices, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[153])(mode, count, type, (nint)indices, instancecount);
			#endif
		}

		public static void DrawElementsInstanced(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			DrawElementsInstancedNative(mode, count, type, indices, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, uint, void>)funcTable[154])(mode, count, type, indices, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, uint, void>)funcTable[154])(mode, count, type, (nint)indices, instancecount, baseinstance);
			#endif
		}

		public static void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, indices, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, void>)funcTable[155])(mode, count, type, indices, instancecount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, void>)funcTable[155])(mode, count, type, (nint)indices, instancecount, basevertex);
			#endif
		}

		public static void DrawElementsInstancedBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexNative(mode, count, type, indices, instancecount, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, uint, void>)funcTable[156])(mode, count, type, indices, instancecount, basevertex, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, uint, void>)funcTable[156])(mode, count, type, (nint)indices, instancecount, basevertex, baseinstance);
			#endif
		}

		public static void DrawElementsInstancedBaseVertexBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			DrawElementsInstancedBaseVertexBaseInstanceNative(mode, count, type, indices, instancecount, basevertex, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, void>)funcTable[157])(mode, start, end, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, void>)funcTable[157])(mode, start, end, count, type, (nint)indices);
			#endif
		}

		public static void DrawRangeElements(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			DrawRangeElementsNative(mode, start, end, count, type, indices);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsBaseVertexNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, int, void>)funcTable[158])(mode, start, end, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, int, void>)funcTable[158])(mode, start, end, count, type, (nint)indices, basevertex);
			#endif
		}

		public static void DrawRangeElementsBaseVertex(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawRangeElementsBaseVertexNative(mode, start, end, count, type, indices, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackNative(GLPrimitiveType mode, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[159])(mode, id);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[159])(mode, id);
			#endif
		}

		public static void DrawTransformFeedback(GLPrimitiveType mode, uint id)
		{
			DrawTransformFeedbackNative(mode, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackInstancedNative(GLPrimitiveType mode, uint id, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[160])(mode, id, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[160])(mode, id, instancecount);
			#endif
		}

		public static void DrawTransformFeedbackInstanced(GLPrimitiveType mode, uint id, int instancecount)
		{
			DrawTransformFeedbackInstancedNative(mode, id, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackStreamNative(GLPrimitiveType mode, uint id, uint stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, void>)funcTable[161])(mode, id, stream);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, void>)funcTable[161])(mode, id, stream);
			#endif
		}

		public static void DrawTransformFeedbackStream(GLPrimitiveType mode, uint id, uint stream)
		{
			DrawTransformFeedbackStreamNative(mode, id, stream);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackStreamInstancedNative(GLPrimitiveType mode, uint id, uint stream, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, void>)funcTable[162])(mode, id, stream, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, void>)funcTable[162])(mode, id, stream, instancecount);
			#endif
		}

		public static void DrawTransformFeedbackStreamInstanced(GLPrimitiveType mode, uint id, uint stream, int instancecount)
		{
			DrawTransformFeedbackStreamInstancedNative(mode, id, stream, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[163])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[163])(cap);
			#endif
		}

		public static void Enable(GLEnableCap cap)
		{
			EnableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[164])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[164])(array);
			#endif
		}

		public static void EnableClientState(GLEnableCap array)
		{
			EnableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[165])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[165])(vaobj, index);
			#endif
		}

		public static void EnableVertexArrayAttrib(uint vaobj, uint index)
		{
			EnableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[166])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[166])(index);
			#endif
		}

		public static void EnableVertexAttribArray(uint index)
		{
			EnableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableiNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[167])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[167])(target, index);
			#endif
		}

		public static void Enablei(GLEnableCap target, uint index)
		{
			EnableiNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndConditionalRenderNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[168])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[168])();
			#endif
		}

		public static void EndConditionalRender()
		{
			EndConditionalRenderNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryNative(GLQueryTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[169])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[169])(target);
			#endif
		}

		public static void EndQuery(GLQueryTarget target)
		{
			EndQueryNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryIndexedNative(GLQueryTarget target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[170])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[170])(target, index);
			#endif
		}

		public static void EndQueryIndexed(GLQueryTarget target, uint index)
		{
			EndQueryIndexedNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndTransformFeedbackNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[171])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[171])();
			#endif
		}

		public static void EndTransformFeedback()
		{
			EndTransformFeedbackNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLSync FenceSyncNative(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[172])(condition, flags);
			#else
			return (GLSync)((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[172])(condition, flags);
			#endif
		}

		public static GLSync FenceSync(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			GLSync ret = FenceSyncNative(condition, flags);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FinishNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[173])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[173])();
			#endif
		}

		public static void Finish()
		{
			FinishNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[174])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[174])();
			#endif
		}

		public static void Flush()
		{
			FlushNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedBufferRangeNative(GLBufferTargetARB target, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[175])(target, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[175])(target, offset, length);
			#endif
		}

		public static void FlushMappedBufferRange(GLBufferTargetARB target, nint offset, nint length)
		{
			FlushMappedBufferRangeNative(target, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedNamedBufferRangeNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[176])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[176])(buffer, offset, length);
			#endif
		}

		public static void FlushMappedNamedBufferRange(uint buffer, nint offset, nint length)
		{
			FlushMappedNamedBufferRangeNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogfNative(GLFogParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, float, void>)funcTable[177])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, float, void>)funcTable[177])(pname, param);
			#endif
		}

		public static void Fogf(GLFogParameter pname, float param)
		{
			FogfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogfvNative(GLFogParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, float*, void>)funcTable[178])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, nint, void>)funcTable[178])(pname, (nint)@params);
			#endif
		}

		public static void Fogfv(GLFogParameter pname, float* @params)
		{
			FogfvNative(pname, @params);
		}

		public static void Fogfv(GLFogParameter pname, out float @params)
		{
			float pparams;
			FogfvNative(pname, &pparams);
			@params = pparams;
		}

		public static void Fogfv(GLFogParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				FogfvNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogxNative(GLFogPName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogPName, int, void>)funcTable[179])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogPName, int, void>)funcTable[179])(pname, param);
			#endif
		}

		public static void Fogx(GLFogPName pname, int param)
		{
			FogxNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogxvNative(GLFogPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogPName, int*, void>)funcTable[180])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogPName, nint, void>)funcTable[180])(pname, (nint)param);
			#endif
		}

		public static void Fogxv(GLFogPName pname, int* param)
		{
			FogxvNative(pname, param);
		}

		public static void Fogxv(GLFogPName pname, out int param)
		{
			int pparam;
			FogxvNative(pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferParameteriNative(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[181])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[181])(target, pname, param);
			#endif
		}

		public static void FramebufferParameteri(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			FramebufferParameteriNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferRenderbufferNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[182])(target, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[182])(target, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		public static void FramebufferRenderbuffer(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			FramebufferRenderbufferNative(target, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[183])(target, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[183])(target, attachment, texture, level);
			#endif
		}

		public static void FramebufferTexture(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			FramebufferTextureNative(target, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture1DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[184])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[184])(target, attachment, textarget, texture, level);
			#endif
		}

		public static void FramebufferTexture1D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture1DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture2DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[185])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[185])(target, attachment, textarget, texture, level);
			#endif
		}

		public static void FramebufferTexture2D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture2DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture3DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[186])(target, attachment, textarget, texture, level, zoffset);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[186])(target, attachment, textarget, texture, level, zoffset);
			#endif
		}

		public static void FramebufferTexture3D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			FramebufferTexture3DNative(target, attachment, textarget, texture, level, zoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureLayerNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[187])(target, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[187])(target, attachment, texture, level, layer);
			#endif
		}

		public static void FramebufferTextureLayer(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			FramebufferTextureLayerNative(target, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrontFaceNative(GLFrontFaceDirection mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[188])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[188])(mode);
			#endif
		}

		public static void FrontFace(GLFrontFaceDirection mode)
		{
			FrontFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrustumfNative(float l, float r, float b, float t, float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>)funcTable[189])(l, r, b, t, n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>)funcTable[189])(l, r, b, t, n, f);
			#endif
		}

		public static void Frustumf(float l, float r, float b, float t, float n, float f)
		{
			FrustumfNative(l, r, b, t, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrustumxNative(int l, int r, int b, int t, int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[190])(l, r, b, t, n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[190])(l, r, b, t, n, f);
			#endif
		}

		public static void Frustumx(int l, int r, int b, int t, int n, int f)
		{
			FrustumxNative(l, r, b, t, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[191])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[191])(n, (nint)buffers);
			#endif
		}

		public static void GenBuffers(int n, uint* buffers)
		{
			GenBuffersNative(n, buffers);
		}

		public static uint GenBuffer()
		{
			uint result;
			GenBuffersNative(1, &result);
			return result;
		}

		public static void GenBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				GenBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[192])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[192])(n, (nint)framebuffers);
			#endif
		}

		public static void GenFramebuffers(int n, uint* framebuffers)
		{
			GenFramebuffersNative(n, framebuffers);
		}

		public static uint GenFramebuffer()
		{
			uint result;
			GenFramebuffersNative(1, &result);
			return result;
		}

		public static void GenFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				GenFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[193])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[193])(n, (nint)pipelines);
			#endif
		}

		public static void GenProgramPipelines(int n, uint* pipelines)
		{
			GenProgramPipelinesNative(n, pipelines);
		}

		public static uint GenProgramPipeline()
		{
			uint result;
			GenProgramPipelinesNative(1, &result);
			return result;
		}

		public static void GenProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				GenProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[194])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[194])(n, (nint)ids);
			#endif
		}

		public static void GenQueries(int n, uint* ids)
		{
			GenQueriesNative(n, ids);
		}

		public static uint GenQuerie()
		{
			uint result;
			GenQueriesNative(1, &result);
			return result;
		}

		public static void GenQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[195])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[195])(n, (nint)renderbuffers);
			#endif
		}

		public static void GenRenderbuffers(int n, uint* renderbuffers)
		{
			GenRenderbuffersNative(n, renderbuffers);
		}

		public static uint GenRenderbuffer()
		{
			uint result;
			GenRenderbuffersNative(1, &result);
			return result;
		}

		public static void GenRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				GenRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[196])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[196])(count, (nint)samplers);
			#endif
		}

		public static void GenSamplers(int count, uint* samplers)
		{
			GenSamplersNative(count, samplers);
		}

		public static uint GenSampler()
		{
			uint result;
			GenSamplersNative(1, &result);
			return result;
		}

		public static void GenSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				GenSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[197])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[197])(n, (nint)textures);
			#endif
		}

		public static void GenTextures(int n, uint* textures)
		{
			GenTexturesNative(n, textures);
		}

		public static uint GenTexture()
		{
			uint result;
			GenTexturesNative(1, &result);
			return result;
		}

		public static void GenTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				GenTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[198])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[198])(n, (nint)ids);
			#endif
		}

		public static void GenTransformFeedbacks(int n, uint* ids)
		{
			GenTransformFeedbacksNative(n, ids);
		}

		public static uint GenTransformFeedback()
		{
			uint result;
			GenTransformFeedbacksNative(1, &result);
			return result;
		}

		public static void GenTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[199])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[199])(n, (nint)arrays);
			#endif
		}

		public static void GenVertexArrays(int n, uint* arrays)
		{
			GenVertexArraysNative(n, arrays);
		}

		public static uint GenVertexArray()
		{
			uint result;
			GenVertexArraysNative(1, &result);
			return result;
		}

		public static void GenVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				GenVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapNative(GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[200])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[200])(target);
			#endif
		}

		public static void GenerateMipmap(GLTextureTarget target)
		{
			GenerateMipmapNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[201])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[201])(texture);
			#endif
		}

		public static void GenerateTextureMipmap(uint texture)
		{
			GenerateTextureMipmapNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAtomicCounterBufferivNative(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, int*, void>)funcTable[202])(program, bufferIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, nint, void>)funcTable[202])(program, bufferIndex, pname, (nint)@params);
			#endif
		}

		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, @params);
		}

		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, out int @params)
		{
			int pparams;
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, &pparams);
			@params = pparams;
		}

		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAttribNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[203])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[203])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetActiveAttribNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveAttribNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveAttribNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveAttribNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[204])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[204])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, name);
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[205])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[205])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, name);
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformivNative(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, int*, void>)funcTable[206])(program, shadertype, index, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, nint, void>)funcTable[206])(program, shadertype, index, pname, (nint)values);
			#endif
		}

		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			GetActiveSubroutineUniformivNative(program, shadertype, index, pname, values);
		}

		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetActiveSubroutineUniformivNative(program, shadertype, index, pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNative(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLUniformType, byte*, void>)funcTable[207])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLUniformType, nint, void>)funcTable[207])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			GetActiveUniformNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveUniformNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockNameNative(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[208])(program, uniformBlockIndex, bufSize, length, uniformBlockName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[208])(program, uniformBlockIndex, bufSize, (nint)length, (nint)uniformBlockName);
			#endif
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, uniformBlockName);
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, byte* uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, uniformBlockName);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ReadOnlySpan<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, ref byte uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformBlockName1 = &uniformBlockName)
				{
					GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, puniformBlockName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockivNative(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, int*, void>)funcTable[209])(program, uniformBlockIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, nint, void>)funcTable[209])(program, uniformBlockIndex, pname, (nint)@params);
			#endif
		}

		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, @params);
		}

		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, out int @params)
		{
			int pparams;
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, &pparams);
			@params = pparams;
		}

		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNameNative(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[210])(program, uniformIndex, bufSize, length, uniformName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[210])(program, uniformIndex, bufSize, (nint)length, (nint)uniformName);
			#endif
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, uniformName);
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, byte* uniformName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, uniformName);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, string uniformName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ReadOnlySpan<byte> uniformName)
		{
			fixed (byte* puniformName0 = uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ref byte uniformName)
		{
			fixed (byte* puniformName0 = &uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, ref byte uniformName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformName1 = &uniformName)
				{
					GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, puniformName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformsivNative(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, GLUniformPName, int*, void>)funcTable[211])(program, uniformCount, uniformIndices, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, GLUniformPName, nint, void>)funcTable[211])(program, uniformCount, (nint)uniformIndices, pname, (nint)@params);
			#endif
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, @params);
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, out int @params)
		{
			int pparams;
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, &pparams);
			@params = pparams;
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, pparams);
			}
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, GLUniformPName pname, int* @params)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, @params);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAttachedShadersNative(uint program, int maxCount, int* count, uint* shaders)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, uint*, void>)funcTable[212])(program, maxCount, count, shaders);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[212])(program, maxCount, (nint)count, (nint)shaders);
			#endif
		}

		public static void GetAttachedShaders(uint program, int maxCount, int* count, uint* shaders)
		{
			GetAttachedShadersNative(program, maxCount, count, shaders);
		}

		public static void GetAttachedShaders(uint program, int maxCount, ref int count, uint* shaders)
		{
			fixed (int* pcount0 = &count)
			{
				GetAttachedShadersNative(program, maxCount, pcount0, shaders);
			}
		}

		public static void GetAttachedShaders(uint program, int maxCount, int* count, ref uint shaders)
		{
			fixed (uint* pshaders0 = &shaders)
			{
				GetAttachedShadersNative(program, maxCount, count, pshaders0);
			}
		}

		public static void GetAttachedShaders(uint program, int maxCount, ref int count, ref uint shaders)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (uint* pshaders1 = &shaders)
				{
					GetAttachedShadersNative(program, maxCount, pcount0, pshaders1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAttribLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[213])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[213])(program, (nint)name);
			#endif
		}

		public static int GetAttribLocation(uint program, byte* name)
		{
			int ret = GetAttribLocationNative(program, name);
			return ret;
		}

		public static int GetAttribLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetAttribLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetAttribLocation(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetAttribLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleani_vNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[214])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[214])(target, index, (nint)data);
			#endif
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleani_vNative(target, index, data);
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleani_vNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanvNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[215])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[215])(pname, (nint)data);
			#endif
		}

		public static void GetBooleanv(GLGetPName pname, byte* data)
		{
			GetBooleanvNative(pname, data);
		}

		public static void GetBooleanv(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanvNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameteri64vNative(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, long*, void>)funcTable[216])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[216])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			GetBufferParameteri64vNative(target, pname, @params);
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, out long @params)
		{
			long pparams;
			GetBufferParameteri64vNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, Span<long> @params)
		{
			fixed (long* pparams = @params)
			{
				GetBufferParameteri64vNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameterivNative(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, int*, void>)funcTable[217])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[217])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			GetBufferParameterivNative(target, pname, @params);
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, out int @params)
		{
			int pparams;
			GetBufferParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetBufferParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferPointervNative(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, void**, void>)funcTable[218])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, nint, void>)funcTable[218])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferPointerv(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			GetBufferPointervNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[219])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[219])(target, offset, size, (nint)data);
			#endif
		}

		public static void GetBufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			GetBufferSubDataNative(target, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetClipPlanefNative(GLClipPlaneName plane, float* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, float*, void>)funcTable[220])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[220])(plane, (nint)equation);
			#endif
		}

		public static void GetClipPlanef(GLClipPlaneName plane, float* equation)
		{
			GetClipPlanefNative(plane, equation);
		}

		public static void GetClipPlanef(GLClipPlaneName plane, ref float equation)
		{
			fixed (float* pequation0 = &equation)
			{
				GetClipPlanefNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetClipPlanexNative(GLClipPlaneName plane, int* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, int*, void>)funcTable[221])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[221])(plane, (nint)equation);
			#endif
		}

		public static void GetClipPlanex(GLClipPlaneName plane, int* equation)
		{
			GetClipPlanexNative(plane, equation);
		}

		public static void GetClipPlanex(GLClipPlaneName plane, ref int equation)
		{
			fixed (int* pequation0 = &equation)
			{
				GetClipPlanexNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTexImageNative(GLTextureTarget target, int level, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, void*, void>)funcTable[222])(target, level, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[222])(target, level, (nint)img);
			#endif
		}

		public static void GetCompressedTexImage(GLTextureTarget target, int level, void* img)
		{
			GetCompressedTexImageNative(target, level, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureImageNative(uint texture, int level, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void*, void>)funcTable[223])(texture, level, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[223])(texture, level, bufSize, (nint)pixels);
			#endif
		}

		public static void GetCompressedTextureImage(uint texture, int level, int bufSize, void* pixels)
		{
			GetCompressedTextureImageNative(texture, level, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void*, void>)funcTable[224])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, nint, void>)funcTable[224])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, (nint)pixels);
			#endif
		}

		public static void GetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			GetCompressedTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetDebugMessageLogNative(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, uint*, GLDebugSeverity, int*, byte*, uint>)funcTable[225])(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, nint, GLDebugSeverity, nint, nint, uint>)funcTable[225])(count, bufSize, sources, types, (nint)ids, severities, (nint)lengths, (nint)messageLog);
			#endif
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			return ret;
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, messageLog);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, messageLog);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, messageLog);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, string messageLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (messageLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(messageLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(messageLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, ReadOnlySpan<byte> messageLog)
		{
			fixed (byte* pmessageLog0 = messageLog)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (byte* pmessageLog0 = &messageLog)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, pmessageLog1);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, pmessageLog1);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					fixed (byte* pmessageLog2 = &messageLog)
					{
						uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, pmessageLog2);
						return ret;
					}
				}
			}
		}
	}
}
