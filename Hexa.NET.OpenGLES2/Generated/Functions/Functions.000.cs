// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES
{
	public static unsafe partial class GL
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveShaderProgramNative(uint pipeline, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#endif
		}

		/// <summary>
		/// Set the active program object for a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void ActiveShaderProgram(uint pipeline, uint program)
		{
			ActiveShaderProgramNative(pipeline, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#endif
		}

		/// <summary>
		/// Select active texture unit
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ActiveTexture(GLTextureUnit texture)
		{
			ActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlphaFuncNative(GLAlphaFunction func, float reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void AlphaFunc(GLAlphaFunction func, float reference)
		{
			AlphaFuncNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlphaFuncxNative(GLAlphaFunction func, int reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[3])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[3])(func, reference);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void AlphaFuncx(GLAlphaFunction func, int reference)
		{
			AlphaFuncxNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AttachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[4])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[4])(program, shader);
			#endif
		}

		/// <summary>
		/// Attaches a shader object to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void AttachShader(uint program, uint shader)
		{
			AttachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginConditionalRenderNative(uint id, GLConditionalRenderMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BeginConditionalRender(uint id, GLConditionalRenderMode mode)
		{
			BeginConditionalRenderNative(id, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryNative(GLQueryTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[6])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[6])(target, id);
			#endif
		}

		/// <summary>
		/// Delimit the boundaries of a query object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BeginQuery(GLQueryTarget target, uint id)
		{
			BeginQueryNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryIndexedNative(GLQueryTarget target, uint index, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[7])(target, index, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[7])(target, index, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public static void BeginQueryIndexed(GLQueryTarget target, uint index, uint id)
		{
			BeginQueryIndexedNative(target, index, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginTransformFeedbackNative(GLPrimitiveType primitiveMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#endif
		}

		/// <summary>
		/// Start transform feedback operation
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BeginTransformFeedback(GLPrimitiveType primitiveMode)
		{
			BeginTransformFeedbackNative(primitiveMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindAttribLocationNative(uint program, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[9])(program, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[9])(program, index, (nint)name);
			#endif
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindAttribLocation(uint program, uint index, byte* name)
		{
			BindAttribLocationNative(program, index, name);
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindAttribLocation(uint program, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindAttribLocationNative(program, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindAttribLocation(uint program, uint index, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindAttribLocation(uint program, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferNative(GLBufferTargetARB target, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[10])(target, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[10])(target, buffer);
			#endif
		}

		/// <summary>
		/// Bind a named buffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindBuffer(GLBufferTargetARB target, uint buffer)
		{
			BindBufferNative(target, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferBaseNative(GLBufferTargetARB target, uint index, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[11])(target, index, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[11])(target, index, buffer);
			#endif
		}

		/// <summary>
		/// Bind a buffer object to an indexed buffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void BindBufferBase(GLBufferTargetARB target, uint index, uint buffer)
		{
			BindBufferBaseNative(target, index, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferRangeNative(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#endif
		}

		/// <summary>
		/// Bind a range within a buffer object to an indexed buffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void BindBufferRange(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			BindBufferRangeNative(target, index, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBuffersBaseNative(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, void>)funcTable[13])(target, first, count, buffers);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, void>)funcTable[13])(target, first, count, (nint)buffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersBase(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			BindBuffersBaseNative(target, first, count, buffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersBase(GLBufferTargetARB target, uint first, int count, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				BindBuffersBaseNative(target, first, count, pbuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersBase(GLBufferTargetARB target, uint first, int count, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersBaseNative(target, first, count, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBuffersRangeNative(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, nint*, nint*, void>)funcTable[14])(target, first, count, buffers, offsets, sizes);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, nint, nint, void>)funcTable[14])(target, first, count, (nint)buffers, (nint)offsets, (nint)sizes);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			BindBuffersRangeNative(target, first, count, buffers, offsets, sizes);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, nint* offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				BindBuffersRangeNative(target, first, count, pbuffers0, offsets, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersRangeNative(target, first, count, pbuffers0, offsets, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, Span<nint> offsets, nint* sizes)
		{
			fixed (nint* poffsets0 = offsets)
			{
				BindBuffersRangeNative(target, first, count, buffers, poffsets0, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, nint* sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindBuffersRangeNative(target, first, count, buffers, poffsets0, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, Span<nint> offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, sizes);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, sizes);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, Span<nint> sizes)
		{
			fixed (nint* psizes0 = sizes)
			{
				BindBuffersRangeNative(target, first, count, buffers, offsets, psizes0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, ref nint sizes)
		{
			fixed (nint* psizes0 = &sizes)
			{
				BindBuffersRangeNative(target, first, count, buffers, offsets, psizes0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, nint* offsets, Span<nint> sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* psizes1 = sizes)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, offsets, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, offsets, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, Span<nint> offsets, Span<nint> sizes)
		{
			fixed (nint* poffsets0 = offsets)
			{
				fixed (nint* psizes1 = sizes)
				{
					BindBuffersRangeNative(target, first, count, buffers, poffsets0, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, ref nint sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, buffers, poffsets0, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, Span<nint> offsets, Span<nint> sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					fixed (nint* psizes2 = sizes)
					{
						BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, psizes2);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (nint* psizes2 = &sizes)
					{
						BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, psizes2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationNative(uint program, uint color, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[15])(program, color, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[15])(program, color, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindFragDataLocation(uint program, uint color, byte* name)
		{
			BindFragDataLocationNative(program, color, name);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindFragDataLocation(uint program, uint color, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationNative(program, color, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindFragDataLocation(uint program, uint color, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationNative(program, color, pname0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindFragDataLocation(uint program, uint color, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationNative(program, color, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationIndexedNative(uint program, uint colorNumber, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, byte*, void>)funcTable[16])(program, colorNumber, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, void>)funcTable[16])(program, colorNumber, index, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, byte* name)
		{
			BindFragDataLocationIndexedNative(program, colorNumber, index, name);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationIndexedNative(program, colorNumber, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFramebufferNative(GLFramebufferTarget target, uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[17])(target, framebuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[17])(target, framebuffer);
			#endif
		}

		/// <summary>
		/// Bind a framebuffer to a framebuffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void BindFramebuffer(GLFramebufferTarget target, uint framebuffer)
		{
			BindFramebufferNative(target, framebuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindImageTextureNative(uint unit, uint texture, int level, bool layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[18])(unit, texture, level, *((byte*)(&layered)), layer, access, format);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[18])(unit, texture, level, *((byte*)(&layered)), layer, access, format);
			#endif
		}

		/// <summary>
		/// Bind a level of a texture to an image unit
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_image_load_store</remarks>
		public static void BindImageTexture(uint unit, uint texture, int level, bool layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			BindImageTextureNative(unit, texture, level, layered, layer, access, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindImageTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[19])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[19])(first, count, (nint)textures);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindImageTextures(uint first, int count, uint* textures)
		{
			BindImageTexturesNative(first, count, textures);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindImageTextures(uint first, int count, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				BindImageTexturesNative(first, count, ptextures0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindImageTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindImageTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[20])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[20])(pipeline);
			#endif
		}

		/// <summary>
		/// Bind a program pipeline to the current context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void BindProgramPipeline(uint pipeline)
		{
			BindProgramPipelineNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindRenderbufferNative(GLRenderbufferTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[21])(target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[21])(target, renderbuffer);
			#endif
		}

		/// <summary>
		/// Bind a renderbuffer to a renderbuffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void BindRenderbuffer(GLRenderbufferTarget target, uint renderbuffer)
		{
			BindRenderbufferNative(target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindSamplerNative(uint unit, uint sampler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[22])(unit, sampler);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[22])(unit, sampler);
			#endif
		}

		/// <summary>
		/// Bind a named sampler to a texturing target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void BindSampler(uint unit, uint sampler)
		{
			BindSamplerNative(unit, sampler);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindSamplersNative(uint first, int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[23])(first, count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[23])(first, count, (nint)samplers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindSamplers(uint first, int count, uint* samplers)
		{
			BindSamplersNative(first, count, samplers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindSamplers(uint first, int count, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				BindSamplersNative(first, count, psamplers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindSamplers(uint first, int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				BindSamplersNative(first, count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTextureNative(GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[24])(target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[24])(target, texture);
			#endif
		}

		/// <summary>
		/// Bind a named texture to a texturing target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BindTexture(GLTextureTarget target, uint texture)
		{
			BindTextureNative(target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTextureUnitNative(uint unit, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[25])(unit, texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[25])(unit, texture);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void BindTextureUnit(uint unit, uint texture)
		{
			BindTextureUnitNative(unit, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[26])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[26])(first, count, (nint)textures);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindTextures(uint first, int count, uint* textures)
		{
			BindTexturesNative(first, count, textures);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindTextures(uint first, int count, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				BindTexturesNative(first, count, ptextures0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTransformFeedbackNative(GLBindTransformFeedbackTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[27])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[27])(target, id);
			#endif
		}

		/// <summary>
		/// Bind a transform feedback object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void BindTransformFeedback(GLBindTransformFeedbackTarget target, uint id)
		{
			BindTransformFeedbackNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[28])(array);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[28])(array);
			#endif
		}

		/// <summary>
		/// Bind a vertex array object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void BindVertexArray(uint array)
		{
			BindVertexArrayNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexBufferNative(uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[29])(bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[29])(bindingindex, buffer, offset, stride);
			#endif
		}

		/// <summary>
		/// Bind a buffer to a vertex buffer bind point
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public static void BindVertexBuffer(uint bindingindex, uint buffer, nint offset, int stride)
		{
			BindVertexBufferNative(bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexBuffersNative(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, nint*, int*, void>)funcTable[30])(first, count, buffers, offsets, strides);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, nint, void>)funcTable[30])(first, count, (nint)buffers, (nint)offsets, (nint)strides);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			BindVertexBuffersNative(first, count, buffers, offsets, strides);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, Span<uint> buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				BindVertexBuffersNative(first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindVertexBuffersNative(first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, uint* buffers, Span<nint> offsets, int* strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				BindVertexBuffersNative(first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, int* strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindVertexBuffersNative(first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, Span<uint> buffers, Span<nint> offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					BindVertexBuffersNative(first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindVertexBuffersNative(first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, Span<int> strides)
		{
			fixed (int* pstrides0 = strides)
			{
				BindVertexBuffersNative(first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, ref int strides)
		{
			fixed (int* pstrides0 = &strides)
			{
				BindVertexBuffersNative(first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, Span<uint> buffers, nint* offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (int* pstrides1 = strides)
				{
					BindVertexBuffersNative(first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, uint* buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				fixed (int* pstrides1 = strides)
				{
					BindVertexBuffersNative(first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, ref int strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, Span<uint> buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					fixed (int* pstrides2 = strides)
					{
						BindVertexBuffersNative(first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public static void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (int* pstrides2 = &strides)
					{
						BindVertexBuffersNative(first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[31])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[31])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// Set the blend color
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void BlendColor(float red, float green, float blue, float alpha)
		{
			BlendColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[32])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[32])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void BlendEquation(GLBlendEquationModeEXT mode)
		{
			BlendEquationNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateNative(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[33])(modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[33])(modeRGB, modeAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BlendEquationSeparate(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateNative(modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateiNative(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[34])(buf, modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[34])(buf, modeRGB, modeAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BlendEquationSeparatei(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateiNative(buf, modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationiNative(uint buf, GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[35])(buf, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[35])(buf, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BlendEquationi(uint buf, GLBlendEquationModeEXT mode)
		{
			BlendEquationiNative(buf, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncNative(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[36])(sfactor, dfactor);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[36])(sfactor, dfactor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BlendFunc(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			BlendFuncNative(sfactor, dfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateNative(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[37])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[37])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BlendFuncSeparate(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			BlendFuncSeparateNative(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateiNative(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[38])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[38])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BlendFuncSeparatei(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			BlendFuncSeparateiNative(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFunciNative(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(buf, src, dst);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(buf, src, dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BlendFunci(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			BlendFunciNative(buf, src, dst);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[40])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[40])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		/// <summary>
		/// Copy a block of pixels from one framebuffer object to another
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitNamedFramebufferNative(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void BlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitNamedFramebufferNative(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferDataNative(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, void*, GLBufferUsageARB, void>)funcTable[42])(target, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLBufferUsageARB, void>)funcTable[42])(target, size, (nint)data, usage);
			#endif
		}

		/// <summary>
		/// Creates and initializes a buffer object's data
		///     store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BufferData(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			BufferDataNative(target, size, data, usage);
		}

		/// <summary>
		/// Creates and initializes a buffer object's data
		///     store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BufferData(GLBufferTargetARB target, nint size, nint data, GLBufferUsageARB usage)
		{
			BufferDataNative(target, size, (void*)data, usage);
		}

		/// <summary>
		/// Creates and initializes a buffer object's data
		///     store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BufferData<TData>(GLBufferTargetARB target, nint size, Span<TData> data, GLBufferUsageARB usage) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				BufferDataNative(target, size, pdata0, usage);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageNative(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, void*, GLBufferStorageMask, void>)funcTable[43])(target, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, GLBufferStorageMask, void>)funcTable[43])(target, size, (nint)data, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_buffer_storage</remarks>
		public static void BufferStorage(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			BufferStorageNative(target, size, data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_buffer_storage</remarks>
		public static void BufferStorage(GLBufferStorageTarget target, nint size, nint data, GLBufferStorageMask flags)
		{
			BufferStorageNative(target, size, (void*)data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_buffer_storage</remarks>
		public static void BufferStorage<TData>(GLBufferStorageTarget target, nint size, Span<TData> data, GLBufferStorageMask flags) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				BufferStorageNative(target, size, pdata0, flags);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[44])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[44])(target, offset, size, (nint)data);
			#endif
		}

		/// <summary>
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			BufferSubDataNative(target, offset, size, data);
		}

		/// <summary>
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BufferSubData(GLBufferTargetARB target, nint offset, nint size, nint data)
		{
			BufferSubDataNative(target, offset, size, (void*)data);
		}

		/// <summary>
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void BufferSubData<TData>(GLBufferTargetARB target, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				BufferSubDataNative(target, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckFramebufferStatusNative(GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[45])(target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[45])(target);
			#endif
		}

		/// <summary>
		/// Check the completeness status of a framebuffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static GLEnum CheckFramebufferStatus(GLFramebufferTarget target)
		{
			GLEnum ret = CheckFramebufferStatusNative(target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckNamedFramebufferStatusNative(uint framebuffer, GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[46])(framebuffer, target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[46])(framebuffer, target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static GLEnum CheckNamedFramebufferStatus(uint framebuffer, GLFramebufferTarget target)
		{
			GLEnum ret = CheckNamedFramebufferStatusNative(framebuffer, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClampColorNative(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[47])(target, clamp);
			#else
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[47])(target, clamp);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClampColor(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			ClampColorNative(target, clamp);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(GLClearBufferMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[48])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[48])(mask);
			#endif
		}

		/// <summary>
		/// Clear buffers to preset values
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Clear(GLClearBufferMask mask)
		{
			ClearNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferDataNative(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[49])(target, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[49])(target, internalformat, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public static void ClearBufferData(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferDataNative(target, internalformat, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public static void ClearBufferData(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearBufferDataNative(target, internalformat, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public static void ClearBufferData<TData>(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearBufferDataNative(target, internalformat, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferSubDataNative(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[50])(target, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[50])(target, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public static void ClearBufferSubData(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferSubDataNative(target, internalformat, offset, size, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public static void ClearBufferSubData(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearBufferSubDataNative(target, internalformat, offset, size, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public static void ClearBufferSubData<TData>(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearBufferSubDataNative(target, internalformat, offset, size, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferfiNative(GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float, int, void>)funcTable[51])(buffer, drawbuffer, depth, stencil);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float, int, void>)funcTable[51])(buffer, drawbuffer, depth, stencil);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferfi(GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			ClearBufferfiNative(buffer, drawbuffer, depth, stencil);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferfvNative(GLBuffer buffer, int drawbuffer, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float*, void>)funcTable[52])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[52])(buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferfv(GLBuffer buffer, int drawbuffer, float* value)
		{
			ClearBufferfvNative(buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferfv(GLBuffer buffer, int drawbuffer, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ClearBufferfvNative(buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferfv(GLBuffer buffer, int drawbuffer, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ClearBufferfvNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferivNative(GLBuffer buffer, int drawbuffer, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, int*, void>)funcTable[53])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[53])(buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferiv(GLBuffer buffer, int drawbuffer, int* value)
		{
			ClearBufferivNative(buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferiv(GLBuffer buffer, int drawbuffer, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ClearBufferivNative(buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferiv(GLBuffer buffer, int drawbuffer, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ClearBufferivNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferuivNative(GLBuffer buffer, int drawbuffer, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, uint*, void>)funcTable[54])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[54])(buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferuiv(GLBuffer buffer, int drawbuffer, uint* value)
		{
			ClearBufferuivNative(buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferuiv(GLBuffer buffer, int drawbuffer, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ClearBufferuivNative(buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearBufferuiv(GLBuffer buffer, int drawbuffer, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ClearBufferuivNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[55])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[55])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// Specify clear values for the color buffers
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearColor(float red, float green, float blue, float alpha)
		{
			ClearColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorxNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[56])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[56])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearColorx(int red, int green, int blue, int alpha)
		{
			ClearColorxNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthNative(double depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[57])(depth);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[57])(depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearDepth(double depth)
		{
			ClearDepthNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthfNative(float d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[58])(d);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[58])(d);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void ClearDepthf(float d)
		{
			ClearDepthfNative(d);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthxNative(int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[59])(depth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[59])(depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearDepthx(int depth)
		{
			ClearDepthxNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferDataNative(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[60])(buffer, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[60])(buffer, internalformat, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedBufferData(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferDataNative(buffer, internalformat, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedBufferData(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearNamedBufferDataNative(buffer, internalformat, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedBufferData<TData>(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearNamedBufferDataNative(buffer, internalformat, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferSubDataNative(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[61])(buffer, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[61])(buffer, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedBufferSubData(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedBufferSubData(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedBufferSubData<TData>(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferfiNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[62])(framebuffer, buffer, drawbuffer, depth, stencil);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[62])(framebuffer, buffer, drawbuffer, depth, stencil);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferfi(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			ClearNamedFramebufferfiNative(framebuffer, buffer, drawbuffer, depth, stencil);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferfvNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float*, void>)funcTable[63])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[63])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, int*, void>)funcTable[64])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[64])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferuivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, uint*, void>)funcTable[65])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[65])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearStencilNative(int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[66])(s);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[66])(s);
			#endif
		}

		/// <summary>
		/// Specify the clear value for the stencil buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClearStencil(int s)
		{
			ClearStencilNative(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexImageNative(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[67])(texture, level, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[67])(texture, level, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public static void ClearTexImage(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexImageNative(texture, level, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public static void ClearTexImage(uint texture, int level, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearTexImageNative(texture, level, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public static void ClearTexImage<TData>(uint texture, int level, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearTexImageNative(texture, level, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[68])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[68])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public static void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public static void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public static void ClearTexSubImage<TData>(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[69])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[69])(texture);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClientActiveTexture(GLTextureUnit texture)
		{
			ClientActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum ClientWaitSyncNative(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[70])(sync, flags, timeout);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[70])(sync, flags, timeout);
			#endif
		}

		/// <summary>
		/// Block and wait for a sync object to become signaled
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static GLEnum ClientWaitSync(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			GLEnum ret = ClientWaitSyncNative(sync, flags, timeout);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipControlNative(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[71])(origin, depth);
			#else
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[71])(origin, depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clip_control</remarks>
		public static void ClipControl(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			ClipControlNative(origin, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipPlanefNative(GLClipPlaneName p, float* eqn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, float*, void>)funcTable[72])(p, eqn);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[72])(p, (nint)eqn);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClipPlanef(GLClipPlaneName p, float* eqn)
		{
			ClipPlanefNative(p, eqn);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClipPlanef(GLClipPlaneName p, Span<float> eqn)
		{
			fixed (float* peqn0 = eqn)
			{
				ClipPlanefNative(p, peqn0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClipPlanef(GLClipPlaneName p, ref float eqn)
		{
			fixed (float* peqn0 = &eqn)
			{
				ClipPlanefNative(p, peqn0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipPlanexNative(GLClipPlaneName plane, int* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, int*, void>)funcTable[73])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[73])(plane, (nint)equation);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClipPlanex(GLClipPlaneName plane, int* equation)
		{
			ClipPlanexNative(plane, equation);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClipPlanex(GLClipPlaneName plane, Span<int> equation)
		{
			fixed (int* pequation0 = equation)
			{
				ClipPlanexNative(plane, pequation0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ClipPlanex(GLClipPlaneName plane, ref int equation)
		{
			fixed (int* pequation0 = &equation)
			{
				ClipPlanexNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4fNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[74])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[74])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Color4f(float red, float green, float blue, float alpha)
		{
			Color4fNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4ubNative(bool red, bool green, bool blue, bool alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[75])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[75])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Color4ub(bool red, bool green, bool blue, bool alpha)
		{
			Color4ubNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4xNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[76])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[76])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Color4x(int red, int green, int blue, int alpha)
		{
			Color4xNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaskNative(bool red, bool green, bool blue, bool alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[77])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[77])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ColorMask(bool red, bool green, bool blue, bool alpha)
		{
			ColorMaskNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaskiNative(uint index, bool r, bool g, bool b, bool a)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[78])(index, *((byte*)(&r)), *((byte*)(&g)), *((byte*)(&b)), *((byte*)(&a)));
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[78])(index, *((byte*)(&r)), *((byte*)(&g)), *((byte*)(&b)), *((byte*)(&a)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ColorMaski(uint index, bool r, bool g, bool b, bool a)
		{
			ColorMaskiNative(index, r, g, b, a);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorPointerNative(int size, GLColorPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void*, void>)funcTable[79])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, nint, void>)funcTable[79])(size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ColorPointer(int size, GLColorPointerType type, int stride, void* pointer)
		{
			ColorPointerNative(size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ColorPointer(int size, GLColorPointerType type, int stride, nint pointer)
		{
			ColorPointerNative(size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void ColorPointer<TPointer>(int size, GLColorPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				ColorPointerNative(size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[80])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[80])(shader);
			#endif
		}

		/// <summary>
		/// Compiles a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompileShader(uint shader)
		{
			CompileShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[81])(target, level, internalformat, width, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[81])(target, level, internalformat, width, border, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, nint data)
		{
			CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage1D<TData>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[82])(target, level, internalformat, width, height, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[82])(target, level, internalformat, width, height, border, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, nint data)
		{
			CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage2D<TData>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage3DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[83])(target, level, internalformat, width, height, depth, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[83])(target, level, internalformat, width, height, depth, border, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, nint data)
		{
			CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexImage3D<TData>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[84])(target, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[84])(target, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage1D<TData>(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[85])(target, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[85])(target, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, (void*)data);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage2D<TData>(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[86])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[86])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)data);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CompressedTexSubImage3D<TData>(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage1DNative(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, void*, void>)funcTable[87])(texture, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, nint, void>)funcTable[87])(texture, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage1D<TData>(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[88])(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[88])(texture, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage2D<TData>(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[89])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[89])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CompressedTextureSubImage3D<TData>(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyBufferSubDataNative(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[90])(readTarget, writeTarget, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[90])(readTarget, writeTarget, readOffset, writeOffset, size);
			#endif
		}

		/// <summary>
		/// Copy all or part of the data store of a buffer object to the data store of another buffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_copy_buffer</remarks>
		public static void CopyBufferSubData(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			CopyBufferSubDataNative(readTarget, writeTarget, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyImageSubDataNative(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[91])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[91])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#endif
		}

		/// <summary>
		/// Perform a raw data copy between two images
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_copy_image</remarks>
		public static void CopyImageSubData(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			CopyImageSubDataNative(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyNamedBufferSubDataNative(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[92])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[92])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CopyNamedBufferSubData(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			CopyNamedBufferSubDataNative(readBuffer, writeBuffer, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[93])(target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[93])(target, level, internalformat, x, y, width, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CopyTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTexImage1DNative(target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[94])(target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[94])(target, level, internalformat, x, y, width, height, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CopyTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTexImage2DNative(target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[95])(target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[95])(target, level, xoffset, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CopyTexSubImage1D(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTexSubImage1DNative(target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[96])(target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[96])(target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CopyTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage2DNative(target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[97])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[97])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CopyTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage1DNative(uint texture, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[98])(texture, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[98])(texture, level, xoffset, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width)
		{
			CopyTextureSubImage1DNative(texture, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[99])(texture, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[99])(texture, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage2DNative(texture, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[100])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[100])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[101])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[101])(n, (nint)buffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateBuffers(int n, uint* buffers)
		{
			CreateBuffersNative(n, buffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateBuffers(int n, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				CreateBuffersNative(n, pbuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				CreateBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[102])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[102])(n, (nint)framebuffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateFramebuffers(int n, uint* framebuffers)
		{
			CreateFramebuffersNative(n, framebuffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateFramebuffers(int n, Span<uint> framebuffers)
		{
			fixed (uint* pframebuffers0 = framebuffers)
			{
				CreateFramebuffersNative(n, pframebuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				CreateFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateProgramNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[103])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[103])();
			#endif
		}

		/// <summary>
		/// Creates a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static uint CreateProgram()
		{
			uint ret = CreateProgramNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[104])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[104])(n, (nint)pipelines);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateProgramPipelines(int n, uint* pipelines)
		{
			CreateProgramPipelinesNative(n, pipelines);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateProgramPipelines(int n, Span<uint> pipelines)
		{
			fixed (uint* ppipelines0 = pipelines)
			{
				CreateProgramPipelinesNative(n, ppipelines0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				CreateProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateQueriesNative(GLQueryTarget target, int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, uint*, void>)funcTable[105])(target, n, ids);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, nint, void>)funcTable[105])(target, n, (nint)ids);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateQueries(GLQueryTarget target, int n, uint* ids)
		{
			CreateQueriesNative(target, n, ids);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateQueries(GLQueryTarget target, int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				CreateQueriesNative(target, n, pids0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateQueries(GLQueryTarget target, int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateQueriesNative(target, n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[106])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[106])(n, (nint)renderbuffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateRenderbuffers(int n, uint* renderbuffers)
		{
			CreateRenderbuffersNative(n, renderbuffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateRenderbuffers(int n, Span<uint> renderbuffers)
		{
			fixed (uint* prenderbuffers0 = renderbuffers)
			{
				CreateRenderbuffersNative(n, prenderbuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				CreateRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateSamplersNative(int n, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[107])(n, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[107])(n, (nint)samplers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateSamplers(int n, uint* samplers)
		{
			CreateSamplersNative(n, samplers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateSamplers(int n, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				CreateSamplersNative(n, psamplers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateSamplers(int n, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				CreateSamplersNative(n, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderNative(GLShaderType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[108])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[108])(type);
			#endif
		}

		/// <summary>
		/// Creates a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static uint CreateShader(GLShaderType type)
		{
			uint ret = CreateShaderNative(type);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderProgramvNative(GLShaderType type, int count, byte** strings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, int, byte**, uint>)funcTable[109])(type, count, strings);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, uint>)funcTable[109])(type, count, (nint)strings);
			#endif
		}

		/// <summary>
		/// Create a stand-alone program from an array of null-terminated source code strings
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static uint CreateShaderProgramv(GLShaderType type, int count, byte** strings)
		{
			uint ret = CreateShaderProgramvNative(type, count, strings);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateTexturesNative(GLTextureTarget target, int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, uint*, void>)funcTable[110])(target, n, textures);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[110])(target, n, (nint)textures);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateTextures(GLTextureTarget target, int n, uint* textures)
		{
			CreateTexturesNative(target, n, textures);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateTextures(GLTextureTarget target, int n, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				CreateTexturesNative(target, n, ptextures0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateTextures(GLTextureTarget target, int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				CreateTexturesNative(target, n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[111])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[111])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateTransformFeedbacks(int n, uint* ids)
		{
			CreateTransformFeedbacksNative(n, ids);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateTransformFeedbacks(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				CreateTransformFeedbacksNative(n, pids0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[112])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[112])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateVertexArrays(int n, uint* arrays)
		{
			CreateVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CullFaceNative(GLTriangleFace mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[113])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[113])(mode);
			#endif
		}

		/// <summary>
		/// Specify whether front- or back-facing facets can be culled
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void CullFace(GLTriangleFace mode)
		{
			CullFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageCallbackNative(GLDebugProc callback, void* userParam)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[114])((void*)Utils.GetFunctionPointerForDelegate(callback), userParam);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[114])(Utils.GetFunctionPointerForDelegate(callback), (nint)userParam);
			#endif
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageCallback(GLDebugProc callback, void* userParam)
		{
			DebugMessageCallbackNative(callback, userParam);
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageCallback(GLDebugProc callback, nint userParam)
		{
			DebugMessageCallbackNative(callback, (void*)userParam);
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageCallback<TUserParam>(GLDebugProc callback, Span<TUserParam> userParam) where TUserParam : unmanaged
		{
			fixed (TUserParam* puserParam0 = userParam)
			{
				DebugMessageCallbackNative(callback, puserParam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageControlNative(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, bool enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, uint*, byte, void>)funcTable[115])(source, type, severity, count, ids, *((byte*)(&enabled)));
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, nint, byte, void>)funcTable[115])(source, type, severity, count, (nint)ids, *((byte*)(&enabled)));
			#endif
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, bool enabled)
		{
			DebugMessageControlNative(source, type, severity, count, ids, enabled);
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, Span<uint> ids, bool enabled)
		{
			fixed (uint* pids0 = ids)
			{
				DebugMessageControlNative(source, type, severity, count, pids0, enabled);
			}
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, ref uint ids, bool enabled)
		{
			fixed (uint* pids0 = &ids)
			{
				DebugMessageControlNative(source, type, severity, count, pids0, enabled);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageInsertNative(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, byte*, void>)funcTable[116])(source, type, id, severity, length, buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, nint, void>)funcTable[116])(source, type, id, severity, length, (nint)buf);
			#endif
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			DebugMessageInsertNative(source, type, id, severity, length, buf);
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugMessageInsertNative(source, type, id, severity, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, Span<byte> buf)
		{
			fixed (byte* pbuf0 = buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, ref byte buf)
		{
			fixed (byte* pbuf0 = &buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[117])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[117])(n, (nint)buffers);
			#endif
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteBuffers(int n, uint* buffers)
		{
			DeleteBuffersNative(n, buffers);
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteBuffer(uint buffer)
		{
			DeleteBuffersNative(1, &buffer);
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteBuffers(int n, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[118])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[118])(n, (nint)framebuffers);
			#endif
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffers(int n, uint* framebuffers)
		{
			DeleteFramebuffersNative(n, framebuffers);
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffer(uint framebuffer)
		{
			DeleteFramebuffersNative(1, &framebuffer);
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffers(int n, Span<uint> framebuffers)
		{
			fixed (uint* pframebuffers0 = framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[119])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[119])(program);
			#endif
		}

		/// <summary>
		/// Deletes a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteProgram(uint program)
		{
			DeleteProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[120])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[120])(n, (nint)pipelines);
			#endif
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipelines(int n, uint* pipelines)
		{
			DeleteProgramPipelinesNative(n, pipelines);
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipeline(uint pipeline)
		{
			DeleteProgramPipelinesNative(1, &pipeline);
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipelines(int n, Span<uint> pipelines)
		{
			fixed (uint* ppipelines0 = pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[121])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[121])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteQueries(int n, uint* ids)
		{
			DeleteQueriesNative(n, ids);
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteQuerie(uint id)
		{
			DeleteQueriesNative(1, &id);
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteQueries(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[122])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[122])(n, (nint)renderbuffers);
			#endif
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffers(int n, uint* renderbuffers)
		{
			DeleteRenderbuffersNative(n, renderbuffers);
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffer(uint renderbuffer)
		{
			DeleteRenderbuffersNative(1, &renderbuffer);
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffers(int n, Span<uint> renderbuffers)
		{
			fixed (uint* prenderbuffers0 = renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[123])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[123])(count, (nint)samplers);
			#endif
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void DeleteSamplers(int count, uint* samplers)
		{
			DeleteSamplersNative(count, samplers);
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void DeleteSampler(uint sampler)
		{
			DeleteSamplersNative(1, &sampler);
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void DeleteSamplers(int count, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void DeleteSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[124])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[124])(shader);
			#endif
		}

		/// <summary>
		/// Deletes a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteShader(uint shader)
		{
			DeleteShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[125])(sync);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[125])(sync);
			#endif
		}

		/// <summary>
		/// Delete a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void DeleteSync(GLSync sync)
		{
			DeleteSyncNative(sync);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[126])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[126])(n, (nint)textures);
			#endif
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteTextures(int n, uint* textures)
		{
			DeleteTexturesNative(n, textures);
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteTexture(uint texture)
		{
			DeleteTexturesNative(1, &texture);
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteTextures(int n, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DeleteTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[127])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[127])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedbacks(int n, uint* ids)
		{
			DeleteTransformFeedbacksNative(n, ids);
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedback(uint id)
		{
			DeleteTransformFeedbacksNative(1, &id);
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedbacks(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[128])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[128])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArrays(int n, uint* arrays)
		{
			DeleteVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArray(uint array)
		{
			DeleteVertexArraysNative(1, &array);
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthFuncNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[129])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[129])(func);
			#endif
		}

		/// <summary>
		/// Specify the value used for depth buffer comparisons
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DepthFunc(GLDepthFunction func)
		{
			DepthFuncNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthMaskNative(bool flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[130])(*((byte*)(&flag)));
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[130])(*((byte*)(&flag)));
			#endif
		}

		/// <summary>
		/// Enable or disable writing into the depth buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DepthMask(bool flag)
		{
			DepthMaskNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeNative(double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[131])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[131])(n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DepthRange(double n, double f)
		{
			DepthRangeNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeArrayvNative(uint first, int count, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[132])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[132])(first, count, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeArrayv(uint first, int count, double* v)
		{
			DepthRangeArrayvNative(first, count, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeArrayv(uint first, int count, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeArrayv(uint first, int count, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeIndexedNative(uint index, double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[133])(index, n, f);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[133])(index, n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeIndexed(uint index, double n, double f)
		{
			DepthRangeIndexedNative(index, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangefNative(float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[134])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[134])(n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void DepthRangef(float n, float f)
		{
			DepthRangefNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangexNative(int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[135])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[135])(n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DepthRangex(int n, int f)
		{
			DepthRangexNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[136])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[136])(program, shader);
			#endif
		}

		/// <summary>
		/// Detaches a shader object from a program object to which it is attached
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DetachShader(uint program, uint shader)
		{
			DetachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[137])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[137])(cap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Disable(GLEnableCap cap)
		{
			DisableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[138])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[138])(array);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DisableClientState(GLEnableCap array)
		{
			DisableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[139])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[139])(vaobj, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void DisableVertexArrayAttrib(uint vaobj, uint index)
		{
			DisableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[140])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[140])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DisableVertexAttribArray(uint index)
		{
			DisableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableiNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[141])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[141])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Disablei(GLEnableCap target, uint index)
		{
			DisableiNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeNative(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[142])(numGroupsX, numGroupsY, numGroupsZ);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[142])(numGroupsX, numGroupsY, numGroupsZ);
			#endif
		}

		/// <summary>
		/// Launch one or more compute work groups
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_compute_shader</remarks>
		public static void DispatchCompute(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			DispatchComputeNative(numGroupsX, numGroupsY, numGroupsZ);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeIndirectNative(nint indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[143])(indirect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[143])(indirect);
			#endif
		}

		/// <summary>
		/// Launch one or more compute work groups using parameters stored in a buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_compute_shader</remarks>
		public static void DispatchComputeIndirect(nint indirect)
		{
			DispatchComputeIndirectNative(indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysNative(GLPrimitiveType mode, int first, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[144])(mode, first, count);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[144])(mode, first, count);
			#endif
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawArrays(GLPrimitiveType mode, int first, int count)
		{
			DrawArraysNative(mode, first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysIndirectNative(GLPrimitiveType mode, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, void>)funcTable[145])(mode, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, void>)funcTable[145])(mode, (nint)indirect);
			#endif
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawArraysIndirect(GLPrimitiveType mode, void* indirect)
		{
			DrawArraysIndirectNative(mode, indirect);
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawArraysIndirect(GLPrimitiveType mode, nint indirect)
		{
			DrawArraysIndirectNative(mode, (void*)indirect);
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawArraysIndirect<TIndirect>(GLPrimitiveType mode, Span<TIndirect> indirect) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				DrawArraysIndirectNative(mode, pindirect0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedNative(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[146])(mode, first, count, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[146])(mode, first, count, instancecount);
			#endif
		}

		/// <summary>
		/// Draw multiple instances of a range of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawArraysInstanced(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			DrawArraysInstancedNative(mode, first, count, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedBaseInstanceNative(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[147])(mode, first, count, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[147])(mode, first, count, instancecount, baseinstance);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawArraysInstancedBaseInstance(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			DrawArraysInstancedBaseInstanceNative(mode, first, count, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBufferNative(GLDrawBufferMode buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[148])(buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[148])(buf);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawBuffer(GLDrawBufferMode buf)
		{
			DrawBufferNative(buf);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersNative(int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[149])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[149])(n, bufs);
			#endif
		}

		/// <summary>
		/// Specifies a list of color buffers to be drawn
		///     into
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawBuffers(int n, GLDrawBufferMode bufs)
		{
			DrawBuffersNative(n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, void>)funcTable[150])(mode, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, void>)funcTable[150])(mode, count, type, (nint)indices);
			#endif
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			DrawElementsNative(mode, count, type, indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices)
		{
			DrawElementsNative(mode, count, type, (void*)indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawElements<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsNative(mode, count, type, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[151])(mode, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[151])(mode, count, type, (nint)indices, basevertex);
			#endif
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, (void*)indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsBaseVertex<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int basevertex) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsBaseVertexNative(mode, count, type, pindices0, basevertex);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsIndirectNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, void>)funcTable[152])(mode, type, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, void>)funcTable[152])(mode, type, (nint)indirect);
			#endif
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			DrawElementsIndirectNative(mode, type, indirect);
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, nint indirect)
		{
			DrawElementsIndirectNative(mode, type, (void*)indirect);
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawElementsIndirect<TIndirect>(GLPrimitiveType mode, GLDrawElementsType type, Span<TIndirect> indirect) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				DrawElementsIndirectNative(mode, type, pindirect0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[153])(mode, count, type, indices, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[153])(mode, count, type, (nint)indices, instancecount);
			#endif
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawElementsInstanced(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			DrawElementsInstancedNative(mode, count, type, indices, instancecount);
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawElementsInstanced(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount)
		{
			DrawElementsInstancedNative(mode, count, type, (void*)indices, instancecount);
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void DrawElementsInstanced<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedNative(mode, count, type, pindices0, instancecount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, uint, void>)funcTable[154])(mode, count, type, indices, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, uint, void>)funcTable[154])(mode, count, type, (nint)indices, instancecount, baseinstance);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, indices, instancecount, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, (void*)indices, instancecount, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseInstance<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount, uint baseinstance) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedBaseInstanceNative(mode, count, type, pindices0, instancecount, baseinstance);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, void>)funcTable[155])(mode, count, type, indices, instancecount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, void>)funcTable[155])(mode, count, type, (nint)indices, instancecount, basevertex);
			#endif
		}

		/// <summary>
		/// Render multiple instances of a set of primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsInstancedBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexNative(mode, count, type, indices, instancecount, basevertex);
		}

		/// <summary>
		/// Render multiple instances of a set of primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsInstancedBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexNative(mode, count, type, (void*)indices, instancecount, basevertex);
		}

		/// <summary>
		/// Render multiple instances of a set of primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsInstancedBaseVertex<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount, int basevertex) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedBaseVertexNative(mode, count, type, pindices0, instancecount, basevertex);
			}
		}
	}
}
