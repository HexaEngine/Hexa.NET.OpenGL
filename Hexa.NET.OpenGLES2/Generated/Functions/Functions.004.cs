// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES
{
	public unsafe partial class GL
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, string pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pEntryPoint != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pEntryPoint);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pEntryPoint, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SpecializeShaderNative(shader, pStr0, numSpecializationConstants, pConstantIndex, pConstantValue);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, Span<byte> pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = pEntryPoint)
			{
				SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, pConstantIndex, pConstantValue);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, ref byte pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = &pEntryPoint)
			{
				SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, pConstantIndex, pConstantValue);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, byte* pEntryPoint, uint numSpecializationConstants, Span<uint> pConstantIndex, uint* pConstantValue)
		{
			fixed (uint* ppConstantIndex0 = pConstantIndex)
			{
				SpecializeShaderNative(shader, pEntryPoint, numSpecializationConstants, ppConstantIndex0, pConstantValue);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, byte* pEntryPoint, uint numSpecializationConstants, ref uint pConstantIndex, uint* pConstantValue)
		{
			fixed (uint* ppConstantIndex0 = &pConstantIndex)
			{
				SpecializeShaderNative(shader, pEntryPoint, numSpecializationConstants, ppConstantIndex0, pConstantValue);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, Span<byte> pEntryPoint, uint numSpecializationConstants, Span<uint> pConstantIndex, uint* pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = pEntryPoint)
			{
				fixed (uint* ppConstantIndex1 = pConstantIndex)
				{
					SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, ppConstantIndex1, pConstantValue);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, ref byte pEntryPoint, uint numSpecializationConstants, ref uint pConstantIndex, uint* pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = &pEntryPoint)
			{
				fixed (uint* ppConstantIndex1 = &pConstantIndex)
				{
					SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, ppConstantIndex1, pConstantValue);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, Span<uint> pConstantValue)
		{
			fixed (uint* ppConstantValue0 = pConstantValue)
			{
				SpecializeShaderNative(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, ppConstantValue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, byte* pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, ref uint pConstantValue)
		{
			fixed (uint* ppConstantValue0 = &pConstantValue)
			{
				SpecializeShaderNative(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, ppConstantValue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, Span<byte> pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, Span<uint> pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = pEntryPoint)
			{
				fixed (uint* ppConstantValue1 = pConstantValue)
				{
					SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, pConstantIndex, ppConstantValue1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, ref byte pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, ref uint pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = &pEntryPoint)
			{
				fixed (uint* ppConstantValue1 = &pConstantValue)
				{
					SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, pConstantIndex, ppConstantValue1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, byte* pEntryPoint, uint numSpecializationConstants, Span<uint> pConstantIndex, Span<uint> pConstantValue)
		{
			fixed (uint* ppConstantIndex0 = pConstantIndex)
			{
				fixed (uint* ppConstantValue1 = pConstantValue)
				{
					SpecializeShaderNative(shader, pEntryPoint, numSpecializationConstants, ppConstantIndex0, ppConstantValue1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, byte* pEntryPoint, uint numSpecializationConstants, ref uint pConstantIndex, ref uint pConstantValue)
		{
			fixed (uint* ppConstantIndex0 = &pConstantIndex)
			{
				fixed (uint* ppConstantValue1 = &pConstantValue)
				{
					SpecializeShaderNative(shader, pEntryPoint, numSpecializationConstants, ppConstantIndex0, ppConstantValue1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, Span<byte> pEntryPoint, uint numSpecializationConstants, Span<uint> pConstantIndex, Span<uint> pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = pEntryPoint)
			{
				fixed (uint* ppConstantIndex1 = pConstantIndex)
				{
					fixed (uint* ppConstantValue2 = pConstantValue)
					{
						SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, ppConstantIndex1, ppConstantValue2);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SpecializeShader(uint shader, ref byte pEntryPoint, uint numSpecializationConstants, ref uint pConstantIndex, ref uint pConstantValue)
		{
			fixed (byte* ppEntryPoint0 = &pEntryPoint)
			{
				fixed (uint* ppConstantIndex1 = &pConstantIndex)
				{
					fixed (uint* ppConstantValue2 = &pConstantValue)
					{
						SpecializeShaderNative(shader, ppEntryPoint0, numSpecializationConstants, ppConstantIndex1, ppConstantValue2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void StencilFuncNative(GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[526])(func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[526])(func, reference, mask);
			#endif
		}

		/// <summary>
		/// Set front and back function and reference value for stencil testing
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void StencilFunc(GLStencilFunction func, int reference, uint mask)
		{
			StencilFuncNative(func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void StencilFuncSeparateNative(GLTriangleFace face, GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilFunction, int, uint, void>)funcTable[527])(face, func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilFunction, int, uint, void>)funcTable[527])(face, func, reference, mask);
			#endif
		}

		/// <summary>
		/// Set front and/or back function and reference value for stencil testing
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void StencilFuncSeparate(GLTriangleFace face, GLStencilFunction func, int reference, uint mask)
		{
			StencilFuncSeparateNative(face, func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void StencilMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[528])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[528])(mask);
			#endif
		}

		/// <summary>
		/// Control the front and back writing of individual bits in the stencil planes
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void StencilMask(uint mask)
		{
			StencilMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void StencilMaskSeparateNative(GLTriangleFace face, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, uint, void>)funcTable[529])(face, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, uint, void>)funcTable[529])(face, mask);
			#endif
		}

		/// <summary>
		/// Control the front and/or back writing of individual bits in the stencil planes
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void StencilMaskSeparate(GLTriangleFace face, uint mask)
		{
			StencilMaskSeparateNative(face, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void StencilOpNative(GLStencilOp fail, GLStencilOp zfail, GLStencilOp zpass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[530])(fail, zfail, zpass);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[530])(fail, zfail, zpass);
			#endif
		}

		/// <summary>
		/// Set front and back stencil test actions
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void StencilOp(GLStencilOp fail, GLStencilOp zfail, GLStencilOp zpass)
		{
			StencilOpNative(fail, zfail, zpass);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void StencilOpSeparateNative(GLTriangleFace face, GLStencilOp sfail, GLStencilOp dpfail, GLStencilOp dppass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[531])(face, sfail, dpfail, dppass);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[531])(face, sfail, dpfail, dppass);
			#endif
		}

		/// <summary>
		/// Set front and/or back stencil test actions
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void StencilOpSeparate(GLTriangleFace face, GLStencilOp sfail, GLStencilOp dpfail, GLStencilOp dppass)
		{
			StencilOpSeparateNative(face, sfail, dpfail, dppass);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexBufferNative(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[532])(target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[532])(target, internalformat, buffer);
			#endif
		}

		/// <summary>
		/// Attach a buffer object's data store to a buffer texture object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexBuffer(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			TexBufferNative(target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexBufferRangeNative(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[533])(target, internalformat, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[533])(target, internalformat, buffer, offset, size);
			#endif
		}

		/// <summary>
		/// Attach a range of a buffer object's data store to a buffer texture object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_buffer_range</remarks>
		public void TexBufferRange(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			TexBufferRangeNative(target, internalformat, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexCoordPointerNative(int size, GLTexCoordPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLTexCoordPointerType, int, void*, void>)funcTable[534])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLTexCoordPointerType, int, nint, void>)funcTable[534])(size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexCoordPointer(int size, GLTexCoordPointerType type, int stride, void* pointer)
		{
			TexCoordPointerNative(size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexCoordPointer(int size, GLTexCoordPointerType type, int stride, nint pointer)
		{
			TexCoordPointerNative(size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexCoordPointer<TPointer>(int size, GLTexCoordPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				TexCoordPointerNative(size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexEnvfNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, float, void>)funcTable[535])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, float, void>)funcTable[535])(target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvf(GLTextureEnvTarget target, GLTextureEnvParameter pname, float param)
		{
			TexEnvfNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexEnvfvNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[536])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[536])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			TexEnvfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				TexEnvfvNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				TexEnvfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexEnviNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[537])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[537])(target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvi(GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			TexEnviNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexEnvivNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[538])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[538])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			TexEnvivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TexEnvivNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TexEnvivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexEnvxNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[539])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[539])(target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvx(GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			TexEnvxNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexEnvxvNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[540])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[540])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvxv(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			TexEnvxvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvxv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TexEnvxvNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexEnvxv(GLTextureEnvTarget target, GLTextureEnvParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TexEnvxvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[541])(target, level, internalformat, width, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[541])(target, level, internalformat, width, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexImage1DNative(target, level, internalformat, width, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexImage1DNative(target, level, internalformat, width, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage1D<TPixels>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexImage1DNative(target, level, internalformat, width, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[542])(target, level, internalformat, width, height, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[542])(target, level, internalformat, width, height, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexImage2DNative(target, level, internalformat, width, height, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexImage2DNative(target, level, internalformat, width, height, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage2D<TPixels>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexImage2DNative(target, level, internalformat, width, height, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexImage2DMultisampleNative(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, byte, void>)funcTable[543])(target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, byte, void>)funcTable[543])(target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_multisample</remarks>
		public void TexImage2DMultisample(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			TexImage2DMultisampleNative(target, samples, internalformat, width, height, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexImage3DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[544])(target, level, internalformat, width, height, depth, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[544])(target, level, internalformat, width, height, depth, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexImage3DNative(target, level, internalformat, width, height, depth, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexImage3DNative(target, level, internalformat, width, height, depth, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexImage3D<TPixels>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexImage3DNative(target, level, internalformat, width, height, depth, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexImage3DMultisampleNative(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, byte, void>)funcTable[545])(target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, byte, void>)funcTable[545])(target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_multisample</remarks>
		public void TexImage3DMultisample(GLTextureTarget target, int samples, GLInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			TexImage3DMultisampleNative(target, samples, internalformat, width, height, depth, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameterIivNative(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[546])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[546])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterIiv(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TexParameterIivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterIiv(GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TexParameterIivNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterIiv(GLTextureTarget target, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TexParameterIivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameterIuivNative(GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[547])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[547])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterIuiv(GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			TexParameterIuivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterIuiv(GLTextureTarget target, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				TexParameterIuivNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterIuiv(GLTextureTarget target, GLTextureParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				TexParameterIuivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameterfNative(GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, float, void>)funcTable[548])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, float, void>)funcTable[548])(target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterf(GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			TexParameterfNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameterfvNative(GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, float*, void>)funcTable[549])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[549])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterfv(GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			TexParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterfv(GLTextureTarget target, GLTextureParameterName pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				TexParameterfvNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterfv(GLTextureTarget target, GLTextureParameterName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				TexParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameteriNative(GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int, void>)funcTable[550])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int, void>)funcTable[550])(target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameteri(GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			TexParameteriNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameterivNative(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[551])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[551])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameteriv(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TexParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameteriv(GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TexParameterivNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameteriv(GLTextureTarget target, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TexParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameterxNative(GLTextureTarget target, GLGetTextureParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int, void>)funcTable[552])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int, void>)funcTable[552])(target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterx(GLTextureTarget target, GLGetTextureParameter pname, int param)
		{
			TexParameterxNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexParameterxvNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[553])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[553])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterxv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			TexParameterxvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterxv(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TexParameterxvNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexParameterxv(GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TexParameterxvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorage1DNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, void>)funcTable[554])(target, levels, internalformat, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, void>)funcTable[554])(target, levels, internalformat, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_storage</remarks>
		public void TexStorage1D(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			TexStorage1DNative(target, levels, internalformat, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorage2DNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, void>)funcTable[555])(target, levels, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, void>)funcTable[555])(target, levels, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_storage</remarks>
		public void TexStorage2D(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			TexStorage2DNative(target, levels, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorage2DMultisampleNative(GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[556])(target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[556])(target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// Specify storage for a two-dimensional multisample texture
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_storage_multisample</remarks>
		public void TexStorage2DMultisample(GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			TexStorage2DMultisampleNative(target, samples, internalformat, width, height, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorage3DNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, void>)funcTable[557])(target, levels, internalformat, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, void>)funcTable[557])(target, levels, internalformat, width, height, depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_storage</remarks>
		public void TexStorage3D(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			TexStorage3DNative(target, levels, internalformat, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorage3DMultisampleNative(GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[558])(target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[558])(target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// Specify storage for a two-dimensional multisample array texture
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_storage_multisample</remarks>
		public void TexStorage3DMultisample(GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			TexStorage3DMultisampleNative(target, samples, internalformat, width, height, depth, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[559])(target, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[559])(target, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage1DNative(target, level, xoffset, width, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage1DNative(target, level, xoffset, width, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage1D<TPixels>(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage1DNative(target, level, xoffset, width, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[560])(target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[560])(target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage2D<TPixels>(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[561])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[561])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TexSubImage3D<TPixels>(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureBarrierNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[562])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[562])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_barrier</remarks>
		public void TextureBarrier()
		{
			TextureBarrierNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureBufferNative(uint texture, GLSizedInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, uint, void>)funcTable[563])(texture, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, uint, void>)funcTable[563])(texture, internalformat, buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureBuffer(uint texture, GLSizedInternalFormat internalformat, uint buffer)
		{
			TextureBufferNative(texture, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureBufferRangeNative(uint texture, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[564])(texture, internalformat, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[564])(texture, internalformat, buffer, offset, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureBufferRange(uint texture, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			TextureBufferRangeNative(texture, internalformat, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterIivNative(uint texture, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, int*, void>)funcTable[565])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, nint, void>)funcTable[565])(texture, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterIiv(uint texture, GLTextureParameterName pname, int* @params)
		{
			TextureParameterIivNative(texture, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterIiv(uint texture, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TextureParameterIivNative(texture, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterIiv(uint texture, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TextureParameterIivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterIuivNative(uint texture, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, uint*, void>)funcTable[566])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, nint, void>)funcTable[566])(texture, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterIuiv(uint texture, GLTextureParameterName pname, uint* @params)
		{
			TextureParameterIuivNative(texture, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterIuiv(uint texture, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				TextureParameterIuivNative(texture, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterIuiv(uint texture, GLTextureParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				TextureParameterIuivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterfNative(uint texture, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, float, void>)funcTable[567])(texture, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, float, void>)funcTable[567])(texture, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterf(uint texture, GLTextureParameterName pname, float param)
		{
			TextureParameterfNative(texture, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterfvNative(uint texture, GLTextureParameterName pname, float* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, float*, void>)funcTable[568])(texture, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, nint, void>)funcTable[568])(texture, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterfv(uint texture, GLTextureParameterName pname, float* param)
		{
			TextureParameterfvNative(texture, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterfv(uint texture, GLTextureParameterName pname, Span<float> param)
		{
			fixed (float* pparam0 = param)
			{
				TextureParameterfvNative(texture, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameterfv(uint texture, GLTextureParameterName pname, ref float param)
		{
			fixed (float* pparam0 = &param)
			{
				TextureParameterfvNative(texture, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameteriNative(uint texture, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, int, void>)funcTable[569])(texture, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, int, void>)funcTable[569])(texture, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameteri(uint texture, GLTextureParameterName pname, int param)
		{
			TextureParameteriNative(texture, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterivNative(uint texture, GLTextureParameterName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, int*, void>)funcTable[570])(texture, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureParameterName, nint, void>)funcTable[570])(texture, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameteriv(uint texture, GLTextureParameterName pname, int* param)
		{
			TextureParameterivNative(texture, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameteriv(uint texture, GLTextureParameterName pname, Span<int> param)
		{
			fixed (int* pparam0 = param)
			{
				TextureParameterivNative(texture, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureParameteriv(uint texture, GLTextureParameterName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				TextureParameterivNative(texture, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage1DNative(uint texture, int levels, GLSizedInternalFormat internalformat, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, void>)funcTable[571])(texture, levels, internalformat, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, void>)funcTable[571])(texture, levels, internalformat, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureStorage1D(uint texture, int levels, GLSizedInternalFormat internalformat, int width)
		{
			TextureStorage1DNative(texture, levels, internalformat, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage2DNative(uint texture, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, void>)funcTable[572])(texture, levels, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, void>)funcTable[572])(texture, levels, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureStorage2D(uint texture, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			TextureStorage2DNative(texture, levels, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage2DMultisampleNative(uint texture, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[573])(texture, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[573])(texture, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureStorage2DMultisample(uint texture, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			TextureStorage2DMultisampleNative(texture, samples, internalformat, width, height, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage3DNative(uint texture, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, void>)funcTable[574])(texture, levels, internalformat, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, void>)funcTable[574])(texture, levels, internalformat, width, height, depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureStorage3D(uint texture, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			TextureStorage3DNative(texture, levels, internalformat, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage3DMultisampleNative(uint texture, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[575])(texture, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[575])(texture, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureStorage3DMultisample(uint texture, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			TextureStorage3DMultisampleNative(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureSubImage1DNative(uint texture, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[576])(texture, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[576])(texture, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage1D(uint texture, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage1DNative(texture, level, xoffset, width, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage1D(uint texture, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage1DNative(texture, level, xoffset, width, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage1D<TPixels>(uint texture, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage1DNative(texture, level, xoffset, width, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[577])(texture, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[577])(texture, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage2D<TPixels>(uint texture, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[578])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[578])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TextureSubImage3D<TPixels>(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureViewNative(uint texture, GLTextureTarget target, uint origtexture, GLSizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, GLSizedInternalFormat, uint, uint, uint, uint, void>)funcTable[579])(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, GLSizedInternalFormat, uint, uint, uint, uint, void>)funcTable[579])(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_view</remarks>
		public void TextureView(uint texture, GLTextureTarget target, uint origtexture, GLSizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers)
		{
			TextureViewNative(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TransformFeedbackBufferBaseNative(uint xfb, uint index, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[580])(xfb, index, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[580])(xfb, index, buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TransformFeedbackBufferBase(uint xfb, uint index, uint buffer)
		{
			TransformFeedbackBufferBaseNative(xfb, index, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TransformFeedbackBufferRangeNative(uint xfb, uint index, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, nint, void>)funcTable[581])(xfb, index, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, nint, void>)funcTable[581])(xfb, index, buffer, offset, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void TransformFeedbackBufferRange(uint xfb, uint index, uint buffer, nint offset, nint size)
		{
			TransformFeedbackBufferRangeNative(xfb, index, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TransformFeedbackVaryingsNative(uint program, int count, byte** varyings, GLTransformFeedbackBufferMode bufferMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, GLTransformFeedbackBufferMode, void>)funcTable[582])(program, count, varyings, bufferMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, GLTransformFeedbackBufferMode, void>)funcTable[582])(program, count, (nint)varyings, bufferMode);
			#endif
		}

		/// <summary>
		/// Specify values to record in transform feedback buffers
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void TransformFeedbackVaryings(uint program, int count, byte** varyings, GLTransformFeedbackBufferMode bufferMode)
		{
			TransformFeedbackVaryingsNative(program, count, varyings, bufferMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TranslatefNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[583])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[583])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Translatef(float x, float y, float z)
		{
			TranslatefNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TranslatexNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[584])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[584])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Translatex(int x, int y, int z)
		{
			TranslatexNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1dNative(int location, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, void>)funcTable[585])(location, x);
			#else
			((delegate* unmanaged[Cdecl]<int, double, void>)funcTable[585])(location, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform1d(int location, double x)
		{
			Uniform1dNative(location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1dvNative(int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, double*, void>)funcTable[586])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[586])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform1dv(int location, int count, double* value)
		{
			Uniform1dvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform1dv(int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				Uniform1dvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform1dv(int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				Uniform1dvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1fNative(int location, float v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[587])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[587])(location, v0);
			#endif
		}

		/// <summary>
		/// Specify the value of a uniform variable for the current program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1f(int location, float v0)
		{
			Uniform1fNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[588])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[588])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1fv(int location, int count, float* value)
		{
			Uniform1fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform1fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform1fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1iNative(int location, int v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[589])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[589])(location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1i(int location, int v0)
		{
			Uniform1iNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[590])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[590])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1iv(int location, int count, int* value)
		{
			Uniform1ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform1ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform1ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1uiNative(int location, uint v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, void>)funcTable[591])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, void>)funcTable[591])(location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1ui(int location, uint v0)
		{
			Uniform1uiNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform1uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[592])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[592])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1uiv(int location, int count, uint* value)
		{
			Uniform1uivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform1uivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform1uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform1uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2dNative(int location, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[593])(location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[593])(location, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform2d(int location, double x, double y)
		{
			Uniform2dNative(location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2dvNative(int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, double*, void>)funcTable[594])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[594])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform2dv(int location, int count, double* value)
		{
			Uniform2dvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform2dv(int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				Uniform2dvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform2dv(int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				Uniform2dvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2fNative(int location, float v0, float v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[595])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[595])(location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2f(int location, float v0, float v1)
		{
			Uniform2fNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[596])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[596])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2fv(int location, int count, float* value)
		{
			Uniform2fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform2fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform2fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2iNative(int location, int v0, int v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[597])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[597])(location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2i(int location, int v0, int v1)
		{
			Uniform2iNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[598])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[598])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2iv(int location, int count, int* value)
		{
			Uniform2ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform2ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform2ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2uiNative(int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[599])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[599])(location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2ui(int location, uint v0, uint v1)
		{
			Uniform2uiNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform2uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[600])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[600])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2uiv(int location, int count, uint* value)
		{
			Uniform2uivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform2uivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform2uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform2uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3dNative(int location, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, double, void>)funcTable[601])(location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, double, void>)funcTable[601])(location, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform3d(int location, double x, double y, double z)
		{
			Uniform3dNative(location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3dvNative(int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, double*, void>)funcTable[602])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[602])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform3dv(int location, int count, double* value)
		{
			Uniform3dvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform3dv(int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				Uniform3dvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform3dv(int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				Uniform3dvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3fNative(int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[603])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[603])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3f(int location, float v0, float v1, float v2)
		{
			Uniform3fNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[604])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[604])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3fv(int location, int count, float* value)
		{
			Uniform3fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3iNative(int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[605])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[605])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3i(int location, int v0, int v1, int v2)
		{
			Uniform3iNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[606])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[606])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3iv(int location, int count, int* value)
		{
			Uniform3ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3uiNative(int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[607])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[607])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3ui(int location, uint v0, uint v1, uint v2)
		{
			Uniform3uiNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform3uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[608])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[608])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3uiv(int location, int count, uint* value)
		{
			Uniform3uivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform3uivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform3uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform3uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4dNative(int location, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, double, double, void>)funcTable[609])(location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, double, double, void>)funcTable[609])(location, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform4d(int location, double x, double y, double z, double w)
		{
			Uniform4dNative(location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4dvNative(int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, double*, void>)funcTable[610])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[610])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform4dv(int location, int count, double* value)
		{
			Uniform4dvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform4dv(int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				Uniform4dvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void Uniform4dv(int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				Uniform4dvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4fNative(int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[611])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[611])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4f(int location, float v0, float v1, float v2, float v3)
		{
			Uniform4fNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[612])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[612])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4fv(int location, int count, float* value)
		{
			Uniform4fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4iNative(int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[613])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[613])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4i(int location, int v0, int v1, int v2, int v3)
		{
			Uniform4iNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[614])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[614])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4iv(int location, int count, int* value)
		{
			Uniform4ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4uiNative(int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[615])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[615])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3)
		{
			Uniform4uiNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Uniform4uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[616])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[616])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4uiv(int location, int count, uint* value)
		{
			Uniform4uivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform4uivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Uniform4uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform4uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformBlockBindingNative(uint program, uint uniformBlockIndex, uint uniformBlockBinding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[617])(program, uniformBlockIndex, uniformBlockBinding);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[617])(program, uniformBlockIndex, uniformBlockBinding);
			#endif
		}

		/// <summary>
		/// Assign a binding point to an active uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public void UniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding)
		{
			UniformBlockBindingNative(program, uniformBlockIndex, uniformBlockBinding);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix2dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[618])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[618])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix2dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix2dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix2dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[619])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[619])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix2x3dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[620])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[620])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2x3dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix2x3dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2x3dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix2x3dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2x3dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix2x3dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix2x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[621])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[621])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix2x4dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[622])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[622])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2x4dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix2x4dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2x4dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix2x4dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix2x4dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix2x4dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix2x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[623])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[623])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix2x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix3dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[624])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[624])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix3dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix3dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix3dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[625])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[625])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix3x2dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[626])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[626])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3x2dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix3x2dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3x2dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix3x2dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3x2dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix3x2dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix3x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[627])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[627])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix3x4dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[628])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[628])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3x4dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix3x4dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3x4dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix3x4dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix3x4dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix3x4dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix3x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[629])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[629])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix3x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix4dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[630])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[630])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix4dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix4dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix4dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[631])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[631])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix4x2dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[632])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[632])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4x2dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix4x2dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4x2dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix4x2dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4x2dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix4x2dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix4x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[633])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[633])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix4x3dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[634])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[634])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4x3dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix4x3dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4x3dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix4x3dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public void UniformMatrix4x3dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix4x3dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformMatrix4x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[635])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[635])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UniformMatrix4x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UniformSubroutinesuivNative(GLShaderType shadertype, int count, uint* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, int, uint*, void>)funcTable[636])(shadertype, count, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, void>)funcTable[636])(shadertype, count, (nint)indices);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public void UniformSubroutinesuiv(GLShaderType shadertype, int count, uint* indices)
		{
			UniformSubroutinesuivNative(shadertype, count, indices);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public void UniformSubroutinesuiv(GLShaderType shadertype, int count, Span<uint> indices)
		{
			fixed (uint* pindices0 = indices)
			{
				UniformSubroutinesuivNative(shadertype, count, pindices0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public void UniformSubroutinesuiv(GLShaderType shadertype, int count, ref uint indices)
		{
			fixed (uint* pindices0 = &indices)
			{
				UniformSubroutinesuivNative(shadertype, count, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte UnmapBufferNative(GLBufferTargetARB target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[637])(target);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[637])(target);
			#endif
		}

		/// <summary>
		/// Release the mapping of a buffer object's data store into the client's address space
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public bool UnmapBuffer(GLBufferTargetARB target)
		{
			byte ret = UnmapBufferNative(target);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte UnmapNamedBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[638])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[638])(buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public bool UnmapNamedBuffer(uint buffer)
		{
			byte ret = UnmapNamedBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UseProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[639])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[639])(program);
			#endif
		}

		/// <summary>
		/// Installs a program object as part of current rendering state
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void UseProgram(uint program)
		{
			UseProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void UseProgramStagesNative(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[640])(pipeline, stages, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[640])(pipeline, stages, program);
			#endif
		}

		/// <summary>
		/// Bind stages of a program object to a program pipeline
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void UseProgramStages(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			UseProgramStagesNative(pipeline, stages, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ValidateProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[641])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[641])(program);
			#endif
		}

		/// <summary>
		/// Validates a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ValidateProgram(uint program)
		{
			ValidateProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ValidateProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[642])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[642])(pipeline);
			#endif
		}

		/// <summary>
		/// Validate a program pipeline object against current GL state
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ValidateProgramPipeline(uint pipeline)
		{
			ValidateProgramPipelineNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayAttribBindingNative(uint vaobj, uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[643])(vaobj, attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[643])(vaobj, attribindex, bindingindex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayAttribBinding(uint vaobj, uint attribindex, uint bindingindex)
		{
			VertexArrayAttribBindingNative(vaobj, attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayAttribFormatNative(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[644])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[644])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayAttribFormat(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			VertexArrayAttribFormatNative(vaobj, attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayAttribIFormatNative(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[645])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[645])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayAttribIFormat(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexArrayAttribIFormatNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayAttribLFormatNative(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[646])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[646])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayAttribLFormat(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexArrayAttribLFormatNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayBindingDivisorNative(uint vaobj, uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[647])(vaobj, bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[647])(vaobj, bindingindex, divisor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayBindingDivisor(uint vaobj, uint bindingindex, uint divisor)
		{
			VertexArrayBindingDivisorNative(vaobj, bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayElementBufferNative(uint vaobj, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[648])(vaobj, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[648])(vaobj, buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayElementBuffer(uint vaobj, uint buffer)
		{
			VertexArrayElementBufferNative(vaobj, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexBufferNative(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[649])(vaobj, bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[649])(vaobj, bindingindex, buffer, offset, stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffer(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			VertexArrayVertexBufferNative(vaobj, bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexBuffersNative(uint vaobj, uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, uint*, nint*, int*, void>)funcTable[650])(vaobj, first, count, buffers, offsets, strides);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, nint, void>)funcTable[650])(vaobj, first, count, (nint)buffers, (nint)offsets, (nint)strides);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			VertexArrayVertexBuffersNative(vaobj, first, count, buffers, offsets, strides);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, Span<nint> offsets, int* strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, ref nint offsets, int* strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, Span<nint> offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, ref nint offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, nint* offsets, Span<int> strides)
		{
			fixed (int* pstrides0 = strides)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, nint* offsets, ref int strides)
		{
			fixed (int* pstrides0 = &strides)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, nint* offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (int* pstrides1 = strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, nint* offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (int* pstrides1 = &strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				fixed (int* pstrides1 = strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, ref nint offsets, ref int strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (int* pstrides1 = &strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					fixed (int* pstrides2 = strides)
					{
						VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, ref nint offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (int* pstrides2 = &strides)
					{
						VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib1dNative(uint index, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[651])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[651])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1d(uint index, double x)
		{
			VertexAttrib1dNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib1dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[652])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[652])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1dv(uint index, double* v)
		{
			VertexAttrib1dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib1fNative(uint index, float x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[653])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[653])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1f(uint index, float x)
		{
			VertexAttrib1fNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib1fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[654])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[654])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1fv(uint index, float* v)
		{
			VertexAttrib1fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib1sNative(uint index, short x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[655])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[655])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1s(uint index, short x)
		{
			VertexAttrib1sNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib1svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[656])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[656])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1sv(uint index, short* v)
		{
			VertexAttrib1svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib1sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib2dNative(uint index, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[657])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[657])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2d(uint index, double x, double y)
		{
			VertexAttrib2dNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib2dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[658])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[658])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2dv(uint index, double* v)
		{
			VertexAttrib2dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib2fNative(uint index, float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[659])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[659])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2f(uint index, float x, float y)
		{
			VertexAttrib2fNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib2fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[660])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[660])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2fv(uint index, float* v)
		{
			VertexAttrib2fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib2sNative(uint index, short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[661])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[661])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2s(uint index, short x, short y)
		{
			VertexAttrib2sNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib2svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[662])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[662])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2sv(uint index, short* v)
		{
			VertexAttrib2svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib2sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib3dNative(uint index, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[663])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[663])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3d(uint index, double x, double y, double z)
		{
			VertexAttrib3dNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib3dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[664])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[664])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3dv(uint index, double* v)
		{
			VertexAttrib3dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib3fNative(uint index, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[665])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[665])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3f(uint index, float x, float y, float z)
		{
			VertexAttrib3fNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib3fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[666])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[666])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3fv(uint index, float* v)
		{
			VertexAttrib3fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib3sNative(uint index, short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[667])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[667])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3s(uint index, short x, short y, short z)
		{
			VertexAttrib3sNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib3svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[668])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[668])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3sv(uint index, short* v)
		{
			VertexAttrib3svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib3sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4NbvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[669])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[669])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nbv(uint index, sbyte* v)
		{
			VertexAttrib4NbvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nbv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nbv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4NivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[670])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[670])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Niv(uint index, int* v)
		{
			VertexAttrib4NivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Niv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Niv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4NsvNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[671])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[671])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nsv(uint index, short* v)
		{
			VertexAttrib4NsvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nsv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nsv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4NubNative(uint index, bool x, bool y, bool z, bool w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[672])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[672])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nub(uint index, bool x, bool y, bool z, bool w)
		{
			VertexAttrib4NubNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4NubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[673])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[673])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nubv(uint index, byte* v)
		{
			VertexAttrib4NubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4NubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4NuivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[674])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[674])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nuiv(uint index, uint* v)
		{
			VertexAttrib4NuivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nuiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nuiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4NusvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[675])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[675])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nusv(uint index, ushort* v)
		{
			VertexAttrib4NusvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nusv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void VertexAttrib4Nusv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}
	}
}
