// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryIndexedNative(GLQueryTarget target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[156])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[156])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public static void EndQueryIndexed(GLQueryTarget target, uint index)
		{
			EndQueryIndexedNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndTransformFeedbackNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[157])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[157])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void EndTransformFeedback()
		{
			EndTransformFeedbackNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLSync FenceSyncNative(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[158])(condition, flags);
			#else
			return (GLSync)((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[158])(condition, flags);
			#endif
		}

		/// <summary>
		/// Create a new sync object and insert it into the GL command stream
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static GLSync FenceSync(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			GLSync ret = FenceSyncNative(condition, flags);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FinishNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[159])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[159])();
			#endif
		}

		/// <summary>
		/// Block until all GL execution is complete
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Finish()
		{
			FinishNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[160])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[160])();
			#endif
		}

		/// <summary>
		/// Force execution of GL commands in finite time
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Flush()
		{
			FlushNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedBufferRangeNative(GLBufferTargetARB target, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[161])(target, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[161])(target, offset, length);
			#endif
		}

		/// <summary>
		/// Indicate modifications to a range of a mapped buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_map_buffer_range</remarks>
		public static void FlushMappedBufferRange(GLBufferTargetARB target, nint offset, nint length)
		{
			FlushMappedBufferRangeNative(target, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedNamedBufferRangeNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[162])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[162])(buffer, offset, length);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void FlushMappedNamedBufferRange(uint buffer, nint offset, nint length)
		{
			FlushMappedNamedBufferRangeNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferParameteriNative(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[163])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[163])(target, pname, param);
			#endif
		}

		/// <summary>
		/// Set a named parameter of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_no_attachments</remarks>
		public static void FramebufferParameteri(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			FramebufferParameteriNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferRenderbufferNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[164])(target, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[164])(target, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		/// <summary>
		/// Attach a renderbuffer as a logical buffer of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferRenderbuffer(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			FramebufferRenderbufferNative(target, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[165])(target, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[165])(target, attachment, texture, level);
			#endif
		}

		/// <summary>
		/// Attach a level of a texture object as a logical buffer of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void FramebufferTexture(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			FramebufferTextureNative(target, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture1DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[166])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[166])(target, attachment, textarget, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTexture1D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture1DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture2DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[167])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[167])(target, attachment, textarget, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTexture2D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture2DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture3DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[168])(target, attachment, textarget, texture, level, zoffset);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[168])(target, attachment, textarget, texture, level, zoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTexture3D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			FramebufferTexture3DNative(target, attachment, textarget, texture, level, zoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureLayerNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[169])(target, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[169])(target, attachment, texture, level, layer);
			#endif
		}

		/// <summary>
		/// Attach a single layer of a texture object as a logical buffer of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTextureLayer(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			FramebufferTextureLayerNative(target, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrontFaceNative(GLFrontFaceDirection mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[170])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[170])(mode);
			#endif
		}

		/// <summary>
		/// Define front- and back-facing polygons
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void FrontFace(GLFrontFaceDirection mode)
		{
			FrontFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[171])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[171])(n, (nint)buffers);
			#endif
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenBuffers(int n, uint* buffers)
		{
			GenBuffersNative(n, buffers);
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static uint GenBuffer()
		{
			uint result;
			GenBuffersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenBuffers(int n, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				GenBuffersNative(n, pbuffers0);
			}
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				GenBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[172])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[172])(n, (nint)framebuffers);
			#endif
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenFramebuffers(int n, uint* framebuffers)
		{
			GenFramebuffersNative(n, framebuffers);
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static uint GenFramebuffer()
		{
			uint result;
			GenFramebuffersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenFramebuffers(int n, Span<uint> framebuffers)
		{
			fixed (uint* pframebuffers0 = framebuffers)
			{
				GenFramebuffersNative(n, pframebuffers0);
			}
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				GenFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[173])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[173])(n, (nint)pipelines);
			#endif
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GenProgramPipelines(int n, uint* pipelines)
		{
			GenProgramPipelinesNative(n, pipelines);
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static uint GenProgramPipeline()
		{
			uint result;
			GenProgramPipelinesNative(1, &result);
			return result;
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GenProgramPipelines(int n, Span<uint> pipelines)
		{
			fixed (uint* ppipelines0 = pipelines)
			{
				GenProgramPipelinesNative(n, ppipelines0);
			}
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GenProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				GenProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[174])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[174])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenQueries(int n, uint* ids)
		{
			GenQueriesNative(n, ids);
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static uint GenQuerie()
		{
			uint result;
			GenQueriesNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenQueries(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				GenQueriesNative(n, pids0);
			}
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[175])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[175])(n, (nint)renderbuffers);
			#endif
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenRenderbuffers(int n, uint* renderbuffers)
		{
			GenRenderbuffersNative(n, renderbuffers);
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static uint GenRenderbuffer()
		{
			uint result;
			GenRenderbuffersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenRenderbuffers(int n, Span<uint> renderbuffers)
		{
			fixed (uint* prenderbuffers0 = renderbuffers)
			{
				GenRenderbuffersNative(n, prenderbuffers0);
			}
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				GenRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[176])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[176])(count, (nint)samplers);
			#endif
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GenSamplers(int count, uint* samplers)
		{
			GenSamplersNative(count, samplers);
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static uint GenSampler()
		{
			uint result;
			GenSamplersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GenSamplers(int count, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				GenSamplersNative(count, psamplers0);
			}
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GenSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				GenSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[177])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[177])(n, (nint)textures);
			#endif
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenTextures(int n, uint* textures)
		{
			GenTexturesNative(n, textures);
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static uint GenTexture()
		{
			uint result;
			GenTexturesNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenTextures(int n, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				GenTexturesNative(n, ptextures0);
			}
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				GenTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[178])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[178])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void GenTransformFeedbacks(int n, uint* ids)
		{
			GenTransformFeedbacksNative(n, ids);
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static uint GenTransformFeedback()
		{
			uint result;
			GenTransformFeedbacksNative(1, &result);
			return result;
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void GenTransformFeedbacks(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				GenTransformFeedbacksNative(n, pids0);
			}
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void GenTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[179])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[179])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void GenVertexArrays(int n, uint* arrays)
		{
			GenVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static uint GenVertexArray()
		{
			uint result;
			GenVertexArraysNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void GenVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				GenVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void GenVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				GenVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapNative(GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[180])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[180])(target);
			#endif
		}

		/// <summary>
		/// Generate mipmaps for a specified texture object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenerateMipmap(GLTextureTarget target)
		{
			GenerateMipmapNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[181])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[181])(texture);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GenerateTextureMipmap(uint texture)
		{
			GenerateTextureMipmapNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAtomicCounterBufferivNative(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, int*, void>)funcTable[182])(program, bufferIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, nint, void>)funcTable[182])(program, bufferIndex, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Retrieve information about the set of active atomic counter buffers for a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_shader_atomic_counters</remarks>
		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, @params);
		}

		/// <summary>
		/// Retrieve information about the set of active atomic counter buffers for a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_shader_atomic_counters</remarks>
		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, out int @params)
		{
			int pparam;
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Retrieve information about the set of active atomic counter buffers for a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_shader_atomic_counters</remarks>
		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAttribNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[183])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[183])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetActiveAttribNative(program, index, bufSize, length, size, type, name);
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveAttribNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveAttribNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = size)
			{
				GetActiveAttribNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveAttribNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveAttribNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* psize0 = size)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveAttribNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					fixed (byte* pname2 = name)
					{
						GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[184])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[184])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, name);
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[185])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[185])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, name);
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformivNative(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, int*, void>)funcTable[186])(program, shadertype, index, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, nint, void>)funcTable[186])(program, shadertype, index, pname, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			GetActiveSubroutineUniformivNative(program, shadertype, index, pname, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, out int values)
		{
			int pparam;
			GetActiveSubroutineUniformivNative(program, shadertype, index, pname, &pparam);
			values = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, Span<int> values)
		{
			fixed (int* pparams = values)
			{
				GetActiveSubroutineUniformivNative(program, shadertype, index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNative(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLUniformType, byte*, void>)funcTable[187])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLUniformType, nint, void>)funcTable[187])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			GetActiveUniformNative(program, index, bufSize, length, size, type, name);
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveUniformNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, Span<int> size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = size)
			{
				GetActiveUniformNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveUniformNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, int* size, GLUniformType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, Span<int> size, GLUniformType type, Span<byte> name)
		{
			fixed (int* psize0 = size)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveUniformNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLUniformType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					fixed (byte* pname2 = name)
					{
						GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockNameNative(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[188])(program, uniformBlockIndex, bufSize, length, uniformBlockName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[188])(program, uniformBlockIndex, bufSize, (nint)length, (nint)uniformBlockName);
			#endif
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, uniformBlockName);
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, Span<int> length, byte* uniformBlockName)
		{
			fixed (int* plength0 = length)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, uniformBlockName);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, byte* uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, uniformBlockName);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, Span<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, Span<int> length, Span<byte> uniformBlockName)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* puniformBlockName1 = uniformBlockName)
				{
					GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, puniformBlockName1);
				}
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, ref byte uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformBlockName1 = &uniformBlockName)
				{
					GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, puniformBlockName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockivNative(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, int*, void>)funcTable[189])(program, uniformBlockIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, nint, void>)funcTable[189])(program, uniformBlockIndex, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, out int @params)
		{
			int pparam;
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNameNative(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[190])(program, uniformIndex, bufSize, length, uniformName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[190])(program, uniformIndex, bufSize, (nint)length, (nint)uniformName);
			#endif
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, uniformName);
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, Span<int> length, byte* uniformName)
		{
			fixed (int* plength0 = length)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, uniformName);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, byte* uniformName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, uniformName);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, string uniformName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, Span<byte> uniformName)
		{
			fixed (byte* puniformName0 = uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ref byte uniformName)
		{
			fixed (byte* puniformName0 = &uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, Span<int> length, Span<byte> uniformName)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* puniformName1 = uniformName)
				{
					GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, puniformName1);
				}
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, ref byte uniformName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformName1 = &uniformName)
				{
					GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, puniformName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformsivNative(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, GLUniformPName, int*, void>)funcTable[191])(program, uniformCount, uniformIndices, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, GLUniformPName, nint, void>)funcTable[191])(program, uniformCount, (nint)uniformIndices, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, @params);
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, out int @params)
		{
			int pparam;
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, pparams);
			}
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, Span<uint> uniformIndices, GLUniformPName pname, int* @params)
		{
			fixed (uint* puniformIndices0 = uniformIndices)
			{
				GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, @params);
			}
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, GLUniformPName pname, int* @params)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, @params);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAttachedShadersNative(uint program, int maxCount, int* count, uint* shaders)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, uint*, void>)funcTable[192])(program, maxCount, count, shaders);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[192])(program, maxCount, (nint)count, (nint)shaders);
			#endif
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, int* count, uint* shaders)
		{
			GetAttachedShadersNative(program, maxCount, count, shaders);
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, Span<int> count, uint* shaders)
		{
			fixed (int* pcount0 = count)
			{
				GetAttachedShadersNative(program, maxCount, pcount0, shaders);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, ref int count, uint* shaders)
		{
			fixed (int* pcount0 = &count)
			{
				GetAttachedShadersNative(program, maxCount, pcount0, shaders);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, int* count, Span<uint> shaders)
		{
			fixed (uint* pshaders0 = shaders)
			{
				GetAttachedShadersNative(program, maxCount, count, pshaders0);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, int* count, ref uint shaders)
		{
			fixed (uint* pshaders0 = &shaders)
			{
				GetAttachedShadersNative(program, maxCount, count, pshaders0);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, Span<int> count, Span<uint> shaders)
		{
			fixed (int* pcount0 = count)
			{
				fixed (uint* pshaders1 = shaders)
				{
					GetAttachedShadersNative(program, maxCount, pcount0, pshaders1);
				}
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, ref int count, ref uint shaders)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (uint* pshaders1 = &shaders)
				{
					GetAttachedShadersNative(program, maxCount, pcount0, pshaders1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAttribLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[193])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[193])(program, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, byte* name)
		{
			int ret = GetAttribLocationNative(program, name);
			return ret;
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetAttribLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleani_vNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[194])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[194])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleani_vNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, out byte data)
		{
			byte pparam;
			GetBooleani_vNative(target, index, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, Span<byte> data)
		{
			fixed (byte* pparams = data)
			{
				GetBooleani_vNative(target, index, pparams);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleani_vNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanvNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[195])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[195])(pname, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, byte* data)
		{
			GetBooleanvNative(pname, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, out byte data)
		{
			byte pparam;
			GetBooleanvNative(pname, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, Span<byte> data)
		{
			fixed (byte* pparams = data)
			{
				GetBooleanvNative(pname, pparams);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanvNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameteri64vNative(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, long*, void>)funcTable[196])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[196])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			GetBufferParameteri64vNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, out long @params)
		{
			long pparam;
			GetBufferParameteri64vNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, Span<long> @params)
		{
			fixed (long* pparams = @params)
			{
				GetBufferParameteri64vNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameterivNative(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, int*, void>)funcTable[197])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[197])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Return parameters of a buffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			GetBufferParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// Return parameters of a buffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, out int @params)
		{
			int pparam;
			GetBufferParameterivNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Return parameters of a buffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetBufferParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferPointervNative(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, void**, void>)funcTable[198])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, nint, void>)funcTable[198])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Return the pointer to a mapped buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetBufferPointerv(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			GetBufferPointervNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[199])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[199])(target, offset, size, (nint)data);
			#endif
		}

		/// <summary>
		/// Returns a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetBufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			GetBufferSubDataNative(target, offset, size, data);
		}

		/// <summary>
		/// Returns a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetBufferSubData(GLBufferTargetARB target, nint offset, nint size, nint data)
		{
			GetBufferSubDataNative(target, offset, size, (void*)data);
		}

		/// <summary>
		/// Returns a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetBufferSubData<TData>(GLBufferTargetARB target, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				GetBufferSubDataNative(target, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTexImageNative(GLTextureTarget target, int level, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, void*, void>)funcTable[200])(target, level, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[200])(target, level, (nint)img);
			#endif
		}

		/// <summary>
		/// Return a compressed texture image
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetCompressedTexImage(GLTextureTarget target, int level, void* img)
		{
			GetCompressedTexImageNative(target, level, img);
		}

		/// <summary>
		/// Return a compressed texture image
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetCompressedTexImage(GLTextureTarget target, int level, nint img)
		{
			GetCompressedTexImageNative(target, level, (void*)img);
		}

		/// <summary>
		/// Return a compressed texture image
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GetCompressedTexImage<TImg>(GLTextureTarget target, int level, Span<TImg> img) where TImg : unmanaged
		{
			fixed (TImg* pimg0 = img)
			{
				GetCompressedTexImageNative(target, level, pimg0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureImageNative(uint texture, int level, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void*, void>)funcTable[201])(texture, level, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[201])(texture, level, bufSize, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetCompressedTextureImage(uint texture, int level, int bufSize, void* pixels)
		{
			GetCompressedTextureImageNative(texture, level, bufSize, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetCompressedTextureImage(uint texture, int level, int bufSize, nint pixels)
		{
			GetCompressedTextureImageNative(texture, level, bufSize, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetCompressedTextureImage<TPixels>(uint texture, int level, int bufSize, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetCompressedTextureImageNative(texture, level, bufSize, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void*, void>)funcTable[202])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, nint, void>)funcTable[202])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, (nint)pixels);
			#endif
		}

		/// <summary>
		/// Retrieve a sub-region of a compressed texture image from a
		///     compressed texture object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_texture_sub_image</remarks>
		public static void GetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			GetCompressedTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
		}

		/// <summary>
		/// Retrieve a sub-region of a compressed texture image from a
		///     compressed texture object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_texture_sub_image</remarks>
		public static void GetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, nint pixels)
		{
			GetCompressedTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, (void*)pixels);
		}

		/// <summary>
		/// Retrieve a sub-region of a compressed texture image from a
		///     compressed texture object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_texture_sub_image</remarks>
		public static void GetCompressedTextureSubImage<TPixels>(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetCompressedTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetDebugMessageLogNative(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, uint*, GLDebugSeverity, int*, byte*, uint>)funcTable[203])(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, nint, GLDebugSeverity, nint, nint, uint>)funcTable[203])(count, bufSize, sources, types, (nint)ids, severities, (nint)lengths, (nint)messageLog);
			#endif
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			return ret;
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, Span<uint> ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			fixed (uint* pids0 = ids)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, messageLog);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, messageLog);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, Span<int> lengths, byte* messageLog)
		{
			fixed (int* plengths0 = lengths)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, messageLog);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, messageLog);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, Span<uint> ids, GLDebugSeverity severities, Span<int> lengths, byte* messageLog)
		{
			fixed (uint* pids0 = ids)
			{
				fixed (int* plengths1 = lengths)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, messageLog);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, messageLog);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, string messageLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (messageLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(messageLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(messageLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, Span<byte> messageLog)
		{
			fixed (byte* pmessageLog0 = messageLog)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (byte* pmessageLog0 = &messageLog)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, Span<uint> ids, GLDebugSeverity severities, int* lengths, Span<byte> messageLog)
		{
			fixed (uint* pids0 = ids)
			{
				fixed (byte* pmessageLog1 = messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, pmessageLog1);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, pmessageLog1);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, Span<int> lengths, Span<byte> messageLog)
		{
			fixed (int* plengths0 = lengths)
			{
				fixed (byte* pmessageLog1 = messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, pmessageLog1);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, pmessageLog1);
					return ret;
				}
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, Span<uint> ids, GLDebugSeverity severities, Span<int> lengths, Span<byte> messageLog)
		{
			fixed (uint* pids0 = ids)
			{
				fixed (int* plengths1 = lengths)
				{
					fixed (byte* pmessageLog2 = messageLog)
					{
						uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, pmessageLog2);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Retrieve messages from the debug message log
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					fixed (byte* pmessageLog2 = &messageLog)
					{
						uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, pmessageLog2);
						return ret;
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublei_vNative(GLGetPName target, uint index, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[204])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[204])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void GetDoublei_v(GLGetPName target, uint index, double* data)
		{
			GetDoublei_vNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void GetDoublei_v(GLGetPName target, uint index, out double data)
		{
			double pparam;
			GetDoublei_vNative(target, index, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void GetDoublei_v(GLGetPName target, uint index, Span<double> data)
		{
			fixed (double* pparams = data)
			{
				GetDoublei_vNative(target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublevNative(GLGetPName pname, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, double*, void>)funcTable[205])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[205])(pname, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetDoublev(GLGetPName pname, double* data)
		{
			GetDoublevNative(pname, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetDoublev(GLGetPName pname, out double data)
		{
			double pparam;
			GetDoublevNative(pname, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetDoublev(GLGetPName pname, Span<double> data)
		{
			fixed (double* pparams = data)
			{
				GetDoublevNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[206])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[206])();
			#endif
		}

		/// <summary>
		/// Return error information
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static GLEnum GetError()
		{
			GLEnum ret = GetErrorNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloati_vNative(GLGetPName target, uint index, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[207])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[207])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void GetFloati_v(GLGetPName target, uint index, float* data)
		{
			GetFloati_vNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void GetFloati_v(GLGetPName target, uint index, out float data)
		{
			float pparam;
			GetFloati_vNative(target, index, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void GetFloati_v(GLGetPName target, uint index, Span<float> data)
		{
			fixed (float* pparams = data)
			{
				GetFloati_vNative(target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloatvNative(GLGetPName pname, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, float*, void>)funcTable[208])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[208])(pname, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetFloatv(GLGetPName pname, float* data)
		{
			GetFloatvNative(pname, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetFloatv(GLGetPName pname, out float data)
		{
			float pparam;
			GetFloatvNative(pname, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetFloatv(GLGetPName pname, Span<float> data)
		{
			fixed (float* pparams = data)
			{
				GetFloatvNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataIndexNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[209])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[209])(program, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the bindings of color indices to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static int GetFragDataIndex(uint program, byte* name)
		{
			int ret = GetFragDataIndexNative(program, name);
			return ret;
		}

		/// <summary>
		/// Query the bindings of color indices to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static int GetFragDataIndex(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Query the bindings of color indices to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static int GetFragDataIndex(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Query the bindings of color indices to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public static int GetFragDataIndex(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[210])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[210])(program, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the bindings of color numbers to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetFragDataLocation(uint program, byte* name)
		{
			int ret = GetFragDataLocationNative(program, name);
			return ret;
		}

		/// <summary>
		/// Query the bindings of color numbers to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetFragDataLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Query the bindings of color numbers to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetFragDataLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataLocationNative(program, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Query the bindings of color numbers to user-defined varying out variables
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetFragDataLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferAttachmentParameterivNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[211])(target, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[211])(target, attachment, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Retrieve information about attachments of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferAttachmentParameterivNative(target, attachment, pname, @params);
		}

		/// <summary>
		/// Retrieve information about attachments of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, out int @params)
		{
			int pparam;
			GetFramebufferAttachmentParameterivNative(target, attachment, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Retrieve information about attachments of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetFramebufferAttachmentParameterivNative(target, attachment, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferParameterivNative(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachmentParameterName, int*, void>)funcTable[212])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachmentParameterName, nint, void>)funcTable[212])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Query a named parameter of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_no_attachments</remarks>
		public static void GetFramebufferParameteriv(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// Query a named parameter of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_no_attachments</remarks>
		public static void GetFramebufferParameteriv(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, out int @params)
		{
			int pparam;
			GetFramebufferParameterivNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Query a named parameter of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_no_attachments</remarks>
		public static void GetFramebufferParameteriv(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetFramebufferParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetGraphicsResetStatusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[213])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[213])();
			#endif
		}

		/// <summary>
		/// Check if the rendering context has not been lost due to software or hardware issues
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static GLEnum GetGraphicsResetStatus()
		{
			GLEnum ret = GetGraphicsResetStatusNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64i_vNative(GLGetPName target, uint index, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, long*, void>)funcTable[214])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[214])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void GetInteger64i_v(GLGetPName target, uint index, long* data)
		{
			GetInteger64i_vNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void GetInteger64i_v(GLGetPName target, uint index, out long data)
		{
			long pparam;
			GetInteger64i_vNative(target, index, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void GetInteger64i_v(GLGetPName target, uint index, Span<long> data)
		{
			fixed (long* pparams = data)
			{
				GetInteger64i_vNative(target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64vNative(GLGetPName pname, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, long*, void>)funcTable[215])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[215])(pname, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetInteger64v(GLGetPName pname, long* data)
		{
			GetInteger64vNative(pname, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetInteger64v(GLGetPName pname, out long data)
		{
			long pparam;
			GetInteger64vNative(pname, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetInteger64v(GLGetPName pname, Span<long> data)
		{
			fixed (long* pparams = data)
			{
				GetInteger64vNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegeri_vNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[216])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[216])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetIntegeri_v(GLGetPName target, uint index, int* data)
		{
			GetIntegeri_vNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetIntegeri_v(GLGetPName target, uint index, out int data)
		{
			int pparam;
			GetIntegeri_vNative(target, index, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetIntegeri_v(GLGetPName target, uint index, Span<int> data)
		{
			fixed (int* pparams = data)
			{
				GetIntegeri_vNative(target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegervNative(GLGetPName pname, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, int*, void>)funcTable[217])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[217])(pname, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetIntegerv(GLGetPName pname, int* data)
		{
			GetIntegervNative(pname, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetIntegerv(GLGetPName pname, out int data)
		{
			int pparam;
			GetIntegervNative(pname, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetIntegerv(GLGetPName pname, Span<int> data)
		{
			fixed (int* pparams = data)
			{
				GetIntegervNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformati64vNative(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, long*, void>)funcTable[218])(target, internalformat, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, nint, void>)funcTable[218])(target, internalformat, pname, count, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_internalformat_query2</remarks>
		public static void GetInternalformati64v(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, long* @params)
		{
			GetInternalformati64vNative(target, internalformat, pname, count, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_internalformat_query2</remarks>
		public static void GetInternalformati64v(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, out long @params)
		{
			long pparam;
			GetInternalformati64vNative(target, internalformat, pname, count, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_internalformat_query2</remarks>
		public static void GetInternalformati64v(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, Span<long> @params)
		{
			fixed (long* pparams = @params)
			{
				GetInternalformati64vNative(target, internalformat, pname, count, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformativNative(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, int*, void>)funcTable[219])(target, internalformat, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, nint, void>)funcTable[219])(target, internalformat, pname, count, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_internalformat_query</remarks>
		public static void GetInternalformativ(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, int* @params)
		{
			GetInternalformativNative(target, internalformat, pname, count, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_internalformat_query</remarks>
		public static void GetInternalformativ(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, out int @params)
		{
			int pparam;
			GetInternalformativNative(target, internalformat, pname, count, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_internalformat_query</remarks>
		public static void GetInternalformativ(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetInternalformativNative(target, internalformat, pname, count, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultisamplefvNative(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, float*, void>)funcTable[220])(pname, index, val);
			#else
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, nint, void>)funcTable[220])(pname, index, (nint)val);
			#endif
		}

		/// <summary>
		/// Retrieve the location of a sample
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_texture_multisample</remarks>
		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			GetMultisamplefvNative(pname, index, val);
		}

		/// <summary>
		/// Retrieve the location of a sample
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_texture_multisample</remarks>
		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, out float val)
		{
			float pparam;
			GetMultisamplefvNative(pname, index, &pparam);
			val = pparam;
		}

		/// <summary>
		/// Retrieve the location of a sample
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_texture_multisample</remarks>
		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, Span<float> val)
		{
			fixed (float* pparams = val)
			{
				GetMultisamplefvNative(pname, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameteri64vNative(uint buffer, GLBufferPNameARB pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, long*, void>)funcTable[221])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[221])(buffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferParameteri64v(uint buffer, GLBufferPNameARB pname, long* @params)
		{
			GetNamedBufferParameteri64vNative(buffer, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferParameteri64v(uint buffer, GLBufferPNameARB pname, out long @params)
		{
			long pparam;
			GetNamedBufferParameteri64vNative(buffer, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferParameteri64v(uint buffer, GLBufferPNameARB pname, Span<long> @params)
		{
			fixed (long* pparams = @params)
			{
				GetNamedBufferParameteri64vNative(buffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameterivNative(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, int*, void>)funcTable[222])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[222])(buffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferParameteriv(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			GetNamedBufferParameterivNative(buffer, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferParameteriv(uint buffer, GLBufferPNameARB pname, out int @params)
		{
			int pparam;
			GetNamedBufferParameterivNative(buffer, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferParameteriv(uint buffer, GLBufferPNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedBufferParameterivNative(buffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferPointervNative(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, void**, void>)funcTable[223])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, nint, void>)funcTable[223])(buffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferPointerv(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			GetNamedBufferPointervNative(buffer, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferSubDataNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[224])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[224])(buffer, offset, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferSubData(uint buffer, nint offset, nint size, void* data)
		{
			GetNamedBufferSubDataNative(buffer, offset, size, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferSubData(uint buffer, nint offset, nint size, nint data)
		{
			GetNamedBufferSubDataNative(buffer, offset, size, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedBufferSubData<TData>(uint buffer, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				GetNamedBufferSubDataNative(buffer, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferAttachmentParameterivNative(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[225])(framebuffer, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[225])(framebuffer, attachment, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetNamedFramebufferAttachmentParameterivNative(framebuffer, attachment, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, out int @params)
		{
			int pparam;
			GetNamedFramebufferAttachmentParameterivNative(framebuffer, attachment, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedFramebufferAttachmentParameterivNative(framebuffer, attachment, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferParameterivNative(uint framebuffer, GLGetFramebufferParameter pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[226])(framebuffer, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[226])(framebuffer, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedFramebufferParameteriv(uint framebuffer, GLGetFramebufferParameter pname, int* param)
		{
			GetNamedFramebufferParameterivNative(framebuffer, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedFramebufferParameteriv(uint framebuffer, GLGetFramebufferParameter pname, out int param)
		{
			int pparam;
			GetNamedFramebufferParameterivNative(framebuffer, pname, &pparam);
			param = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedFramebufferParameteriv(uint framebuffer, GLGetFramebufferParameter pname, Span<int> param)
		{
			fixed (int* pparams = param)
			{
				GetNamedFramebufferParameterivNative(framebuffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedRenderbufferParameterivNative(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, int*, void>)funcTable[227])(renderbuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, nint, void>)funcTable[227])(renderbuffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedRenderbufferParameteriv(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			GetNamedRenderbufferParameterivNative(renderbuffer, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedRenderbufferParameteriv(uint renderbuffer, GLRenderbufferParameterName pname, out int @params)
		{
			int pparam;
			GetNamedRenderbufferParameterivNative(renderbuffer, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetNamedRenderbufferParameteriv(uint renderbuffer, GLRenderbufferParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedRenderbufferParameterivNative(renderbuffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectLabelNative(GLObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLObjectIdentifier, uint, int, int*, byte*, void>)funcTable[228])(identifier, name, bufSize, length, label);
			#else
			((delegate* unmanaged[Cdecl]<GLObjectIdentifier, uint, int, nint, nint, void>)funcTable[228])(identifier, name, bufSize, (nint)length, (nint)label);
			#endif
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label)
		{
			GetObjectLabelNative(identifier, name, bufSize, length, label);
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, Span<int> length, byte* label)
		{
			fixed (int* plength0 = length)
			{
				GetObjectLabelNative(identifier, name, bufSize, plength0, label);
			}
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, ref int length, byte* label)
		{
			fixed (int* plength0 = &length)
			{
				GetObjectLabelNative(identifier, name, bufSize, plength0, label);
			}
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetObjectLabelNative(identifier, name, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, Span<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				GetObjectLabelNative(identifier, name, bufSize, length, plabel0);
			}
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				GetObjectLabelNative(identifier, name, bufSize, length, plabel0);
			}
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, Span<int> length, Span<byte> label)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* plabel1 = label)
				{
					GetObjectLabelNative(identifier, name, bufSize, plength0, plabel1);
				}
			}
		}

		/// <summary>
		/// Retrieve the label of a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, ref int length, ref byte label)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* plabel1 = &label)
				{
					GetObjectLabelNative(identifier, name, bufSize, plength0, plabel1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectPtrLabelNative(void* ptr, int bufSize, int* length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, int, int*, byte*, void>)funcTable[229])(ptr, bufSize, length, label);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[229])((nint)ptr, bufSize, (nint)length, (nint)label);
			#endif
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label)
		{
			GetObjectPtrLabelNative(ptr, bufSize, length, label);
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(nint ptr, int bufSize, int* length, byte* label)
		{
			GetObjectPtrLabelNative((void*)ptr, bufSize, length, label);
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel<TPtr>(Span<TPtr> ptr, int bufSize, int* length, byte* label) where TPtr : unmanaged
		{
			fixed (TPtr* pptr0 = ptr)
			{
				GetObjectPtrLabelNative(pptr0, bufSize, length, label);
			}
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, Span<int> length, byte* label)
		{
			fixed (int* plength0 = length)
			{
				GetObjectPtrLabelNative(ptr, bufSize, plength0, label);
			}
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, ref int length, byte* label)
		{
			fixed (int* plength0 = &length)
			{
				GetObjectPtrLabelNative(ptr, bufSize, plength0, label);
			}
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetObjectPtrLabelNative(ptr, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, Span<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				GetObjectPtrLabelNative(ptr, bufSize, length, plabel0);
			}
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				GetObjectPtrLabelNative(ptr, bufSize, length, plabel0);
			}
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, Span<int> length, Span<byte> label)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* plabel1 = label)
				{
					GetObjectPtrLabelNative(ptr, bufSize, plength0, plabel1);
				}
			}
		}

		/// <summary>
		/// Retrieve the label of a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetObjectPtrLabel(void* ptr, int bufSize, ref int length, ref byte label)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* plabel1 = &label)
				{
					GetObjectPtrLabelNative(ptr, bufSize, plength0, plabel1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointervNative(GLGetPointervPName pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, void**, void>)funcTable[230])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, nint, void>)funcTable[230])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Return the address of the specified pointer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.3 - GL 4.6<br/>GL 4.0 Compat - GL 4.2 Compat<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void GetPointerv(GLGetPointervPName pname, void** @params)
		{
			GetPointervNative(pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramBinaryNative(uint program, int bufSize, int* length, GLEnum* binaryFormat, void* binary)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, GLEnum*, void*, void>)funcTable[231])(program, bufSize, length, binaryFormat, binary);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, nint, void>)funcTable[231])(program, bufSize, (nint)length, (nint)binaryFormat, (nint)binary);
			#endif
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, int* length, GLEnum* binaryFormat, void* binary)
		{
			GetProgramBinaryNative(program, bufSize, length, binaryFormat, binary);
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, Span<int> length, GLEnum* binaryFormat, void* binary)
		{
			fixed (int* plength0 = length)
			{
				GetProgramBinaryNative(program, bufSize, plength0, binaryFormat, binary);
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, ref int length, GLEnum* binaryFormat, void* binary)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramBinaryNative(program, bufSize, plength0, binaryFormat, binary);
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, int* length, Span<GLEnum> binaryFormat, void* binary)
		{
			fixed (GLEnum* pbinaryFormat0 = binaryFormat)
			{
				GetProgramBinaryNative(program, bufSize, length, pbinaryFormat0, binary);
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, int* length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (GLEnum* pbinaryFormat0 = &binaryFormat)
			{
				GetProgramBinaryNative(program, bufSize, length, pbinaryFormat0, binary);
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, Span<int> length, Span<GLEnum> binaryFormat, void* binary)
		{
			fixed (int* plength0 = length)
			{
				fixed (GLEnum* pbinaryFormat1 = binaryFormat)
				{
					GetProgramBinaryNative(program, bufSize, plength0, pbinaryFormat1, binary);
				}
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, ref int length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (int* plength0 = &length)
			{
				fixed (GLEnum* pbinaryFormat1 = &binaryFormat)
				{
					GetProgramBinaryNative(program, bufSize, plength0, pbinaryFormat1, binary);
				}
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, int* length, GLEnum* binaryFormat, nint binary)
		{
			GetProgramBinaryNative(program, bufSize, length, binaryFormat, (void*)binary);
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary<TBinary>(uint program, int bufSize, int* length, GLEnum* binaryFormat, Span<TBinary> binary) where TBinary : unmanaged
		{
			fixed (TBinary* pbinary0 = binary)
			{
				GetProgramBinaryNative(program, bufSize, length, binaryFormat, pbinary0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInfoLogNative(uint program, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[232])(program, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[232])(program, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, byte* infoLog)
		{
			GetProgramInfoLogNative(program, bufSize, length, infoLog);
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static string GetProgramInfoLog(uint program)
		{
			int pStrSize0;
			GetProgramiv(program, GLProgramPropertyARB.InfoLogLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetProgramInfoLogNative(program, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, Span<int> length, byte* infoLog)
		{
			fixed (int* plength0 = length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramInfoLogNative(program, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, Span<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, Span<int> length, Span<byte> infoLog)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pinfoLog1 = infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInterfaceivNative(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, int*, void>)funcTable[233])(program, programInterface, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, nint, void>)funcTable[233])(program, programInterface, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			GetProgramInterfaceivNative(program, programInterface, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, out int @params)
		{
			int pparam;
			GetProgramInterfaceivNative(program, programInterface, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetProgramInterfaceivNative(program, programInterface, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineInfoLogNative(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[234])(pipeline, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[234])(pipeline, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, infoLog);
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static string GetProgramPipelineInfoLog(uint pipeline)
		{
			int pStrSize0;
			GetProgramPipelineiv(pipeline, GLPipelineParameterName.InfoLogLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetProgramPipelineInfoLogNative(pipeline, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, Span<int> length, byte* infoLog)
		{
			fixed (int* plength0 = length)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, Span<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, Span<int> length, Span<byte> infoLog)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pinfoLog1 = infoLog)
				{
					GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineivNative(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, int*, void>)funcTable[235])(pipeline, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, nint, void>)funcTable[235])(pipeline, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			GetProgramPipelineivNative(pipeline, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, out int @params)
		{
			int pparam;
			GetProgramPipelineivNative(pipeline, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetProgramPipelineivNative(pipeline, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetProgramResourceIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, uint>)funcTable[236])(program, programInterface, name);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, uint>)funcTable[236])(program, programInterface, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			uint ret = GetProgramResourceIndexNative(program, programInterface, name);
			return ret;
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetProgramResourceIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[237])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[237])(program, programInterface, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationNative(program, programInterface, name);
			return ret;
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[238])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[238])(program, programInterface, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the fragment color index of a named variable within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, name);
			return ret;
		}

		/// <summary>
		/// Query the fragment color index of a named variable within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Query the fragment color index of a named variable within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Query the fragment color index of a named variable within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourceNameNative(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, int*, byte*, void>)funcTable[239])(program, programInterface, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, nint, nint, void>)funcTable[239])(program, programInterface, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, name);
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, Span<int> length, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pname0);
			}
		}
	}
}
