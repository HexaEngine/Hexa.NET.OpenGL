// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2uiNative(int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[519])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[519])(location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2ui(int location, uint v0, uint v1)
		{
			Uniform2uiNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[520])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[520])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2uiv(int location, int count, uint* value)
		{
			Uniform2uivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform2uivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform2uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3dNative(int location, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, double, void>)funcTable[521])(location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, double, void>)funcTable[521])(location, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform3d(int location, double x, double y, double z)
		{
			Uniform3dNative(location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3dvNative(int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, double*, void>)funcTable[522])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[522])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform3dv(int location, int count, double* value)
		{
			Uniform3dvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform3dv(int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				Uniform3dvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform3dv(int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				Uniform3dvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3fNative(int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[523])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[523])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3f(int location, float v0, float v1, float v2)
		{
			Uniform3fNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[524])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[524])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3fv(int location, int count, float* value)
		{
			Uniform3fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3iNative(int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[525])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[525])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3i(int location, int v0, int v1, int v2)
		{
			Uniform3iNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[526])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[526])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3iv(int location, int count, int* value)
		{
			Uniform3ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3uiNative(int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[527])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[527])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3ui(int location, uint v0, uint v1, uint v2)
		{
			Uniform3uiNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[528])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[528])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3uiv(int location, int count, uint* value)
		{
			Uniform3uivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform3uivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform3uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4dNative(int location, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, double, double, void>)funcTable[529])(location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, double, double, void>)funcTable[529])(location, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform4d(int location, double x, double y, double z, double w)
		{
			Uniform4dNative(location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4dvNative(int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, double*, void>)funcTable[530])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[530])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform4dv(int location, int count, double* value)
		{
			Uniform4dvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform4dv(int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				Uniform4dvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void Uniform4dv(int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				Uniform4dvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4fNative(int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[531])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[531])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4f(int location, float v0, float v1, float v2, float v3)
		{
			Uniform4fNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[532])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[532])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4fv(int location, int count, float* value)
		{
			Uniform4fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4iNative(int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[533])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[533])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4i(int location, int v0, int v1, int v2, int v3)
		{
			Uniform4iNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[534])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[534])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4iv(int location, int count, int* value)
		{
			Uniform4ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4uiNative(int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[535])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[535])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4ui(int location, uint v0, uint v1, uint v2, uint v3)
		{
			Uniform4uiNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4uivNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[536])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[536])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4uiv(int location, int count, uint* value)
		{
			Uniform4uivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4uiv(int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				Uniform4uivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4uiv(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform4uivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformBlockBindingNative(uint program, uint uniformBlockIndex, uint uniformBlockBinding)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[537])(program, uniformBlockIndex, uniformBlockBinding);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[537])(program, uniformBlockIndex, uniformBlockBinding);
			#endif
		}

		/// <summary>
		/// Assign a binding point to an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void UniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding)
		{
			UniformBlockBindingNative(program, uniformBlockIndex, uniformBlockBinding);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[538])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[538])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix2dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix2dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix2dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[539])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[539])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x3dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[540])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[540])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2x3dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix2x3dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2x3dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix2x3dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2x3dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix2x3dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[541])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[541])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x4dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[542])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[542])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2x4dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix2x4dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2x4dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix2x4dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix2x4dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix2x4dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[543])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[543])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[544])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[544])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix3dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix3dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix3dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[545])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[545])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x2dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[546])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[546])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3x2dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix3x2dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3x2dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix3x2dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3x2dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix3x2dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[547])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[547])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x4dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[548])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[548])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3x4dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix3x4dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3x4dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix3x4dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix3x4dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix3x4dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[549])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[549])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[550])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[550])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix4dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix4dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix4dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[551])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[551])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x2dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[552])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[552])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4x2dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix4x2dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4x2dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix4x2dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4x2dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix4x2dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[553])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[553])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x3dvNative(int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, double*, void>)funcTable[554])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[554])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4x3dv(int location, int count, bool transpose, double* value)
		{
			UniformMatrix4x3dvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4x3dv(int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				UniformMatrix4x3dvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void UniformMatrix4x3dv(int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				UniformMatrix4x3dvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[555])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[555])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformSubroutinesuivNative(GLShaderType shadertype, int count, uint* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, int, uint*, void>)funcTable[556])(shadertype, count, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, void>)funcTable[556])(shadertype, count, (nint)indices);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void UniformSubroutinesuiv(GLShaderType shadertype, int count, uint* indices)
		{
			UniformSubroutinesuivNative(shadertype, count, indices);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void UniformSubroutinesuiv(GLShaderType shadertype, int count, Span<uint> indices)
		{
			fixed (uint* pindices0 = indices)
			{
				UniformSubroutinesuivNative(shadertype, count, pindices0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void UniformSubroutinesuiv(GLShaderType shadertype, int count, ref uint indices)
		{
			fixed (uint* pindices0 = &indices)
			{
				UniformSubroutinesuivNative(shadertype, count, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnmapBufferNative(GLBufferTargetARB target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[557])(target);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[557])(target);
			#endif
		}

		/// <summary>
		/// Release the mapping of a buffer object's data store into the client's address space
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static bool UnmapBuffer(GLBufferTargetARB target)
		{
			byte ret = UnmapBufferNative(target);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnmapNamedBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[558])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[558])(buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static bool UnmapNamedBuffer(uint buffer)
		{
			byte ret = UnmapNamedBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[559])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[559])(program);
			#endif
		}

		/// <summary>
		/// Installs a program object as part of current rendering state
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UseProgram(uint program)
		{
			UseProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseProgramStagesNative(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[560])(pipeline, stages, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[560])(pipeline, stages, program);
			#endif
		}

		/// <summary>
		/// Bind stages of a program object to a program pipeline
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void UseProgramStages(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			UseProgramStagesNative(pipeline, stages, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ValidateProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[561])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[561])(program);
			#endif
		}

		/// <summary>
		/// Validates a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void ValidateProgram(uint program)
		{
			ValidateProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ValidateProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[562])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[562])(pipeline);
			#endif
		}

		/// <summary>
		/// Validate a program pipeline object against current GL state
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void ValidateProgramPipeline(uint pipeline)
		{
			ValidateProgramPipelineNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayAttribBindingNative(uint vaobj, uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[563])(vaobj, attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[563])(vaobj, attribindex, bindingindex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayAttribBinding(uint vaobj, uint attribindex, uint bindingindex)
		{
			VertexArrayAttribBindingNative(vaobj, attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayAttribFormatNative(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[564])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[564])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayAttribFormat(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			VertexArrayAttribFormatNative(vaobj, attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayAttribIFormatNative(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[565])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[565])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayAttribIFormat(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexArrayAttribIFormatNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayAttribLFormatNative(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[566])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[566])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayAttribLFormat(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexArrayAttribLFormatNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayBindingDivisorNative(uint vaobj, uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[567])(vaobj, bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[567])(vaobj, bindingindex, divisor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayBindingDivisor(uint vaobj, uint bindingindex, uint divisor)
		{
			VertexArrayBindingDivisorNative(vaobj, bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayElementBufferNative(uint vaobj, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[568])(vaobj, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[568])(vaobj, buffer);
			#endif
		}

		/// <summary>
		/// Configures element array buffer binding of a vertex array object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayElementBuffer(uint vaobj, uint buffer)
		{
			VertexArrayElementBufferNative(vaobj, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexBufferNative(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[569])(vaobj, bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[569])(vaobj, bindingindex, buffer, offset, stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffer(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			VertexArrayVertexBufferNative(vaobj, bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexBuffersNative(uint vaobj, uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, uint*, nint*, int*, void>)funcTable[570])(vaobj, first, count, buffers, offsets, strides);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, nint, void>)funcTable[570])(vaobj, first, count, (nint)buffers, (nint)offsets, (nint)strides);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			VertexArrayVertexBuffersNative(vaobj, first, count, buffers, offsets, strides);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, Span<nint> offsets, int* strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, ref nint offsets, int* strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, Span<nint> offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, ref nint offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, nint* offsets, Span<int> strides)
		{
			fixed (int* pstrides0 = strides)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, nint* offsets, ref int strides)
		{
			fixed (int* pstrides0 = &strides)
			{
				VertexArrayVertexBuffersNative(vaobj, first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, nint* offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (int* pstrides1 = strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, nint* offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (int* pstrides1 = &strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				fixed (int* pstrides1 = strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, ref nint offsets, ref int strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (int* pstrides1 = &strides)
				{
					VertexArrayVertexBuffersNative(vaobj, first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, Span<uint> buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					fixed (int* pstrides2 = strides)
					{
						VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void VertexArrayVertexBuffers(uint vaobj, uint first, int count, ref uint buffers, ref nint offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (int* pstrides2 = &strides)
					{
						VertexArrayVertexBuffersNative(vaobj, first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1dNative(uint index, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[571])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[571])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1d(uint index, double x)
		{
			VertexAttrib1dNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[572])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[572])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1dv(uint index, double* v)
		{
			VertexAttrib1dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1fNative(uint index, float x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[573])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[573])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1f(uint index, float x)
		{
			VertexAttrib1fNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[574])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[574])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1fv(uint index, float* v)
		{
			VertexAttrib1fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1sNative(uint index, short x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[575])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[575])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1s(uint index, short x)
		{
			VertexAttrib1sNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[576])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[576])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1sv(uint index, short* v)
		{
			VertexAttrib1svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2dNative(uint index, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[577])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[577])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2d(uint index, double x, double y)
		{
			VertexAttrib2dNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[578])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[578])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2dv(uint index, double* v)
		{
			VertexAttrib2dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2fNative(uint index, float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[579])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[579])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2f(uint index, float x, float y)
		{
			VertexAttrib2fNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[580])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[580])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2fv(uint index, float* v)
		{
			VertexAttrib2fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2sNative(uint index, short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[581])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[581])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2s(uint index, short x, short y)
		{
			VertexAttrib2sNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[582])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[582])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2sv(uint index, short* v)
		{
			VertexAttrib2svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3dNative(uint index, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[583])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[583])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3d(uint index, double x, double y, double z)
		{
			VertexAttrib3dNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[584])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[584])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3dv(uint index, double* v)
		{
			VertexAttrib3dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3fNative(uint index, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[585])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[585])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3f(uint index, float x, float y, float z)
		{
			VertexAttrib3fNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[586])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[586])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3fv(uint index, float* v)
		{
			VertexAttrib3fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3sNative(uint index, short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[587])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[587])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3s(uint index, short x, short y, short z)
		{
			VertexAttrib3sNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[588])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[588])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3sv(uint index, short* v)
		{
			VertexAttrib3svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NbvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[589])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[589])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nbv(uint index, sbyte* v)
		{
			VertexAttrib4NbvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nbv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nbv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[590])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[590])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Niv(uint index, int* v)
		{
			VertexAttrib4NivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Niv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Niv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NsvNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[591])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[591])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nsv(uint index, short* v)
		{
			VertexAttrib4NsvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nsv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nsv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NubNative(uint index, bool x, bool y, bool z, bool w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[592])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[592])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nub(uint index, bool x, bool y, bool z, bool w)
		{
			VertexAttrib4NubNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[593])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[593])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, byte* v)
		{
			VertexAttrib4NubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4NubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NuivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[594])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[594])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nuiv(uint index, uint* v)
		{
			VertexAttrib4NuivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nuiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nuiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NusvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[595])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[595])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nusv(uint index, ushort* v)
		{
			VertexAttrib4NusvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nusv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nusv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4bvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[596])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[596])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4bv(uint index, sbyte* v)
		{
			VertexAttrib4bvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4bv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttrib4bvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4bv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttrib4bvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4dNative(uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[597])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[597])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4d(uint index, double x, double y, double z, double w)
		{
			VertexAttrib4dNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[598])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[598])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4dv(uint index, double* v)
		{
			VertexAttrib4dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib4dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib4dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4fNative(uint index, float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[599])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[599])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4f(uint index, float x, float y, float z, float w)
		{
			VertexAttrib4fNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[600])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[600])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4fv(uint index, float* v)
		{
			VertexAttrib4fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[601])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[601])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4iv(uint index, int* v)
		{
			VertexAttrib4ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4sNative(uint index, short x, short y, short z, short w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[602])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[602])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4s(uint index, short x, short y, short z, short w)
		{
			VertexAttrib4sNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[603])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[603])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4sv(uint index, short* v)
		{
			VertexAttrib4svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4ubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[604])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[604])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, byte* v)
		{
			VertexAttrib4ubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4ubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[605])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[605])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4uiv(uint index, uint* v)
		{
			VertexAttrib4uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4usvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[606])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[606])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4usv(uint index, ushort* v)
		{
			VertexAttrib4usvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4usv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4usv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribBindingNative(uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[607])(attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[607])(attribindex, bindingindex);
			#endif
		}

		/// <summary>
		/// Associate a vertex attribute and a vertex buffer binding for a vertex array object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public static void VertexAttribBinding(uint attribindex, uint bindingindex)
		{
			VertexAttribBindingNative(attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribDivisorNative(uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[608])(index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[608])(index, divisor);
			#endif
		}

		/// <summary>
		/// Modify the rate at which generic vertex attributes advance during instanced rendering
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X</remarks>
		public static void VertexAttribDivisor(uint index, uint divisor)
		{
			VertexAttribDivisorNative(index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribFormatNative(uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribType, byte, uint, void>)funcTable[609])(attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribType, byte, uint, void>)funcTable[609])(attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#endif
		}

		/// <summary>
		/// Specify the organization of vertex arrays
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public static void VertexAttribFormat(uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			VertexAttribFormatNative(attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1iNative(uint index, int x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[610])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[610])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1i(uint index, int x)
		{
			VertexAttribI1iNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[611])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[611])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1iv(uint index, int* v)
		{
			VertexAttribI1ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI1ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI1ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1uiNative(uint index, uint x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[612])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[612])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1ui(uint index, uint x)
		{
			VertexAttribI1uiNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[613])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[613])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1uiv(uint index, uint* v)
		{
			VertexAttribI1uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI1uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI1uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI1uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2iNative(uint index, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[614])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[614])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2i(uint index, int x, int y)
		{
			VertexAttribI2iNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[615])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[615])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2iv(uint index, int* v)
		{
			VertexAttribI2ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI2ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI2ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2uiNative(uint index, uint x, uint y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[616])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[616])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2ui(uint index, uint x, uint y)
		{
			VertexAttribI2uiNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[617])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[617])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2uiv(uint index, uint* v)
		{
			VertexAttribI2uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI2uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI2uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI2uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3iNative(uint index, int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[618])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[618])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3i(uint index, int x, int y, int z)
		{
			VertexAttribI3iNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[619])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[619])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3iv(uint index, int* v)
		{
			VertexAttribI3ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI3ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI3ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3uiNative(uint index, uint x, uint y, uint z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[620])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[620])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3ui(uint index, uint x, uint y, uint z)
		{
			VertexAttribI3uiNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[621])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[621])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3uiv(uint index, uint* v)
		{
			VertexAttribI3uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI3uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI3uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI3uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4bvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[622])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[622])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4bv(uint index, sbyte* v)
		{
			VertexAttribI4bvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4bv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttribI4bvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4bv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttribI4bvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4iNative(uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[623])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[623])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4i(uint index, int x, int y, int z, int w)
		{
			VertexAttribI4iNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[624])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[624])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4iv(uint index, int* v)
		{
			VertexAttribI4ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI4ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI4ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[625])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[625])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4sv(uint index, short* v)
		{
			VertexAttribI4svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttribI4svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttribI4svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4ubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[626])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[626])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4ubv(uint index, byte* v)
		{
			VertexAttribI4ubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4ubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttribI4ubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4ubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttribI4ubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4ubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttribI4ubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4uiNative(uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[627])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[627])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w)
		{
			VertexAttribI4uiNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[628])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[628])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4uiv(uint index, uint* v)
		{
			VertexAttribI4uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI4uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI4uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4usvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[629])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[629])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4usv(uint index, ushort* v)
		{
			VertexAttribI4usvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4usv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttribI4usvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribI4usv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttribI4usvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribIFormatNative(uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, uint, void>)funcTable[630])(attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, uint, void>)funcTable[630])(attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public static void VertexAttribIFormat(uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexAttribIFormatNative(attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribIPointerNative(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, void*, void>)funcTable[631])(index, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, nint, void>)funcTable[631])(index, size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribIPointer(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			VertexAttribIPointerNative(index, size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribIPointer(uint index, int size, GLVertexAttribIType type, int stride, nint pointer)
		{
			VertexAttribIPointerNative(index, size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribIPointer<TPointer>(uint index, int size, GLVertexAttribIType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribIPointerNative(index, size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL1dNative(uint index, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[632])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[632])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL1d(uint index, double x)
		{
			VertexAttribL1dNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL1dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[633])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[633])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL1dv(uint index, double* v)
		{
			VertexAttribL1dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL1dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL1dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL1dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL1dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL2dNative(uint index, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[634])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[634])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL2d(uint index, double x, double y)
		{
			VertexAttribL2dNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL2dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[635])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[635])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL2dv(uint index, double* v)
		{
			VertexAttribL2dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL2dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL2dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL2dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL2dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL3dNative(uint index, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[636])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[636])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL3d(uint index, double x, double y, double z)
		{
			VertexAttribL3dNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL3dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[637])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[637])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL3dv(uint index, double* v)
		{
			VertexAttribL3dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL3dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL3dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL3dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL3dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL4dNative(uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[638])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[638])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL4d(uint index, double x, double y, double z, double w)
		{
			VertexAttribL4dNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL4dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[639])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[639])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL4dv(uint index, double* v)
		{
			VertexAttribL4dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL4dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL4dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribL4dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL4dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribLFormatNative(uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, uint, void>)funcTable[640])(attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, uint, void>)funcTable[640])(attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public static void VertexAttribLFormat(uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexAttribLFormatNative(attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribLPointerNative(uint index, int size, GLVertexAttribLType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, int, void*, void>)funcTable[641])(index, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, int, nint, void>)funcTable[641])(index, size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribLPointer(uint index, int size, GLVertexAttribLType type, int stride, void* pointer)
		{
			VertexAttribLPointerNative(index, size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribLPointer(uint index, int size, GLVertexAttribLType type, int stride, nint pointer)
		{
			VertexAttribLPointerNative(index, size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void VertexAttribLPointer<TPointer>(uint index, int size, GLVertexAttribLType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribLPointerNative(index, size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP1uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[642])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[642])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP1ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP1uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP1uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[643])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[643])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP1uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP1uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP1uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP2uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[644])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[644])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP2ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP2uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP2uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[645])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[645])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP2uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP2uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP2uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP3uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[646])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[646])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP3ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP3uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP3uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[647])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[647])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP3uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP3uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP3uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP4uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[648])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[648])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP4ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP4uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribP4uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[649])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[649])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP4uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP4uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public static void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP4uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribPointerNative(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, void*, void>)funcTable[650])(index, size, type, *((byte*)(&normalized)), stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[650])(index, size, type, *((byte*)(&normalized)), stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, pointer);
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, (void*)pointer);
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribPointer<TPointer>(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribPointerNative(index, size, type, normalized, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexBindingDivisorNative(uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[651])(bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[651])(bindingindex, divisor);
			#endif
		}

		/// <summary>
		/// Modify the rate at which generic vertex attributes
		///     advance
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public static void VertexBindingDivisor(uint bindingindex, uint divisor)
		{
			VertexBindingDivisorNative(bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[652])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[652])(x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Viewport(int x, int y, int width, int height)
		{
			ViewportNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportArrayvNative(uint first, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[653])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[653])(first, count, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void ViewportArrayv(uint first, int count, float* v)
		{
			ViewportArrayvNative(first, count, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void ViewportArrayv(uint first, int count, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				ViewportArrayvNative(first, count, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void ViewportArrayv(uint first, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ViewportArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportIndexedfNative(uint index, float x, float y, float w, float h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[654])(index, x, y, w, h);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[654])(index, x, y, w, h);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void ViewportIndexedf(uint index, float x, float y, float w, float h)
		{
			ViewportIndexedfNative(index, x, y, w, h);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportIndexedfvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[655])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[655])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void ViewportIndexedfv(uint index, float* v)
		{
			ViewportIndexedfvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void ViewportIndexedfv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				ViewportIndexedfvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void ViewportIndexedfv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ViewportIndexedfvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitSyncNative(GLSync sync, GLSyncBehaviorFlags flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncBehaviorFlags, ulong, void>)funcTable[656])(sync, flags, timeout);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncBehaviorFlags, ulong, void>)funcTable[656])(sync, flags, timeout);
			#endif
		}

		/// <summary>
		/// Instruct the GL server to block until the specified sync object becomes signaled
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void WaitSync(GLSync sync, GLSyncBehaviorFlags flags, ulong timeout)
		{
			WaitSyncNative(sync, flags, timeout);
		}

	}
}
