// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.NV
{
	public static unsafe partial class GLNVShadingRateImage
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindShadingRateImageNVNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(texture);
			#endif
		}

		public static void BindShadingRateImageNV(uint texture)
		{
			BindShadingRateImageNVNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShadingRateImagePaletteNVNative(uint viewport, uint entry, GLEnum* rate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum*, void>)funcTable[1])(viewport, entry, rate);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[1])(viewport, entry, (nint)rate);
			#endif
		}

		public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, GLEnum* rate)
		{
			GetShadingRateImagePaletteNVNative(viewport, entry, rate);
		}

		public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, ref GLEnum rate)
		{
			fixed (GLEnum* prate0 = &rate)
			{
				GetShadingRateImagePaletteNVNative(viewport, entry, prate0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShadingRateSampleLocationivNVNative(GLEnum rate, uint samples, uint index, int* location)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, uint, int*, void>)funcTable[2])(rate, samples, index, location);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, uint, nint, void>)funcTable[2])(rate, samples, index, (nint)location);
			#endif
		}

		public static void GetShadingRateSampleLocationivNV(GLEnum rate, uint samples, uint index, int* location)
		{
			GetShadingRateSampleLocationivNVNative(rate, samples, index, location);
		}

		public static void GetShadingRateSampleLocationivNV(GLEnum rate, uint samples, uint index, ref int location)
		{
			fixed (int* plocation0 = &location)
			{
				GetShadingRateSampleLocationivNVNative(rate, samples, index, plocation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateImageBarrierNVNative(byte synchronize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[3])(synchronize);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[3])(synchronize);
			#endif
		}

		public static void ShadingRateImageBarrierNV(byte synchronize)
		{
			ShadingRateImageBarrierNVNative(synchronize);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateImagePaletteNVNative(uint viewport, uint first, int count, GLEnum* rates)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLEnum*, void>)funcTable[4])(viewport, first, count, rates);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[4])(viewport, first, count, (nint)rates);
			#endif
		}

		public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, GLEnum* rates)
		{
			ShadingRateImagePaletteNVNative(viewport, first, count, rates);
		}

		public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, ref GLEnum rates)
		{
			fixed (GLEnum* prates0 = &rates)
			{
				ShadingRateImagePaletteNVNative(viewport, first, count, prates0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateSampleOrderNVNative(GLEnum order)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[5])(order);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[5])(order);
			#endif
		}

		public static void ShadingRateSampleOrderNV(GLEnum order)
		{
			ShadingRateSampleOrderNVNative(order);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateSampleOrderCustomNVNative(GLEnum rate, uint samples, int* locations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int*, void>)funcTable[6])(rate, samples, locations);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[6])(rate, samples, (nint)locations);
			#endif
		}

		public static void ShadingRateSampleOrderCustomNV(GLEnum rate, uint samples, int* locations)
		{
			ShadingRateSampleOrderCustomNVNative(rate, samples, locations);
		}

		public static void ShadingRateSampleOrderCustomNV(GLEnum rate, uint samples, ref int locations)
		{
			fixed (int* plocations0 = &locations)
			{
				ShadingRateSampleOrderCustomNVNative(rate, samples, plocations0);
			}
		}

	}
}
