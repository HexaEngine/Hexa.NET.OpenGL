// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.NV
{
	public static unsafe partial class GLNVCommandList
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CallCommandListNVNative(uint list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(list);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(list);
			#endif
		}

		public static void CallCommandListNV(uint list)
		{
			CallCommandListNVNative(list);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CommandListSegmentsNVNative(uint list, uint segments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1])(list, segments);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1])(list, segments);
			#endif
		}

		public static void CommandListSegmentsNV(uint list, uint segments)
		{
			CommandListSegmentsNVNative(list, segments);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileCommandListNVNative(uint list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[2])(list);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[2])(list);
			#endif
		}

		public static void CompileCommandListNV(uint list)
		{
			CompileCommandListNVNative(list);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateCommandListsNVNative(int n, uint* lists)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[3])(n, lists);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[3])(n, (nint)lists);
			#endif
		}

		public static void CreateCommandListsNV(int n, uint* lists)
		{
			CreateCommandListsNVNative(n, lists);
		}

		public static void CreateCommandListsNV(int n, ref uint lists)
		{
			fixed (uint* plists0 = &lists)
			{
				CreateCommandListsNVNative(n, plists0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateStatesNVNative(int n, uint* states)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[4])(n, states);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[4])(n, (nint)states);
			#endif
		}

		public static void CreateStatesNV(int n, uint* states)
		{
			CreateStatesNVNative(n, states);
		}

		public static void CreateStatesNV(int n, ref uint states)
		{
			fixed (uint* pstates0 = &states)
			{
				CreateStatesNVNative(n, pstates0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteCommandListsNVNative(int n, uint* lists)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[5])(n, lists);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[5])(n, (nint)lists);
			#endif
		}

		public static void DeleteCommandListsNV(int n, uint* lists)
		{
			DeleteCommandListsNVNative(n, lists);
		}

		public static void DeleteCommandListsNV(int n, ref uint lists)
		{
			fixed (uint* plists0 = &lists)
			{
				DeleteCommandListsNVNative(n, plists0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteStatesNVNative(int n, uint* states)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[6])(n, states);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[6])(n, (nint)states);
			#endif
		}

		public static void DeleteStatesNV(int n, uint* states)
		{
			DeleteStatesNVNative(n, states);
		}

		public static void DeleteStatesNV(int n, ref uint states)
		{
			fixed (uint* pstates0 = &states)
			{
				DeleteStatesNVNative(n, pstates0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsAddressNVNative(GLEnum primitiveMode, ulong* indirects, int* sizes, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, ulong*, int*, uint, void>)funcTable[7])(primitiveMode, indirects, sizes, count);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, uint, void>)funcTable[7])(primitiveMode, (nint)indirects, (nint)sizes, count);
			#endif
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ulong* indirects, int* sizes, uint count)
		{
			DrawCommandsAddressNVNative(primitiveMode, indirects, sizes, count);
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ref ulong indirects, int* sizes, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				DrawCommandsAddressNVNative(primitiveMode, pindirects0, sizes, count);
			}
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ulong* indirects, ref int sizes, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsAddressNVNative(primitiveMode, indirects, psizes0, count);
			}
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ref ulong indirects, ref int sizes, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsAddressNVNative(primitiveMode, pindirects0, psizes1, count);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsNVNative(GLEnum primitiveMode, uint buffer, nint* indirects, int* sizes, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint*, int*, uint, void>)funcTable[8])(primitiveMode, buffer, indirects, sizes, count);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, nint, uint, void>)funcTable[8])(primitiveMode, buffer, (nint)indirects, (nint)sizes, count);
			#endif
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, nint* indirects, int* sizes, uint count)
		{
			DrawCommandsNVNative(primitiveMode, buffer, indirects, sizes, count);
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, ref nint indirects, int* sizes, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				DrawCommandsNVNative(primitiveMode, buffer, pindirects0, sizes, count);
			}
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, nint* indirects, ref int sizes, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsNVNative(primitiveMode, buffer, indirects, psizes0, count);
			}
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, ref nint indirects, ref int sizes, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsNVNative(primitiveMode, buffer, pindirects0, psizes1, count);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsStatesAddressNVNative(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong*, int*, uint*, uint*, uint, void>)funcTable[9])(indirects, sizes, states, fbos, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, uint, void>)funcTable[9])((nint)indirects, (nint)sizes, (nint)states, (nint)fbos, count);
			#endif
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			DrawCommandsStatesAddressNVNative(indirects, sizes, states, fbos, count);
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				DrawCommandsStatesAddressNVNative(pindirects0, sizes, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsStatesAddressNVNative(indirects, psizes0, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsStatesAddressNVNative(pindirects0, psizes1, states, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				DrawCommandsStatesAddressNVNative(indirects, sizes, pstates0, fbos, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesAddressNVNative(pindirects0, sizes, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesAddressNVNative(indirects, psizes0, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						DrawCommandsStatesAddressNVNative(pindirects0, psizes1, pstates2, fbos, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (uint* pfbos0 = &fbos)
			{
				DrawCommandsStatesAddressNVNative(indirects, sizes, states, pfbos0, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesAddressNVNative(pindirects0, sizes, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesAddressNVNative(indirects, psizes0, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesAddressNVNative(pindirects0, psizes1, states, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesAddressNVNative(indirects, sizes, pstates0, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesAddressNVNative(pindirects0, sizes, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesAddressNVNative(indirects, psizes0, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						fixed (uint* pfbos3 = &fbos)
						{
							DrawCommandsStatesAddressNVNative(pindirects0, psizes1, pstates2, pfbos3, count);
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsStatesNVNative(uint buffer, nint* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint*, int*, uint*, uint*, uint, void>)funcTable[10])(buffer, indirects, sizes, states, fbos, count);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, uint, void>)funcTable[10])(buffer, (nint)indirects, (nint)sizes, (nint)states, (nint)fbos, count);
			#endif
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			DrawCommandsStatesNVNative(buffer, indirects, sizes, states, fbos, count);
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				DrawCommandsStatesNVNative(buffer, pindirects0, sizes, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsStatesNVNative(buffer, indirects, psizes0, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, states, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				DrawCommandsStatesNVNative(buffer, indirects, sizes, pstates0, fbos, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesNVNative(buffer, pindirects0, sizes, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesNVNative(buffer, indirects, psizes0, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, pstates2, fbos, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (uint* pfbos0 = &fbos)
			{
				DrawCommandsStatesNVNative(buffer, indirects, sizes, states, pfbos0, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesNVNative(buffer, pindirects0, sizes, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesNVNative(buffer, indirects, psizes0, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, states, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesNVNative(buffer, indirects, sizes, pstates0, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesNVNative(buffer, pindirects0, sizes, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesNVNative(buffer, indirects, psizes0, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						fixed (uint* pfbos3 = &fbos)
						{
							DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, pstates2, pfbos3, count);
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCommandHeaderNVNative(GLCommandOpcodesNV tokenID, uint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLCommandOpcodesNV, uint, uint>)funcTable[11])(tokenID, size);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLCommandOpcodesNV, uint, uint>)funcTable[11])(tokenID, size);
			#endif
		}

		public static uint GetCommandHeaderNV(GLCommandOpcodesNV tokenID, uint size)
		{
			uint ret = GetCommandHeaderNVNative(tokenID, size);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetStageIndexNVNative(GLShaderType shadertype)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, ushort>)funcTable[12])(shadertype);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<GLShaderType, ushort>)funcTable[12])(shadertype);
			#endif
		}

		public static ushort GetStageIndexNV(GLShaderType shadertype)
		{
			ushort ret = GetStageIndexNVNative(shadertype);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsCommandListNVNative(uint list)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[13])(list);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[13])(list);
			#endif
		}

		public static bool IsCommandListNV(uint list)
		{
			byte ret = IsCommandListNVNative(list);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsStateNVNative(uint state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[14])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[14])(state);
			#endif
		}

		public static bool IsStateNV(uint state)
		{
			byte ret = IsStateNVNative(state);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ListDrawCommandsStatesClientNVNative(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void**, int*, uint*, uint*, uint, void>)funcTable[15])(list, segment, indirects, sizes, states, fbos, count);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, nint, uint, void>)funcTable[15])(list, segment, (nint)indirects, (nint)sizes, (nint)states, (nint)fbos, count);
			#endif
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, states, fbos, count);
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, states, fbos, count);
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, pstates0, fbos, count);
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, pstates1, fbos, count);
				}
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (uint* pfbos0 = &fbos)
			{
				ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, states, pfbos0, count);
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, states, pfbos1, count);
				}
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, pstates0, pfbos1, count);
				}
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, pstates1, pfbos2, count);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StateCaptureNVNative(uint state, GLEnum mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[16])(state, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[16])(state, mode);
			#endif
		}

		public static void StateCaptureNV(uint state, GLEnum mode)
		{
			StateCaptureNVNative(state, mode);
		}

	}
}
