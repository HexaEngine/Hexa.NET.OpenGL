// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.NV
{
	public static unsafe partial class GLNv
	{

		public static void LGPUCopyImageSubDataNVX(uint sourceGpu, uint destinationGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)
		{
			LGPUCopyImageSubDataNVXNative(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LGPUInterlockNVXNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[192])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[192])();
			#endif
		}

		public static void LGPUInterlockNVX()
		{
			LGPUInterlockNVXNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LGPUNamedBufferSubDataNVXNative(uint gpuMask, uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, void*, void>)funcTable[193])(gpuMask, buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[193])(gpuMask, buffer, offset, size, (nint)data);
			#endif
		}

		public static void LGPUNamedBufferSubDataNVX(uint gpuMask, uint buffer, nint offset, nint size, void* data)
		{
			LGPUNamedBufferSubDataNVXNative(gpuMask, buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ListDrawCommandsStatesClientNVNative(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void**, int*, uint*, uint*, uint, void>)funcTable[194])(list, segment, indirects, sizes, states, fbos, count);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, nint, uint, void>)funcTable[194])(list, segment, (nint)indirects, (nint)sizes, (nint)states, (nint)fbos, count);
			#endif
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, states, fbos, count);
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, states, fbos, count);
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, pstates0, fbos, count);
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, pstates1, fbos, count);
				}
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (uint* pfbos0 = &fbos)
			{
				ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, states, pfbos0, count);
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, states, pfbos1, count);
				}
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					ListDrawCommandsStatesClientNVNative(list, segment, indirects, sizes, pstates0, pfbos1, count);
				}
			}
		}

		public static void ListDrawCommandsStatesClientNV(uint list, uint segment, void** indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						ListDrawCommandsStatesClientNVNative(list, segment, indirects, psizes0, pstates1, pfbos2, count);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadProgramNVNative(GLVertexAttribEnumNV target, uint id, int len, byte* program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, int, byte*, void>)funcTable[195])(target, id, len, program);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, int, nint, void>)funcTable[195])(target, id, len, (nint)program);
			#endif
		}

		public static void LoadProgramNV(GLVertexAttribEnumNV target, uint id, int len, byte* program)
		{
			LoadProgramNVNative(target, id, len, program);
		}

		public static void LoadProgramNV(GLVertexAttribEnumNV target, uint id, int len, string program)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (program != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(program);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(program, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LoadProgramNVNative(target, id, len, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LoadProgramNV(GLVertexAttribEnumNV target, uint id, int len, ReadOnlySpan<byte> program)
		{
			fixed (byte* pprogram0 = program)
			{
				LoadProgramNVNative(target, id, len, pprogram0);
			}
		}

		public static void LoadProgramNV(GLVertexAttribEnumNV target, uint id, int len, ref byte program)
		{
			fixed (byte* pprogram0 = &program)
			{
				LoadProgramNVNative(target, id, len, pprogram0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeBufferNonResidentNVNative(GLEnum target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[196])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[196])(target);
			#endif
		}

		public static void MakeBufferNonResidentNV(GLEnum target)
		{
			MakeBufferNonResidentNVNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeBufferResidentNVNative(GLEnum target, GLEnum access)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, void>)funcTable[197])(target, access);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, void>)funcTable[197])(target, access);
			#endif
		}

		public static void MakeBufferResidentNV(GLEnum target, GLEnum access)
		{
			MakeBufferResidentNVNative(target, access);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeImageHandleNonResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[198])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[198])(handle);
			#endif
		}

		public static void MakeImageHandleNonResidentNV(ulong handle)
		{
			MakeImageHandleNonResidentNVNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeImageHandleResidentNVNative(ulong handle, GLEnum access)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, GLEnum, void>)funcTable[199])(handle, access);
			#else
			((delegate* unmanaged[Cdecl]<ulong, GLEnum, void>)funcTable[199])(handle, access);
			#endif
		}

		public static void MakeImageHandleResidentNV(ulong handle, GLEnum access)
		{
			MakeImageHandleResidentNVNative(handle, access);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeNamedBufferNonResidentNVNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[200])(buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[200])(buffer);
			#endif
		}

		public static void MakeNamedBufferNonResidentNV(uint buffer)
		{
			MakeNamedBufferNonResidentNVNative(buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeNamedBufferResidentNVNative(uint buffer, GLEnum access)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[201])(buffer, access);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[201])(buffer, access);
			#endif
		}

		public static void MakeNamedBufferResidentNV(uint buffer, GLEnum access)
		{
			MakeNamedBufferResidentNVNative(buffer, access);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTextureHandleNonResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[202])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[202])(handle);
			#endif
		}

		public static void MakeTextureHandleNonResidentNV(ulong handle)
		{
			MakeTextureHandleNonResidentNVNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTextureHandleResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[203])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[203])(handle);
			#endif
		}

		public static void MakeTextureHandleResidentNV(ulong handle)
		{
			MakeTextureHandleResidentNVNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapControlPointsNVNative(GLEvalTargetNV target, uint index, GLMapTypeNV type, int ustride, int vstride, int uorder, int vorder, byte packed, void* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapTypeNV, int, int, int, int, byte, void*, void>)funcTable[204])(target, index, type, ustride, vstride, uorder, vorder, packed, points);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapTypeNV, int, int, int, int, byte, nint, void>)funcTable[204])(target, index, type, ustride, vstride, uorder, vorder, packed, (nint)points);
			#endif
		}

		public static void MapControlPointsNV(GLEvalTargetNV target, uint index, GLMapTypeNV type, int ustride, int vstride, int uorder, int vorder, byte packed, void* points)
		{
			MapControlPointsNVNative(target, index, type, ustride, vstride, uorder, vorder, packed, points);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapParameterfvNVNative(GLEvalTargetNV target, GLMapParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, float*, void>)funcTable[205])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, nint, void>)funcTable[205])(target, pname, (nint)@params);
			#endif
		}

		public static void MapParameterfvNV(GLEvalTargetNV target, GLMapParameterNV pname, float* @params)
		{
			MapParameterfvNVNative(target, pname, @params);
		}

		public static void MapParameterfvNV(GLEvalTargetNV target, GLMapParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				MapParameterfvNVNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapParameterivNVNative(GLEvalTargetNV target, GLMapParameterNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, int*, void>)funcTable[206])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, nint, void>)funcTable[206])(target, pname, (nint)@params);
			#endif
		}

		public static void MapParameterivNV(GLEvalTargetNV target, GLMapParameterNV pname, int* @params)
		{
			MapParameterivNVNative(target, pname, @params);
		}

		public static void MapParameterivNV(GLEvalTargetNV target, GLMapParameterNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MapParameterivNVNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixFrustumEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[207])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[207])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixFrustumEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixFrustumEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoad3x2fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[208])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[208])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoad3x2fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoad3x2fNVNative(matrixMode, m);
		}

		public static void MatrixLoad3x2fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoad3x2fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoad3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[209])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[209])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoad3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoad3x3fNVNative(matrixMode, m);
		}

		public static void MatrixLoad3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoad3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadIdentityEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[210])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[210])(mode);
			#endif
		}

		public static void MatrixLoadIdentityEXT(GLMatrixMode mode)
		{
			MatrixLoadIdentityEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTranspose3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[211])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[211])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoadTranspose3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoadTranspose3x3fNVNative(matrixMode, m);
		}

		public static void MatrixLoadTranspose3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[212])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[212])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoadTransposedEXTNative(mode, m);
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoadTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[213])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[213])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadTransposefEXTNative(mode, m);
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoaddEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[214])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[214])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoaddEXTNative(mode, m);
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoaddEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[215])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[215])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadfEXTNative(mode, m);
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMult3x2fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[216])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[216])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMult3x2fNV(GLEnum matrixMode, float* m)
		{
			MatrixMult3x2fNVNative(matrixMode, m);
		}

		public static void MatrixMult3x2fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMult3x2fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMult3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[217])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[217])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMult3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixMult3x3fNVNative(matrixMode, m);
		}

		public static void MatrixMult3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMult3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTranspose3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[218])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[218])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMultTranspose3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixMultTranspose3x3fNVNative(matrixMode, m);
		}

		public static void MatrixMultTranspose3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[219])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[219])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultTransposedEXTNative(mode, m);
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[220])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[220])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultTransposefEXTNative(mode, m);
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultdEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[221])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[221])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultdEXTNative(mode, m);
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultdEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[222])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[222])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultfEXTNative(mode, m);
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixOrthoEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[223])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[223])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixOrthoEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixOrthoEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPopEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[224])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[224])(mode);
			#endif
		}

		public static void MatrixPopEXT(GLMatrixMode mode)
		{
			MatrixPopEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPushEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[225])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[225])(mode);
			#endif
		}

		public static void MatrixPushEXT(GLMatrixMode mode)
		{
			MatrixPushEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatedEXTNative(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[226])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[226])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatedEXT(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			MatrixRotatedEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatefEXTNative(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[227])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[227])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatefEXT(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			MatrixRotatefEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScaledEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[228])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[228])(mode, x, y, z);
			#endif
		}

		public static void MatrixScaledEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixScaledEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScalefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[229])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[229])(mode, x, y, z);
			#endif
		}

		public static void MatrixScalefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixScalefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatedEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[230])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[230])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatedEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixTranslatedEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[231])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[231])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixTranslatefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysIndirectBindlessCountNVNative(GLPrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, int, int, int, int, void>)funcTable[232])(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, int, int, int, int, void>)funcTable[232])(mode, (nint)indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
			#endif
		}

		public static void MultiDrawArraysIndirectBindlessCountNV(GLPrimitiveType mode, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
		{
			MultiDrawArraysIndirectBindlessCountNVNative(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysIndirectBindlessNVNative(GLPrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, int, int, int, void>)funcTable[233])(mode, indirect, drawCount, stride, vertexBufferCount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, int, int, int, void>)funcTable[233])(mode, (nint)indirect, drawCount, stride, vertexBufferCount);
			#endif
		}

		public static void MultiDrawArraysIndirectBindlessNV(GLPrimitiveType mode, void* indirect, int drawCount, int stride, int vertexBufferCount)
		{
			MultiDrawArraysIndirectBindlessNVNative(mode, indirect, drawCount, stride, vertexBufferCount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsIndirectBindlessCountNVNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, int, int, int, int, void>)funcTable[234])(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, int, int, int, int, void>)funcTable[234])(mode, type, (nint)indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
			#endif
		}

		public static void MultiDrawElementsIndirectBindlessCountNV(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount)
		{
			MultiDrawElementsIndirectBindlessCountNVNative(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsIndirectBindlessNVNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, int, int, int, void>)funcTable[235])(mode, type, indirect, drawCount, stride, vertexBufferCount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, int, int, int, void>)funcTable[235])(mode, type, (nint)indirect, drawCount, stride, vertexBufferCount);
			#endif
		}

		public static void MultiDrawElementsIndirectBindlessNV(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawCount, int stride, int vertexBufferCount)
		{
			MultiDrawElementsIndirectBindlessNVNative(mode, type, indirect, drawCount, stride, vertexBufferCount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawMeshTasksIndirectNVNative(nint indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[236])(indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[236])(indirect, drawcount, stride);
			#endif
		}

		public static void MultiDrawMeshTasksIndirectNV(nint indirect, int drawcount, int stride)
		{
			MultiDrawMeshTasksIndirectNVNative(indirect, drawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawMeshTasksIndirectCountNVNative(nint indirect, nint drawcount, int maxdrawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)funcTable[237])(indirect, drawcount, maxdrawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)funcTable[237])(indirect, drawcount, maxdrawcount, stride);
			#endif
		}

		public static void MultiDrawMeshTasksIndirectCountNV(nint indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawMeshTasksIndirectCountNVNative(indirect, drawcount, maxdrawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1hNVNative(GLTextureUnit target, Half s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, void>)funcTable[238])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, void>)funcTable[238])(target, s);
			#endif
		}

		public static void MultiTexCoord1hNV(GLTextureUnit target, Half s)
		{
			MultiTexCoord1hNVNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1hvNVNative(GLTextureUnit target, Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half*, void>)funcTable[239])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[239])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1hvNV(GLTextureUnit target, Half* v)
		{
			MultiTexCoord1hvNVNative(target, v);
		}

		public static void MultiTexCoord1hvNV(GLTextureUnit target, ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				MultiTexCoord1hvNVNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2hNVNative(GLTextureUnit target, Half s, Half t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, Half, void>)funcTable[240])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, Half, void>)funcTable[240])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2hNV(GLTextureUnit target, Half s, Half t)
		{
			MultiTexCoord2hNVNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2hvNVNative(GLTextureUnit target, Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half*, void>)funcTable[241])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[241])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2hvNV(GLTextureUnit target, Half* v)
		{
			MultiTexCoord2hvNVNative(target, v);
		}

		public static void MultiTexCoord2hvNV(GLTextureUnit target, ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				MultiTexCoord2hvNVNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3hNVNative(GLTextureUnit target, Half s, Half t, Half r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, Half, Half, void>)funcTable[242])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, Half, Half, void>)funcTable[242])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3hNV(GLTextureUnit target, Half s, Half t, Half r)
		{
			MultiTexCoord3hNVNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3hvNVNative(GLTextureUnit target, Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half*, void>)funcTable[243])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[243])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3hvNV(GLTextureUnit target, Half* v)
		{
			MultiTexCoord3hvNVNative(target, v);
		}

		public static void MultiTexCoord3hvNV(GLTextureUnit target, ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				MultiTexCoord3hvNVNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4hNVNative(GLTextureUnit target, Half s, Half t, Half r, Half q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, Half, Half, Half, void>)funcTable[244])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half, Half, Half, Half, void>)funcTable[244])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4hNV(GLTextureUnit target, Half s, Half t, Half r, Half q)
		{
			MultiTexCoord4hNVNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4hvNVNative(GLTextureUnit target, Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, Half*, void>)funcTable[245])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[245])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4hvNV(GLTextureUnit target, Half* v)
		{
			MultiTexCoord4hvNVNative(target, v);
		}

		public static void MultiTexCoord4hvNV(GLTextureUnit target, ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				MultiTexCoord4hvNVNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastBarrierNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[246])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[246])();
			#endif
		}

		public static void MulticastBarrierNV()
		{
			MulticastBarrierNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastBlitFramebufferNVNative(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLEnum filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLEnum, void>)funcTable[247])(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLEnum, void>)funcTable[247])(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void MulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLEnum filter)
		{
			MulticastBlitFramebufferNVNative(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastBufferSubDataNVNative(uint gpuMask, uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, void*, void>)funcTable[248])(gpuMask, buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[248])(gpuMask, buffer, offset, size, (nint)data);
			#endif
		}

		public static void MulticastBufferSubDataNV(uint gpuMask, uint buffer, nint offset, nint size, void* data)
		{
			MulticastBufferSubDataNVNative(gpuMask, buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastCopyBufferSubDataNVNative(uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, nint, nint, nint, void>)funcTable[249])(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, nint, nint, nint, void>)funcTable[249])(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
			#endif
		}

		public static void MulticastCopyBufferSubDataNV(uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			MulticastCopyBufferSubDataNVNative(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastCopyImageSubDataNVNative(uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, GLEnum, int, int, int, int, uint, GLEnum, int, int, int, int, int, int, int, void>)funcTable[250])(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, GLEnum, int, int, int, int, uint, GLEnum, int, int, int, int, int, int, int, void>)funcTable[250])(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#endif
		}

		public static void MulticastCopyImageSubDataNV(uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			MulticastCopyImageSubDataNVNative(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastFramebufferSampleLocationsfvNVNative(uint gpu, uint framebuffer, uint start, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, float*, void>)funcTable[251])(gpu, framebuffer, start, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, nint, void>)funcTable[251])(gpu, framebuffer, start, count, (nint)v);
			#endif
		}

		public static void MulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, float* v)
		{
			MulticastFramebufferSampleLocationsfvNVNative(gpu, framebuffer, start, count, v);
		}

		public static void MulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MulticastFramebufferSampleLocationsfvNVNative(gpu, framebuffer, start, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastGetQueryObjecti64vNVNative(uint gpu, uint id, GLEnum pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, long*, void>)funcTable[252])(gpu, id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[252])(gpu, id, pname, (nint)@params);
			#endif
		}

		public static void MulticastGetQueryObjecti64vNV(uint gpu, uint id, GLEnum pname, long* @params)
		{
			MulticastGetQueryObjecti64vNVNative(gpu, id, pname, @params);
		}

		public static void MulticastGetQueryObjecti64vNV(uint gpu, uint id, GLEnum pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				MulticastGetQueryObjecti64vNVNative(gpu, id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastGetQueryObjectivNVNative(uint gpu, uint id, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int*, void>)funcTable[253])(gpu, id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[253])(gpu, id, pname, (nint)@params);
			#endif
		}

		public static void MulticastGetQueryObjectivNV(uint gpu, uint id, GLEnum pname, int* @params)
		{
			MulticastGetQueryObjectivNVNative(gpu, id, pname, @params);
		}

		public static void MulticastGetQueryObjectivNV(uint gpu, uint id, GLEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MulticastGetQueryObjectivNVNative(gpu, id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastGetQueryObjectui64vNVNative(uint gpu, uint id, GLEnum pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, ulong*, void>)funcTable[254])(gpu, id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[254])(gpu, id, pname, (nint)@params);
			#endif
		}

		public static void MulticastGetQueryObjectui64vNV(uint gpu, uint id, GLEnum pname, ulong* @params)
		{
			MulticastGetQueryObjectui64vNVNative(gpu, id, pname, @params);
		}

		public static void MulticastGetQueryObjectui64vNV(uint gpu, uint id, GLEnum pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				MulticastGetQueryObjectui64vNVNative(gpu, id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastGetQueryObjectuivNVNative(uint gpu, uint id, GLEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, uint*, void>)funcTable[255])(gpu, id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[255])(gpu, id, pname, (nint)@params);
			#endif
		}

		public static void MulticastGetQueryObjectuivNV(uint gpu, uint id, GLEnum pname, uint* @params)
		{
			MulticastGetQueryObjectuivNVNative(gpu, id, pname, @params);
		}

		public static void MulticastGetQueryObjectuivNV(uint gpu, uint id, GLEnum pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				MulticastGetQueryObjectuivNVNative(gpu, id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastScissorArrayvNVXNative(uint gpu, uint first, int count, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, void>)funcTable[256])(gpu, first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[256])(gpu, first, count, (nint)v);
			#endif
		}

		public static void MulticastScissorArrayvNVX(uint gpu, uint first, int count, int* v)
		{
			MulticastScissorArrayvNVXNative(gpu, first, count, v);
		}

		public static void MulticastScissorArrayvNVX(uint gpu, uint first, int count, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MulticastScissorArrayvNVXNative(gpu, first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastViewportArrayvNVXNative(uint gpu, uint first, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, float*, void>)funcTable[257])(gpu, first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[257])(gpu, first, count, (nint)v);
			#endif
		}

		public static void MulticastViewportArrayvNVX(uint gpu, uint first, int count, float* v)
		{
			MulticastViewportArrayvNVXNative(gpu, first, count, v);
		}

		public static void MulticastViewportArrayvNVX(uint gpu, uint first, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MulticastViewportArrayvNVXNative(gpu, first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastViewportPositionWScaleNVXNative(uint gpu, uint index, float xcoeff, float ycoeff)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, float, float, void>)funcTable[258])(gpu, index, xcoeff, ycoeff);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, float, float, void>)funcTable[258])(gpu, index, xcoeff, ycoeff);
			#endif
		}

		public static void MulticastViewportPositionWScaleNVX(uint gpu, uint index, float xcoeff, float ycoeff)
		{
			MulticastViewportPositionWScaleNVXNative(gpu, index, xcoeff, ycoeff);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MulticastWaitSyncNVNative(uint signalGpu, uint waitGpuMask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[259])(signalGpu, waitGpuMask);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[259])(signalGpu, waitGpuMask);
			#endif
		}

		public static void MulticastWaitSyncNV(uint signalGpu, uint waitGpuMask)
		{
			MulticastWaitSyncNVNative(signalGpu, waitGpuMask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferAttachMemoryNVNative(uint buffer, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[260])(buffer, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[260])(buffer, memory, offset);
			#endif
		}

		public static void NamedBufferAttachMemoryNV(uint buffer, uint memory, ulong offset)
		{
			NamedBufferAttachMemoryNVNative(buffer, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferPageCommitmentMemNVNative(uint buffer, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, uint, ulong, byte, void>)funcTable[261])(buffer, offset, size, memory, memOffset, commit);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, uint, ulong, byte, void>)funcTable[261])(buffer, offset, size, memory, memOffset, commit);
			#endif
		}

		public static void NamedBufferPageCommitmentMemNV(uint buffer, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			NamedBufferPageCommitmentMemNVNative(buffer, offset, size, memory, memOffset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferSampleLocationsfvNVNative(uint framebuffer, uint start, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, float*, void>)funcTable[262])(framebuffer, start, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[262])(framebuffer, start, count, (nint)v);
			#endif
		}

		public static void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, float* v)
		{
			NamedFramebufferSampleLocationsfvNVNative(framebuffer, start, count, v);
		}

		public static void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				NamedFramebufferSampleLocationsfvNVNative(framebuffer, start, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3hNVNative(Half nx, Half ny, Half nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[263])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[263])(nx, ny, nz);
			#endif
		}

		public static void Normal3hNV(Half nx, Half ny, Half nz)
		{
			Normal3hNVNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[264])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[264])((nint)v);
			#endif
		}

		public static void Normal3hvNV(Half* v)
		{
			Normal3hvNVNative(v);
		}

		public static void Normal3hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				Normal3hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NormalFormatNVNative(GLEnum type, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[265])(type, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[265])(type, stride);
			#endif
		}

		public static void NormalFormatNV(GLEnum type, int stride)
		{
			NormalFormatNVNative(type, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathColorGenNVNative(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, GLPathColorFormat, float*, void>)funcTable[266])(color, genMode, colorFormat, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, GLPathColorFormat, nint, void>)funcTable[266])(color, genMode, colorFormat, (nint)coeffs);
			#endif
		}

		public static void PathColorGenNV(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, float* coeffs)
		{
			PathColorGenNVNative(color, genMode, colorFormat, coeffs);
		}

		public static void PathColorGenNV(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				PathColorGenNVNative(color, genMode, colorFormat, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCommandsNVNative(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, int, GLPathCoordType, void*, void>)funcTable[267])(path, numCommands, commands, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, int, GLPathCoordType, nint, void>)funcTable[267])(path, numCommands, commands, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathCommandsNV(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathCommandsNVNative(path, numCommands, commands, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCoordsNVNative(uint path, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, void*, void>)funcTable[268])(path, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, nint, void>)funcTable[268])(path, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathCoordsNV(uint path, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathCoordsNVNative(path, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCoverDepthFuncNVNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[269])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[269])(func);
			#endif
		}

		public static void PathCoverDepthFuncNV(GLDepthFunction func)
		{
			PathCoverDepthFuncNVNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathDashArrayNVNative(uint path, int dashCount, float* dashArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[270])(path, dashCount, dashArray);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[270])(path, dashCount, (nint)dashArray);
			#endif
		}

		public static void PathDashArrayNV(uint path, int dashCount, float* dashArray)
		{
			PathDashArrayNVNative(path, dashCount, dashArray);
		}

		public static void PathDashArrayNV(uint path, int dashCount, ref float dashArray)
		{
			fixed (float* pdashArray0 = &dashArray)
			{
				PathDashArrayNVNative(path, dashCount, pdashArray0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathFogGenNVNative(GLPathGenMode genMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathGenMode, void>)funcTable[271])(genMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPathGenMode, void>)funcTable[271])(genMode);
			#endif
		}

		public static void PathFogGenNV(GLPathGenMode genMode)
		{
			PathFogGenNVNative(genMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathGlyphIndexArrayNVNative(uint firstPathName, GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLEnum, void*, GLPathFontStyle, uint, int, uint, float, GLEnum>)funcTable[272])(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, GLPathFontStyle, uint, int, uint, float, GLEnum>)funcTable[272])(firstPathName, fontTarget, (nint)fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static GLEnum PathGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathGlyphIndexArrayNVNative(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathGlyphIndexRangeNVNative(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum, void*, GLPathFontStyle, uint, float, uint*, GLEnum>)funcTable[273])(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum, nint, GLPathFontStyle, uint, float, nint, GLEnum>)funcTable[273])(fontTarget, (nint)fontName, fontStyle, pathParameterTemplate, emScale, (nint)baseAndCount);
			#endif
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
		{
			GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
			return ret;
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount)
		{
			fixed (uint* pbaseAndCount0 = &baseAndCount)
			{
				GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, pbaseAndCount0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathGlyphRangeNVNative(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, void*, GLPathFontStyle, uint, int, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[274])(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, nint, GLPathFontStyle, uint, int, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[274])(firstPathName, fontTarget, (nint)fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static void PathGlyphRangeNV(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphRangeNVNative(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathGlyphsNVNative(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, void*, GLPathFontStyle, int, GLPathElementType, void*, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[275])(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, nint, GLPathFontStyle, int, GLPathElementType, nint, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[275])(firstPathName, fontTarget, (nint)fontName, fontStyle, numGlyphs, type, (nint)charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static void PathGlyphsNV(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphsNVNative(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathMemoryGlyphIndexArrayNVNative(uint firstPathName, GLEnum fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void*, int, uint, int, uint, float, GLEnum>)funcTable[276])(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, nint, int, uint, int, uint, float, GLEnum>)funcTable[276])(firstPathName, fontTarget, fontSize, (nint)fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static GLEnum PathMemoryGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathMemoryGlyphIndexArrayNVNative(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterfNVNative(uint path, GLPathParameter pname, float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float, void>)funcTable[277])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float, void>)funcTable[277])(path, pname, value);
			#endif
		}

		public static void PathParameterfNV(uint path, GLPathParameter pname, float value)
		{
			PathParameterfNVNative(path, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterfvNVNative(uint path, GLPathParameter pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float*, void>)funcTable[278])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[278])(path, pname, (nint)value);
			#endif
		}

		public static void PathParameterfvNV(uint path, GLPathParameter pname, float* value)
		{
			PathParameterfvNVNative(path, pname, value);
		}

		public static void PathParameterfvNV(uint path, GLPathParameter pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				PathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameteriNVNative(uint path, GLPathParameter pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int, void>)funcTable[279])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int, void>)funcTable[279])(path, pname, value);
			#endif
		}

		public static void PathParameteriNV(uint path, GLPathParameter pname, int value)
		{
			PathParameteriNVNative(path, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterivNVNative(uint path, GLPathParameter pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int*, void>)funcTable[280])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[280])(path, pname, (nint)value);
			#endif
		}

		public static void PathParameterivNV(uint path, GLPathParameter pname, int* value)
		{
			PathParameterivNVNative(path, pname, value);
		}

		public static void PathParameterivNV(uint path, GLPathParameter pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				PathParameterivNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStencilDepthOffsetNVNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[281])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[281])(factor, units);
			#endif
		}

		public static void PathStencilDepthOffsetNV(float factor, float units)
		{
			PathStencilDepthOffsetNVNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStencilFuncNVNative(GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[282])(func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[282])(func, reference, mask);
			#endif
		}

		public static void PathStencilFuncNV(GLStencilFunction func, int reference, uint mask)
		{
			PathStencilFuncNVNative(func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStringNVNative(uint path, GLPathStringFormat format, int length, void* pathString)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathStringFormat, int, void*, void>)funcTable[283])(path, format, length, pathString);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathStringFormat, int, nint, void>)funcTable[283])(path, format, length, (nint)pathString);
			#endif
		}

		public static void PathStringNV(uint path, GLPathStringFormat format, int length, void* pathString)
		{
			PathStringNVNative(path, format, length, pathString);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathSubCommandsNVNative(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPathCoordType, int, GLPathCoordType, void*, void>)funcTable[284])(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPathCoordType, int, GLPathCoordType, nint, void>)funcTable[284])(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathSubCommandsNVNative(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathSubCoordsNVNative(uint path, int coordStart, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, GLPathCoordType, void*, void>)funcTable[285])(path, coordStart, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, GLPathCoordType, nint, void>)funcTable[285])(path, coordStart, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathSubCoordsNVNative(path, coordStart, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathTexGenNVNative(GLPathColor texCoordSet, GLPathGenMode genMode, int components, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int, float*, void>)funcTable[286])(texCoordSet, genMode, components, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int, nint, void>)funcTable[286])(texCoordSet, genMode, components, (nint)coeffs);
			#endif
		}

		public static void PathTexGenNV(GLPathColor texCoordSet, GLPathGenMode genMode, int components, float* coeffs)
		{
			PathTexGenNVNative(texCoordSet, genMode, components, coeffs);
		}

		public static void PathTexGenNV(GLPathColor texCoordSet, GLPathGenMode genMode, int components, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				PathTexGenNVNative(texCoordSet, genMode, components, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PauseTransformFeedbackNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[287])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[287])();
			#endif
		}

		public static void PauseTransformFeedbackNV()
		{
			PauseTransformFeedbackNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelDataRangeNVNative(GLPixelDataRangeTargetNV target, int length, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelDataRangeTargetNV, int, void*, void>)funcTable[288])(target, length, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelDataRangeTargetNV, int, nint, void>)funcTable[288])(target, length, (nint)pointer);
			#endif
		}

		public static void PixelDataRangeNV(GLPixelDataRangeTargetNV target, int length, void* pointer)
		{
			PixelDataRangeNVNative(target, length, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PointAlongPathNVNative(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, float, float*, float*, float*, float*, byte>)funcTable[289])(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, int, int, float, nint, nint, nint, nint, byte>)funcTable[289])(path, startSegment, numSegments, distance, (nint)x, (nint)y, (nint)tangentX, (nint)tangentY);
			#endif
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY)
		{
			byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
			return ret != 0;
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, float* tangentX, float* tangentY)
		{
			fixed (float* py0 = &y)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, ref float tangentX, float* tangentY)
		{
			fixed (float* ptangentX0 = &tangentX)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, ref float tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, ref float tangentX, float* tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentX2 = &tangentX)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, tangentY);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, ref float tangentY)
		{
			fixed (float* ptangentY0 = &tangentY)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, tangentX, ptangentY0);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, float* tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, float* tangentX, ref float tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, float* tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, ref float tangentX, ref float tangentY)
		{
			fixed (float* ptangentX0 = &tangentX)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, ref float tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, ref float tangentX, ref float tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentX2 = &tangentX)
					{
						fixed (float* ptangentY3 = &tangentY)
						{
							byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, ptangentY3);
							return ret != 0;
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameteriNVNative(GLPointParameterNameARB pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[290])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[290])(pname, param);
			#endif
		}

		public static void PointParameteriNV(GLPointParameterNameARB pname, int param)
		{
			PointParameteriNVNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterivNVNative(GLPointParameterNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int*, void>)funcTable[291])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[291])(pname, (nint)@params);
			#endif
		}

		public static void PointParameterivNV(GLPointParameterNameARB pname, int* @params)
		{
			PointParameterivNVNative(pname, @params);
		}

		public static void PointParameterivNV(GLPointParameterNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				PointParameterivNVNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PresentFrameDualFillNVNative(uint videoSlot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, GLEnum type, GLEnum target0, uint fill0, GLEnum target1, uint fill1, GLEnum target2, uint fill2, GLEnum target3, uint fill3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ulong, uint, uint, GLEnum, GLEnum, uint, GLEnum, uint, GLEnum, uint, GLEnum, uint, void>)funcTable[292])(videoSlot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
			#else
			((delegate* unmanaged[Cdecl]<uint, ulong, uint, uint, GLEnum, GLEnum, uint, GLEnum, uint, GLEnum, uint, GLEnum, uint, void>)funcTable[292])(videoSlot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
			#endif
		}

		public static void PresentFrameDualFillNV(uint videoSlot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, GLEnum type, GLEnum target0, uint fill0, GLEnum target1, uint fill1, GLEnum target2, uint fill2, GLEnum target3, uint fill3)
		{
			PresentFrameDualFillNVNative(videoSlot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PresentFrameKeyedNVNative(uint videoSlot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, GLEnum type, GLEnum target0, uint fill0, uint key0, GLEnum target1, uint fill1, uint key1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ulong, uint, uint, GLEnum, GLEnum, uint, uint, GLEnum, uint, uint, void>)funcTable[293])(videoSlot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
			#else
			((delegate* unmanaged[Cdecl]<uint, ulong, uint, uint, GLEnum, GLEnum, uint, uint, GLEnum, uint, uint, void>)funcTable[293])(videoSlot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
			#endif
		}

		public static void PresentFrameKeyedNV(uint videoSlot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, GLEnum type, GLEnum target0, uint fill0, uint key0, GLEnum target1, uint fill1, uint key1)
		{
			PresentFrameKeyedNVNative(videoSlot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PrimitiveRestartIndexNVNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[294])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[294])(index);
			#endif
		}

		public static void PrimitiveRestartIndexNV(uint index)
		{
			PrimitiveRestartIndexNVNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PrimitiveRestartNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[295])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[295])();
			#endif
		}

		public static void PrimitiveRestartNV()
		{
			PrimitiveRestartNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramBufferParametersIivNVNative(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, int, int*, void>)funcTable[296])(target, bindingIndex, wordIndex, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, int, nint, void>)funcTable[296])(target, bindingIndex, wordIndex, count, (nint)@params);
			#endif
		}

		public static void ProgramBufferParametersIivNV(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, int* @params)
		{
			ProgramBufferParametersIivNVNative(target, bindingIndex, wordIndex, count, @params);
		}

		public static void ProgramBufferParametersIivNV(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ProgramBufferParametersIivNVNative(target, bindingIndex, wordIndex, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramBufferParametersIuivNVNative(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, int, uint*, void>)funcTable[297])(target, bindingIndex, wordIndex, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, int, nint, void>)funcTable[297])(target, bindingIndex, wordIndex, count, (nint)@params);
			#endif
		}

		public static void ProgramBufferParametersIuivNV(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, uint* @params)
		{
			ProgramBufferParametersIuivNVNative(target, bindingIndex, wordIndex, count, @params);
		}

		public static void ProgramBufferParametersIuivNV(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				ProgramBufferParametersIuivNVNative(target, bindingIndex, wordIndex, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramBufferParametersfvNVNative(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, int, float*, void>)funcTable[298])(target, bindingIndex, wordIndex, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, int, nint, void>)funcTable[298])(target, bindingIndex, wordIndex, count, (nint)@params);
			#endif
		}

		public static void ProgramBufferParametersfvNV(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, float* @params)
		{
			ProgramBufferParametersfvNVNative(target, bindingIndex, wordIndex, count, @params);
		}

		public static void ProgramBufferParametersfvNV(GLProgramTarget target, uint bindingIndex, uint wordIndex, int count, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ProgramBufferParametersfvNVNative(target, bindingIndex, wordIndex, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramEnvParameterI4iNVNative(GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, int, int, int, void>)funcTable[299])(target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, int, int, int, void>)funcTable[299])(target, index, x, y, z, w);
			#endif
		}

		public static void ProgramEnvParameterI4iNV(GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			ProgramEnvParameterI4iNVNative(target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramEnvParameterI4ivNVNative(GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int*, void>)funcTable[300])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[300])(target, index, (nint)@params);
			#endif
		}

		public static void ProgramEnvParameterI4ivNV(GLProgramTarget target, uint index, int* @params)
		{
			ProgramEnvParameterI4ivNVNative(target, index, @params);
		}

		public static void ProgramEnvParameterI4ivNV(GLProgramTarget target, uint index, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ProgramEnvParameterI4ivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramEnvParameterI4uiNVNative(GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[301])(target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[301])(target, index, x, y, z, w);
			#endif
		}

		public static void ProgramEnvParameterI4uiNV(GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			ProgramEnvParameterI4uiNVNative(target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramEnvParameterI4uivNVNative(GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint*, void>)funcTable[302])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[302])(target, index, (nint)@params);
			#endif
		}

		public static void ProgramEnvParameterI4uivNV(GLProgramTarget target, uint index, uint* @params)
		{
			ProgramEnvParameterI4uivNVNative(target, index, @params);
		}

		public static void ProgramEnvParameterI4uivNV(GLProgramTarget target, uint index, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				ProgramEnvParameterI4uivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramEnvParametersI4ivNVNative(GLProgramTarget target, uint index, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, int*, void>)funcTable[303])(target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, nint, void>)funcTable[303])(target, index, count, (nint)@params);
			#endif
		}

		public static void ProgramEnvParametersI4ivNV(GLProgramTarget target, uint index, int count, int* @params)
		{
			ProgramEnvParametersI4ivNVNative(target, index, count, @params);
		}

		public static void ProgramEnvParametersI4ivNV(GLProgramTarget target, uint index, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ProgramEnvParametersI4ivNVNative(target, index, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramEnvParametersI4uivNVNative(GLProgramTarget target, uint index, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, uint*, void>)funcTable[304])(target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, nint, void>)funcTable[304])(target, index, count, (nint)@params);
			#endif
		}

		public static void ProgramEnvParametersI4uivNV(GLProgramTarget target, uint index, int count, uint* @params)
		{
			ProgramEnvParametersI4uivNVNative(target, index, count, @params);
		}

		public static void ProgramEnvParametersI4uivNV(GLProgramTarget target, uint index, int count, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				ProgramEnvParametersI4uivNVNative(target, index, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramLocalParameterI4iNVNative(GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, int, int, int, void>)funcTable[305])(target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, int, int, int, void>)funcTable[305])(target, index, x, y, z, w);
			#endif
		}

		public static void ProgramLocalParameterI4iNV(GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			ProgramLocalParameterI4iNVNative(target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramLocalParameterI4ivNVNative(GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int*, void>)funcTable[306])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[306])(target, index, (nint)@params);
			#endif
		}

		public static void ProgramLocalParameterI4ivNV(GLProgramTarget target, uint index, int* @params)
		{
			ProgramLocalParameterI4ivNVNative(target, index, @params);
		}

		public static void ProgramLocalParameterI4ivNV(GLProgramTarget target, uint index, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ProgramLocalParameterI4ivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramLocalParameterI4uiNVNative(GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[307])(target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[307])(target, index, x, y, z, w);
			#endif
		}

		public static void ProgramLocalParameterI4uiNV(GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			ProgramLocalParameterI4uiNVNative(target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramLocalParameterI4uivNVNative(GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint*, void>)funcTable[308])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[308])(target, index, (nint)@params);
			#endif
		}

		public static void ProgramLocalParameterI4uivNV(GLProgramTarget target, uint index, uint* @params)
		{
			ProgramLocalParameterI4uivNVNative(target, index, @params);
		}

		public static void ProgramLocalParameterI4uivNV(GLProgramTarget target, uint index, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				ProgramLocalParameterI4uivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramLocalParametersI4ivNVNative(GLProgramTarget target, uint index, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, int*, void>)funcTable[309])(target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, nint, void>)funcTable[309])(target, index, count, (nint)@params);
			#endif
		}

		public static void ProgramLocalParametersI4ivNV(GLProgramTarget target, uint index, int count, int* @params)
		{
			ProgramLocalParametersI4ivNVNative(target, index, count, @params);
		}

		public static void ProgramLocalParametersI4ivNV(GLProgramTarget target, uint index, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ProgramLocalParametersI4ivNVNative(target, index, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramLocalParametersI4uivNVNative(GLProgramTarget target, uint index, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, uint*, void>)funcTable[310])(target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int, nint, void>)funcTable[310])(target, index, count, (nint)@params);
			#endif
		}

		public static void ProgramLocalParametersI4uivNV(GLProgramTarget target, uint index, int count, uint* @params)
		{
			ProgramLocalParametersI4uivNVNative(target, index, count, @params);
		}

		public static void ProgramLocalParametersI4uivNV(GLProgramTarget target, uint index, int count, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				ProgramLocalParametersI4uivNVNative(target, index, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramNamedParameter4dNVNative(uint id, int len, byte* name, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte*, double, double, double, double, void>)funcTable[311])(id, len, name, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, double, double, double, double, void>)funcTable[311])(id, len, (nint)name, x, y, z, w);
			#endif
		}

		public static void ProgramNamedParameter4dNV(uint id, int len, byte* name, double x, double y, double z, double w)
		{
			ProgramNamedParameter4dNVNative(id, len, name, x, y, z, w);
		}

		public static void ProgramNamedParameter4dNV(uint id, int len, string name, double x, double y, double z, double w)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgramNamedParameter4dNVNative(id, len, pStr0, x, y, z, w);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ProgramNamedParameter4dNV(uint id, int len, ReadOnlySpan<byte> name, double x, double y, double z, double w)
		{
			fixed (byte* pname0 = name)
			{
				ProgramNamedParameter4dNVNative(id, len, pname0, x, y, z, w);
			}
		}

		public static void ProgramNamedParameter4dNV(uint id, int len, ref byte name, double x, double y, double z, double w)
		{
			fixed (byte* pname0 = &name)
			{
				ProgramNamedParameter4dNVNative(id, len, pname0, x, y, z, w);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramNamedParameter4dvNVNative(uint id, int len, byte* name, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte*, double*, void>)funcTable[312])(id, len, name, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[312])(id, len, (nint)name, (nint)v);
			#endif
		}

		public static void ProgramNamedParameter4dvNV(uint id, int len, byte* name, double* v)
		{
			ProgramNamedParameter4dvNVNative(id, len, name, v);
		}

		public static void ProgramNamedParameter4dvNV(uint id, int len, string name, double* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgramNamedParameter4dvNVNative(id, len, pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ProgramNamedParameter4dvNV(uint id, int len, ReadOnlySpan<byte> name, double* v)
		{
			fixed (byte* pname0 = name)
			{
				ProgramNamedParameter4dvNVNative(id, len, pname0, v);
			}
		}

		public static void ProgramNamedParameter4dvNV(uint id, int len, ref byte name, double* v)
		{
			fixed (byte* pname0 = &name)
			{
				ProgramNamedParameter4dvNVNative(id, len, pname0, v);
			}
		}

		public static void ProgramNamedParameter4dvNV(uint id, int len, byte* name, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				ProgramNamedParameter4dvNVNative(id, len, name, pv0);
			}
		}

		public static void ProgramNamedParameter4dvNV(uint id, int len, ref byte name, ref double v)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (double* pv1 = &v)
				{
					ProgramNamedParameter4dvNVNative(id, len, pname0, pv1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramNamedParameter4fNVNative(uint id, int len, byte* name, float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte*, float, float, float, float, void>)funcTable[313])(id, len, name, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, float, float, float, float, void>)funcTable[313])(id, len, (nint)name, x, y, z, w);
			#endif
		}

		public static void ProgramNamedParameter4fNV(uint id, int len, byte* name, float x, float y, float z, float w)
		{
			ProgramNamedParameter4fNVNative(id, len, name, x, y, z, w);
		}

		public static void ProgramNamedParameter4fNV(uint id, int len, string name, float x, float y, float z, float w)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgramNamedParameter4fNVNative(id, len, pStr0, x, y, z, w);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ProgramNamedParameter4fNV(uint id, int len, ReadOnlySpan<byte> name, float x, float y, float z, float w)
		{
			fixed (byte* pname0 = name)
			{
				ProgramNamedParameter4fNVNative(id, len, pname0, x, y, z, w);
			}
		}

		public static void ProgramNamedParameter4fNV(uint id, int len, ref byte name, float x, float y, float z, float w)
		{
			fixed (byte* pname0 = &name)
			{
				ProgramNamedParameter4fNVNative(id, len, pname0, x, y, z, w);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramNamedParameter4fvNVNative(uint id, int len, byte* name, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte*, float*, void>)funcTable[314])(id, len, name, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[314])(id, len, (nint)name, (nint)v);
			#endif
		}

		public static void ProgramNamedParameter4fvNV(uint id, int len, byte* name, float* v)
		{
			ProgramNamedParameter4fvNVNative(id, len, name, v);
		}

		public static void ProgramNamedParameter4fvNV(uint id, int len, string name, float* v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ProgramNamedParameter4fvNVNative(id, len, pStr0, v);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ProgramNamedParameter4fvNV(uint id, int len, ReadOnlySpan<byte> name, float* v)
		{
			fixed (byte* pname0 = name)
			{
				ProgramNamedParameter4fvNVNative(id, len, pname0, v);
			}
		}

		public static void ProgramNamedParameter4fvNV(uint id, int len, ref byte name, float* v)
		{
			fixed (byte* pname0 = &name)
			{
				ProgramNamedParameter4fvNVNative(id, len, pname0, v);
			}
		}

		public static void ProgramNamedParameter4fvNV(uint id, int len, byte* name, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ProgramNamedParameter4fvNVNative(id, len, name, pv0);
			}
		}

		public static void ProgramNamedParameter4fvNV(uint id, int len, ref byte name, ref float v)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (float* pv1 = &v)
				{
					ProgramNamedParameter4fvNVNative(id, len, pname0, pv1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramParameter4dNVNative(GLVertexAttribEnumNV target, uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, double, double, double, double, void>)funcTable[315])(target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, double, double, double, double, void>)funcTable[315])(target, index, x, y, z, w);
			#endif
		}

		public static void ProgramParameter4dNV(GLVertexAttribEnumNV target, uint index, double x, double y, double z, double w)
		{
			ProgramParameter4dNVNative(target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramParameter4dvNVNative(GLVertexAttribEnumNV target, uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, double*, void>)funcTable[316])(target, index, v);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, nint, void>)funcTable[316])(target, index, (nint)v);
			#endif
		}

		public static void ProgramParameter4dvNV(GLVertexAttribEnumNV target, uint index, double* v)
		{
			ProgramParameter4dvNVNative(target, index, v);
		}

		public static void ProgramParameter4dvNV(GLVertexAttribEnumNV target, uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				ProgramParameter4dvNVNative(target, index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramParameter4fNVNative(GLVertexAttribEnumNV target, uint index, float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, float, float, float, float, void>)funcTable[317])(target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, float, float, float, float, void>)funcTable[317])(target, index, x, y, z, w);
			#endif
		}

		public static void ProgramParameter4fNV(GLVertexAttribEnumNV target, uint index, float x, float y, float z, float w)
		{
			ProgramParameter4fNVNative(target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramParameter4fvNVNative(GLVertexAttribEnumNV target, uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, float*, void>)funcTable[318])(target, index, v);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, nint, void>)funcTable[318])(target, index, (nint)v);
			#endif
		}

		public static void ProgramParameter4fvNV(GLVertexAttribEnumNV target, uint index, float* v)
		{
			ProgramParameter4fvNVNative(target, index, v);
		}

		public static void ProgramParameter4fvNV(GLVertexAttribEnumNV target, uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ProgramParameter4fvNVNative(target, index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramParameters4dvNVNative(GLVertexAttribEnumNV target, uint index, int count, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, int, double*, void>)funcTable[319])(target, index, count, v);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, int, nint, void>)funcTable[319])(target, index, count, (nint)v);
			#endif
		}

		public static void ProgramParameters4dvNV(GLVertexAttribEnumNV target, uint index, int count, double* v)
		{
			ProgramParameters4dvNVNative(target, index, count, v);
		}

		public static void ProgramParameters4dvNV(GLVertexAttribEnumNV target, uint index, int count, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				ProgramParameters4dvNVNative(target, index, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramParameters4fvNVNative(GLVertexAttribEnumNV target, uint index, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, int, float*, void>)funcTable[320])(target, index, count, v);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, int, nint, void>)funcTable[320])(target, index, count, (nint)v);
			#endif
		}

		public static void ProgramParameters4fvNV(GLVertexAttribEnumNV target, uint index, int count, float* v)
		{
			ProgramParameters4fvNVNative(target, index, count, v);
		}

		public static void ProgramParameters4fvNV(GLVertexAttribEnumNV target, uint index, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ProgramParameters4fvNVNative(target, index, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramPathFragmentInputGenNVNative(uint program, int location, GLEnum genMode, int components, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLEnum, int, float*, void>)funcTable[321])(program, location, genMode, components, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLEnum, int, nint, void>)funcTable[321])(program, location, genMode, components, (nint)coeffs);
			#endif
		}

		public static void ProgramPathFragmentInputGenNV(uint program, int location, GLEnum genMode, int components, float* coeffs)
		{
			ProgramPathFragmentInputGenNVNative(program, location, genMode, components, coeffs);
		}

		public static void ProgramPathFragmentInputGenNV(uint program, int location, GLEnum genMode, int components, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				ProgramPathFragmentInputGenNVNative(program, location, genMode, components, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramSubroutineParametersuivNVNative(GLEnum target, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, uint*, void>)funcTable[322])(target, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, nint, void>)funcTable[322])(target, count, (nint)@params);
			#endif
		}

		public static void ProgramSubroutineParametersuivNV(GLEnum target, int count, uint* @params)
		{
			ProgramSubroutineParametersuivNVNative(target, count, @params);
		}

		public static void ProgramSubroutineParametersuivNV(GLEnum target, int count, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				ProgramSubroutineParametersuivNVNative(target, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1i64NVNative(uint program, int location, long x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, void>)funcTable[323])(program, location, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, void>)funcTable[323])(program, location, x);
			#endif
		}

		public static void ProgramUniform1i64NV(uint program, int location, long x)
		{
			ProgramUniform1i64NVNative(program, location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[324])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[324])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform1i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform1i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform1i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1ui64NVNative(uint program, int location, ulong x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[325])(program, location, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[325])(program, location, x);
			#endif
		}

		public static void ProgramUniform1ui64NV(uint program, int location, ulong x)
		{
			ProgramUniform1ui64NVNative(program, location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[326])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[326])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform1ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform1ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform1ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2i64NVNative(uint program, int location, long x, long y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, long, void>)funcTable[327])(program, location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, long, void>)funcTable[327])(program, location, x, y);
			#endif
		}

		public static void ProgramUniform2i64NV(uint program, int location, long x, long y)
		{
			ProgramUniform2i64NVNative(program, location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[328])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[328])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform2i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform2i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform2i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2ui64NVNative(uint program, int location, ulong x, ulong y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, void>)funcTable[329])(program, location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, void>)funcTable[329])(program, location, x, y);
			#endif
		}

		public static void ProgramUniform2ui64NV(uint program, int location, ulong x, ulong y)
		{
			ProgramUniform2ui64NVNative(program, location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[330])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[330])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform2ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform2ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform2ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3i64NVNative(uint program, int location, long x, long y, long z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, void>)funcTable[331])(program, location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, void>)funcTable[331])(program, location, x, y, z);
			#endif
		}

		public static void ProgramUniform3i64NV(uint program, int location, long x, long y, long z)
		{
			ProgramUniform3i64NVNative(program, location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[332])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[332])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform3i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform3i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform3i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3ui64NVNative(uint program, int location, ulong x, ulong y, ulong z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, void>)funcTable[333])(program, location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, void>)funcTable[333])(program, location, x, y, z);
			#endif
		}

		public static void ProgramUniform3ui64NV(uint program, int location, ulong x, ulong y, ulong z)
		{
			ProgramUniform3ui64NVNative(program, location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[334])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[334])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform3ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform3ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform3ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4i64NVNative(uint program, int location, long x, long y, long z, long w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, long, void>)funcTable[335])(program, location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, long, void>)funcTable[335])(program, location, x, y, z, w);
			#endif
		}

		public static void ProgramUniform4i64NV(uint program, int location, long x, long y, long z, long w)
		{
			ProgramUniform4i64NVNative(program, location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[336])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[336])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform4i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform4i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform4i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4ui64NVNative(uint program, int location, ulong x, ulong y, ulong z, ulong w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, ulong, void>)funcTable[337])(program, location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, ulong, void>)funcTable[337])(program, location, x, y, z, w);
			#endif
		}

		public static void ProgramUniform4ui64NV(uint program, int location, ulong x, ulong y, ulong z, ulong w)
		{
			ProgramUniform4ui64NVNative(program, location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[338])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[338])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform4ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform4ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform4ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformHandleui64NVNative(uint program, int location, ulong value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[339])(program, location, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[339])(program, location, value);
			#endif
		}

		public static void ProgramUniformHandleui64NV(uint program, int location, ulong value)
		{
			ProgramUniformHandleui64NVNative(program, location, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformHandleui64vNVNative(uint program, int location, int count, ulong* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[340])(program, location, count, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[340])(program, location, count, (nint)values);
			#endif
		}

		public static void ProgramUniformHandleui64vNV(uint program, int location, int count, ulong* values)
		{
			ProgramUniformHandleui64vNVNative(program, location, count, values);
		}

		public static void ProgramUniformHandleui64vNV(uint program, int location, int count, ref ulong values)
		{
			fixed (ulong* pvalues0 = &values)
			{
				ProgramUniformHandleui64vNVNative(program, location, count, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformui64NVNative(uint program, int location, ulong value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[341])(program, location, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[341])(program, location, value);
			#endif
		}

		public static void ProgramUniformui64NV(uint program, int location, ulong value)
		{
			ProgramUniformui64NVNative(program, location, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[342])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[342])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniformui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniformui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniformui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniformui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramVertexLimitNVNative(GLProgramTarget target, int limit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, int, void>)funcTable[343])(target, limit);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, int, void>)funcTable[343])(target, limit);
			#endif
		}

		public static void ProgramVertexLimitNV(GLProgramTarget target, int limit)
		{
			ProgramVertexLimitNVNative(target, limit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int QueryResourceNVNative(GLEnum queryType, int tagId, uint count, int* buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum, int, uint, int*, int>)funcTable[344])(queryType, tagId, count, buffer);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GLEnum, int, uint, nint, int>)funcTable[344])(queryType, tagId, count, (nint)buffer);
			#endif
		}

		public static int QueryResourceNV(GLEnum queryType, int tagId, uint count, int* buffer)
		{
			int ret = QueryResourceNVNative(queryType, tagId, count, buffer);
			return ret;
		}

		public static int QueryResourceNV(GLEnum queryType, int tagId, uint count, ref int buffer)
		{
			fixed (int* pbuffer0 = &buffer)
			{
				int ret = QueryResourceNVNative(queryType, tagId, count, pbuffer0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QueryResourceTagNVNative(int tagId, byte* tagString)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[345])(tagId, tagString);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[345])(tagId, (nint)tagString);
			#endif
		}

		public static void QueryResourceTagNV(int tagId, byte* tagString)
		{
			QueryResourceTagNVNative(tagId, tagString);
		}

		public static void QueryResourceTagNV(int tagId, string tagString)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (tagString != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(tagString);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(tagString, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			QueryResourceTagNVNative(tagId, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void QueryResourceTagNV(int tagId, ReadOnlySpan<byte> tagString)
		{
			fixed (byte* ptagString0 = tagString)
			{
				QueryResourceTagNVNative(tagId, ptagString0);
			}
		}

		public static void QueryResourceTagNV(int tagId, ref byte tagString)
		{
			fixed (byte* ptagString0 = &tagString)
			{
				QueryResourceTagNVNative(tagId, ptagString0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterSamplesEXTNative(uint samples, byte fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[346])(samples, fixedsamplelocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[346])(samples, fixedsamplelocations);
			#endif
		}

		public static void RasterSamplesEXT(uint samples, byte fixedsamplelocations)
		{
			RasterSamplesEXTNative(samples, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderGpuMaskNVNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[347])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[347])(mask);
			#endif
		}

		public static void RenderGpuMaskNV(uint mask)
		{
			RenderGpuMaskNVNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderbufferStorageMultisampleCoverageNVNative(GLRenderbufferTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, int, GLInternalFormat, int, int, void>)funcTable[348])(target, coverageSamples, colorSamples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, int, GLInternalFormat, int, int, void>)funcTable[348])(target, coverageSamples, colorSamples, internalformat, width, height);
			#endif
		}

		public static void RenderbufferStorageMultisampleCoverageNV(GLRenderbufferTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalformat, int width, int height)
		{
			RenderbufferStorageMultisampleCoverageNVNative(target, coverageSamples, colorSamples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RequestResidentProgramsNVNative(int n, uint* programs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[349])(n, programs);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[349])(n, (nint)programs);
			#endif
		}

		public static void RequestResidentProgramsNV(int n, uint* programs)
		{
			RequestResidentProgramsNVNative(n, programs);
		}

		public static void RequestResidentProgramsNV(int n, ref uint programs)
		{
			fixed (uint* pprograms0 = &programs)
			{
				RequestResidentProgramsNVNative(n, pprograms0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetMemoryObjectParameterNVNative(uint memory, GLEnum pname)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[350])(memory, pname);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[350])(memory, pname);
			#endif
		}

		public static void ResetMemoryObjectParameterNV(uint memory, GLEnum pname)
		{
			ResetMemoryObjectParameterNVNative(memory, pname);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResolveDepthValuesNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[351])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[351])();
			#endif
		}

		public static void ResolveDepthValuesNV()
		{
			ResolveDepthValuesNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResumeTransformFeedbackNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[352])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[352])();
			#endif
		}

		public static void ResumeTransformFeedbackNV()
		{
			ResumeTransformFeedbackNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SampleMaskIndexedNVNative(uint index, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[353])(index, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[353])(index, mask);
			#endif
		}

		public static void SampleMaskIndexedNV(uint index, uint mask)
		{
			SampleMaskIndexedNVNative(index, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorExclusiveArrayvNVNative(uint first, int count, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[354])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[354])(first, count, (nint)v);
			#endif
		}

		public static void ScissorExclusiveArrayvNV(uint first, int count, int* v)
		{
			ScissorExclusiveArrayvNVNative(first, count, v);
		}

		public static void ScissorExclusiveArrayvNV(uint first, int count, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				ScissorExclusiveArrayvNVNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorExclusiveNVNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[355])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[355])(x, y, width, height);
			#endif
		}

		public static void ScissorExclusiveNV(int x, int y, int width, int height)
		{
			ScissorExclusiveNVNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3hNVNative(Half red, Half green, Half blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[356])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[356])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3hNV(Half red, Half green, Half blue)
		{
			SecondaryColor3hNVNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[357])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[357])((nint)v);
			#endif
		}

		public static void SecondaryColor3hvNV(Half* v)
		{
			SecondaryColor3hvNVNative(v);
		}

		public static void SecondaryColor3hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				SecondaryColor3hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColorFormatNVNative(int size, GLColorPointerType type, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void>)funcTable[358])(size, type, stride);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void>)funcTable[358])(size, type, stride);
			#endif
		}

		public static void SecondaryColorFormatNV(int size, GLColorPointerType type, int stride)
		{
			SecondaryColorFormatNVNative(size, type, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SemaphoreParameterivNVNative(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, int*, void>)funcTable[359])(semaphore, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, nint, void>)funcTable[359])(semaphore, pname, (nint)@params);
			#endif
		}

		public static void SemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			SemaphoreParameterivNVNative(semaphore, pname, @params);
		}

		public static void SemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				SemaphoreParameterivNVNative(semaphore, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFenceNVNative(uint fence, GLFenceConditionNV condition)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFenceConditionNV, void>)funcTable[360])(fence, condition);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFenceConditionNV, void>)funcTable[360])(fence, condition);
			#endif
		}

		public static void SetFenceNV(uint fence, GLFenceConditionNV condition)
		{
			SetFenceNVNative(fence, condition);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateImageBarrierNVNative(byte synchronize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[361])(synchronize);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[361])(synchronize);
			#endif
		}

		public static void ShadingRateImageBarrierNV(byte synchronize)
		{
			ShadingRateImageBarrierNVNative(synchronize);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateImagePaletteNVNative(uint viewport, uint first, int count, GLEnum* rates)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLEnum*, void>)funcTable[362])(viewport, first, count, rates);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[362])(viewport, first, count, (nint)rates);
			#endif
		}

		public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, GLEnum* rates)
		{
			ShadingRateImagePaletteNVNative(viewport, first, count, rates);
		}

		public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, ref GLEnum rates)
		{
			fixed (GLEnum* prates0 = &rates)
			{
				ShadingRateImagePaletteNVNative(viewport, first, count, prates0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateSampleOrderNVNative(GLEnum order)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[363])(order);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[363])(order);
			#endif
		}

		public static void ShadingRateSampleOrderNV(GLEnum order)
		{
			ShadingRateSampleOrderNVNative(order);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateSampleOrderCustomNVNative(GLEnum rate, uint samples, int* locations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int*, void>)funcTable[364])(rate, samples, locations);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[364])(rate, samples, (nint)locations);
			#endif
		}

		public static void ShadingRateSampleOrderCustomNV(GLEnum rate, uint samples, int* locations)
		{
			ShadingRateSampleOrderCustomNVNative(rate, samples, locations);
		}

		public static void ShadingRateSampleOrderCustomNV(GLEnum rate, uint samples, ref int locations)
		{
			fixed (int* plocations0 = &locations)
			{
				ShadingRateSampleOrderCustomNVNative(rate, samples, plocations0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalSemaphoreui64NVXNative(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, ulong*, void>)funcTable[365])(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[365])(signalGpu, fenceObjectCount, (nint)semaphoreArray, (nint)fenceValueArray);
			#endif
		}

		public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray)
		{
			SignalSemaphoreui64NVXNative(signalGpu, fenceObjectCount, semaphoreArray, fenceValueArray);
		}

		public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, ref uint semaphoreArray, ulong* fenceValueArray)
		{
			fixed (uint* psemaphoreArray0 = &semaphoreArray)
			{
				SignalSemaphoreui64NVXNative(signalGpu, fenceObjectCount, psemaphoreArray0, fenceValueArray);
			}
		}

		public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, uint* semaphoreArray, ref ulong fenceValueArray)
		{
			fixed (ulong* pfenceValueArray0 = &fenceValueArray)
			{
				SignalSemaphoreui64NVXNative(signalGpu, fenceObjectCount, semaphoreArray, pfenceValueArray0);
			}
		}

		public static void SignalSemaphoreui64NVX(uint signalGpu, int fenceObjectCount, ref uint semaphoreArray, ref ulong fenceValueArray)
		{
			fixed (uint* psemaphoreArray0 = &semaphoreArray)
			{
				fixed (ulong* pfenceValueArray1 = &fenceValueArray)
				{
					SignalSemaphoreui64NVXNative(signalGpu, fenceObjectCount, psemaphoreArray0, pfenceValueArray1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StateCaptureNVNative(uint state, GLEnum mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[366])(state, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[366])(state, mode);
			#endif
		}

		public static void StateCaptureNV(uint state, GLEnum mode)
		{
			StateCaptureNVNative(state, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLPathFillMode, uint, GLPathTransformType, float*, void>)funcTable[367])(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLPathFillMode, uint, GLPathTransformType, nint, void>)funcTable[367])(numPaths, pathNameType, (nint)paths, pathBase, fillMode, mask, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFillPathNVNative(uint path, GLPathFillMode fillMode, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, void>)funcTable[368])(path, fillMode, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, void>)funcTable[368])(path, fillMode, mask);
			#endif
		}

		public static void StencilFillPathNV(uint path, GLPathFillMode fillMode, uint mask)
		{
			StencilFillPathNVNative(path, fillMode, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, int, uint, GLPathTransformType, float*, void>)funcTable[369])(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, int, uint, GLPathTransformType, nint, void>)funcTable[369])(numPaths, pathNameType, (nint)paths, pathBase, reference, mask, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilStrokePathNVNative(uint path, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[370])(path, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[370])(path, reference, mask);
			#endif
		}

		public static void StencilStrokePathNV(uint path, int reference, uint mask)
		{
			StencilStrokePathNVNative(path, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLPathFillMode, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[371])(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLPathFillMode, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[371])(numPaths, pathNameType, (nint)paths, pathBase, fillMode, mask, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverFillPathNVNative(uint path, GLPathFillMode fillMode, uint mask, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, GLPathCoverMode, void>)funcTable[372])(path, fillMode, mask, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, GLPathCoverMode, void>)funcTable[372])(path, fillMode, mask, coverMode);
			#endif
		}

		public static void StencilThenCoverFillPathNV(uint path, GLPathFillMode fillMode, uint mask, GLPathCoverMode coverMode)
		{
			StencilThenCoverFillPathNVNative(path, fillMode, mask, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, int, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[373])(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, int, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[373])(numPaths, pathNameType, (nint)paths, pathBase, reference, mask, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverStrokePathNVNative(uint path, int reference, uint mask, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, GLPathCoverMode, void>)funcTable[374])(path, reference, mask, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, GLPathCoverMode, void>)funcTable[374])(path, reference, mask, coverMode);
			#endif
		}

		public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, GLPathCoverMode coverMode)
		{
			StencilThenCoverStrokePathNVNative(path, reference, mask, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SubpixelPrecisionBiasNVNative(uint xbits, uint ybits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[375])(xbits, ybits);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[375])(xbits, ybits);
			#endif
		}

		public static void SubpixelPrecisionBiasNV(uint xbits, uint ybits)
		{
			SubpixelPrecisionBiasNVNative(xbits, ybits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestFenceNVNative(uint fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[376])(fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[376])(fence);
			#endif
		}

		public static bool TestFenceNV(uint fence)
		{
			byte ret = TestFenceNVNative(fence);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexAttachMemoryNVNative(GLTextureTarget target, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, ulong, void>)funcTable[377])(target, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, ulong, void>)funcTable[377])(target, memory, offset);
			#endif
		}

		public static void TexAttachMemoryNV(GLTextureTarget target, uint memory, ulong offset)
		{
			TexAttachMemoryNVNative(target, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord1hNVNative(Half s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, void>)funcTable[378])(s);
			#else
			((delegate* unmanaged[Cdecl]<Half, void>)funcTable[378])(s);
			#endif
		}

		public static void TexCoord1hNV(Half s)
		{
			TexCoord1hNVNative(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord1hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[379])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[379])((nint)v);
			#endif
		}

		public static void TexCoord1hvNV(Half* v)
		{
			TexCoord1hvNVNative(v);
		}

		public static void TexCoord1hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				TexCoord1hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord2hNVNative(Half s, Half t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, Half, void>)funcTable[380])(s, t);
			#else
			((delegate* unmanaged[Cdecl]<Half, Half, void>)funcTable[380])(s, t);
			#endif
		}

		public static void TexCoord2hNV(Half s, Half t)
		{
			TexCoord2hNVNative(s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord2hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[381])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[381])((nint)v);
			#endif
		}

		public static void TexCoord2hvNV(Half* v)
		{
			TexCoord2hvNVNative(v);
		}

		public static void TexCoord2hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				TexCoord2hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord3hNVNative(Half s, Half t, Half r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[382])(s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[382])(s, t, r);
			#endif
		}

		public static void TexCoord3hNV(Half s, Half t, Half r)
		{
			TexCoord3hNVNative(s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord3hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[383])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[383])((nint)v);
			#endif
		}

		public static void TexCoord3hvNV(Half* v)
		{
			TexCoord3hvNVNative(v);
		}

		public static void TexCoord3hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				TexCoord3hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord4hNVNative(Half s, Half t, Half r, Half q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, Half, Half, Half, void>)funcTable[384])(s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<Half, Half, Half, Half, void>)funcTable[384])(s, t, r, q);
			#endif
		}

		public static void TexCoord4hNV(Half s, Half t, Half r, Half q)
		{
			TexCoord4hNVNative(s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord4hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[385])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[385])((nint)v);
			#endif
		}

		public static void TexCoord4hvNV(Half* v)
		{
			TexCoord4hvNVNative(v);
		}

		public static void TexCoord4hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				TexCoord4hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoordFormatNVNative(int size, GLEnum type, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLEnum, int, void>)funcTable[386])(size, type, stride);
			#else
			((delegate* unmanaged[Cdecl]<int, GLEnum, int, void>)funcTable[386])(size, type, stride);
			#endif
		}

		public static void TexCoordFormatNV(int size, GLEnum type, int stride)
		{
			TexCoordFormatNVNative(size, type, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexImage2DMultisampleCoverageNVNative(GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, byte fixedSampleLocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, GLInternalFormat, int, int, byte, void>)funcTable[387])(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, GLInternalFormat, int, int, byte, void>)funcTable[387])(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
			#endif
		}

		public static void TexImage2DMultisampleCoverageNV(GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, byte fixedSampleLocations)
		{
			TexImage2DMultisampleCoverageNVNative(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexImage3DMultisampleCoverageNVNative(GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, GLInternalFormat, int, int, int, byte, void>)funcTable[388])(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, GLInternalFormat, int, int, int, byte, void>)funcTable[388])(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
			#endif
		}

		public static void TexImage3DMultisampleCoverageNV(GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations)
		{
			TexImage3DMultisampleCoverageNVNative(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexPageCommitmentMemNVNative(GLTextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[389])(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[389])(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#endif
		}

		public static void TexPageCommitmentMemNV(GLTextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			TexPageCommitmentMemNVNative(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexRenderbufferNVNative(GLTextureTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[390])(target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[390])(target, renderbuffer);
			#endif
		}

		public static void TexRenderbufferNV(GLTextureTarget target, uint renderbuffer)
		{
			TexRenderbufferNVNative(target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureAttachMemoryNVNative(uint texture, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[391])(texture, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[391])(texture, memory, offset);
			#endif
		}

		public static void TextureAttachMemoryNV(uint texture, uint memory, ulong offset)
		{
			TextureAttachMemoryNVNative(texture, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureBarrierNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[392])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[392])();
			#endif
		}

		public static void TextureBarrierNV()
		{
			TextureBarrierNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage2DMultisampleCoverageNVNative(uint texture, GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, byte fixedSampleLocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, GLInternalFormat, int, int, byte, void>)funcTable[393])(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, GLInternalFormat, int, int, byte, void>)funcTable[393])(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
			#endif
		}

		public static void TextureImage2DMultisampleCoverageNV(uint texture, GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, byte fixedSampleLocations)
		{
			TextureImage2DMultisampleCoverageNVNative(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage2DMultisampleNVNative(uint texture, GLTextureTarget target, int samples, GLInternalFormat internalFormat, int width, int height, byte fixedSampleLocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, byte, void>)funcTable[394])(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, byte, void>)funcTable[394])(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
			#endif
		}

		public static void TextureImage2DMultisampleNV(uint texture, GLTextureTarget target, int samples, GLInternalFormat internalFormat, int width, int height, byte fixedSampleLocations)
		{
			TextureImage2DMultisampleNVNative(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage3DMultisampleCoverageNVNative(uint texture, GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, GLInternalFormat, int, int, int, byte, void>)funcTable[395])(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, GLInternalFormat, int, int, int, byte, void>)funcTable[395])(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
			#endif
		}

		public static void TextureImage3DMultisampleCoverageNV(uint texture, GLTextureTarget target, int coverageSamples, int colorSamples, GLInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations)
		{
			TextureImage3DMultisampleCoverageNVNative(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage3DMultisampleNVNative(uint texture, GLTextureTarget target, int samples, GLInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, byte, void>)funcTable[396])(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, byte, void>)funcTable[396])(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
			#endif
		}

		public static void TextureImage3DMultisampleNV(uint texture, GLTextureTarget target, int samples, GLInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations)
		{
			TextureImage3DMultisampleNVNative(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexturePageCommitmentMemNVNative(uint texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[397])(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[397])(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#endif
		}

		public static void TexturePageCommitmentMemNV(uint texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			TexturePageCommitmentMemNVNative(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TrackMatrixNVNative(GLVertexAttribEnumNV target, uint address, GLVertexAttribEnumNV matrix, GLVertexAttribEnumNV transform)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, GLVertexAttribEnumNV, void>)funcTable[398])(target, address, matrix, transform);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, GLVertexAttribEnumNV, void>)funcTable[398])(target, address, matrix, transform);
			#endif
		}

		public static void TrackMatrixNV(GLVertexAttribEnumNV target, uint address, GLVertexAttribEnumNV matrix, GLVertexAttribEnumNV transform)
		{
			TrackMatrixNVNative(target, address, matrix, transform);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformFeedbackAttribsNVNative(int count, int* attribs, GLEnum bufferMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int*, GLEnum, void>)funcTable[399])(count, attribs, bufferMode);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, GLEnum, void>)funcTable[399])(count, (nint)attribs, bufferMode);
			#endif
		}

		public static void TransformFeedbackAttribsNV(int count, int* attribs, GLEnum bufferMode)
		{
			TransformFeedbackAttribsNVNative(count, attribs, bufferMode);
		}

		public static void TransformFeedbackAttribsNV(int count, ref int attribs, GLEnum bufferMode)
		{
			fixed (int* pattribs0 = &attribs)
			{
				TransformFeedbackAttribsNVNative(count, pattribs0, bufferMode);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformFeedbackStreamAttribsNVNative(int count, int* attribs, int nbuffers, int* bufstreams, GLEnum bufferMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int*, int, int*, GLEnum, void>)funcTable[400])(count, attribs, nbuffers, bufstreams, bufferMode);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, int, nint, GLEnum, void>)funcTable[400])(count, (nint)attribs, nbuffers, (nint)bufstreams, bufferMode);
			#endif
		}

		public static void TransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int* bufstreams, GLEnum bufferMode)
		{
			TransformFeedbackStreamAttribsNVNative(count, attribs, nbuffers, bufstreams, bufferMode);
		}

		public static void TransformFeedbackStreamAttribsNV(int count, ref int attribs, int nbuffers, int* bufstreams, GLEnum bufferMode)
		{
			fixed (int* pattribs0 = &attribs)
			{
				TransformFeedbackStreamAttribsNVNative(count, pattribs0, nbuffers, bufstreams, bufferMode);
			}
		}

		public static void TransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, ref int bufstreams, GLEnum bufferMode)
		{
			fixed (int* pbufstreams0 = &bufstreams)
			{
				TransformFeedbackStreamAttribsNVNative(count, attribs, nbuffers, pbufstreams0, bufferMode);
			}
		}

		public static void TransformFeedbackStreamAttribsNV(int count, ref int attribs, int nbuffers, ref int bufstreams, GLEnum bufferMode)
		{
			fixed (int* pattribs0 = &attribs)
			{
				fixed (int* pbufstreams1 = &bufstreams)
				{
					TransformFeedbackStreamAttribsNVNative(count, pattribs0, nbuffers, pbufstreams1, bufferMode);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformFeedbackVaryingsNVNative(uint program, int count, GLTransformFeedbackTokenNV locations, GLTransformFeedbackBufferMode bufferMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLTransformFeedbackTokenNV, GLTransformFeedbackBufferMode, void>)funcTable[401])(program, count, locations, bufferMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLTransformFeedbackTokenNV, GLTransformFeedbackBufferMode, void>)funcTable[401])(program, count, locations, bufferMode);
			#endif
		}

		public static void TransformFeedbackVaryingsNV(uint program, int count, GLTransformFeedbackTokenNV locations, GLTransformFeedbackBufferMode bufferMode)
		{
			TransformFeedbackVaryingsNVNative(program, count, locations, bufferMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformPathNVNative(uint resultPath, uint srcPath, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLPathTransformType, float*, void>)funcTable[402])(resultPath, srcPath, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLPathTransformType, nint, void>)funcTable[402])(resultPath, srcPath, transformType, (nint)transformValues);
			#endif
		}

		public static void TransformPathNV(uint resultPath, uint srcPath, GLPathTransformType transformType, float* transformValues)
		{
			TransformPathNVNative(resultPath, srcPath, transformType, transformValues);
		}

		public static void TransformPathNV(uint resultPath, uint srcPath, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				TransformPathNVNative(resultPath, srcPath, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1i64NVNative(int location, long x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, void>)funcTable[403])(location, x);
			#else
			((delegate* unmanaged[Cdecl]<int, long, void>)funcTable[403])(location, x);
			#endif
		}

		public static void Uniform1i64NV(int location, long x)
		{
			Uniform1i64NVNative(location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[404])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[404])(location, count, (nint)value);
			#endif
		}

		public static void Uniform1i64vNV(int location, int count, long* value)
		{
			Uniform1i64vNVNative(location, count, value);
		}

		public static void Uniform1i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform1i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1ui64NVNative(int location, ulong x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[405])(location, x);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[405])(location, x);
			#endif
		}

		public static void Uniform1ui64NV(int location, ulong x)
		{
			Uniform1ui64NVNative(location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[406])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[406])(location, count, (nint)value);
			#endif
		}

		public static void Uniform1ui64vNV(int location, int count, ulong* value)
		{
			Uniform1ui64vNVNative(location, count, value);
		}

		public static void Uniform1ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform1ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2i64NVNative(int location, long x, long y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, long, void>)funcTable[407])(location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, long, long, void>)funcTable[407])(location, x, y);
			#endif
		}

		public static void Uniform2i64NV(int location, long x, long y)
		{
			Uniform2i64NVNative(location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[408])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[408])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2i64vNV(int location, int count, long* value)
		{
			Uniform2i64vNVNative(location, count, value);
		}

		public static void Uniform2i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform2i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2ui64NVNative(int location, ulong x, ulong y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, void>)funcTable[409])(location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, void>)funcTable[409])(location, x, y);
			#endif
		}

		public static void Uniform2ui64NV(int location, ulong x, ulong y)
		{
			Uniform2ui64NVNative(location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[410])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[410])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2ui64vNV(int location, int count, ulong* value)
		{
			Uniform2ui64vNVNative(location, count, value);
		}

		public static void Uniform2ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform2ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3i64NVNative(int location, long x, long y, long z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, long, long, void>)funcTable[411])(location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, long, long, long, void>)funcTable[411])(location, x, y, z);
			#endif
		}

		public static void Uniform3i64NV(int location, long x, long y, long z)
		{
			Uniform3i64NVNative(location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[412])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[412])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3i64vNV(int location, int count, long* value)
		{
			Uniform3i64vNVNative(location, count, value);
		}

		public static void Uniform3i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform3i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3ui64NVNative(int location, ulong x, ulong y, ulong z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, void>)funcTable[413])(location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, void>)funcTable[413])(location, x, y, z);
			#endif
		}

		public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z)
		{
			Uniform3ui64NVNative(location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[414])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[414])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3ui64vNV(int location, int count, ulong* value)
		{
			Uniform3ui64vNVNative(location, count, value);
		}

		public static void Uniform3ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform3ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4i64NVNative(int location, long x, long y, long z, long w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, long, long, long, void>)funcTable[415])(location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, long, long, long, long, void>)funcTable[415])(location, x, y, z, w);
			#endif
		}

		public static void Uniform4i64NV(int location, long x, long y, long z, long w)
		{
			Uniform4i64NVNative(location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[416])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[416])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4i64vNV(int location, int count, long* value)
		{
			Uniform4i64vNVNative(location, count, value);
		}

		public static void Uniform4i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform4i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4ui64NVNative(int location, ulong x, ulong y, ulong z, ulong w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, ulong, void>)funcTable[417])(location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, ulong, void>)funcTable[417])(location, x, y, z, w);
			#endif
		}

		public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w)
		{
			Uniform4ui64NVNative(location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[418])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[418])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4ui64vNV(int location, int count, ulong* value)
		{
			Uniform4ui64vNVNative(location, count, value);
		}

		public static void Uniform4ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform4ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformHandleui64NVNative(int location, ulong value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[419])(location, value);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[419])(location, value);
			#endif
		}

		public static void UniformHandleui64NV(int location, ulong value)
		{
			UniformHandleui64NVNative(location, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformHandleui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[420])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[420])(location, count, (nint)value);
			#endif
		}

		public static void UniformHandleui64vNV(int location, int count, ulong* value)
		{
			UniformHandleui64vNVNative(location, count, value);
		}

		public static void UniformHandleui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				UniformHandleui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniformui64NVNative(int location, ulong value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[421])(location, value);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[421])(location, value);
			#endif
		}

		public static void Uniformui64NV(int location, ulong value)
		{
			Uniformui64NVNative(location, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniformui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[422])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[422])(location, count, (nint)value);
			#endif
		}

		public static void Uniformui64vNV(int location, int count, ulong* value)
		{
			Uniformui64vNVNative(location, count, value);
		}

		public static void Uniformui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniformui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UploadGpuMaskNVXNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[423])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[423])(mask);
			#endif
		}

		public static void UploadGpuMaskNVX(uint mask)
		{
			UploadGpuMaskNVXNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VDPAUFiniNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[424])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[424])();
			#endif
		}

		public static void VDPAUFiniNV()
		{
			VDPAUFiniNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VDPAUGetSurfaceivNVNative(GLvdpauSurfaceNV surface, GLEnum pname, int count, int* length, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLvdpauSurfaceNV, GLEnum, int, int*, int*, void>)funcTable[425])(surface, pname, count, length, values);
			#else
			((delegate* unmanaged[Cdecl]<GLvdpauSurfaceNV, GLEnum, int, nint, nint, void>)funcTable[425])(surface, pname, count, (nint)length, (nint)values);
			#endif
		}

		public static void VDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLEnum pname, int count, int* length, int* values)
		{
			VDPAUGetSurfaceivNVNative(surface, pname, count, length, values);
		}

		public static void VDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLEnum pname, int count, ref int length, int* values)
		{
			fixed (int* plength0 = &length)
			{
				VDPAUGetSurfaceivNVNative(surface, pname, count, plength0, values);
			}
		}

		public static void VDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLEnum pname, int count, int* length, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				VDPAUGetSurfaceivNVNative(surface, pname, count, length, pvalues0);
			}
		}

		public static void VDPAUGetSurfaceivNV(GLvdpauSurfaceNV surface, GLEnum pname, int count, ref int length, ref int values)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* pvalues1 = &values)
				{
					VDPAUGetSurfaceivNVNative(surface, pname, count, plength0, pvalues1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VDPAUInitNVNative(void* vdpDevice, void* getProcAddress)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[426])(vdpDevice, getProcAddress);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[426])((nint)vdpDevice, (nint)getProcAddress);
			#endif
		}

		public static void VDPAUInitNV(void* vdpDevice, void* getProcAddress)
		{
			VDPAUInitNVNative(vdpDevice, getProcAddress);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte VDPAUIsSurfaceNVNative(GLvdpauSurfaceNV surface)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLvdpauSurfaceNV, byte>)funcTable[427])(surface);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLvdpauSurfaceNV, byte>)funcTable[427])(surface);
			#endif
		}

		public static bool VDPAUIsSurfaceNV(GLvdpauSurfaceNV surface)
		{
			byte ret = VDPAUIsSurfaceNVNative(surface);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VDPAUMapSurfacesNVNative(int numSurfaces, GLvdpauSurfaceNV* surfaces)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLvdpauSurfaceNV*, void>)funcTable[428])(numSurfaces, surfaces);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[428])(numSurfaces, (nint)surfaces);
			#endif
		}

		public static void VDPAUMapSurfacesNV(int numSurfaces, GLvdpauSurfaceNV* surfaces)
		{
			VDPAUMapSurfacesNVNative(numSurfaces, surfaces);
		}

		public static void VDPAUMapSurfacesNV(int numSurfaces, ref GLvdpauSurfaceNV surfaces)
		{
			fixed (GLvdpauSurfaceNV* psurfaces0 = &surfaces)
			{
				VDPAUMapSurfacesNVNative(numSurfaces, psurfaces0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLvdpauSurfaceNV VDPAURegisterOutputSurfaceNVNative(void* vdpSurface, GLEnum target, int numTextureNames, uint* textureNames)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, GLEnum, int, uint*, GLvdpauSurfaceNV>)funcTable[429])(vdpSurface, target, numTextureNames, textureNames);
			#else
			return (GLvdpauSurfaceNV)((delegate* unmanaged[Cdecl]<nint, GLEnum, int, nint, GLvdpauSurfaceNV>)funcTable[429])((nint)vdpSurface, target, numTextureNames, (nint)textureNames);
			#endif
		}

		public static GLvdpauSurfaceNV VDPAURegisterOutputSurfaceNV(void* vdpSurface, GLEnum target, int numTextureNames, uint* textureNames)
		{
			GLvdpauSurfaceNV ret = VDPAURegisterOutputSurfaceNVNative(vdpSurface, target, numTextureNames, textureNames);
			return ret;
		}

		public static GLvdpauSurfaceNV VDPAURegisterOutputSurfaceNV(void* vdpSurface, GLEnum target, int numTextureNames, ref uint textureNames)
		{
			fixed (uint* ptextureNames0 = &textureNames)
			{
				GLvdpauSurfaceNV ret = VDPAURegisterOutputSurfaceNVNative(vdpSurface, target, numTextureNames, ptextureNames0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLvdpauSurfaceNV VDPAURegisterVideoSurfaceNVNative(void* vdpSurface, GLEnum target, int numTextureNames, uint* textureNames)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, GLEnum, int, uint*, GLvdpauSurfaceNV>)funcTable[430])(vdpSurface, target, numTextureNames, textureNames);
			#else
			return (GLvdpauSurfaceNV)((delegate* unmanaged[Cdecl]<nint, GLEnum, int, nint, GLvdpauSurfaceNV>)funcTable[430])((nint)vdpSurface, target, numTextureNames, (nint)textureNames);
			#endif
		}

		public static GLvdpauSurfaceNV VDPAURegisterVideoSurfaceNV(void* vdpSurface, GLEnum target, int numTextureNames, uint* textureNames)
		{
			GLvdpauSurfaceNV ret = VDPAURegisterVideoSurfaceNVNative(vdpSurface, target, numTextureNames, textureNames);
			return ret;
		}

		public static GLvdpauSurfaceNV VDPAURegisterVideoSurfaceNV(void* vdpSurface, GLEnum target, int numTextureNames, ref uint textureNames)
		{
			fixed (uint* ptextureNames0 = &textureNames)
			{
				GLvdpauSurfaceNV ret = VDPAURegisterVideoSurfaceNVNative(vdpSurface, target, numTextureNames, ptextureNames0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLvdpauSurfaceNV VDPAURegisterVideoSurfaceWithPictureStructureNVNative(void* vdpSurface, GLEnum target, int numTextureNames, uint* textureNames, byte isFrameStructure)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<void*, GLEnum, int, uint*, byte, GLvdpauSurfaceNV>)funcTable[431])(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
			#else
			return (GLvdpauSurfaceNV)((delegate* unmanaged[Cdecl]<nint, GLEnum, int, nint, byte, GLvdpauSurfaceNV>)funcTable[431])((nint)vdpSurface, target, numTextureNames, (nint)textureNames, isFrameStructure);
			#endif
		}

		public static GLvdpauSurfaceNV VDPAURegisterVideoSurfaceWithPictureStructureNV(void* vdpSurface, GLEnum target, int numTextureNames, uint* textureNames, byte isFrameStructure)
		{
			GLvdpauSurfaceNV ret = VDPAURegisterVideoSurfaceWithPictureStructureNVNative(vdpSurface, target, numTextureNames, textureNames, isFrameStructure);
			return ret;
		}

		public static GLvdpauSurfaceNV VDPAURegisterVideoSurfaceWithPictureStructureNV(void* vdpSurface, GLEnum target, int numTextureNames, ref uint textureNames, byte isFrameStructure)
		{
			fixed (uint* ptextureNames0 = &textureNames)
			{
				GLvdpauSurfaceNV ret = VDPAURegisterVideoSurfaceWithPictureStructureNVNative(vdpSurface, target, numTextureNames, ptextureNames0, isFrameStructure);
				return ret;
			}
		}
	}
}
