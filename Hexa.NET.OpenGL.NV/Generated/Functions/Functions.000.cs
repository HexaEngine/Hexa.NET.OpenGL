// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.NV
{
	public static unsafe partial class GLNv
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveVaryingNVNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[0])(program, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[0])(program, (nint)name);
			#endif
		}

		public static void ActiveVaryingNV(uint program, byte* name)
		{
			ActiveVaryingNVNative(program, name);
		}

		public static void ActiveVaryingNV(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ActiveVaryingNVNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ActiveVaryingNV(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				ActiveVaryingNVNative(program, pname0);
			}
		}

		public static void ActiveVaryingNV(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				ActiveVaryingNVNative(program, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlphaToCoverageDitherControlNVNative(GLEnum mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[1])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[1])(mode);
			#endif
		}

		public static void AlphaToCoverageDitherControlNV(GLEnum mode)
		{
			AlphaToCoverageDitherControlNVNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AreProgramsResidentNVNative(int n, uint* programs, byte* residences)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint*, byte*, byte>)funcTable[2])(n, programs, residences);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, nint, nint, byte>)funcTable[2])(n, (nint)programs, (nint)residences);
			#endif
		}

		public static bool AreProgramsResidentNV(int n, uint* programs, byte* residences)
		{
			byte ret = AreProgramsResidentNVNative(n, programs, residences);
			return ret != 0;
		}

		public static bool AreProgramsResidentNV(int n, ref uint programs, byte* residences)
		{
			fixed (uint* pprograms0 = &programs)
			{
				byte ret = AreProgramsResidentNVNative(n, pprograms0, residences);
				return ret != 0;
			}
		}

		public static bool AreProgramsResidentNV(int n, uint* programs, string residences)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (residences != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(residences);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(residences, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = AreProgramsResidentNVNative(n, programs, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool AreProgramsResidentNV(int n, uint* programs, ReadOnlySpan<byte> residences)
		{
			fixed (byte* presidences0 = residences)
			{
				byte ret = AreProgramsResidentNVNative(n, programs, presidences0);
				return ret != 0;
			}
		}

		public static bool AreProgramsResidentNV(int n, uint* programs, ref byte residences)
		{
			fixed (byte* presidences0 = &residences)
			{
				byte ret = AreProgramsResidentNVNative(n, programs, presidences0);
				return ret != 0;
			}
		}

		public static bool AreProgramsResidentNV(int n, ref uint programs, ref byte residences)
		{
			fixed (uint* pprograms0 = &programs)
			{
				fixed (byte* presidences1 = &residences)
				{
					byte ret = AreProgramsResidentNVNative(n, pprograms0, presidences1);
					return ret != 0;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint AsyncCopyBufferSubDataNVXNative(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint*, ulong*, uint, uint, uint, uint, nint, nint, nint, int, uint*, ulong*, uint>)funcTable[3])(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, nint, nint, uint, uint, uint, uint, nint, nint, nint, int, nint, nint, uint>)funcTable[3])(waitSemaphoreCount, (nint)waitSemaphoreArray, (nint)fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, (nint)signalSemaphoreArray, (nint)signalValueArray);
			#endif
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
			return ret;
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
				return ret;
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (ulong* pfenceValueArray0 = &fenceValueArray)
			{
				uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pfenceValueArray0, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
				return ret;
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pfenceValueArray1 = &fenceValueArray)
				{
					uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pfenceValueArray1, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
					return ret;
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* psignalSemaphoreArray0 = &signalSemaphoreArray)
			{
				uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray0, signalValueArray);
				return ret;
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray1, signalValueArray);
					return ret;
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (ulong* pfenceValueArray0 = &fenceValueArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pfenceValueArray0, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray1, signalValueArray);
					return ret;
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pfenceValueArray1 = &fenceValueArray)
				{
					fixed (uint* psignalSemaphoreArray2 = &signalSemaphoreArray)
					{
						uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pfenceValueArray1, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray2, signalValueArray);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (ulong* psignalValueArray0 = &signalValueArray)
			{
				uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray0);
				return ret;
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* psignalValueArray1 = &signalValueArray)
				{
					uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray1);
					return ret;
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (ulong* pfenceValueArray0 = &fenceValueArray)
			{
				fixed (ulong* psignalValueArray1 = &signalValueArray)
				{
					uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pfenceValueArray0, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray1);
					return ret;
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pfenceValueArray1 = &fenceValueArray)
				{
					fixed (ulong* psignalValueArray2 = &signalValueArray)
					{
						uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pfenceValueArray1, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray2);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* psignalSemaphoreArray0 = &signalSemaphoreArray)
			{
				fixed (ulong* psignalValueArray1 = &signalValueArray)
				{
					uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray0, psignalValueArray1);
					return ret;
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					fixed (ulong* psignalValueArray2 = &signalValueArray)
					{
						uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, fenceValueArray, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray1, psignalValueArray2);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (ulong* pfenceValueArray0 = &fenceValueArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					fixed (ulong* psignalValueArray2 = &signalValueArray)
					{
						uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pfenceValueArray0, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray1, psignalValueArray2);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyBufferSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong fenceValueArray, uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pfenceValueArray1 = &fenceValueArray)
				{
					fixed (uint* psignalSemaphoreArray2 = &signalSemaphoreArray)
					{
						fixed (ulong* psignalValueArray3 = &signalValueArray)
						{
							uint ret = AsyncCopyBufferSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pfenceValueArray1, readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size, signalSemaphoreCount, psignalSemaphoreArray2, psignalValueArray3);
							return ret;
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint AsyncCopyImageSubDataNVXNative(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint*, ulong*, uint, uint, uint, GLEnum, int, int, int, int, uint, GLEnum, int, int, int, int, int, int, int, int, uint*, ulong*, uint>)funcTable[4])(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, nint, nint, uint, uint, uint, GLEnum, int, int, int, int, uint, GLEnum, int, int, int, int, int, int, int, int, nint, nint, uint>)funcTable[4])(waitSemaphoreCount, (nint)waitSemaphoreArray, (nint)waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, (nint)signalSemaphoreArray, (nint)signalValueArray);
			#endif
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
			return ret;
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
				return ret;
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (ulong* pwaitValueArray0 = &waitValueArray)
			{
				uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pwaitValueArray0, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
				return ret;
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pwaitValueArray1 = &waitValueArray)
				{
					uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pwaitValueArray1, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, signalValueArray);
					return ret;
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* psignalSemaphoreArray0 = &signalSemaphoreArray)
			{
				uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray0, signalValueArray);
				return ret;
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray1, signalValueArray);
					return ret;
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (ulong* pwaitValueArray0 = &waitValueArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pwaitValueArray0, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray1, signalValueArray);
					return ret;
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ulong* signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pwaitValueArray1 = &waitValueArray)
				{
					fixed (uint* psignalSemaphoreArray2 = &signalSemaphoreArray)
					{
						uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pwaitValueArray1, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray2, signalValueArray);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (ulong* psignalValueArray0 = &signalValueArray)
			{
				uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray0);
				return ret;
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* psignalValueArray1 = &signalValueArray)
				{
					uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray1);
					return ret;
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (ulong* pwaitValueArray0 = &waitValueArray)
			{
				fixed (ulong* psignalValueArray1 = &signalValueArray)
				{
					uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pwaitValueArray0, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray1);
					return ret;
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, uint* signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pwaitValueArray1 = &waitValueArray)
				{
					fixed (ulong* psignalValueArray2 = &signalValueArray)
					{
						uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pwaitValueArray1, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, signalSemaphoreArray, psignalValueArray2);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* psignalSemaphoreArray0 = &signalSemaphoreArray)
			{
				fixed (ulong* psignalValueArray1 = &signalValueArray)
				{
					uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray0, psignalValueArray1);
					return ret;
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ulong* waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					fixed (ulong* psignalValueArray2 = &signalValueArray)
					{
						uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, waitValueArray, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray1, psignalValueArray2);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, uint* waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (ulong* pwaitValueArray0 = &waitValueArray)
			{
				fixed (uint* psignalSemaphoreArray1 = &signalSemaphoreArray)
				{
					fixed (ulong* psignalValueArray2 = &signalValueArray)
					{
						uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, waitSemaphoreArray, pwaitValueArray0, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray1, psignalValueArray2);
						return ret;
					}
				}
			}
		}

		public static uint AsyncCopyImageSubDataNVX(int waitSemaphoreCount, ref uint waitSemaphoreArray, ref ulong waitValueArray, uint srcGpu, uint dstGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth, int signalSemaphoreCount, ref uint signalSemaphoreArray, ref ulong signalValueArray)
		{
			fixed (uint* pwaitSemaphoreArray0 = &waitSemaphoreArray)
			{
				fixed (ulong* pwaitValueArray1 = &waitValueArray)
				{
					fixed (uint* psignalSemaphoreArray2 = &signalSemaphoreArray)
					{
						fixed (ulong* psignalValueArray3 = &signalValueArray)
						{
							uint ret = AsyncCopyImageSubDataNVXNative(waitSemaphoreCount, pwaitSemaphoreArray0, pwaitValueArray1, srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth, signalSemaphoreCount, psignalSemaphoreArray2, psignalValueArray3);
							return ret;
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginConditionalRenderNVNative(uint id, GLConditionalRenderMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#endif
		}

		public static void BeginConditionalRenderNV(uint id, GLConditionalRenderMode mode)
		{
			BeginConditionalRenderNVNative(id, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginConditionalRenderNVXNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[6])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[6])(id);
			#endif
		}

		public static void BeginConditionalRenderNVX(uint id)
		{
			BeginConditionalRenderNVXNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginOcclusionQueryNVNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[7])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[7])(id);
			#endif
		}

		public static void BeginOcclusionQueryNV(uint id)
		{
			BeginOcclusionQueryNVNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginTransformFeedbackNVNative(GLPrimitiveType primitiveMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#endif
		}

		public static void BeginTransformFeedbackNV(GLPrimitiveType primitiveMode)
		{
			BeginTransformFeedbackNVNative(primitiveMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginVideoCaptureNVNative(uint videoCaptureSlot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[9])(videoCaptureSlot);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[9])(videoCaptureSlot);
			#endif
		}

		public static void BeginVideoCaptureNV(uint videoCaptureSlot)
		{
			BeginVideoCaptureNVNative(videoCaptureSlot);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferBaseNVNative(GLBufferTargetARB target, uint index, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[10])(target, index, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[10])(target, index, buffer);
			#endif
		}

		public static void BindBufferBaseNV(GLBufferTargetARB target, uint index, uint buffer)
		{
			BindBufferBaseNVNative(target, index, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferOffsetNVNative(GLBufferTargetARB target, uint index, uint buffer, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, void>)funcTable[11])(target, index, buffer, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, void>)funcTable[11])(target, index, buffer, offset);
			#endif
		}

		public static void BindBufferOffsetNV(GLBufferTargetARB target, uint index, uint buffer, nint offset)
		{
			BindBufferOffsetNVNative(target, index, buffer, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferRangeNVNative(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#endif
		}

		public static void BindBufferRangeNV(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			BindBufferRangeNVNative(target, index, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindProgramNVNative(GLVertexAttribEnumNV target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, void>)funcTable[13])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, void>)funcTable[13])(target, id);
			#endif
		}

		public static void BindProgramNV(GLVertexAttribEnumNV target, uint id)
		{
			BindProgramNVNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindShadingRateImageNVNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[14])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[14])(texture);
			#endif
		}

		public static void BindShadingRateImageNV(uint texture)
		{
			BindShadingRateImageNVNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTransformFeedbackNVNative(GLBufferTargetARB target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[15])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[15])(target, id);
			#endif
		}

		public static void BindTransformFeedbackNV(GLBufferTargetARB target, uint id)
		{
			BindTransformFeedbackNVNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVideoCaptureStreamBufferNVNative(uint videoCaptureSlot, uint stream, GLEnum frameRegion, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[16])(videoCaptureSlot, stream, frameRegion, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[16])(videoCaptureSlot, stream, frameRegion, offset);
			#endif
		}

		public static void BindVideoCaptureStreamBufferNV(uint videoCaptureSlot, uint stream, GLEnum frameRegion, nint offset)
		{
			BindVideoCaptureStreamBufferNVNative(videoCaptureSlot, stream, frameRegion, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVideoCaptureStreamTextureNVNative(uint videoCaptureSlot, uint stream, GLEnum frameRegion, GLEnum target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, GLEnum, uint, void>)funcTable[17])(videoCaptureSlot, stream, frameRegion, target, texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, GLEnum, uint, void>)funcTable[17])(videoCaptureSlot, stream, frameRegion, target, texture);
			#endif
		}

		public static void BindVideoCaptureStreamTextureNV(uint videoCaptureSlot, uint stream, GLEnum frameRegion, GLEnum target, uint texture)
		{
			BindVideoCaptureStreamTextureNVNative(videoCaptureSlot, stream, frameRegion, target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendBarrierNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[18])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[18])();
			#endif
		}

		public static void BlendBarrierNV()
		{
			BlendBarrierNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendParameteriNVNative(GLEnum pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[19])(pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[19])(pname, value);
			#endif
		}

		public static void BlendParameteriNV(GLEnum pname, int value)
		{
			BlendParameteriNVNative(pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferAddressRangeNVNative(GLEnum pname, uint index, ulong address, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, ulong, nint, void>)funcTable[20])(pname, index, address, length);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, ulong, nint, void>)funcTable[20])(pname, index, address, length);
			#endif
		}

		public static void BufferAddressRangeNV(GLEnum pname, uint index, ulong address, nint length)
		{
			BufferAddressRangeNVNative(pname, index, address, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferAttachMemoryNVNative(GLBufferTargetARB target, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, ulong, void>)funcTable[21])(target, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, ulong, void>)funcTable[21])(target, memory, offset);
			#endif
		}

		public static void BufferAttachMemoryNV(GLBufferTargetARB target, uint memory, ulong offset)
		{
			BufferAttachMemoryNVNative(target, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferPageCommitmentMemNVNative(GLBufferStorageTarget target, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, uint, ulong, byte, void>)funcTable[22])(target, offset, size, memory, memOffset, commit);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, uint, ulong, byte, void>)funcTable[22])(target, offset, size, memory, memOffset, commit);
			#endif
		}

		public static void BufferPageCommitmentMemNV(GLBufferStorageTarget target, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			BufferPageCommitmentMemNVNative(target, offset, size, memory, memOffset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CallCommandListNVNative(uint list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[23])(list);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[23])(list);
			#endif
		}

		public static void CallCommandListNV(uint list)
		{
			CallCommandListNVNative(list);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthdNVNative(double depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[24])(depth);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[24])(depth);
			#endif
		}

		public static void ClearDepthdNV(double depth)
		{
			ClearDepthdNVNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientWaitSemaphoreui64NVXNative(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, ulong*, void>)funcTable[25])(fenceObjectCount, semaphoreArray, fenceValueArray);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, nint, void>)funcTable[25])(fenceObjectCount, (nint)semaphoreArray, (nint)fenceValueArray);
			#endif
		}

		public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint* semaphoreArray, ulong* fenceValueArray)
		{
			ClientWaitSemaphoreui64NVXNative(fenceObjectCount, semaphoreArray, fenceValueArray);
		}

		public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, ref uint semaphoreArray, ulong* fenceValueArray)
		{
			fixed (uint* psemaphoreArray0 = &semaphoreArray)
			{
				ClientWaitSemaphoreui64NVXNative(fenceObjectCount, psemaphoreArray0, fenceValueArray);
			}
		}

		public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, uint* semaphoreArray, ref ulong fenceValueArray)
		{
			fixed (ulong* pfenceValueArray0 = &fenceValueArray)
			{
				ClientWaitSemaphoreui64NVXNative(fenceObjectCount, semaphoreArray, pfenceValueArray0);
			}
		}

		public static void ClientWaitSemaphoreui64NVX(int fenceObjectCount, ref uint semaphoreArray, ref ulong fenceValueArray)
		{
			fixed (uint* psemaphoreArray0 = &semaphoreArray)
			{
				fixed (ulong* pfenceValueArray1 = &fenceValueArray)
				{
					ClientWaitSemaphoreui64NVXNative(fenceObjectCount, psemaphoreArray0, pfenceValueArray1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3hNVNative(Half red, Half green, Half blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[26])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<Half, Half, Half, void>)funcTable[26])(red, green, blue);
			#endif
		}

		public static void Color3hNV(Half red, Half green, Half blue)
		{
			Color3hNVNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[27])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[27])((nint)v);
			#endif
		}

		public static void Color3hvNV(Half* v)
		{
			Color3hvNVNative(v);
		}

		public static void Color3hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				Color3hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4hNVNative(Half red, Half green, Half blue, Half alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, Half, Half, Half, void>)funcTable[28])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<Half, Half, Half, Half, void>)funcTable[28])(red, green, blue, alpha);
			#endif
		}

		public static void Color4hNV(Half red, Half green, Half blue, Half alpha)
		{
			Color4hNVNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4hvNVNative(Half* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[29])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[29])((nint)v);
			#endif
		}

		public static void Color4hvNV(Half* v)
		{
			Color4hvNVNative(v);
		}

		public static void Color4hvNV(ref Half v)
		{
			fixed (Half* pv0 = &v)
			{
				Color4hvNVNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorFormatNVNative(int size, GLColorPointerType type, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void>)funcTable[30])(size, type, stride);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void>)funcTable[30])(size, type, stride);
			#endif
		}

		public static void ColorFormatNV(int size, GLColorPointerType type, int stride)
		{
			ColorFormatNVNative(size, type, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombinerInputNVNative(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerRegisterNV input, GLCombinerMappingNV mapping, GLCombinerComponentUsageNV componentUsage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerVariableNV, GLCombinerRegisterNV, GLCombinerMappingNV, GLCombinerComponentUsageNV, void>)funcTable[31])(stage, portion, variable, input, mapping, componentUsage);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerVariableNV, GLCombinerRegisterNV, GLCombinerMappingNV, GLCombinerComponentUsageNV, void>)funcTable[31])(stage, portion, variable, input, mapping, componentUsage);
			#endif
		}

		public static void CombinerInputNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerRegisterNV input, GLCombinerMappingNV mapping, GLCombinerComponentUsageNV componentUsage)
		{
			CombinerInputNVNative(stage, portion, variable, input, mapping, componentUsage);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombinerOutputNVNative(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerRegisterNV abOutput, GLCombinerRegisterNV cdOutput, GLCombinerRegisterNV sumOutput, GLCombinerScaleNV scale, GLCombinerBiasNV bias, byte abDotProduct, byte cdDotProduct, byte muxSum)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerRegisterNV, GLCombinerRegisterNV, GLCombinerRegisterNV, GLCombinerScaleNV, GLCombinerBiasNV, byte, byte, byte, void>)funcTable[32])(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerRegisterNV, GLCombinerRegisterNV, GLCombinerRegisterNV, GLCombinerScaleNV, GLCombinerBiasNV, byte, byte, byte, void>)funcTable[32])(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
			#endif
		}

		public static void CombinerOutputNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerRegisterNV abOutput, GLCombinerRegisterNV cdOutput, GLCombinerRegisterNV sumOutput, GLCombinerScaleNV scale, GLCombinerBiasNV bias, byte abDotProduct, byte cdDotProduct, byte muxSum)
		{
			CombinerOutputNVNative(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombinerParameterfNVNative(GLCombinerParameterNV pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, float, void>)funcTable[33])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, float, void>)funcTable[33])(pname, param);
			#endif
		}

		public static void CombinerParameterfNV(GLCombinerParameterNV pname, float param)
		{
			CombinerParameterfNVNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombinerParameterfvNVNative(GLCombinerParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, float*, void>)funcTable[34])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, nint, void>)funcTable[34])(pname, (nint)@params);
			#endif
		}

		public static void CombinerParameterfvNV(GLCombinerParameterNV pname, float* @params)
		{
			CombinerParameterfvNVNative(pname, @params);
		}

		public static void CombinerParameterfvNV(GLCombinerParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				CombinerParameterfvNVNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombinerParameteriNVNative(GLCombinerParameterNV pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, int, void>)funcTable[35])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, int, void>)funcTable[35])(pname, param);
			#endif
		}

		public static void CombinerParameteriNV(GLCombinerParameterNV pname, int param)
		{
			CombinerParameteriNVNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombinerParameterivNVNative(GLCombinerParameterNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, int*, void>)funcTable[36])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerParameterNV, nint, void>)funcTable[36])(pname, (nint)@params);
			#endif
		}

		public static void CombinerParameterivNV(GLCombinerParameterNV pname, int* @params)
		{
			CombinerParameterivNVNative(pname, @params);
		}

		public static void CombinerParameterivNV(GLCombinerParameterNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				CombinerParameterivNVNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CombinerStageParameterfvNVNative(GLCombinerStageNV stage, GLCombinerParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerParameterNV, float*, void>)funcTable[37])(stage, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerParameterNV, nint, void>)funcTable[37])(stage, pname, (nint)@params);
			#endif
		}

		public static void CombinerStageParameterfvNV(GLCombinerStageNV stage, GLCombinerParameterNV pname, float* @params)
		{
			CombinerStageParameterfvNVNative(stage, pname, @params);
		}

		public static void CombinerStageParameterfvNV(GLCombinerStageNV stage, GLCombinerParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				CombinerStageParameterfvNVNative(stage, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CommandListSegmentsNVNative(uint list, uint segments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[38])(list, segments);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[38])(list, segments);
			#endif
		}

		public static void CommandListSegmentsNV(uint list, uint segments)
		{
			CommandListSegmentsNVNative(list, segments);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileCommandListNVNative(uint list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[39])(list);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[39])(list);
			#endif
		}

		public static void CompileCommandListNV(uint list)
		{
			CompileCommandListNVNative(list);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConservativeRasterParameterfNVNative(GLEnum pname, float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float, void>)funcTable[40])(pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, float, void>)funcTable[40])(pname, value);
			#endif
		}

		public static void ConservativeRasterParameterfNV(GLEnum pname, float value)
		{
			ConservativeRasterParameterfNVNative(pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConservativeRasterParameteriNVNative(GLEnum pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[41])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[41])(pname, param);
			#endif
		}

		public static void ConservativeRasterParameteriNV(GLEnum pname, int param)
		{
			ConservativeRasterParameteriNVNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyImageSubDataNVNative(uint srcName, GLCopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLCopyBufferSubDataTarget, int, int, int, int, uint, GLCopyBufferSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[42])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLCopyBufferSubDataTarget, int, int, int, int, uint, GLCopyBufferSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[42])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
			#endif
		}

		public static void CopyImageSubDataNV(uint srcName, GLCopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)
		{
			CopyImageSubDataNVNative(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyPathNVNative(uint resultPath, uint srcPath)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[43])(resultPath, srcPath);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[43])(resultPath, srcPath);
			#endif
		}

		public static void CopyPathNV(uint resultPath, uint srcPath)
		{
			CopyPathNVNative(resultPath, srcPath);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[44])(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[44])(numPaths, pathNameType, (nint)paths, pathBase, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				CoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverFillPathNVNative(uint path, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[45])(path, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[45])(path, coverMode);
			#endif
		}

		public static void CoverFillPathNV(uint path, GLPathCoverMode coverMode)
		{
			CoverFillPathNVNative(path, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[46])(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[46])(numPaths, pathNameType, (nint)paths, pathBase, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				CoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverStrokePathNVNative(uint path, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[47])(path, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[47])(path, coverMode);
			#endif
		}

		public static void CoverStrokePathNV(uint path, GLPathCoverMode coverMode)
		{
			CoverStrokePathNVNative(path, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverageModulationNVNative(GLEnum components)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[48])(components);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[48])(components);
			#endif
		}

		public static void CoverageModulationNV(GLEnum components)
		{
			CoverageModulationNVNative(components);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverageModulationTableNVNative(int n, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float*, void>)funcTable[49])(n, v);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[49])(n, (nint)v);
			#endif
		}

		public static void CoverageModulationTableNV(int n, float* v)
		{
			CoverageModulationTableNVNative(n, v);
		}

		public static void CoverageModulationTableNV(int n, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				CoverageModulationTableNVNative(n, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateCommandListsNVNative(int n, uint* lists)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[50])(n, lists);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[50])(n, (nint)lists);
			#endif
		}

		public static void CreateCommandListsNV(int n, uint* lists)
		{
			CreateCommandListsNVNative(n, lists);
		}

		public static void CreateCommandListsNV(int n, ref uint lists)
		{
			fixed (uint* plists0 = &lists)
			{
				CreateCommandListsNVNative(n, plists0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateProgressFenceNVXNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[51])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[51])();
			#endif
		}

		public static uint CreateProgressFenceNVX()
		{
			uint ret = CreateProgressFenceNVXNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateSemaphoresNVNative(int n, uint* semaphores)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[52])(n, semaphores);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[52])(n, (nint)semaphores);
			#endif
		}

		public static void CreateSemaphoresNV(int n, uint* semaphores)
		{
			CreateSemaphoresNVNative(n, semaphores);
		}

		public static void CreateSemaphoresNV(int n, ref uint semaphores)
		{
			fixed (uint* psemaphores0 = &semaphores)
			{
				CreateSemaphoresNVNative(n, psemaphores0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateStatesNVNative(int n, uint* states)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[53])(n, states);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[53])(n, (nint)states);
			#endif
		}

		public static void CreateStatesNV(int n, uint* states)
		{
			CreateStatesNVNative(n, states);
		}

		public static void CreateStatesNV(int n, ref uint states)
		{
			fixed (uint* pstates0 = &states)
			{
				CreateStatesNVNative(n, pstates0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteCommandListsNVNative(int n, uint* lists)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[54])(n, lists);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[54])(n, (nint)lists);
			#endif
		}

		public static void DeleteCommandListsNV(int n, uint* lists)
		{
			DeleteCommandListsNVNative(n, lists);
		}

		public static void DeleteCommandListsNV(int n, ref uint lists)
		{
			fixed (uint* plists0 = &lists)
			{
				DeleteCommandListsNVNative(n, plists0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteFencesNVNative(int n, uint* fences)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[55])(n, fences);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[55])(n, (nint)fences);
			#endif
		}

		public static void DeleteFencesNV(int n, uint* fences)
		{
			DeleteFencesNVNative(n, fences);
		}

		public static void DeleteFencesNV(int n, ref uint fences)
		{
			fixed (uint* pfences0 = &fences)
			{
				DeleteFencesNVNative(n, pfences0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteOcclusionQueriesNVNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[56])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[56])(n, (nint)ids);
			#endif
		}

		public static void DeleteOcclusionQueriesNV(int n, uint* ids)
		{
			DeleteOcclusionQueriesNVNative(n, ids);
		}

		public static void DeleteOcclusionQueriesNV(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteOcclusionQueriesNVNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeletePathsNVNative(uint path, int range)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[57])(path, range);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[57])(path, range);
			#endif
		}

		public static void DeletePathsNV(uint path, int range)
		{
			DeletePathsNVNative(path, range);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramsNVNative(int n, uint* programs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[58])(n, programs);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[58])(n, (nint)programs);
			#endif
		}

		public static void DeleteProgramsNV(int n, uint* programs)
		{
			DeleteProgramsNVNative(n, programs);
		}

		public static void DeleteProgramsNV(int n, ref uint programs)
		{
			fixed (uint* pprograms0 = &programs)
			{
				DeleteProgramsNVNative(n, pprograms0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteQueryResourceTagNVNative(int n, int* tagIds)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int*, void>)funcTable[59])(n, tagIds);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[59])(n, (nint)tagIds);
			#endif
		}

		public static void DeleteQueryResourceTagNV(int n, int* tagIds)
		{
			DeleteQueryResourceTagNVNative(n, tagIds);
		}

		public static void DeleteQueryResourceTagNV(int n, ref int tagIds)
		{
			fixed (int* ptagIds0 = &tagIds)
			{
				DeleteQueryResourceTagNVNative(n, ptagIds0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteStatesNVNative(int n, uint* states)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[60])(n, states);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[60])(n, (nint)states);
			#endif
		}

		public static void DeleteStatesNV(int n, uint* states)
		{
			DeleteStatesNVNative(n, states);
		}

		public static void DeleteStatesNV(int n, ref uint states)
		{
			fixed (uint* pstates0 = &states)
			{
				DeleteStatesNVNative(n, pstates0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTransformFeedbacksNVNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[61])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[61])(n, (nint)ids);
			#endif
		}

		public static void DeleteTransformFeedbacksNV(int n, uint* ids)
		{
			DeleteTransformFeedbacksNVNative(n, ids);
		}

		public static void DeleteTransformFeedbacksNV(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteTransformFeedbacksNVNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthBoundsdNVNative(double zmin, double zmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[62])(zmin, zmax);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[62])(zmin, zmax);
			#endif
		}

		public static void DepthBoundsdNV(double zmin, double zmax)
		{
			DepthBoundsdNVNative(zmin, zmax);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangedNVNative(double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[63])(zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[63])(zNear, zFar);
			#endif
		}

		public static void DepthRangedNV(double zNear, double zFar)
		{
			DepthRangedNVNative(zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsAddressNVNative(GLEnum primitiveMode, ulong* indirects, int* sizes, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, ulong*, int*, uint, void>)funcTable[64])(primitiveMode, indirects, sizes, count);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, uint, void>)funcTable[64])(primitiveMode, (nint)indirects, (nint)sizes, count);
			#endif
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ulong* indirects, int* sizes, uint count)
		{
			DrawCommandsAddressNVNative(primitiveMode, indirects, sizes, count);
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ref ulong indirects, int* sizes, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				DrawCommandsAddressNVNative(primitiveMode, pindirects0, sizes, count);
			}
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ulong* indirects, ref int sizes, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsAddressNVNative(primitiveMode, indirects, psizes0, count);
			}
		}

		public static void DrawCommandsAddressNV(GLEnum primitiveMode, ref ulong indirects, ref int sizes, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsAddressNVNative(primitiveMode, pindirects0, psizes1, count);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsNVNative(GLEnum primitiveMode, uint buffer, nint* indirects, int* sizes, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint*, int*, uint, void>)funcTable[65])(primitiveMode, buffer, indirects, sizes, count);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, nint, uint, void>)funcTable[65])(primitiveMode, buffer, (nint)indirects, (nint)sizes, count);
			#endif
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, nint* indirects, int* sizes, uint count)
		{
			DrawCommandsNVNative(primitiveMode, buffer, indirects, sizes, count);
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, ref nint indirects, int* sizes, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				DrawCommandsNVNative(primitiveMode, buffer, pindirects0, sizes, count);
			}
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, nint* indirects, ref int sizes, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsNVNative(primitiveMode, buffer, indirects, psizes0, count);
			}
		}

		public static void DrawCommandsNV(GLEnum primitiveMode, uint buffer, ref nint indirects, ref int sizes, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsNVNative(primitiveMode, buffer, pindirects0, psizes1, count);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsStatesAddressNVNative(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong*, int*, uint*, uint*, uint, void>)funcTable[66])(indirects, sizes, states, fbos, count);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, nint, nint, uint, void>)funcTable[66])((nint)indirects, (nint)sizes, (nint)states, (nint)fbos, count);
			#endif
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			DrawCommandsStatesAddressNVNative(indirects, sizes, states, fbos, count);
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				DrawCommandsStatesAddressNVNative(pindirects0, sizes, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsStatesAddressNVNative(indirects, psizes0, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsStatesAddressNVNative(pindirects0, psizes1, states, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				DrawCommandsStatesAddressNVNative(indirects, sizes, pstates0, fbos, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesAddressNVNative(pindirects0, sizes, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesAddressNVNative(indirects, psizes0, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						DrawCommandsStatesAddressNVNative(pindirects0, psizes1, pstates2, fbos, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (uint* pfbos0 = &fbos)
			{
				DrawCommandsStatesAddressNVNative(indirects, sizes, states, pfbos0, count);
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesAddressNVNative(pindirects0, sizes, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesAddressNVNative(indirects, psizes0, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesAddressNVNative(pindirects0, psizes1, states, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesAddressNVNative(indirects, sizes, pstates0, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesAddressNVNative(pindirects0, sizes, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ulong* indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesAddressNVNative(indirects, psizes0, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesAddressNV(ref ulong indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (ulong* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						fixed (uint* pfbos3 = &fbos)
						{
							DrawCommandsStatesAddressNVNative(pindirects0, psizes1, pstates2, pfbos3, count);
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawCommandsStatesNVNative(uint buffer, nint* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint*, int*, uint*, uint*, uint, void>)funcTable[67])(buffer, indirects, sizes, states, fbos, count);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, nint, uint, void>)funcTable[67])(buffer, (nint)indirects, (nint)sizes, (nint)states, (nint)fbos, count);
			#endif
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			DrawCommandsStatesNVNative(buffer, indirects, sizes, states, fbos, count);
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, uint* states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				DrawCommandsStatesNVNative(buffer, pindirects0, sizes, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				DrawCommandsStatesNVNative(buffer, indirects, psizes0, states, fbos, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, uint* states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, states, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				DrawCommandsStatesNVNative(buffer, indirects, sizes, pstates0, fbos, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesNVNative(buffer, pindirects0, sizes, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					DrawCommandsStatesNVNative(buffer, indirects, psizes0, pstates1, fbos, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, ref uint states, uint* fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, pstates2, fbos, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (uint* pfbos0 = &fbos)
			{
				DrawCommandsStatesNVNative(buffer, indirects, sizes, states, pfbos0, count);
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesNVNative(buffer, pindirects0, sizes, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesNVNative(buffer, indirects, psizes0, states, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, uint* states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, states, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (uint* pstates0 = &states)
			{
				fixed (uint* pfbos1 = &fbos)
				{
					DrawCommandsStatesNVNative(buffer, indirects, sizes, pstates0, pfbos1, count);
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, int* sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesNVNative(buffer, pindirects0, sizes, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, nint* indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (int* psizes0 = &sizes)
			{
				fixed (uint* pstates1 = &states)
				{
					fixed (uint* pfbos2 = &fbos)
					{
						DrawCommandsStatesNVNative(buffer, indirects, psizes0, pstates1, pfbos2, count);
					}
				}
			}
		}

		public static void DrawCommandsStatesNV(uint buffer, ref nint indirects, ref int sizes, ref uint states, ref uint fbos, uint count)
		{
			fixed (nint* pindirects0 = &indirects)
			{
				fixed (int* psizes1 = &sizes)
				{
					fixed (uint* pstates2 = &states)
					{
						fixed (uint* pfbos3 = &fbos)
						{
							DrawCommandsStatesNVNative(buffer, pindirects0, psizes1, pstates2, pfbos3, count);
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawMeshTasksNVNative(uint first, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[68])(first, count);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[68])(first, count);
			#endif
		}

		public static void DrawMeshTasksNV(uint first, uint count)
		{
			DrawMeshTasksNVNative(first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawMeshTasksIndirectNVNative(nint indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[69])(indirect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[69])(indirect);
			#endif
		}

		public static void DrawMeshTasksIndirectNV(nint indirect)
		{
			DrawMeshTasksIndirectNVNative(indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTextureNVNative(uint texture, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, float, float, float, float, float, float, float, float, float, void>)funcTable[70])(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, float, float, float, float, float, float, float, float, float, void>)funcTable[70])(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
			#endif
		}

		public static void DrawTextureNV(uint texture, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1)
		{
			DrawTextureNVNative(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackNVNative(GLPrimitiveType mode, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[71])(mode, id);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[71])(mode, id);
			#endif
		}

		public static void DrawTransformFeedbackNV(GLPrimitiveType mode, uint id)
		{
			DrawTransformFeedbackNVNative(mode, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagFormatNVNative(int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[72])(stride);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[72])(stride);
			#endif
		}

		public static void EdgeFlagFormatNV(int stride)
		{
			EdgeFlagFormatNVNative(stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndConditionalRenderNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[73])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[73])();
			#endif
		}

		public static void EndConditionalRenderNV()
		{
			EndConditionalRenderNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndConditionalRenderNVXNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[74])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[74])();
			#endif
		}

		public static void EndConditionalRenderNVX()
		{
			EndConditionalRenderNVXNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndOcclusionQueryNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[75])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[75])();
			#endif
		}

		public static void EndOcclusionQueryNV()
		{
			EndOcclusionQueryNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndTransformFeedbackNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[76])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[76])();
			#endif
		}

		public static void EndTransformFeedbackNV()
		{
			EndTransformFeedbackNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndVideoCaptureNVNative(uint videoCaptureSlot)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[77])(videoCaptureSlot);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[77])(videoCaptureSlot);
			#endif
		}

		public static void EndVideoCaptureNV(uint videoCaptureSlot)
		{
			EndVideoCaptureNVNative(videoCaptureSlot);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalMapsNVNative(GLEvalTargetNV target, GLEvalMapsModeNV mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLEvalMapsModeNV, void>)funcTable[78])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLEvalMapsModeNV, void>)funcTable[78])(target, mode);
			#endif
		}

		public static void EvalMapsNV(GLEvalTargetNV target, GLEvalMapsModeNV mode)
		{
			EvalMapsNVNative(target, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ExecuteProgramNVNative(GLVertexAttribEnumNV target, uint id, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, float*, void>)funcTable[79])(target, id, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, nint, void>)funcTable[79])(target, id, (nint)@params);
			#endif
		}

		public static void ExecuteProgramNV(GLVertexAttribEnumNV target, uint id, float* @params)
		{
			ExecuteProgramNVNative(target, id, @params);
		}

		public static void ExecuteProgramNV(GLVertexAttribEnumNV target, uint id, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ExecuteProgramNVNative(target, id, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FinalCombinerInputNVNative(GLCombinerVariableNV variable, GLCombinerRegisterNV input, GLCombinerMappingNV mapping, GLCombinerComponentUsageNV componentUsage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerVariableNV, GLCombinerRegisterNV, GLCombinerMappingNV, GLCombinerComponentUsageNV, void>)funcTable[80])(variable, input, mapping, componentUsage);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerVariableNV, GLCombinerRegisterNV, GLCombinerMappingNV, GLCombinerComponentUsageNV, void>)funcTable[80])(variable, input, mapping, componentUsage);
			#endif
		}

		public static void FinalCombinerInputNV(GLCombinerVariableNV variable, GLCombinerRegisterNV input, GLCombinerMappingNV mapping, GLCombinerComponentUsageNV componentUsage)
		{
			FinalCombinerInputNVNative(variable, input, mapping, componentUsage);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FinishFenceNVNative(uint fence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[81])(fence);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[81])(fence);
			#endif
		}

		public static void FinishFenceNV(uint fence)
		{
			FinishFenceNVNative(fence);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushPixelDataRangeNVNative(GLPixelDataRangeTargetNV target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelDataRangeTargetNV, void>)funcTable[82])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelDataRangeTargetNV, void>)funcTable[82])(target);
			#endif
		}

		public static void FlushPixelDataRangeNV(GLPixelDataRangeTargetNV target)
		{
			FlushPixelDataRangeNVNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushVertexArrayRangeNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[83])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[83])();
			#endif
		}

		public static void FlushVertexArrayRangeNV()
		{
			FlushVertexArrayRangeNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordFormatNVNative(GLEnum type, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[84])(type, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[84])(type, stride);
			#endif
		}

		public static void FogCoordFormatNV(GLEnum type, int stride)
		{
			FogCoordFormatNVNative(type, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordhNVNative(Half fog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half, void>)funcTable[85])(fog);
			#else
			((delegate* unmanaged[Cdecl]<Half, void>)funcTable[85])(fog);
			#endif
		}

		public static void FogCoordhNV(Half fog)
		{
			FogCoordhNVNative(fog);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordhvNVNative(Half* fog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<Half*, void>)funcTable[86])(fog);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[86])((nint)fog);
			#endif
		}

		public static void FogCoordhvNV(Half* fog)
		{
			FogCoordhvNVNative(fog);
		}

		public static void FogCoordhvNV(ref Half fog)
		{
			fixed (Half* pfog0 = &fog)
			{
				FogCoordhvNVNative(pfog0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FragmentCoverageColorNVNative(uint color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[87])(color);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[87])(color);
			#endif
		}

		public static void FragmentCoverageColorNV(uint color)
		{
			FragmentCoverageColorNVNative(color);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferSampleLocationsfvNVNative(GLFramebufferTarget target, uint start, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, int, float*, void>)funcTable[88])(target, start, count, v);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, int, nint, void>)funcTable[88])(target, start, count, (nint)v);
			#endif
		}

		public static void FramebufferSampleLocationsfvNV(GLFramebufferTarget target, uint start, int count, float* v)
		{
			FramebufferSampleLocationsfvNVNative(target, start, count, v);
		}

		public static void FramebufferSampleLocationsfvNV(GLFramebufferTarget target, uint start, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				FramebufferSampleLocationsfvNVNative(target, start, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[89])(target, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[89])(target, attachment, texture, level);
			#endif
		}

		public static void FramebufferTextureEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			FramebufferTextureEXTNative(target, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureFaceEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[90])(target, attachment, texture, level, face);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[90])(target, attachment, texture, level, face);
			#endif
		}

		public static void FramebufferTextureFaceEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			FramebufferTextureFaceEXTNative(target, attachment, texture, level, face);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureLayerEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[91])(target, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[91])(target, attachment, texture, level, layer);
			#endif
		}

		public static void FramebufferTextureLayerEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			FramebufferTextureLayerEXTNative(target, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenFencesNVNative(int n, uint* fences)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[92])(n, fences);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[92])(n, (nint)fences);
			#endif
		}

		public static void GenFencesNV(int n, uint* fences)
		{
			GenFencesNVNative(n, fences);
		}

		public static void GenFencesNV(int n, ref uint fences)
		{
			fixed (uint* pfences0 = &fences)
			{
				GenFencesNVNative(n, pfences0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenOcclusionQueriesNVNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[93])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[93])(n, (nint)ids);
			#endif
		}

		public static void GenOcclusionQueriesNV(int n, uint* ids)
		{
			GenOcclusionQueriesNVNative(n, ids);
		}

		public static void GenOcclusionQueriesNV(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenOcclusionQueriesNVNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenPathsNVNative(int range)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[94])(range);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[94])(range);
			#endif
		}

		public static uint GenPathsNV(int range)
		{
			uint ret = GenPathsNVNative(range);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramsNVNative(int n, uint* programs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[95])(n, programs);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[95])(n, (nint)programs);
			#endif
		}

		public static void GenProgramsNV(int n, uint* programs)
		{
			GenProgramsNVNative(n, programs);
		}

		public static void GenProgramsNV(int n, ref uint programs)
		{
			fixed (uint* pprograms0 = &programs)
			{
				GenProgramsNVNative(n, pprograms0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenQueryResourceTagNVNative(int n, int* tagIds)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int*, void>)funcTable[96])(n, tagIds);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[96])(n, (nint)tagIds);
			#endif
		}

		public static void GenQueryResourceTagNV(int n, int* tagIds)
		{
			GenQueryResourceTagNVNative(n, tagIds);
		}

		public static void GenQueryResourceTagNV(int n, ref int tagIds)
		{
			fixed (int* ptagIds0 = &tagIds)
			{
				GenQueryResourceTagNVNative(n, ptagIds0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTransformFeedbacksNVNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[97])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[97])(n, (nint)ids);
			#endif
		}

		public static void GenTransformFeedbacksNV(int n, uint* ids)
		{
			GenTransformFeedbacksNVNative(n, ids);
		}

		public static void GenTransformFeedbacksNV(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenTransformFeedbacksNVNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveVaryingNVNative(uint program, uint index, int bufSize, int* length, int* size, GLEnum* type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLEnum*, byte*, void>)funcTable[98])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, nint, nint, void>)funcTable[98])(program, index, bufSize, (nint)length, (nint)size, (nint)type, (nint)name);
			#endif
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, GLEnum* type, byte* name)
		{
			GetActiveVaryingNVNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, int* size, GLEnum* type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveVaryingNVNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, ref int size, GLEnum* type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveVaryingNVNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, ref int size, GLEnum* type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveVaryingNVNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, ref GLEnum type, byte* name)
		{
			fixed (GLEnum* ptype0 = &type)
			{
				GetActiveVaryingNVNative(program, index, bufSize, length, size, ptype0, name);
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, int* size, ref GLEnum type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (GLEnum* ptype1 = &type)
				{
					GetActiveVaryingNVNative(program, index, bufSize, plength0, size, ptype1, name);
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, ref int size, ref GLEnum type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (GLEnum* ptype1 = &type)
				{
					GetActiveVaryingNVNative(program, index, bufSize, length, psize0, ptype1, name);
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, ref int size, ref GLEnum type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (GLEnum* ptype2 = &type)
					{
						GetActiveVaryingNVNative(program, index, bufSize, plength0, psize1, ptype2, name);
					}
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, GLEnum* type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveVaryingNVNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, GLEnum* type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveVaryingNVNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, GLEnum* type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveVaryingNVNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, int* size, GLEnum* type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveVaryingNVNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, ref int size, GLEnum* type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveVaryingNVNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, ref int size, GLEnum* type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveVaryingNVNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, ref GLEnum type, ref byte name)
		{
			fixed (GLEnum* ptype0 = &type)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveVaryingNVNative(program, index, bufSize, length, size, ptype0, pname1);
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, int* size, ref GLEnum type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (GLEnum* ptype1 = &type)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveVaryingNVNative(program, index, bufSize, plength0, size, ptype1, pname2);
					}
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, int* length, ref int size, ref GLEnum type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (GLEnum* ptype1 = &type)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveVaryingNVNative(program, index, bufSize, length, psize0, ptype1, pname2);
					}
				}
			}
		}

		public static void GetActiveVaryingNV(uint program, uint index, int bufSize, ref int length, ref int size, ref GLEnum type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (GLEnum* ptype2 = &type)
					{
						fixed (byte* pname3 = &name)
						{
							GetActiveVaryingNVNative(program, index, bufSize, plength0, psize1, ptype2, pname3);
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameterui64vNVNative(GLBufferTargetARB target, GLEnum pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLEnum, ulong*, void>)funcTable[99])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLEnum, nint, void>)funcTable[99])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameterui64vNV(GLBufferTargetARB target, GLEnum pname, ulong* @params)
		{
			GetBufferParameterui64vNVNative(target, pname, @params);
		}

		public static void GetBufferParameterui64vNV(GLBufferTargetARB target, GLEnum pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetBufferParameterui64vNVNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCombinerInputParameterfvNVNative(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerVariableNV, GLCombinerParameterNV, float*, void>)funcTable[100])(stage, portion, variable, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerVariableNV, GLCombinerParameterNV, nint, void>)funcTable[100])(stage, portion, variable, pname, (nint)@params);
			#endif
		}

		public static void GetCombinerInputParameterfvNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerParameterNV pname, float* @params)
		{
			GetCombinerInputParameterfvNVNative(stage, portion, variable, pname, @params);
		}

		public static void GetCombinerInputParameterfvNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetCombinerInputParameterfvNVNative(stage, portion, variable, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCombinerInputParameterivNVNative(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerParameterNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerVariableNV, GLCombinerParameterNV, int*, void>)funcTable[101])(stage, portion, variable, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerVariableNV, GLCombinerParameterNV, nint, void>)funcTable[101])(stage, portion, variable, pname, (nint)@params);
			#endif
		}

		public static void GetCombinerInputParameterivNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerParameterNV pname, int* @params)
		{
			GetCombinerInputParameterivNVNative(stage, portion, variable, pname, @params);
		}

		public static void GetCombinerInputParameterivNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerVariableNV variable, GLCombinerParameterNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetCombinerInputParameterivNVNative(stage, portion, variable, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCombinerOutputParameterfvNVNative(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerParameterNV, float*, void>)funcTable[102])(stage, portion, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerParameterNV, nint, void>)funcTable[102])(stage, portion, pname, (nint)@params);
			#endif
		}

		public static void GetCombinerOutputParameterfvNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerParameterNV pname, float* @params)
		{
			GetCombinerOutputParameterfvNVNative(stage, portion, pname, @params);
		}

		public static void GetCombinerOutputParameterfvNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetCombinerOutputParameterfvNVNative(stage, portion, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCombinerOutputParameterivNVNative(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerParameterNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerParameterNV, int*, void>)funcTable[103])(stage, portion, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerPortionNV, GLCombinerParameterNV, nint, void>)funcTable[103])(stage, portion, pname, (nint)@params);
			#endif
		}

		public static void GetCombinerOutputParameterivNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerParameterNV pname, int* @params)
		{
			GetCombinerOutputParameterivNVNative(stage, portion, pname, @params);
		}

		public static void GetCombinerOutputParameterivNV(GLCombinerStageNV stage, GLCombinerPortionNV portion, GLCombinerParameterNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetCombinerOutputParameterivNVNative(stage, portion, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCombinerStageParameterfvNVNative(GLCombinerStageNV stage, GLCombinerParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerParameterNV, float*, void>)funcTable[104])(stage, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerStageNV, GLCombinerParameterNV, nint, void>)funcTable[104])(stage, pname, (nint)@params);
			#endif
		}

		public static void GetCombinerStageParameterfvNV(GLCombinerStageNV stage, GLCombinerParameterNV pname, float* @params)
		{
			GetCombinerStageParameterfvNVNative(stage, pname, @params);
		}

		public static void GetCombinerStageParameterfvNV(GLCombinerStageNV stage, GLCombinerParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetCombinerStageParameterfvNVNative(stage, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetCommandHeaderNVNative(GLCommandOpcodesNV tokenID, uint size)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLCommandOpcodesNV, uint, uint>)funcTable[105])(tokenID, size);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLCommandOpcodesNV, uint, uint>)funcTable[105])(tokenID, size);
			#endif
		}

		public static uint GetCommandHeaderNV(GLCommandOpcodesNV tokenID, uint size)
		{
			uint ret = GetCommandHeaderNVNative(tokenID, size);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCoverageModulationTableNVNative(int bufSize, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float*, void>)funcTable[106])(bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[106])(bufSize, (nint)v);
			#endif
		}

		public static void GetCoverageModulationTableNV(int bufSize, float* v)
		{
			GetCoverageModulationTableNVNative(bufSize, v);
		}

		public static void GetCoverageModulationTableNV(int bufSize, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetCoverageModulationTableNVNative(bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFenceivNVNative(uint fence, GLFenceParameterNameNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFenceParameterNameNV, int*, void>)funcTable[107])(fence, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFenceParameterNameNV, nint, void>)funcTable[107])(fence, pname, (nint)@params);
			#endif
		}

		public static void GetFenceivNV(uint fence, GLFenceParameterNameNV pname, int* @params)
		{
			GetFenceivNVNative(fence, pname, @params);
		}

		public static void GetFenceivNV(uint fence, GLFenceParameterNameNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFenceivNVNative(fence, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFinalCombinerInputParameterfvNVNative(GLCombinerVariableNV variable, GLCombinerParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerVariableNV, GLCombinerParameterNV, float*, void>)funcTable[108])(variable, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerVariableNV, GLCombinerParameterNV, nint, void>)funcTable[108])(variable, pname, (nint)@params);
			#endif
		}

		public static void GetFinalCombinerInputParameterfvNV(GLCombinerVariableNV variable, GLCombinerParameterNV pname, float* @params)
		{
			GetFinalCombinerInputParameterfvNVNative(variable, pname, @params);
		}

		public static void GetFinalCombinerInputParameterfvNV(GLCombinerVariableNV variable, GLCombinerParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetFinalCombinerInputParameterfvNVNative(variable, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFinalCombinerInputParameterivNVNative(GLCombinerVariableNV variable, GLCombinerParameterNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCombinerVariableNV, GLCombinerParameterNV, int*, void>)funcTable[109])(variable, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCombinerVariableNV, GLCombinerParameterNV, nint, void>)funcTable[109])(variable, pname, (nint)@params);
			#endif
		}

		public static void GetFinalCombinerInputParameterivNV(GLCombinerVariableNV variable, GLCombinerParameterNV pname, int* @params)
		{
			GetFinalCombinerInputParameterivNVNative(variable, pname, @params);
		}

		public static void GetFinalCombinerInputParameterivNV(GLCombinerVariableNV variable, GLCombinerParameterNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFinalCombinerInputParameterivNVNative(variable, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetImageHandleNVNative(uint texture, int level, byte layered, int layer, GLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, byte, int, GLPixelFormat, ulong>)funcTable[110])(texture, level, layered, layer, format);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, int, byte, int, GLPixelFormat, ulong>)funcTable[110])(texture, level, layered, layer, format);
			#endif
		}

		public static ulong GetImageHandleNV(uint texture, int level, byte layered, int layer, GLPixelFormat format)
		{
			ulong ret = GetImageHandleNVNative(texture, level, layered, layer, format);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegerui64i_vNVNative(GLEnum value, uint index, ulong* result)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, ulong*, void>)funcTable[111])(value, index, result);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[111])(value, index, (nint)result);
			#endif
		}

		public static void GetIntegerui64i_vNV(GLEnum value, uint index, ulong* result)
		{
			GetIntegerui64i_vNVNative(value, index, result);
		}

		public static void GetIntegerui64i_vNV(GLEnum value, uint index, ref ulong result)
		{
			fixed (ulong* presult0 = &result)
			{
				GetIntegerui64i_vNVNative(value, index, presult0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegerui64vNVNative(GLEnum value, ulong* result)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, ulong*, void>)funcTable[112])(value, result);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[112])(value, (nint)result);
			#endif
		}

		public static void GetIntegerui64vNV(GLEnum value, ulong* result)
		{
			GetIntegerui64vNVNative(value, result);
		}

		public static void GetIntegerui64vNV(GLEnum value, ref ulong result)
		{
			fixed (ulong* presult0 = &result)
			{
				GetIntegerui64vNVNative(value, presult0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformatSampleivNVNative(GLTextureTarget target, GLInternalFormat internalformat, int samples, GLInternalFormatPName pname, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, int, GLInternalFormatPName, int, int*, void>)funcTable[113])(target, internalformat, samples, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, int, GLInternalFormatPName, int, nint, void>)funcTable[113])(target, internalformat, samples, pname, count, (nint)@params);
			#endif
		}

		public static void GetInternalformatSampleivNV(GLTextureTarget target, GLInternalFormat internalformat, int samples, GLInternalFormatPName pname, int count, int* @params)
		{
			GetInternalformatSampleivNVNative(target, internalformat, samples, pname, count, @params);
		}

		public static void GetInternalformatSampleivNV(GLTextureTarget target, GLInternalFormat internalformat, int samples, GLInternalFormatPName pname, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetInternalformatSampleivNVNative(target, internalformat, samples, pname, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapAttribParameterfvNVNative(GLEvalTargetNV target, uint index, GLMapAttribParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapAttribParameterNV, float*, void>)funcTable[114])(target, index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapAttribParameterNV, nint, void>)funcTable[114])(target, index, pname, (nint)@params);
			#endif
		}

		public static void GetMapAttribParameterfvNV(GLEvalTargetNV target, uint index, GLMapAttribParameterNV pname, float* @params)
		{
			GetMapAttribParameterfvNVNative(target, index, pname, @params);
		}

		public static void GetMapAttribParameterfvNV(GLEvalTargetNV target, uint index, GLMapAttribParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMapAttribParameterfvNVNative(target, index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapAttribParameterivNVNative(GLEvalTargetNV target, uint index, GLMapAttribParameterNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapAttribParameterNV, int*, void>)funcTable[115])(target, index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapAttribParameterNV, nint, void>)funcTable[115])(target, index, pname, (nint)@params);
			#endif
		}

		public static void GetMapAttribParameterivNV(GLEvalTargetNV target, uint index, GLMapAttribParameterNV pname, int* @params)
		{
			GetMapAttribParameterivNVNative(target, index, pname, @params);
		}

		public static void GetMapAttribParameterivNV(GLEvalTargetNV target, uint index, GLMapAttribParameterNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMapAttribParameterivNVNative(target, index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapControlPointsNVNative(GLEvalTargetNV target, uint index, GLMapTypeNV type, int ustride, int vstride, byte packed, void* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapTypeNV, int, int, byte, void*, void>)funcTable[116])(target, index, type, ustride, vstride, packed, points);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, uint, GLMapTypeNV, int, int, byte, nint, void>)funcTable[116])(target, index, type, ustride, vstride, packed, (nint)points);
			#endif
		}

		public static void GetMapControlPointsNV(GLEvalTargetNV target, uint index, GLMapTypeNV type, int ustride, int vstride, byte packed, void* points)
		{
			GetMapControlPointsNVNative(target, index, type, ustride, vstride, packed, points);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapParameterfvNVNative(GLEvalTargetNV target, GLMapParameterNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, float*, void>)funcTable[117])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, nint, void>)funcTable[117])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMapParameterfvNV(GLEvalTargetNV target, GLMapParameterNV pname, float* @params)
		{
			GetMapParameterfvNVNative(target, pname, @params);
		}

		public static void GetMapParameterfvNV(GLEvalTargetNV target, GLMapParameterNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMapParameterfvNVNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapParameterivNVNative(GLEvalTargetNV target, GLMapParameterNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, int*, void>)funcTable[118])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEvalTargetNV, GLMapParameterNV, nint, void>)funcTable[118])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMapParameterivNV(GLEvalTargetNV target, GLMapParameterNV pname, int* @params)
		{
			GetMapParameterivNVNative(target, pname, @params);
		}

		public static void GetMapParameterivNV(GLEvalTargetNV target, GLMapParameterNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMapParameterivNVNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMemoryObjectDetachedResourcesuivNVNative(uint memory, GLEnum pname, int first, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, int, uint*, void>)funcTable[119])(memory, pname, first, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, int, nint, void>)funcTable[119])(memory, pname, first, count, (nint)@params);
			#endif
		}

		public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, GLEnum pname, int first, int count, uint* @params)
		{
			GetMemoryObjectDetachedResourcesuivNVNative(memory, pname, first, count, @params);
		}

		public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, GLEnum pname, int first, int count, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetMemoryObjectDetachedResourcesuivNVNative(memory, pname, first, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultisamplefvNVNative(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, float*, void>)funcTable[120])(pname, index, val);
			#else
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, nint, void>)funcTable[120])(pname, index, (nint)val);
			#endif
		}

		public static void GetMultisamplefvNV(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			GetMultisamplefvNVNative(pname, index, val);
		}

		public static void GetMultisamplefvNV(GLGetMultisamplePNameNV pname, uint index, ref float val)
		{
			fixed (float* pval0 = &val)
			{
				GetMultisamplefvNVNative(pname, index, pval0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameterui64vNVNative(uint buffer, GLBufferPNameARB pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, ulong*, void>)funcTable[121])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[121])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferParameterui64vNV(uint buffer, GLBufferPNameARB pname, ulong* @params)
		{
			GetNamedBufferParameterui64vNVNative(buffer, pname, @params);
		}

		public static void GetNamedBufferParameterui64vNV(uint buffer, GLBufferPNameARB pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetNamedBufferParameterui64vNVNative(buffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetOcclusionQueryivNVNative(uint id, GLOcclusionQueryParameterNameNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLOcclusionQueryParameterNameNV, int*, void>)funcTable[122])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLOcclusionQueryParameterNameNV, nint, void>)funcTable[122])(id, pname, (nint)@params);
			#endif
		}

		public static void GetOcclusionQueryivNV(uint id, GLOcclusionQueryParameterNameNV pname, int* @params)
		{
			GetOcclusionQueryivNVNative(id, pname, @params);
		}

		public static void GetOcclusionQueryivNV(uint id, GLOcclusionQueryParameterNameNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetOcclusionQueryivNVNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetOcclusionQueryuivNVNative(uint id, GLOcclusionQueryParameterNameNV pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLOcclusionQueryParameterNameNV, uint*, void>)funcTable[123])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLOcclusionQueryParameterNameNV, nint, void>)funcTable[123])(id, pname, (nint)@params);
			#endif
		}

		public static void GetOcclusionQueryuivNV(uint id, GLOcclusionQueryParameterNameNV pname, uint* @params)
		{
			GetOcclusionQueryuivNVNative(id, pname, @params);
		}

		public static void GetOcclusionQueryuivNV(uint id, GLOcclusionQueryParameterNameNV pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetOcclusionQueryuivNVNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathColorGenfvNVNative(GLPathColor color, GLPathGenMode pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, float*, void>)funcTable[124])(color, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, nint, void>)funcTable[124])(color, pname, (nint)value);
			#endif
		}

		public static void GetPathColorGenfvNV(GLPathColor color, GLPathGenMode pname, float* value)
		{
			GetPathColorGenfvNVNative(color, pname, value);
		}

		public static void GetPathColorGenfvNV(GLPathColor color, GLPathGenMode pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathColorGenfvNVNative(color, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathColorGenivNVNative(GLPathColor color, GLPathGenMode pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int*, void>)funcTable[125])(color, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, nint, void>)funcTable[125])(color, pname, (nint)value);
			#endif
		}

		public static void GetPathColorGenivNV(GLPathColor color, GLPathGenMode pname, int* value)
		{
			GetPathColorGenivNVNative(color, pname, value);
		}

		public static void GetPathColorGenivNV(GLPathColor color, GLPathGenMode pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathColorGenivNVNative(color, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathCommandsNVNative(uint path, GLPathCoordType commands)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoordType, void>)funcTable[126])(path, commands);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoordType, void>)funcTable[126])(path, commands);
			#endif
		}

		public static void GetPathCommandsNV(uint path, GLPathCoordType commands)
		{
			GetPathCommandsNVNative(path, commands);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathCoordsNVNative(uint path, float* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[127])(path, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[127])(path, (nint)coords);
			#endif
		}

		public static void GetPathCoordsNV(uint path, float* coords)
		{
			GetPathCoordsNVNative(path, coords);
		}

		public static void GetPathCoordsNV(uint path, ref float coords)
		{
			fixed (float* pcoords0 = &coords)
			{
				GetPathCoordsNVNative(path, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathDashArrayNVNative(uint path, float* dashArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[128])(path, dashArray);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[128])(path, (nint)dashArray);
			#endif
		}

		public static void GetPathDashArrayNV(uint path, float* dashArray)
		{
			GetPathDashArrayNVNative(path, dashArray);
		}

		public static void GetPathDashArrayNV(uint path, ref float dashArray)
		{
			fixed (float* pdashArray0 = &dashArray)
			{
				GetPathDashArrayNVNative(path, pdashArray0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetPathLengthNVNative(uint path, int startSegment, int numSegments)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, float>)funcTable[129])(path, startSegment, numSegments);
			#else
			return (float)((delegate* unmanaged[Cdecl]<uint, int, int, float>)funcTable[129])(path, startSegment, numSegments);
			#endif
		}

		public static float GetPathLengthNV(uint path, int startSegment, int numSegments)
		{
			float ret = GetPathLengthNVNative(path, startSegment, numSegments);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathMetricRangeNVNative(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, uint, int, int, float*, void>)funcTable[130])(metricQueryMask, firstPathName, numPaths, stride, metrics);
			#else
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, uint, int, int, nint, void>)funcTable[130])(metricQueryMask, firstPathName, numPaths, stride, (nint)metrics);
			#endif
		}

		public static void GetPathMetricRangeNV(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics)
		{
			GetPathMetricRangeNVNative(metricQueryMask, firstPathName, numPaths, stride, metrics);
		}

		public static void GetPathMetricRangeNV(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, ref float metrics)
		{
			fixed (float* pmetrics0 = &metrics)
			{
				GetPathMetricRangeNVNative(metricQueryMask, firstPathName, numPaths, stride, pmetrics0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathMetricsNVNative(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, int, GLPathElementType, void*, uint, int, float*, void>)funcTable[131])(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
			#else
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, int, GLPathElementType, nint, uint, int, nint, void>)funcTable[131])(metricQueryMask, numPaths, pathNameType, (nint)paths, pathBase, stride, (nint)metrics);
			#endif
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics)
		{
			GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, ref float metrics)
		{
			fixed (float* pmetrics0 = &metrics)
			{
				GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, pmetrics0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathParameterfvNVNative(uint path, GLPathParameter pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float*, void>)funcTable[132])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[132])(path, pname, (nint)value);
			#endif
		}

		public static void GetPathParameterfvNV(uint path, GLPathParameter pname, float* value)
		{
			GetPathParameterfvNVNative(path, pname, value);
		}

		public static void GetPathParameterfvNV(uint path, GLPathParameter pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathParameterivNVNative(uint path, GLPathParameter pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int*, void>)funcTable[133])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[133])(path, pname, (nint)value);
			#endif
		}

		public static void GetPathParameterivNV(uint path, GLPathParameter pname, int* value)
		{
			GetPathParameterivNVNative(path, pname, value);
		}

		public static void GetPathParameterivNV(uint path, GLPathParameter pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathParameterivNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathSpacingNVNative(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathListMode, int, GLPathElementType, void*, uint, float, float, GLPathTransformType, float*, void>)funcTable[134])(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
			#else
			((delegate* unmanaged[Cdecl]<GLPathListMode, int, GLPathElementType, nint, uint, float, float, GLPathTransformType, nint, void>)funcTable[134])(pathListMode, numPaths, pathNameType, (nint)paths, pathBase, advanceScale, kerningScale, transformType, (nint)returnedSpacing);
			#endif
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing)
		{
			GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, ref float returnedSpacing)
		{
			fixed (float* preturnedSpacing0 = &returnedSpacing)
			{
				GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, preturnedSpacing0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathTexGenfvNVNative(GLTextureUnit texCoordSet, GLPathGenMode pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, float*, void>)funcTable[135])(texCoordSet, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, nint, void>)funcTable[135])(texCoordSet, pname, (nint)value);
			#endif
		}

		public static void GetPathTexGenfvNV(GLTextureUnit texCoordSet, GLPathGenMode pname, float* value)
		{
			GetPathTexGenfvNVNative(texCoordSet, pname, value);
		}

		public static void GetPathTexGenfvNV(GLTextureUnit texCoordSet, GLPathGenMode pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathTexGenfvNVNative(texCoordSet, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathTexGenivNVNative(GLTextureUnit texCoordSet, GLPathGenMode pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, int*, void>)funcTable[136])(texCoordSet, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, nint, void>)funcTable[136])(texCoordSet, pname, (nint)value);
			#endif
		}

		public static void GetPathTexGenivNV(GLTextureUnit texCoordSet, GLPathGenMode pname, int* value)
		{
			GetPathTexGenivNVNative(texCoordSet, pname, value);
		}

		public static void GetPathTexGenivNV(GLTextureUnit texCoordSet, GLPathGenMode pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathTexGenivNVNative(texCoordSet, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramEnvParameterIivNVNative(GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int*, void>)funcTable[137])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[137])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramEnvParameterIivNV(GLProgramTarget target, uint index, int* @params)
		{
			GetProgramEnvParameterIivNVNative(target, index, @params);
		}

		public static void GetProgramEnvParameterIivNV(GLProgramTarget target, uint index, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramEnvParameterIivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramEnvParameterIuivNVNative(GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint*, void>)funcTable[138])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[138])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramEnvParameterIuivNV(GLProgramTarget target, uint index, uint* @params)
		{
			GetProgramEnvParameterIuivNVNative(target, index, @params);
		}

		public static void GetProgramEnvParameterIuivNV(GLProgramTarget target, uint index, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetProgramEnvParameterIuivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramLocalParameterIivNVNative(GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, int*, void>)funcTable[139])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[139])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramLocalParameterIivNV(GLProgramTarget target, uint index, int* @params)
		{
			GetProgramLocalParameterIivNVNative(target, index, @params);
		}

		public static void GetProgramLocalParameterIivNV(GLProgramTarget target, uint index, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramLocalParameterIivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramLocalParameterIuivNVNative(GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, uint*, void>)funcTable[140])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[140])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramLocalParameterIuivNV(GLProgramTarget target, uint index, uint* @params)
		{
			GetProgramLocalParameterIuivNVNative(target, index, @params);
		}

		public static void GetProgramLocalParameterIuivNV(GLProgramTarget target, uint index, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetProgramLocalParameterIuivNVNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramNamedParameterdvNVNative(uint id, int len, byte* name, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte*, double*, void>)funcTable[141])(id, len, name, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[141])(id, len, (nint)name, (nint)@params);
			#endif
		}

		public static void GetProgramNamedParameterdvNV(uint id, int len, byte* name, double* @params)
		{
			GetProgramNamedParameterdvNVNative(id, len, name, @params);
		}

		public static void GetProgramNamedParameterdvNV(uint id, int len, string name, double* @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramNamedParameterdvNVNative(id, len, pStr0, @params);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramNamedParameterdvNV(uint id, int len, ReadOnlySpan<byte> name, double* @params)
		{
			fixed (byte* pname0 = name)
			{
				GetProgramNamedParameterdvNVNative(id, len, pname0, @params);
			}
		}

		public static void GetProgramNamedParameterdvNV(uint id, int len, ref byte name, double* @params)
		{
			fixed (byte* pname0 = &name)
			{
				GetProgramNamedParameterdvNVNative(id, len, pname0, @params);
			}
		}

		public static void GetProgramNamedParameterdvNV(uint id, int len, byte* name, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetProgramNamedParameterdvNVNative(id, len, name, pparams0);
			}
		}

		public static void GetProgramNamedParameterdvNV(uint id, int len, ref byte name, ref double @params)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (double* pparams1 = &@params)
				{
					GetProgramNamedParameterdvNVNative(id, len, pname0, pparams1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramNamedParameterfvNVNative(uint id, int len, byte* name, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte*, float*, void>)funcTable[142])(id, len, name, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[142])(id, len, (nint)name, (nint)@params);
			#endif
		}

		public static void GetProgramNamedParameterfvNV(uint id, int len, byte* name, float* @params)
		{
			GetProgramNamedParameterfvNVNative(id, len, name, @params);
		}

		public static void GetProgramNamedParameterfvNV(uint id, int len, string name, float* @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramNamedParameterfvNVNative(id, len, pStr0, @params);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramNamedParameterfvNV(uint id, int len, ReadOnlySpan<byte> name, float* @params)
		{
			fixed (byte* pname0 = name)
			{
				GetProgramNamedParameterfvNVNative(id, len, pname0, @params);
			}
		}

		public static void GetProgramNamedParameterfvNV(uint id, int len, ref byte name, float* @params)
		{
			fixed (byte* pname0 = &name)
			{
				GetProgramNamedParameterfvNVNative(id, len, pname0, @params);
			}
		}

		public static void GetProgramNamedParameterfvNV(uint id, int len, byte* name, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetProgramNamedParameterfvNVNative(id, len, name, pparams0);
			}
		}

		public static void GetProgramNamedParameterfvNV(uint id, int len, ref byte name, ref float @params)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (float* pparams1 = &@params)
				{
					GetProgramNamedParameterfvNVNative(id, len, pname0, pparams1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramParameterdvNVNative(GLVertexAttribEnumNV target, uint index, GLVertexAttribEnumNV pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, double*, void>)funcTable[143])(target, index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, nint, void>)funcTable[143])(target, index, pname, (nint)@params);
			#endif
		}

		public static void GetProgramParameterdvNV(GLVertexAttribEnumNV target, uint index, GLVertexAttribEnumNV pname, double* @params)
		{
			GetProgramParameterdvNVNative(target, index, pname, @params);
		}

		public static void GetProgramParameterdvNV(GLVertexAttribEnumNV target, uint index, GLVertexAttribEnumNV pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetProgramParameterdvNVNative(target, index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramParameterfvNVNative(GLVertexAttribEnumNV target, uint index, GLVertexAttribEnumNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, float*, void>)funcTable[144])(target, index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, nint, void>)funcTable[144])(target, index, pname, (nint)@params);
			#endif
		}

		public static void GetProgramParameterfvNV(GLVertexAttribEnumNV target, uint index, GLVertexAttribEnumNV pname, float* @params)
		{
			GetProgramParameterfvNVNative(target, index, pname, @params);
		}

		public static void GetProgramParameterfvNV(GLVertexAttribEnumNV target, uint index, GLVertexAttribEnumNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetProgramParameterfvNVNative(target, index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourcefvNVNative(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLEnum*, int, int*, float*, void>)funcTable[145])(program, programInterface, index, propCount, props, count, length, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, nint, int, nint, nint, void>)funcTable[145])(program, programInterface, index, propCount, (nint)props, count, (nint)length, (nint)@params);
			#endif
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, float* @params)
		{
			GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, length, @params);
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, int* length, float* @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, length, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, ref int length, float* @params)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, ref int length, float* @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				fixed (int* plength1 = &length)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, plength1, @params);
				}
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, length, pparams0);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, int* length, ref float @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				fixed (float* pparams1 = &@params)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, length, pparams1);
				}
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, ref int length, ref float @params)
		{
			fixed (int* plength0 = &length)
			{
				fixed (float* pparams1 = &@params)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, plength0, pparams1);
				}
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, ref int length, ref float @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				fixed (int* plength1 = &length)
				{
					fixed (float* pparams2 = &@params)
					{
						GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, plength1, pparams2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramStringNVNative(uint id, GLVertexAttribEnumNV pname, byte* program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, byte*, void>)funcTable[146])(id, pname, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, nint, void>)funcTable[146])(id, pname, (nint)program);
			#endif
		}

		public static void GetProgramStringNV(uint id, GLVertexAttribEnumNV pname, byte* program)
		{
			GetProgramStringNVNative(id, pname, program);
		}

		public static void GetProgramStringNV(uint id, GLVertexAttribEnumNV pname, string program)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (program != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(program);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(program, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramStringNVNative(id, pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramStringNV(uint id, GLVertexAttribEnumNV pname, ReadOnlySpan<byte> program)
		{
			fixed (byte* pprogram0 = program)
			{
				GetProgramStringNVNative(id, pname, pprogram0);
			}
		}

		public static void GetProgramStringNV(uint id, GLVertexAttribEnumNV pname, ref byte program)
		{
			fixed (byte* pprogram0 = &program)
			{
				GetProgramStringNVNative(id, pname, pprogram0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramSubroutineParameteruivNVNative(GLEnum target, uint index, uint* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, uint*, void>)funcTable[147])(target, index, param);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[147])(target, index, (nint)param);
			#endif
		}

		public static void GetProgramSubroutineParameteruivNV(GLEnum target, uint index, uint* param)
		{
			GetProgramSubroutineParameteruivNVNative(target, index, param);
		}

		public static void GetProgramSubroutineParameteruivNV(GLEnum target, uint index, ref uint param)
		{
			fixed (uint* pparam0 = &param)
			{
				GetProgramSubroutineParameteruivNVNative(target, index, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramivNVNative(uint id, GLVertexAttribEnumNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, int*, void>)funcTable[148])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, nint, void>)funcTable[148])(id, pname, (nint)@params);
			#endif
		}

		public static void GetProgramivNV(uint id, GLVertexAttribEnumNV pname, int* @params)
		{
			GetProgramivNVNative(id, pname, @params);
		}

		public static void GetProgramivNV(uint id, GLVertexAttribEnumNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramivNVNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSemaphoreParameterivNVNative(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, int*, void>)funcTable[149])(semaphore, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, nint, void>)funcTable[149])(semaphore, pname, (nint)@params);
			#endif
		}

		public static void GetSemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			GetSemaphoreParameterivNVNative(semaphore, pname, @params);
		}

		public static void GetSemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetSemaphoreParameterivNVNative(semaphore, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShadingRateImagePaletteNVNative(uint viewport, uint entry, GLEnum* rate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum*, void>)funcTable[150])(viewport, entry, rate);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[150])(viewport, entry, (nint)rate);
			#endif
		}

		public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, GLEnum* rate)
		{
			GetShadingRateImagePaletteNVNative(viewport, entry, rate);
		}

		public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, ref GLEnum rate)
		{
			fixed (GLEnum* prate0 = &rate)
			{
				GetShadingRateImagePaletteNVNative(viewport, entry, prate0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShadingRateSampleLocationivNVNative(GLEnum rate, uint samples, uint index, int* location)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, uint, int*, void>)funcTable[151])(rate, samples, index, location);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, uint, nint, void>)funcTable[151])(rate, samples, index, (nint)location);
			#endif
		}

		public static void GetShadingRateSampleLocationivNV(GLEnum rate, uint samples, uint index, int* location)
		{
			GetShadingRateSampleLocationivNVNative(rate, samples, index, location);
		}

		public static void GetShadingRateSampleLocationivNV(GLEnum rate, uint samples, uint index, ref int location)
		{
			fixed (int* plocation0 = &location)
			{
				GetShadingRateSampleLocationivNVNative(rate, samples, index, plocation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ushort GetStageIndexNVNative(GLShaderType shadertype)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, ushort>)funcTable[152])(shadertype);
			#else
			return (ushort)((delegate* unmanaged[Cdecl]<GLShaderType, ushort>)funcTable[152])(shadertype);
			#endif
		}

		public static ushort GetStageIndexNV(GLShaderType shadertype)
		{
			ushort ret = GetStageIndexNVNative(shadertype);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTextureHandleNVNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ulong>)funcTable[153])(texture);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, ulong>)funcTable[153])(texture);
			#endif
		}

		public static ulong GetTextureHandleNV(uint texture)
		{
			ulong ret = GetTextureHandleNVNative(texture);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTextureSamplerHandleNVNative(uint texture, uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, ulong>)funcTable[154])(texture, sampler);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, uint, ulong>)funcTable[154])(texture, sampler);
			#endif
		}

		public static ulong GetTextureSamplerHandleNV(uint texture, uint sampler)
		{
			ulong ret = GetTextureSamplerHandleNVNative(texture, sampler);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTrackMatrixivNVNative(GLVertexAttribEnumNV target, uint address, GLVertexAttribEnumNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, int*, void>)funcTable[155])(target, address, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexAttribEnumNV, uint, GLVertexAttribEnumNV, nint, void>)funcTable[155])(target, address, pname, (nint)@params);
			#endif
		}

		public static void GetTrackMatrixivNV(GLVertexAttribEnumNV target, uint address, GLVertexAttribEnumNV pname, int* @params)
		{
			GetTrackMatrixivNVNative(target, address, pname, @params);
		}

		public static void GetTrackMatrixivNV(GLVertexAttribEnumNV target, uint address, GLVertexAttribEnumNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTrackMatrixivNVNative(target, address, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackVaryingNVNative(uint program, uint index, int* location)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int*, void>)funcTable[156])(program, index, location);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[156])(program, index, (nint)location);
			#endif
		}

		public static void GetTransformFeedbackVaryingNV(uint program, uint index, int* location)
		{
			GetTransformFeedbackVaryingNVNative(program, index, location);
		}

		public static void GetTransformFeedbackVaryingNV(uint program, uint index, ref int location)
		{
			fixed (int* plocation0 = &location)
			{
				GetTransformFeedbackVaryingNVNative(program, index, plocation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformi64vNVNative(uint program, int location, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long*, void>)funcTable[157])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[157])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformi64vNV(uint program, int location, long* @params)
		{
			GetUniformi64vNVNative(program, location, @params);
		}

		public static void GetUniformi64vNV(uint program, int location, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetUniformi64vNVNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformui64vNVNative(uint program, int location, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong*, void>)funcTable[158])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[158])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformui64vNV(uint program, int location, ulong* @params)
		{
			GetUniformui64vNVNative(program, location, @params);
		}

		public static void GetUniformui64vNV(uint program, int location, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetUniformui64vNVNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetVaryingLocationNVNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[159])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[159])(program, (nint)name);
			#endif
		}

		public static int GetVaryingLocationNV(uint program, byte* name)
		{
			int ret = GetVaryingLocationNVNative(program, name);
			return ret;
		}

		public static int GetVaryingLocationNV(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetVaryingLocationNVNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetVaryingLocationNV(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetVaryingLocationNVNative(program, pname0);
				return ret;
			}
		}

		public static int GetVaryingLocationNV(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetVaryingLocationNVNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIivEXTNative(uint index, GLVertexAttribEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, int*, void>)funcTable[160])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[160])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIivEXT(uint index, GLVertexAttribEnum pname, int* @params)
		{
			GetVertexAttribIivEXTNative(index, pname, @params);
		}

		public static void GetVertexAttribIivEXT(uint index, GLVertexAttribEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVertexAttribIivEXTNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIuivEXTNative(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, uint*, void>)funcTable[161])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[161])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIuivEXT(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			GetVertexAttribIuivEXTNative(index, pname, @params);
		}

		public static void GetVertexAttribIuivEXT(uint index, GLVertexAttribEnum pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetVertexAttribIuivEXTNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribLi64vNVNative(uint index, GLVertexAttribEnum pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, long*, void>)funcTable[162])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[162])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribLi64vNV(uint index, GLVertexAttribEnum pname, long* @params)
		{
			GetVertexAttribLi64vNVNative(index, pname, @params);
		}

		public static void GetVertexAttribLi64vNV(uint index, GLVertexAttribEnum pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetVertexAttribLi64vNVNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribLui64vNVNative(uint index, GLVertexAttribEnum pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, ulong*, void>)funcTable[163])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[163])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribLui64vNV(uint index, GLVertexAttribEnum pname, ulong* @params)
		{
			GetVertexAttribLui64vNVNative(index, pname, @params);
		}

		public static void GetVertexAttribLui64vNV(uint index, GLVertexAttribEnum pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetVertexAttribLui64vNVNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervNVNative(uint index, GLVertexAttribEnumNV pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, void**, void>)funcTable[164])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, nint, void>)funcTable[164])(index, pname, (nint)pointer);
			#endif
		}

		public static void GetVertexAttribPointervNV(uint index, GLVertexAttribEnumNV pname, void** pointer)
		{
			GetVertexAttribPointervNVNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvNVNative(uint index, GLVertexAttribEnumNV pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, double*, void>)funcTable[165])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, nint, void>)funcTable[165])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribdvNV(uint index, GLVertexAttribEnumNV pname, double* @params)
		{
			GetVertexAttribdvNVNative(index, pname, @params);
		}

		public static void GetVertexAttribdvNV(uint index, GLVertexAttribEnumNV pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvNVNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvNVNative(uint index, GLVertexAttribEnumNV pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, float*, void>)funcTable[166])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, nint, void>)funcTable[166])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribfvNV(uint index, GLVertexAttribEnumNV pname, float* @params)
		{
			GetVertexAttribfvNVNative(index, pname, @params);
		}

		public static void GetVertexAttribfvNV(uint index, GLVertexAttribEnumNV pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetVertexAttribfvNVNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivNVNative(uint index, GLVertexAttribEnumNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, int*, void>)funcTable[167])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnumNV, nint, void>)funcTable[167])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribivNV(uint index, GLVertexAttribEnumNV pname, int* @params)
		{
			GetVertexAttribivNVNative(index, pname, @params);
		}

		public static void GetVertexAttribivNV(uint index, GLVertexAttribEnumNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVertexAttribivNVNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideoCaptureStreamdvNVNative(uint videoCaptureSlot, uint stream, GLEnum pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, double*, void>)funcTable[168])(videoCaptureSlot, stream, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[168])(videoCaptureSlot, stream, pname, (nint)@params);
			#endif
		}

		public static void GetVideoCaptureStreamdvNV(uint videoCaptureSlot, uint stream, GLEnum pname, double* @params)
		{
			GetVideoCaptureStreamdvNVNative(videoCaptureSlot, stream, pname, @params);
		}

		public static void GetVideoCaptureStreamdvNV(uint videoCaptureSlot, uint stream, GLEnum pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVideoCaptureStreamdvNVNative(videoCaptureSlot, stream, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideoCaptureStreamfvNVNative(uint videoCaptureSlot, uint stream, GLEnum pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, float*, void>)funcTable[169])(videoCaptureSlot, stream, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[169])(videoCaptureSlot, stream, pname, (nint)@params);
			#endif
		}

		public static void GetVideoCaptureStreamfvNV(uint videoCaptureSlot, uint stream, GLEnum pname, float* @params)
		{
			GetVideoCaptureStreamfvNVNative(videoCaptureSlot, stream, pname, @params);
		}

		public static void GetVideoCaptureStreamfvNV(uint videoCaptureSlot, uint stream, GLEnum pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetVideoCaptureStreamfvNVNative(videoCaptureSlot, stream, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideoCaptureStreamivNVNative(uint videoCaptureSlot, uint stream, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int*, void>)funcTable[170])(videoCaptureSlot, stream, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, nint, void>)funcTable[170])(videoCaptureSlot, stream, pname, (nint)@params);
			#endif
		}

		public static void GetVideoCaptureStreamivNV(uint videoCaptureSlot, uint stream, GLEnum pname, int* @params)
		{
			GetVideoCaptureStreamivNVNative(videoCaptureSlot, stream, pname, @params);
		}

		public static void GetVideoCaptureStreamivNV(uint videoCaptureSlot, uint stream, GLEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVideoCaptureStreamivNVNative(videoCaptureSlot, stream, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideoCaptureivNVNative(uint videoCaptureSlot, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int*, void>)funcTable[171])(videoCaptureSlot, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void>)funcTable[171])(videoCaptureSlot, pname, (nint)@params);
			#endif
		}

		public static void GetVideoCaptureivNV(uint videoCaptureSlot, GLEnum pname, int* @params)
		{
			GetVideoCaptureivNVNative(videoCaptureSlot, pname, @params);
		}

		public static void GetVideoCaptureivNV(uint videoCaptureSlot, GLEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVideoCaptureivNVNative(videoCaptureSlot, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideoi64vNVNative(uint videoSlot, GLEnum pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, long*, void>)funcTable[172])(videoSlot, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void>)funcTable[172])(videoSlot, pname, (nint)@params);
			#endif
		}

		public static void GetVideoi64vNV(uint videoSlot, GLEnum pname, long* @params)
		{
			GetVideoi64vNVNative(videoSlot, pname, @params);
		}

		public static void GetVideoi64vNV(uint videoSlot, GLEnum pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetVideoi64vNVNative(videoSlot, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideoivNVNative(uint videoSlot, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int*, void>)funcTable[173])(videoSlot, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void>)funcTable[173])(videoSlot, pname, (nint)@params);
			#endif
		}

		public static void GetVideoivNV(uint videoSlot, GLEnum pname, int* @params)
		{
			GetVideoivNVNative(videoSlot, pname, @params);
		}

		public static void GetVideoivNV(uint videoSlot, GLEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVideoivNVNative(videoSlot, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideoui64vNVNative(uint videoSlot, GLEnum pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, ulong*, void>)funcTable[174])(videoSlot, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void>)funcTable[174])(videoSlot, pname, (nint)@params);
			#endif
		}

		public static void GetVideoui64vNV(uint videoSlot, GLEnum pname, ulong* @params)
		{
			GetVideoui64vNVNative(videoSlot, pname, @params);
		}

		public static void GetVideoui64vNV(uint videoSlot, GLEnum pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetVideoui64vNVNative(videoSlot, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVideouivNVNative(uint videoSlot, GLEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, uint*, void>)funcTable[175])(videoSlot, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void>)funcTable[175])(videoSlot, pname, (nint)@params);
			#endif
		}

		public static void GetVideouivNV(uint videoSlot, GLEnum pname, uint* @params)
		{
			GetVideouivNVNative(videoSlot, pname, @params);
		}

		public static void GetVideouivNV(uint videoSlot, GLEnum pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetVideouivNVNative(videoSlot, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexFormatNVNative(GLEnum type, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[176])(type, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[176])(type, stride);
			#endif
		}

		public static void IndexFormatNV(GLEnum type, int stride)
		{
			IndexFormatNVNative(type, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InterpolatePathsNVNative(uint resultPath, uint pathA, uint pathB, float weight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, float, void>)funcTable[177])(resultPath, pathA, pathB, weight);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, float, void>)funcTable[177])(resultPath, pathA, pathB, weight);
			#endif
		}

		public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight)
		{
			InterpolatePathsNVNative(resultPath, pathA, pathB, weight);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBufferResidentNVNative(GLEnum target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum, byte>)funcTable[178])(target);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnum, byte>)funcTable[178])(target);
			#endif
		}

		public static bool IsBufferResidentNV(GLEnum target)
		{
			byte ret = IsBufferResidentNVNative(target);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsCommandListNVNative(uint list)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[179])(list);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[179])(list);
			#endif
		}

		public static bool IsCommandListNV(uint list)
		{
			byte ret = IsCommandListNVNative(list);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFenceNVNative(uint fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[180])(fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[180])(fence);
			#endif
		}

		public static bool IsFenceNV(uint fence)
		{
			byte ret = IsFenceNVNative(fence);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsImageHandleResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[181])(handle);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[181])(handle);
			#endif
		}

		public static bool IsImageHandleResidentNV(ulong handle)
		{
			byte ret = IsImageHandleResidentNVNative(handle);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsNamedBufferResidentNVNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[182])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[182])(buffer);
			#endif
		}

		public static bool IsNamedBufferResidentNV(uint buffer)
		{
			byte ret = IsNamedBufferResidentNVNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsOcclusionQueryNVNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[183])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[183])(id);
			#endif
		}

		public static bool IsOcclusionQueryNV(uint id)
		{
			byte ret = IsOcclusionQueryNVNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPathNVNative(uint path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[184])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[184])(path);
			#endif
		}

		public static bool IsPathNV(uint path)
		{
			byte ret = IsPathNVNative(path);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPointInFillPathNVNative(uint path, uint mask, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, float, float, byte>)funcTable[185])(path, mask, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, uint, float, float, byte>)funcTable[185])(path, mask, x, y);
			#endif
		}

		public static bool IsPointInFillPathNV(uint path, uint mask, float x, float y)
		{
			byte ret = IsPointInFillPathNVNative(path, mask, x, y);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPointInStrokePathNVNative(uint path, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, float, float, byte>)funcTable[186])(path, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, float, float, byte>)funcTable[186])(path, x, y);
			#endif
		}

		public static bool IsPointInStrokePathNV(uint path, float x, float y)
		{
			byte ret = IsPointInStrokePathNVNative(path, x, y);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramNVNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[187])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[187])(id);
			#endif
		}

		public static bool IsProgramNV(uint id)
		{
			byte ret = IsProgramNVNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsStateNVNative(uint state)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[188])(state);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[188])(state);
			#endif
		}

		public static bool IsStateNV(uint state)
		{
			byte ret = IsStateNVNative(state);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureHandleResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[189])(handle);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[189])(handle);
			#endif
		}

		public static bool IsTextureHandleResidentNV(ulong handle)
		{
			byte ret = IsTextureHandleResidentNVNative(handle);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTransformFeedbackNVNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[190])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[190])(id);
			#endif
		}

		public static bool IsTransformFeedbackNV(uint id)
		{
			byte ret = IsTransformFeedbackNVNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LGPUCopyImageSubDataNVXNative(uint sourceGpu, uint destinationGpuMask, uint srcName, GLEnum srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, GLEnum dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, GLEnum, int, int, int, int, uint, GLEnum, int, int, int, int, int, int, int, void>)funcTable[191])(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, GLEnum, int, int, int, int, uint, GLEnum, int, int, int, int, int, int, int, void>)funcTable[191])(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
			#endif
		}
	}
}
