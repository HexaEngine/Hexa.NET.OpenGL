// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleani_vNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[197])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[197])(target, index, (nint)data);
			#endif
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleani_vNative(target, index, data);
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleani_vNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, Span<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanvNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[198])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[198])(pname, (nint)data);
			#endif
		}

		public static void GetBooleanv(GLGetPName pname, byte* data)
		{
			GetBooleanvNative(pname, data);
		}

		public static void GetBooleanv(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanvNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, Span<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameteri64vNative(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, long*, void>)funcTable[199])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[199])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			GetBufferParameteri64vNative(target, pname, @params);
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, out long @params)
		{
			long pparams;
			GetBufferParameteri64vNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, Span<long> @params)
		{
			fixed (long* pparams = @params)
			{
				GetBufferParameteri64vNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameterivNative(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, int*, void>)funcTable[200])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[200])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			GetBufferParameterivNative(target, pname, @params);
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, out int @params)
		{
			int pparams;
			GetBufferParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetBufferParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferPointervNative(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, void**, void>)funcTable[201])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, nint, void>)funcTable[201])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferPointerv(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			GetBufferPointervNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[202])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[202])(target, offset, size, (nint)data);
			#endif
		}

		public static void GetBufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			GetBufferSubDataNative(target, offset, size, data);
		}

		public static void GetBufferSubData(GLBufferTargetARB target, nint offset, nint size, nint data)
		{
			GetBufferSubDataNative(target, offset, size, (void*)data);
		}

		public static void GetBufferSubData<TData>(GLBufferTargetARB target, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				GetBufferSubDataNative(target, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetClipPlaneNative(GLClipPlaneName plane, double* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, double*, void>)funcTable[203])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[203])(plane, (nint)equation);
			#endif
		}

		public static void GetClipPlane(GLClipPlaneName plane, double* equation)
		{
			GetClipPlaneNative(plane, equation);
		}

		public static void GetClipPlane(GLClipPlaneName plane, Span<double> equation)
		{
			fixed (double* pequation0 = equation)
			{
				GetClipPlaneNative(plane, pequation0);
			}
		}

		public static void GetClipPlane(GLClipPlaneName plane, ref double equation)
		{
			fixed (double* pequation0 = &equation)
			{
				GetClipPlaneNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTexImageNative(GLTextureTarget target, int level, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, void*, void>)funcTable[204])(target, level, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[204])(target, level, (nint)img);
			#endif
		}

		public static void GetCompressedTexImage(GLTextureTarget target, int level, void* img)
		{
			GetCompressedTexImageNative(target, level, img);
		}

		public static void GetCompressedTexImage(GLTextureTarget target, int level, nint img)
		{
			GetCompressedTexImageNative(target, level, (void*)img);
		}

		public static void GetCompressedTexImage<TImg>(GLTextureTarget target, int level, Span<TImg> img) where TImg : unmanaged
		{
			fixed (TImg* pimg0 = img)
			{
				GetCompressedTexImageNative(target, level, pimg0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublevNative(GLGetPName pname, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, double*, void>)funcTable[205])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[205])(pname, (nint)data);
			#endif
		}

		public static void GetDoublev(GLGetPName pname, double* data)
		{
			GetDoublevNative(pname, data);
		}

		public static void GetDoublev(GLGetPName pname, Span<double> data)
		{
			fixed (double* pdata0 = data)
			{
				GetDoublevNative(pname, pdata0);
			}
		}

		public static void GetDoublev(GLGetPName pname, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoublevNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[206])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[206])();
			#endif
		}

		public static GLEnum GetError()
		{
			GLEnum ret = GetErrorNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloatvNative(GLGetPName pname, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, float*, void>)funcTable[207])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[207])(pname, (nint)data);
			#endif
		}

		public static void GetFloatv(GLGetPName pname, float* data)
		{
			GetFloatvNative(pname, data);
		}

		public static void GetFloatv(GLGetPName pname, Span<float> data)
		{
			fixed (float* pdata0 = data)
			{
				GetFloatvNative(pname, pdata0);
			}
		}

		public static void GetFloatv(GLGetPName pname, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloatvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataIndexNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[208])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[208])(program, (nint)name);
			#endif
		}

		public static int GetFragDataIndex(uint program, byte* name)
		{
			int ret = GetFragDataIndexNative(program, name);
			return ret;
		}

		public static int GetFragDataIndex(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetFragDataIndex(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		public static int GetFragDataIndex(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[209])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[209])(program, (nint)name);
			#endif
		}

		public static int GetFragDataLocation(uint program, byte* name)
		{
			int ret = GetFragDataLocationNative(program, name);
			return ret;
		}

		public static int GetFragDataLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetFragDataLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetFragDataLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferAttachmentParameterivNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[210])(target, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[210])(target, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferAttachmentParameterivNative(target, attachment, pname, @params);
		}

		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, out int @params)
		{
			int pparams;
			GetFramebufferAttachmentParameterivNative(target, attachment, pname, &pparams);
			@params = pparams;
		}

		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetFramebufferAttachmentParameterivNative(target, attachment, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64i_vNative(GLGetPName target, uint index, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, long*, void>)funcTable[211])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[211])(target, index, (nint)data);
			#endif
		}

		public static void GetInteger64i_v(GLGetPName target, uint index, long* data)
		{
			GetInteger64i_vNative(target, index, data);
		}

		public static void GetInteger64i_v(GLGetPName target, uint index, Span<long> data)
		{
			fixed (long* pdata0 = data)
			{
				GetInteger64i_vNative(target, index, pdata0);
			}
		}

		public static void GetInteger64i_v(GLGetPName target, uint index, ref long data)
		{
			fixed (long* pdata0 = &data)
			{
				GetInteger64i_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64vNative(GLGetPName pname, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, long*, void>)funcTable[212])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[212])(pname, (nint)data);
			#endif
		}

		public static void GetInteger64v(GLGetPName pname, long* data)
		{
			GetInteger64vNative(pname, data);
		}

		public static void GetInteger64v(GLGetPName pname, Span<long> data)
		{
			fixed (long* pdata0 = data)
			{
				GetInteger64vNative(pname, pdata0);
			}
		}

		public static void GetInteger64v(GLGetPName pname, ref long data)
		{
			fixed (long* pdata0 = &data)
			{
				GetInteger64vNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegeri_vNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[213])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[213])(target, index, (nint)data);
			#endif
		}

		public static void GetIntegeri_v(GLGetPName target, uint index, int* data)
		{
			GetIntegeri_vNative(target, index, data);
		}

		public static void GetIntegeri_v(GLGetPName target, uint index, Span<int> data)
		{
			fixed (int* pdata0 = data)
			{
				GetIntegeri_vNative(target, index, pdata0);
			}
		}

		public static void GetIntegeri_v(GLGetPName target, uint index, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegeri_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegervNative(GLGetPName pname, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, int*, void>)funcTable[214])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[214])(pname, (nint)data);
			#endif
		}

		public static void GetIntegerv(GLGetPName pname, int* data)
		{
			GetIntegervNative(pname, data);
		}

		public static void GetIntegerv(GLGetPName pname, Span<int> data)
		{
			fixed (int* pdata0 = data)
			{
				GetIntegervNative(pname, pdata0);
			}
		}

		public static void GetIntegerv(GLGetPName pname, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegervNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[215])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[215])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			GetLightfvNative(light, pname, @params);
		}

		public static void GetLightfv(GLLightName light, GLLightParameter pname, out float @params)
		{
			float pparams;
			GetLightfvNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void GetLightfv(GLLightName light, GLLightParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetLightfvNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightivNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[216])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[216])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightiv(GLLightName light, GLLightParameter pname, int* @params)
		{
			GetLightivNative(light, pname, @params);
		}

		public static void GetLightiv(GLLightName light, GLLightParameter pname, out int @params)
		{
			int pparams;
			GetLightivNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void GetLightiv(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetLightivNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapdvNative(GLMapTarget target, GLGetMapQuery query, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, double*, void>)funcTable[217])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[217])(target, query, (nint)v);
			#endif
		}

		public static void GetMapdv(GLMapTarget target, GLGetMapQuery query, double* v)
		{
			GetMapdvNative(target, query, v);
		}

		public static void GetMapdv(GLMapTarget target, GLGetMapQuery query, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				GetMapdvNative(target, query, pv0);
			}
		}

		public static void GetMapdv(GLMapTarget target, GLGetMapQuery query, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				GetMapdvNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapfvNative(GLMapTarget target, GLGetMapQuery query, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, float*, void>)funcTable[218])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[218])(target, query, (nint)v);
			#endif
		}

		public static void GetMapfv(GLMapTarget target, GLGetMapQuery query, float* v)
		{
			GetMapfvNative(target, query, v);
		}

		public static void GetMapfv(GLMapTarget target, GLGetMapQuery query, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				GetMapfvNative(target, query, pv0);
			}
		}

		public static void GetMapfv(GLMapTarget target, GLGetMapQuery query, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetMapfvNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapivNative(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, int*, void>)funcTable[219])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[219])(target, query, (nint)v);
			#endif
		}

		public static void GetMapiv(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			GetMapivNative(target, query, v);
		}

		public static void GetMapiv(GLMapTarget target, GLGetMapQuery query, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				GetMapivNative(target, query, pv0);
			}
		}

		public static void GetMapiv(GLMapTarget target, GLGetMapQuery query, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				GetMapivNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialfvNative(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float*, void>)funcTable[220])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[220])(face, pname, (nint)@params);
			#endif
		}

		public static void GetMaterialfv(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			GetMaterialfvNative(face, pname, @params);
		}

		public static void GetMaterialfv(GLTriangleFace face, GLMaterialParameter pname, out float @params)
		{
			float pparams;
			GetMaterialfvNative(face, pname, &pparams);
			@params = pparams;
		}

		public static void GetMaterialfv(GLTriangleFace face, GLMaterialParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetMaterialfvNative(face, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialivNative(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[221])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[221])(face, pname, (nint)@params);
			#endif
		}

		public static void GetMaterialiv(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			GetMaterialivNative(face, pname, @params);
		}

		public static void GetMaterialiv(GLTriangleFace face, GLMaterialParameter pname, out int @params)
		{
			int pparams;
			GetMaterialivNative(face, pname, &pparams);
			@params = pparams;
		}

		public static void GetMaterialiv(GLTriangleFace face, GLMaterialParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMaterialivNative(face, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultisamplefvNative(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, float*, void>)funcTable[222])(pname, index, val);
			#else
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, nint, void>)funcTable[222])(pname, index, (nint)val);
			#endif
		}

		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			GetMultisamplefvNative(pname, index, val);
		}

		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, Span<float> val)
		{
			fixed (float* pval0 = val)
			{
				GetMultisamplefvNative(pname, index, pval0);
			}
		}

		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, ref float val)
		{
			fixed (float* pval0 = &val)
			{
				GetMultisamplefvNative(pname, index, pval0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapfvNative(GLPixelMap map, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, float*, void>)funcTable[223])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[223])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapfv(GLPixelMap map, float* values)
		{
			GetPixelMapfvNative(map, values);
		}

		public static void GetPixelMapfv(GLPixelMap map, Span<float> values)
		{
			fixed (float* pvalues0 = values)
			{
				GetPixelMapfvNative(map, pvalues0);
			}
		}

		public static void GetPixelMapfv(GLPixelMap map, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				GetPixelMapfvNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapuivNative(GLPixelMap map, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, uint*, void>)funcTable[224])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[224])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapuiv(GLPixelMap map, uint* values)
		{
			GetPixelMapuivNative(map, values);
		}

		public static void GetPixelMapuiv(GLPixelMap map, Span<uint> values)
		{
			fixed (uint* pvalues0 = values)
			{
				GetPixelMapuivNative(map, pvalues0);
			}
		}

		public static void GetPixelMapuiv(GLPixelMap map, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				GetPixelMapuivNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapusvNative(GLPixelMap map, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, ushort*, void>)funcTable[225])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[225])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapusv(GLPixelMap map, ushort* values)
		{
			GetPixelMapusvNative(map, values);
		}

		public static void GetPixelMapusv(GLPixelMap map, Span<ushort> values)
		{
			fixed (ushort* pvalues0 = values)
			{
				GetPixelMapusvNative(map, pvalues0);
			}
		}

		public static void GetPixelMapusv(GLPixelMap map, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				GetPixelMapusvNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointervNative(GLGetPointervPName pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, void**, void>)funcTable[226])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, nint, void>)funcTable[226])(pname, (nint)@params);
			#endif
		}

		public static void GetPointerv(GLGetPointervPName pname, void** @params)
		{
			GetPointervNative(pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPolygonStippleNative(byte* mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[227])(mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[227])((nint)mask);
			#endif
		}

		public static void GetPolygonStipple(byte* mask)
		{
			GetPolygonStippleNative(mask);
		}

		public static void GetPolygonStipple(string mask)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mask != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mask);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mask, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetPolygonStippleNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetPolygonStipple(Span<byte> mask)
		{
			fixed (byte* pmask0 = mask)
			{
				GetPolygonStippleNative(pmask0);
			}
		}

		public static void GetPolygonStipple(ref byte mask)
		{
			fixed (byte* pmask0 = &mask)
			{
				GetPolygonStippleNative(pmask0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInfoLogNative(uint program, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[228])(program, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[228])(program, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, byte* infoLog)
		{
			GetProgramInfoLogNative(program, bufSize, length, infoLog);
		}

		public static string GetProgramInfoLog(uint program)
		{
			int pStrSize0;
			GetProgramiv(program, GLProgramPropertyARB.InfoLogLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetProgramInfoLogNative(program, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void GetProgramInfoLog(uint program, int bufSize, Span<int> length, byte* infoLog)
		{
			fixed (int* plength0 = length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramInfoLogNative(program, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, Span<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, Span<int> length, Span<byte> infoLog)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pinfoLog1 = infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramivNative(uint program, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, int*, void>)funcTable[229])(program, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, nint, void>)funcTable[229])(program, pname, (nint)@params);
			#endif
		}

		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, int* @params)
		{
			GetProgramivNative(program, pname, @params);
		}

		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, out int @params)
		{
			int pparams;
			GetProgramivNative(program, pname, &pparams);
			@params = pparams;
		}

		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetProgramivNative(program, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjecti64vNative(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, long*, void>)funcTable[230])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[230])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			GetQueryObjecti64vNative(id, pname, @params);
		}

		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, out long @params)
		{
			long pparams;
			GetQueryObjecti64vNative(id, pname, &pparams);
			@params = pparams;
		}

		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, Span<long> @params)
		{
			fixed (long* pparams = @params)
			{
				GetQueryObjecti64vNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectivNative(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, int*, void>)funcTable[231])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[231])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			GetQueryObjectivNative(id, pname, @params);
		}

		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, out int @params)
		{
			int pparams;
			GetQueryObjectivNative(id, pname, &pparams);
			@params = pparams;
		}

		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetQueryObjectivNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectui64vNative(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, ulong*, void>)funcTable[232])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[232])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			GetQueryObjectui64vNative(id, pname, @params);
		}

		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, out ulong @params)
		{
			ulong pparams;
			GetQueryObjectui64vNative(id, pname, &pparams);
			@params = pparams;
		}

		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, Span<ulong> @params)
		{
			fixed (ulong* pparams = @params)
			{
				GetQueryObjectui64vNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectuivNative(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, uint*, void>)funcTable[233])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[233])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			GetQueryObjectuivNative(id, pname, @params);
		}

		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, out uint @params)
		{
			uint pparams;
			GetQueryObjectuivNative(id, pname, &pparams);
			@params = pparams;
		}

		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetQueryObjectuivNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryivNative(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, int*, void>)funcTable[234])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, nint, void>)funcTable[234])(target, pname, (nint)@params);
			#endif
		}

		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			GetQueryivNative(target, pname, @params);
		}

		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, out int @params)
		{
			int pparams;
			GetQueryivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetQueryivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRenderbufferParameterivNative(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, int*, void>)funcTable[235])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, nint, void>)funcTable[235])(target, pname, (nint)@params);
			#endif
		}

		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			GetRenderbufferParameterivNative(target, pname, @params);
		}

		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, out int @params)
		{
			int pparams;
			GetRenderbufferParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetRenderbufferParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[236])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[236])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterIivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, out int @params)
		{
			int pparams;
			GetSamplerParameterIivNative(sampler, pname, &pparams);
			@params = pparams;
		}

		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetSamplerParameterIivNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIuivNative(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[237])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[237])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			GetSamplerParameterIuivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, out uint @params)
		{
			uint pparams;
			GetSamplerParameterIuivNative(sampler, pname, &pparams);
			@params = pparams;
		}

		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetSamplerParameterIuivNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterfvNative(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float*, void>)funcTable[238])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, nint, void>)funcTable[238])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			GetSamplerParameterfvNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, out float @params)
		{
			float pparams;
			GetSamplerParameterfvNative(sampler, pname, &pparams);
			@params = pparams;
		}

		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetSamplerParameterfvNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[239])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[239])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, out int @params)
		{
			int pparams;
			GetSamplerParameterivNative(sampler, pname, &pparams);
			@params = pparams;
		}

		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetSamplerParameterivNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderInfoLogNative(uint shader, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[240])(shader, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[240])(shader, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, byte* infoLog)
		{
			GetShaderInfoLogNative(shader, bufSize, length, infoLog);
		}

		public static string GetShaderInfoLog(uint shader)
		{
			int pStrSize0;
			GetShaderiv(shader, GLShaderParameterName.InfoLogLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetShaderInfoLogNative(shader, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, Span<int> length, byte* infoLog)
		{
			fixed (int* plength0 = length)
			{
				GetShaderInfoLogNative(shader, bufSize, plength0, infoLog);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderInfoLogNative(shader, bufSize, plength0, infoLog);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderInfoLogNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, Span<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, Span<int> length, Span<byte> infoLog)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pinfoLog1 = infoLog)
				{
					GetShaderInfoLogNative(shader, bufSize, plength0, pinfoLog1);
				}
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetShaderInfoLogNative(shader, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderSourceNative(uint shader, int bufSize, int* length, byte* source)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[241])(shader, bufSize, length, source);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[241])(shader, bufSize, (nint)length, (nint)source);
			#endif
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, byte* source)
		{
			GetShaderSourceNative(shader, bufSize, length, source);
		}

		public static string GetShaderSource(uint shader)
		{
			int pStrSize0;
			GetShaderiv(shader, GLShaderParameterName.SourceLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetShaderSourceNative(shader, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static void GetShaderSource(uint shader, int bufSize, Span<int> length, byte* source)
		{
			fixed (int* plength0 = length)
			{
				GetShaderSourceNative(shader, bufSize, plength0, source);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, ref int length, byte* source)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderSourceNative(shader, bufSize, plength0, source);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderSourceNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, Span<byte> source)
		{
			fixed (byte* psource0 = source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, ref byte source)
		{
			fixed (byte* psource0 = &source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, Span<int> length, Span<byte> source)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* psource1 = source)
				{
					GetShaderSourceNative(shader, bufSize, plength0, psource1);
				}
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, ref int length, ref byte source)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* psource1 = &source)
				{
					GetShaderSourceNative(shader, bufSize, plength0, psource1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderivNative(uint shader, GLShaderParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, int*, void>)funcTable[242])(shader, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, nint, void>)funcTable[242])(shader, pname, (nint)@params);
			#endif
		}

		public static void GetShaderiv(uint shader, GLShaderParameterName pname, int* @params)
		{
			GetShaderivNative(shader, pname, @params);
		}

		public static void GetShaderiv(uint shader, GLShaderParameterName pname, out int @params)
		{
			int pparams;
			GetShaderivNative(shader, pname, &pparams);
			@params = pparams;
		}

		public static void GetShaderiv(uint shader, GLShaderParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetShaderivNative(shader, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringNative(GLStringName name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLStringName, byte*>)funcTable[243])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GLStringName, nint>)funcTable[243])(name);
			#endif
		}

		public static byte* GetString(GLStringName name)
		{
			byte* ret = GetStringNative(name);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringiNative(GLStringName name, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLStringName, uint, byte*>)funcTable[244])(name, index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GLStringName, uint, nint>)funcTable[244])(name, index);
			#endif
		}

		public static byte* GetStringi(GLStringName name, uint index)
		{
			byte* ret = GetStringiNative(name, index);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSyncivNative(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, int*, int*, void>)funcTable[245])(sync, pname, count, length, values);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, nint, nint, void>)funcTable[245])(sync, pname, count, (nint)length, (nint)values);
			#endif
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			GetSyncivNative(sync, pname, count, length, values);
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, Span<int> length, int* values)
		{
			fixed (int* plength0 = length)
			{
				GetSyncivNative(sync, pname, count, plength0, values);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, int* values)
		{
			fixed (int* plength0 = &length)
			{
				GetSyncivNative(sync, pname, count, plength0, values);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, Span<int> values)
		{
			fixed (int* pvalues0 = values)
			{
				GetSyncivNative(sync, pname, count, length, pvalues0);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetSyncivNative(sync, pname, count, length, pvalues0);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, Span<int> length, Span<int> values)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* pvalues1 = values)
				{
					GetSyncivNative(sync, pname, count, plength0, pvalues1);
				}
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, ref int values)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* pvalues1 = &values)
				{
					GetSyncivNative(sync, pname, count, plength0, pvalues1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvfvNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[246])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[246])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			GetTexEnvfvNative(target, pname, @params);
		}

		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, out float @params)
		{
			float pparams;
			GetTexEnvfvNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexEnvfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvivNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[247])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[247])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetTexEnvivNative(target, pname, @params);
		}

		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, out int @params)
		{
			int pparams;
			GetTexEnvivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexEnvivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGendvNative(GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[248])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[248])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGendv(GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			GetTexGendvNative(coord, pname, @params);
		}

		public static void GetTexGendv(GLTextureCoordName coord, GLTextureGenParameter pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetTexGendvNative(coord, pname, pparams0);
			}
		}

		public static void GetTexGendv(GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetTexGendvNative(coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGenfvNative(GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[249])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[249])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGenfv(GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			GetTexGenfvNative(coord, pname, @params);
		}

		public static void GetTexGenfv(GLTextureCoordName coord, GLTextureGenParameter pname, out float @params)
		{
			float pparams;
			GetTexGenfvNative(coord, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexGenfv(GLTextureCoordName coord, GLTextureGenParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexGenfvNative(coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGenivNative(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[250])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[250])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGeniv(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			GetTexGenivNative(coord, pname, @params);
		}

		public static void GetTexGeniv(GLTextureCoordName coord, GLTextureGenParameter pname, out int @params)
		{
			int pparams;
			GetTexGenivNative(coord, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexGeniv(GLTextureCoordName coord, GLTextureGenParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexGenivNative(coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexImageNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[251])(target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[251])(target, level, format, type, (nint)pixels);
			#endif
		}

		public static void GetTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetTexImageNative(target, level, format, type, pixels);
		}

		public static void GetTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			GetTexImageNative(target, level, format, type, (void*)pixels);
		}

		public static void GetTexImage<TPixels>(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetTexImageNative(target, level, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterfvNative(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[252])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[252])(target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTexLevelParameterfvNative(target, level, pname, @params);
		}

		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTexLevelParameterfvNative(target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexLevelParameterfvNative(target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterivNative(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[253])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[253])(target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTexLevelParameterivNative(target, level, pname, @params);
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexLevelParameterivNative(target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexLevelParameterivNative(target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[254])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[254])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterIivNative(target, pname, @params);
		}

		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexParameterIivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexParameterIivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIuivNative(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[255])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[255])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTexParameterIuivNative(target, pname, @params);
		}

		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, out uint @params)
		{
			uint pparams;
			GetTexParameterIuivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetTexParameterIuivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterfvNative(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[256])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[256])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTexParameterfvNative(target, pname, @params);
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTexParameterfvNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[257])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[257])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterivNative(target, pname, @params);
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackVaryingNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[258])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[258])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = size)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* psize0 = size)
			{
				fixed (byte* pname1 = name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					fixed (byte* pname2 = name)
					{
						GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUniformBlockIndexNative(uint program, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, uint>)funcTable[259])(program, uniformBlockName);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint>)funcTable[259])(program, (nint)uniformBlockName);
			#endif
		}

		public static uint GetUniformBlockIndex(uint program, byte* uniformBlockName)
		{
			uint ret = GetUniformBlockIndexNative(program, uniformBlockName);
			return ret;
		}

		public static uint GetUniformBlockIndex(uint program, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetUniformBlockIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetUniformBlockIndex(uint program, Span<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		public static uint GetUniformBlockIndex(uint program, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformIndicesNative(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, uint*, void>)funcTable[260])(program, uniformCount, uniformNames, uniformIndices);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[260])(program, uniformCount, (nint)uniformNames, (nint)uniformIndices);
			#endif
		}

		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			GetUniformIndicesNative(program, uniformCount, uniformNames, uniformIndices);
		}

		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
		{
			fixed (uint* puniformIndices0 = uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUniformLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[261])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[261])(program, (nint)name);
			#endif
		}

		public static int GetUniformLocation(uint program, byte* name)
		{
			int ret = GetUniformLocationNative(program, name);
			return ret;
		}

		public static int GetUniformLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetUniformLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetUniformLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetUniformLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformfvNative(uint program, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[262])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[262])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformfv(uint program, int location, float* @params)
		{
			GetUniformfvNative(program, location, @params);
		}

		public static void GetUniformfv(uint program, int location, out float @params)
		{
			float pparams;
			GetUniformfvNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformfv(uint program, int location, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetUniformfvNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformivNative(uint program, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[263])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[263])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformiv(uint program, int location, int* @params)
		{
			GetUniformivNative(program, location, @params);
		}

		public static void GetUniformiv(uint program, int location, out int @params)
		{
			int pparams;
			GetUniformivNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformiv(uint program, int location, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetUniformivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformuivNative(uint program, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[264])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[264])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformuiv(uint program, int location, uint* @params)
		{
			GetUniformuivNative(program, location, @params);
		}

		public static void GetUniformuiv(uint program, int location, out uint @params)
		{
			uint pparams;
			GetUniformuivNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformuiv(uint program, int location, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetUniformuivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIivNative(uint index, GLVertexAttribEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, int*, void>)funcTable[265])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[265])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, int* @params)
		{
			GetVertexAttribIivNative(index, pname, @params);
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, out int @params)
		{
			int pparams;
			GetVertexAttribIivNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribIivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIuivNative(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, uint*, void>)funcTable[266])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[266])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			GetVertexAttribIuivNative(index, pname, @params);
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, out uint @params)
		{
			uint pparams;
			GetVertexAttribIuivNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetVertexAttribIuivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[267])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[267])(index, pname, (nint)pointer);
			#endif
		}

		public static void GetVertexAttribPointerv(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[268])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[268])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvNative(index, pname, @params);
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[269])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[269])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvNative(index, pname, @params);
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, out float @params)
		{
			float pparams;
			GetVertexAttribfvNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetVertexAttribfvNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[270])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[270])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivNative(index, pname, @params);
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, out int @params)
		{
			int pparams;
			GetVertexAttribivNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HintNative(GLHintTarget target, GLHintMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[271])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[271])(target, mode);
			#endif
		}

		public static void Hint(GLHintTarget target, GLHintMode mode)
		{
			HintNative(target, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[272])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[272])(mask);
			#endif
		}

		public static void IndexMask(uint mask)
		{
			IndexMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexPointerNative(GLIndexPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, void*, void>)funcTable[273])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, nint, void>)funcTable[273])(type, stride, (nint)pointer);
			#endif
		}

		public static void IndexPointer(GLIndexPointerType type, int stride, void* pointer)
		{
			IndexPointerNative(type, stride, pointer);
		}

		public static void IndexPointer(GLIndexPointerType type, int stride, nint pointer)
		{
			IndexPointerNative(type, stride, (void*)pointer);
		}

		public static void IndexPointer<TPointer>(GLIndexPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				IndexPointerNative(type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexdNative(double c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[274])(c);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[274])(c);
			#endif
		}

		public static void Indexd(double c)
		{
			IndexdNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexdvNative(double* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[275])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[275])((nint)c);
			#endif
		}

		public static void Indexdv(double* c)
		{
			IndexdvNative(c);
		}

		public static void Indexdv(Span<double> c)
		{
			fixed (double* pc0 = c)
			{
				IndexdvNative(pc0);
			}
		}

		public static void Indexdv(ref double c)
		{
			fixed (double* pc0 = &c)
			{
				IndexdvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexfNative(float c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[276])(c);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[276])(c);
			#endif
		}

		public static void Indexf(float c)
		{
			IndexfNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexfvNative(float* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[277])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[277])((nint)c);
			#endif
		}

		public static void Indexfv(float* c)
		{
			IndexfvNative(c);
		}

		public static void Indexfv(Span<float> c)
		{
			fixed (float* pc0 = c)
			{
				IndexfvNative(pc0);
			}
		}

		public static void Indexfv(ref float c)
		{
			fixed (float* pc0 = &c)
			{
				IndexfvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexiNative(int c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[278])(c);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[278])(c);
			#endif
		}

		public static void Indexi(int c)
		{
			IndexiNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexivNative(int* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[279])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[279])((nint)c);
			#endif
		}

		public static void Indexiv(int* c)
		{
			IndexivNative(c);
		}

		public static void Indexiv(Span<int> c)
		{
			fixed (int* pc0 = c)
			{
				IndexivNative(pc0);
			}
		}

		public static void Indexiv(ref int c)
		{
			fixed (int* pc0 = &c)
			{
				IndexivNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexsNative(short c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[280])(c);
			#else
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[280])(c);
			#endif
		}

		public static void Indexs(short c)
		{
			IndexsNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexsvNative(short* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[281])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[281])((nint)c);
			#endif
		}

		public static void Indexsv(short* c)
		{
			IndexsvNative(c);
		}

		public static void Indexsv(Span<short> c)
		{
			fixed (short* pc0 = c)
			{
				IndexsvNative(pc0);
			}
		}

		public static void Indexsv(ref short c)
		{
			fixed (short* pc0 = &c)
			{
				IndexsvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexubNative(bool c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[282])(*((byte*)(&c)));
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[282])(*((byte*)(&c)));
			#endif
		}

		public static void Indexub(bool c)
		{
			IndexubNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexubvNative(byte* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[283])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[283])((nint)c);
			#endif
		}

		public static void Indexubv(byte* c)
		{
			IndexubvNative(c);
		}

		public static void Indexubv(string c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (c != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(c);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(c, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IndexubvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Indexubv(Span<byte> c)
		{
			fixed (byte* pc0 = c)
			{
				IndexubvNative(pc0);
			}
		}

		public static void Indexubv(ref byte c)
		{
			fixed (byte* pc0 = &c)
			{
				IndexubvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitNamesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[284])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[284])();
			#endif
		}

		public static void InitNames()
		{
			InitNamesNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InterleavedArraysNative(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, void*, void>)funcTable[285])(format, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, nint, void>)funcTable[285])(format, stride, (nint)pointer);
			#endif
		}

		public static void InterleavedArrays(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			InterleavedArraysNative(format, stride, pointer);
		}

		public static void InterleavedArrays(GLInterleavedArrayFormat format, int stride, nint pointer)
		{
			InterleavedArraysNative(format, stride, (void*)pointer);
		}

		public static void InterleavedArrays<TPointer>(GLInterleavedArrayFormat format, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				InterleavedArraysNative(format, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[286])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[286])(buffer);
			#endif
		}

		public static bool IsBuffer(uint buffer)
		{
			byte ret = IsBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnabledNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[287])(cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[287])(cap);
			#endif
		}

		public static bool IsEnabled(GLEnableCap cap)
		{
			byte ret = IsEnabledNative(cap);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnablediNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[288])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[288])(target, index);
			#endif
		}

		public static bool IsEnabledi(GLEnableCap target, uint index)
		{
			byte ret = IsEnablediNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFramebufferNative(uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[289])(framebuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[289])(framebuffer);
			#endif
		}

		public static bool IsFramebuffer(uint framebuffer)
		{
			byte ret = IsFramebufferNative(framebuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsListNative(uint list)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[290])(list);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[290])(list);
			#endif
		}

		public static bool IsList(uint list)
		{
			byte ret = IsListNative(list);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[291])(program);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[291])(program);
			#endif
		}

		public static bool IsProgram(uint program)
		{
			byte ret = IsProgramNative(program);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQueryNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[292])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[292])(id);
			#endif
		}

		public static bool IsQuery(uint id)
		{
			byte ret = IsQueryNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsRenderbufferNative(uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[293])(renderbuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[293])(renderbuffer);
			#endif
		}

		public static bool IsRenderbuffer(uint renderbuffer)
		{
			byte ret = IsRenderbufferNative(renderbuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSamplerNative(uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[294])(sampler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[294])(sampler);
			#endif
		}

		public static bool IsSampler(uint sampler)
		{
			byte ret = IsSamplerNative(sampler);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[295])(shader);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[295])(shader);
			#endif
		}

		public static bool IsShader(uint shader)
		{
			byte ret = IsShaderNative(shader);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[296])(sync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[296])(sync);
			#endif
		}

		public static bool IsSync(GLSync sync)
		{
			byte ret = IsSyncNative(sync);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[297])(texture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[297])(texture);
			#endif
		}

		public static bool IsTexture(uint texture)
		{
			byte ret = IsTextureNative(texture);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[298])(array);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[298])(array);
			#endif
		}

		public static bool IsVertexArray(uint array)
		{
			byte ret = IsVertexArrayNative(array);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfNative(GLLightModelParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[299])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[299])(pname, param);
			#endif
		}

		public static void LightModelf(GLLightModelParameter pname, float param)
		{
			LightModelfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfvNative(GLLightModelParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float*, void>)funcTable[300])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[300])(pname, (nint)@params);
			#endif
		}

		public static void LightModelfv(GLLightModelParameter pname, float* @params)
		{
			LightModelfvNative(pname, @params);
		}

		public static void LightModelfv(GLLightModelParameter pname, out float @params)
		{
			float pparams;
			LightModelfvNative(pname, &pparams);
			@params = pparams;
		}

		public static void LightModelfv(GLLightModelParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				LightModelfvNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModeliNative(GLLightModelParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[301])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[301])(pname, param);
			#endif
		}

		public static void LightModeli(GLLightModelParameter pname, int param)
		{
			LightModeliNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelivNative(GLLightModelParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int*, void>)funcTable[302])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[302])(pname, (nint)@params);
			#endif
		}

		public static void LightModeliv(GLLightModelParameter pname, int* @params)
		{
			LightModelivNative(pname, @params);
		}

		public static void LightModeliv(GLLightModelParameter pname, out int @params)
		{
			int pparams;
			LightModelivNative(pname, &pparams);
			@params = pparams;
		}

		public static void LightModeliv(GLLightModelParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				LightModelivNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfNative(GLLightName light, GLLightParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[303])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[303])(light, pname, param);
			#endif
		}

		public static void Lightf(GLLightName light, GLLightParameter pname, float param)
		{
			LightfNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[304])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[304])(light, pname, (nint)@params);
			#endif
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			LightfvNative(light, pname, @params);
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, out float @params)
		{
			float pparams;
			LightfvNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				LightfvNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightiNative(GLLightName light, GLLightParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[305])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[305])(light, pname, param);
			#endif
		}

		public static void Lighti(GLLightName light, GLLightParameter pname, int param)
		{
			LightiNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightivNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[306])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[306])(light, pname, (nint)@params);
			#endif
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, int* @params)
		{
			LightivNative(light, pname, @params);
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, out int @params)
		{
			int pparams;
			LightivNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				LightivNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineStippleNative(int factor, ushort pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[307])(factor, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[307])(factor, pattern);
			#endif
		}

		public static void LineStipple(int factor, ushort pattern)
		{
			LineStippleNative(factor, pattern);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineWidthNative(float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[308])(width);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[308])(width);
			#endif
		}

		public static void LineWidth(float width)
		{
			LineWidthNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LinkProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[309])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[309])(program);
			#endif
		}

		public static void LinkProgram(uint program)
		{
			LinkProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ListBaseNative(uint baseValue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[310])(baseValue);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[310])(baseValue);
			#endif
		}

		public static void ListBase(uint baseValue)
		{
			ListBaseNative(baseValue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadIdentityNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[311])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[311])();
			#endif
		}

		public static void LoadIdentity()
		{
			LoadIdentityNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[312])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[312])((nint)m);
			#endif
		}

		public static void LoadMatrixd(double* m)
		{
			LoadMatrixdNative(m);
		}

		public static void LoadMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				LoadMatrixdNative(pm0);
			}
		}

		public static void LoadMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[313])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[313])((nint)m);
			#endif
		}

		public static void LoadMatrixf(float* m)
		{
			LoadMatrixfNative(m);
		}

		public static void LoadMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		public static void LoadMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadNameNative(uint name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[314])(name);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[314])(name);
			#endif
		}

		public static void LoadName(uint name)
		{
			LoadNameNative(name);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[315])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[315])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixd(double* m)
		{
			LoadTransposeMatrixdNative(m);
		}

		public static void LoadTransposeMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				LoadTransposeMatrixdNative(pm0);
			}
		}

		public static void LoadTransposeMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadTransposeMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[316])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[316])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixf(float* m)
		{
			LoadTransposeMatrixfNative(m);
		}

		public static void LoadTransposeMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				LoadTransposeMatrixfNative(pm0);
			}
		}

		public static void LoadTransposeMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadTransposeMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogicOpNative(GLLogicOp opcode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[317])(opcode);
			#else
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[317])(opcode);
			#endif
		}

		public static void LogicOp(GLLogicOp opcode)
		{
			LogicOpNative(opcode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map1dNative(GLMapTarget target, double u1, double u2, int stride, int order, double* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double*, void>)funcTable[318])(target, u1, u2, stride, order, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, nint, void>)funcTable[318])(target, u1, u2, stride, order, (nint)points);
			#endif
		}

		public static void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, double* points)
		{
			Map1dNative(target, u1, u2, stride, order, points);
		}

		public static void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, Span<double> points)
		{
			fixed (double* ppoints0 = points)
			{
				Map1dNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		public static void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, ref double points)
		{
			fixed (double* ppoints0 = &points)
			{
				Map1dNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map1fNative(GLMapTarget target, float u1, float u2, int stride, int order, float* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float*, void>)funcTable[319])(target, u1, u2, stride, order, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, nint, void>)funcTable[319])(target, u1, u2, stride, order, (nint)points);
			#endif
		}

		public static void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, float* points)
		{
			Map1fNative(target, u1, u2, stride, order, points);
		}

		public static void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, Span<float> points)
		{
			fixed (float* ppoints0 = points)
			{
				Map1fNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		public static void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, ref float points)
		{
			fixed (float* ppoints0 = &points)
			{
				Map1fNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map2dNative(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double, double, int, int, double*, void>)funcTable[320])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double, double, int, int, nint, void>)funcTable[320])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (nint)points);
			#endif
		}

		public static void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
		{
			Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		}

		public static void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, Span<double> points)
		{
			fixed (double* ppoints0 = points)
			{
				Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		public static void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ref double points)
		{
			fixed (double* ppoints0 = &points)
			{
				Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map2fNative(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float, float, int, int, float*, void>)funcTable[321])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float, float, int, int, nint, void>)funcTable[321])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (nint)points);
			#endif
		}

		public static void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
		{
			Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		}

		public static void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, Span<float> points)
		{
			fixed (float* ppoints0 = points)
			{
				Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		public static void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ref float points)
		{
			fixed (float* ppoints0 = &points)
			{
				Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferNative(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, void*>)funcTable[322])(target, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, nint>)funcTable[322])(target, access);
			#endif
		}

		public static void* MapBuffer(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			void* ret = MapBufferNative(target, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferRangeNative(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, void*>)funcTable[323])(target, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, nint>)funcTable[323])(target, offset, length, access);
			#endif
		}

		public static void* MapBufferRange(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapBufferRangeNative(target, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid1dNative(int un, double u1, double u2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[324])(un, u1, u2);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[324])(un, u1, u2);
			#endif
		}

		public static void MapGrid1d(int un, double u1, double u2)
		{
			MapGrid1dNative(un, u1, u2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid1fNative(int un, float u1, float u2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[325])(un, u1, u2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[325])(un, u1, u2);
			#endif
		}

		public static void MapGrid1f(int un, float u1, float u2)
		{
			MapGrid1fNative(un, u1, u2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid2dNative(int un, double u1, double u2, int vn, double v1, double v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, int, double, double, void>)funcTable[326])(un, u1, u2, vn, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, int, double, double, void>)funcTable[326])(un, u1, u2, vn, v1, v2);
			#endif
		}

		public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2)
		{
			MapGrid2dNative(un, u1, u2, vn, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid2fNative(int un, float u1, float u2, int vn, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, int, float, float, void>)funcTable[327])(un, u1, u2, vn, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, int, float, float, void>)funcTable[327])(un, u1, u2, vn, v1, v2);
			#endif
		}

		public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2)
		{
			MapGrid2fNative(un, u1, u2, vn, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialfNative(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[328])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[328])(face, pname, param);
			#endif
		}

		public static void Materialf(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			MaterialfNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialfvNative(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float*, void>)funcTable[329])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[329])(face, pname, (nint)@params);
			#endif
		}

		public static void Materialfv(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			MaterialfvNative(face, pname, @params);
		}

		public static void Materialfv(GLTriangleFace face, GLMaterialParameter pname, out float @params)
		{
			float pparams;
			MaterialfvNative(face, pname, &pparams);
			@params = pparams;
		}

		public static void Materialfv(GLTriangleFace face, GLMaterialParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				MaterialfvNative(face, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialiNative(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[330])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[330])(face, pname, param);
			#endif
		}

		public static void Materiali(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			MaterialiNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialivNative(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[331])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[331])(face, pname, (nint)@params);
			#endif
		}

		public static void Materialiv(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			MaterialivNative(face, pname, @params);
		}

		public static void Materialiv(GLTriangleFace face, GLMaterialParameter pname, out int @params)
		{
			int pparams;
			MaterialivNative(face, pname, &pparams);
			@params = pparams;
		}

		public static void Materialiv(GLTriangleFace face, GLMaterialParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				MaterialivNative(face, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixModeNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[332])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[332])(mode);
			#endif
		}

		public static void MatrixMode(GLMatrixMode mode)
		{
			MatrixModeNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[333])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[333])((nint)m);
			#endif
		}

		public static void MultMatrixd(double* m)
		{
			MultMatrixdNative(m);
		}

		public static void MultMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MultMatrixdNative(pm0);
			}
		}

		public static void MultMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MultMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[334])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[334])((nint)m);
			#endif
		}

		public static void MultMatrixf(float* m)
		{
			MultMatrixfNative(m);
		}

		public static void MultMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MultMatrixfNative(pm0);
			}
		}

		public static void MultMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultTransposeMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[335])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[335])((nint)m);
			#endif
		}

		public static void MultTransposeMatrixd(double* m)
		{
			MultTransposeMatrixdNative(m);
		}

		public static void MultTransposeMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MultTransposeMatrixdNative(pm0);
			}
		}

		public static void MultTransposeMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MultTransposeMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultTransposeMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[336])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[336])((nint)m);
			#endif
		}

		public static void MultTransposeMatrixf(float* m)
		{
			MultTransposeMatrixfNative(m);
		}

		public static void MultTransposeMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MultTransposeMatrixfNative(pm0);
			}
		}

		public static void MultTransposeMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultTransposeMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysNative(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, int*, int, void>)funcTable[337])(mode, first, count, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, void>)funcTable[337])(mode, (nint)first, (nint)count, drawcount);
			#endif
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			MultiDrawArraysNative(mode, first, count, drawcount);
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, ref int first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, Span<int> count, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, ref int count, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, Span<int> count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				fixed (int* pcount1 = count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, ref int first, ref int count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				fixed (int* pcount1 = &count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, void>)funcTable[338])(mode, count, type, indices, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, void>)funcTable[338])(mode, (nint)count, type, (nint)indices, drawcount);
			#endif
		}

		public static void MultiDrawElements(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			MultiDrawElementsNative(mode, count, type, indices, drawcount);
		}

		public static void MultiDrawElements(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		public static void MultiDrawElements(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsBaseVertexNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, int*, void>)funcTable[339])(mode, count, type, indices, drawcount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, nint, void>)funcTable[339])(mode, (nint)count, type, (nint)indices, drawcount, (nint)basevertex);
			#endif
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, basevertex);
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pbasevertex0 = basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pbasevertex0 = &basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pcount0 = count)
			{
				fixed (int* pbasevertex1 = basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (int* pbasevertex1 = &basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1dNative(GLTextureUnit target, double s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[340])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[340])(target, s);
			#endif
		}

		public static void MultiTexCoord1d(GLTextureUnit target, double s)
		{
			MultiTexCoord1dNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[341])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[341])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord1dvNative(target, v);
		}

		public static void MultiTexCoord1dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord1dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord1dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord1dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1fNative(GLTextureUnit target, float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[342])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[342])(target, s);
			#endif
		}

		public static void MultiTexCoord1f(GLTextureUnit target, float s)
		{
			MultiTexCoord1fNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[343])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[343])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord1fvNative(target, v);
		}

		public static void MultiTexCoord1fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord1fvNative(target, pv0);
			}
		}

		public static void MultiTexCoord1fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord1fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1iNative(GLTextureUnit target, int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[344])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[344])(target, s);
			#endif
		}

		public static void MultiTexCoord1i(GLTextureUnit target, int s)
		{
			MultiTexCoord1iNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[345])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[345])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord1ivNative(target, v);
		}

		public static void MultiTexCoord1iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord1ivNative(target, pv0);
			}
		}

		public static void MultiTexCoord1iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord1ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1sNative(GLTextureUnit target, short s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[346])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[346])(target, s);
			#endif
		}

		public static void MultiTexCoord1s(GLTextureUnit target, short s)
		{
			MultiTexCoord1sNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[347])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[347])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord1svNative(target, v);
		}

		public static void MultiTexCoord1sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord1svNative(target, pv0);
			}
		}

		public static void MultiTexCoord1sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord1svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2dNative(GLTextureUnit target, double s, double t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[348])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[348])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2d(GLTextureUnit target, double s, double t)
		{
			MultiTexCoord2dNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[349])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[349])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord2dvNative(target, v);
		}

		public static void MultiTexCoord2dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord2dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord2dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord2dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2fNative(GLTextureUnit target, float s, float t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[350])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[350])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2f(GLTextureUnit target, float s, float t)
		{
			MultiTexCoord2fNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[351])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[351])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord2fvNative(target, v);
		}

		public static void MultiTexCoord2fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord2fvNative(target, pv0);
			}
		}

		public static void MultiTexCoord2fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord2fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2iNative(GLTextureUnit target, int s, int t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[352])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[352])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2i(GLTextureUnit target, int s, int t)
		{
			MultiTexCoord2iNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[353])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[353])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord2ivNative(target, v);
		}

		public static void MultiTexCoord2iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord2ivNative(target, pv0);
			}
		}

		public static void MultiTexCoord2iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord2ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2sNative(GLTextureUnit target, short s, short t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[354])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[354])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2s(GLTextureUnit target, short s, short t)
		{
			MultiTexCoord2sNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[355])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[355])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord2svNative(target, v);
		}

		public static void MultiTexCoord2sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord2svNative(target, pv0);
			}
		}

		public static void MultiTexCoord2sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord2svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3dNative(GLTextureUnit target, double s, double t, double r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[356])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[356])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3d(GLTextureUnit target, double s, double t, double r)
		{
			MultiTexCoord3dNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[357])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[357])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord3dvNative(target, v);
		}

		public static void MultiTexCoord3dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord3dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord3dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord3dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3fNative(GLTextureUnit target, float s, float t, float r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[358])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[358])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3f(GLTextureUnit target, float s, float t, float r)
		{
			MultiTexCoord3fNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[359])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[359])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord3fvNative(target, v);
		}

		public static void MultiTexCoord3fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord3fvNative(target, pv0);
			}
		}

		public static void MultiTexCoord3fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord3fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3iNative(GLTextureUnit target, int s, int t, int r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[360])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[360])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3i(GLTextureUnit target, int s, int t, int r)
		{
			MultiTexCoord3iNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[361])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[361])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord3ivNative(target, v);
		}

		public static void MultiTexCoord3iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord3ivNative(target, pv0);
			}
		}

		public static void MultiTexCoord3iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord3ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3sNative(GLTextureUnit target, short s, short t, short r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[362])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[362])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3s(GLTextureUnit target, short s, short t, short r)
		{
			MultiTexCoord3sNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[363])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[363])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord3svNative(target, v);
		}

		public static void MultiTexCoord3sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord3svNative(target, pv0);
			}
		}

		public static void MultiTexCoord3sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord3svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4dNative(GLTextureUnit target, double s, double t, double r, double q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[364])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[364])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4d(GLTextureUnit target, double s, double t, double r, double q)
		{
			MultiTexCoord4dNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[365])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[365])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord4dvNative(target, v);
		}

		public static void MultiTexCoord4dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord4dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord4dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord4dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4fNative(GLTextureUnit target, float s, float t, float r, float q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[366])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[366])(target, s, t, r, q);
			#endif
		}
	}
}
