// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public unsafe partial class GL
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetUniformIndicesNative(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, uint*, void>)funcTable[260])(program, uniformCount, uniformNames, uniformIndices);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[260])(program, uniformCount, (nint)uniformNames, (nint)uniformIndices);
			#endif
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			GetUniformIndicesNative(program, uniformCount, uniformNames, uniformIndices);
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
		{
			fixed (uint* puniformIndices0 = uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal int GetUniformLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[261])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[261])(program, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public int GetUniformLocation(uint program, byte* name)
		{
			int ret = GetUniformLocationNative(program, name);
			return ret;
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public int GetUniformLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetUniformLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public int GetUniformLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public int GetUniformLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetUniformfvNative(uint program, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[262])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[262])(program, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// Returns the value of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformfv(uint program, int location, float* @params)
		{
			GetUniformfvNative(program, location, @params);
		}

		/// <summary>
		/// Returns the value of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformfv(uint program, int location, out float @params)
		{
			float pparam;
			GetUniformfvNative(program, location, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Returns the value of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformfv(uint program, int location, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetUniformfvNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetUniformivNative(uint program, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[263])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[263])(program, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformiv(uint program, int location, int* @params)
		{
			GetUniformivNative(program, location, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformiv(uint program, int location, out int @params)
		{
			int pparam;
			GetUniformivNative(program, location, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformiv(uint program, int location, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetUniformivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetUniformuivNative(uint program, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[264])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[264])(program, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformuiv(uint program, int location, uint* @params)
		{
			GetUniformuivNative(program, location, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformuiv(uint program, int location, out uint @params)
		{
			uint pparam;
			GetUniformuivNative(program, location, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetUniformuiv(uint program, int location, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetUniformuivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetVertexAttribIivNative(uint index, GLVertexAttribEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, int*, void>)funcTable[265])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[265])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, int* @params)
		{
			GetVertexAttribIivNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, out int @params)
		{
			int pparam;
			GetVertexAttribIivNative(index, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribIivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetVertexAttribIuivNative(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, uint*, void>)funcTable[266])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[266])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			GetVertexAttribIuivNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, out uint @params)
		{
			uint pparam;
			GetVertexAttribIuivNative(index, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetVertexAttribIuivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetVertexAttribPointervNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[267])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[267])(index, pname, (nint)pointer);
			#endif
		}

		/// <summary>
		/// Return the address of the specified generic vertex attribute pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribPointerv(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetVertexAttribdvNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[268])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[268])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Return a generic vertex attribute parameter
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvNative(index, pname, @params);
		}

		/// <summary>
		/// Return a generic vertex attribute parameter
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, out double @params)
		{
			double pparam;
			GetVertexAttribdvNative(index, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Return a generic vertex attribute parameter
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, Span<double> @params)
		{
			fixed (double* pparams = @params)
			{
				GetVertexAttribdvNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetVertexAttribfvNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[269])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[269])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, out float @params)
		{
			float pparam;
			GetVertexAttribfvNative(index, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetVertexAttribfvNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetVertexAttribivNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[270])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[270])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, out int @params)
		{
			int pparam;
			GetVertexAttribivNative(index, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void HintNative(GLHintTarget target, GLHintMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[271])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[271])(target, mode);
			#endif
		}

		/// <summary>
		/// Specify implementation-specific hints
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void Hint(GLHintTarget target, GLHintMode mode)
		{
			HintNative(target, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[272])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[272])(mask);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void IndexMask(uint mask)
		{
			IndexMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexPointerNative(GLIndexPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, void*, void>)funcTable[273])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, nint, void>)funcTable[273])(type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void IndexPointer(GLIndexPointerType type, int stride, void* pointer)
		{
			IndexPointerNative(type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void IndexPointer(GLIndexPointerType type, int stride, nint pointer)
		{
			IndexPointerNative(type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void IndexPointer<TPointer>(GLIndexPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				IndexPointerNative(type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexdNative(double c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[274])(c);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[274])(c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexd(double c)
		{
			IndexdNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexdvNative(double* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[275])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[275])((nint)c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexdv(double* c)
		{
			IndexdvNative(c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexdv(Span<double> c)
		{
			fixed (double* pc0 = c)
			{
				IndexdvNative(pc0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexdv(ref double c)
		{
			fixed (double* pc0 = &c)
			{
				IndexdvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexfNative(float c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[276])(c);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[276])(c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexf(float c)
		{
			IndexfNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexfvNative(float* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[277])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[277])((nint)c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexfv(float* c)
		{
			IndexfvNative(c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexfv(Span<float> c)
		{
			fixed (float* pc0 = c)
			{
				IndexfvNative(pc0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexfv(ref float c)
		{
			fixed (float* pc0 = &c)
			{
				IndexfvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexiNative(int c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[278])(c);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[278])(c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexi(int c)
		{
			IndexiNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexivNative(int* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[279])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[279])((nint)c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexiv(int* c)
		{
			IndexivNative(c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexiv(Span<int> c)
		{
			fixed (int* pc0 = c)
			{
				IndexivNative(pc0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexiv(ref int c)
		{
			fixed (int* pc0 = &c)
			{
				IndexivNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexsNative(short c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[280])(c);
			#else
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[280])(c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexs(short c)
		{
			IndexsNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexsvNative(short* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[281])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[281])((nint)c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexsv(short* c)
		{
			IndexsvNative(c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexsv(Span<short> c)
		{
			fixed (short* pc0 = c)
			{
				IndexsvNative(pc0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexsv(ref short c)
		{
			fixed (short* pc0 = &c)
			{
				IndexsvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexubNative(bool c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[282])(*((byte*)(&c)));
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[282])(*((byte*)(&c)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexub(bool c)
		{
			IndexubNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void IndexubvNative(byte* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[283])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[283])((nint)c);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexubv(byte* c)
		{
			IndexubvNative(c);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexubv(string c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (c != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(c);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(c, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IndexubvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexubv(Span<byte> c)
		{
			fixed (byte* pc0 = c)
			{
				IndexubvNative(pc0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Indexubv(ref byte c)
		{
			fixed (byte* pc0 = &c)
			{
				IndexubvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void InitNamesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[284])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[284])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void InitNames()
		{
			InitNamesNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void InterleavedArraysNative(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, void*, void>)funcTable[285])(format, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, nint, void>)funcTable[285])(format, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void InterleavedArrays(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			InterleavedArraysNative(format, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void InterleavedArrays(GLInterleavedArrayFormat format, int stride, nint pointer)
		{
			InterleavedArraysNative(format, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void InterleavedArrays<TPointer>(GLInterleavedArrayFormat format, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				InterleavedArraysNative(format, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[286])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[286])(buffer);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a buffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public bool IsBuffer(uint buffer)
		{
			byte ret = IsBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsEnabledNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[287])(cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[287])(cap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public bool IsEnabled(GLEnableCap cap)
		{
			byte ret = IsEnabledNative(cap);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsEnablediNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[288])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[288])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public bool IsEnabledi(GLEnableCap target, uint index)
		{
			byte ret = IsEnablediNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsFramebufferNative(uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[289])(framebuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[289])(framebuffer);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public bool IsFramebuffer(uint framebuffer)
		{
			byte ret = IsFramebufferNative(framebuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsListNative(uint list)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[290])(list);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[290])(list);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public bool IsList(uint list)
		{
			byte ret = IsListNative(list);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[291])(program);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[291])(program);
			#endif
		}

		/// <summary>
		/// Determines if a name corresponds to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public bool IsProgram(uint program)
		{
			byte ret = IsProgramNative(program);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsQueryNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[292])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[292])(id);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a query object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public bool IsQuery(uint id)
		{
			byte ret = IsQueryNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsRenderbufferNative(uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[293])(renderbuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[293])(renderbuffer);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a renderbuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public bool IsRenderbuffer(uint renderbuffer)
		{
			byte ret = IsRenderbufferNative(renderbuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsSamplerNative(uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[294])(sampler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[294])(sampler);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a sampler object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public bool IsSampler(uint sampler)
		{
			byte ret = IsSamplerNative(sampler);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[295])(shader);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[295])(shader);
			#endif
		}

		/// <summary>
		/// Determines if a name corresponds to a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public bool IsShader(uint shader)
		{
			byte ret = IsShaderNative(shader);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[296])(sync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[296])(sync);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a sync object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public bool IsSync(GLSync sync)
		{
			byte ret = IsSyncNative(sync);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsTextureNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[297])(texture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[297])(texture);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a texture
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public bool IsTexture(uint texture)
		{
			byte ret = IsTextureNative(texture);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[298])(array);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[298])(array);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a vertex array object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public bool IsVertexArray(uint array)
		{
			byte ret = IsVertexArrayNative(array);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightModelfNative(GLLightModelParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[299])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[299])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModelf(GLLightModelParameter pname, float param)
		{
			LightModelfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightModelfvNative(GLLightModelParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float*, void>)funcTable[300])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[300])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModelfv(GLLightModelParameter pname, float* @params)
		{
			LightModelfvNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModelfv(GLLightModelParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				LightModelfvNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModelfv(GLLightModelParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				LightModelfvNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightModeliNative(GLLightModelParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[301])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[301])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModeli(GLLightModelParameter pname, int param)
		{
			LightModeliNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightModelivNative(GLLightModelParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int*, void>)funcTable[302])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[302])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModeliv(GLLightModelParameter pname, int* @params)
		{
			LightModelivNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModeliv(GLLightModelParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				LightModelivNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LightModeliv(GLLightModelParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				LightModelivNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightfNative(GLLightName light, GLLightParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[303])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[303])(light, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lightf(GLLightName light, GLLightParameter pname, float param)
		{
			LightfNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[304])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[304])(light, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			LightfvNative(light, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lightfv(GLLightName light, GLLightParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				LightfvNative(light, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lightfv(GLLightName light, GLLightParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				LightfvNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightiNative(GLLightName light, GLLightParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[305])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[305])(light, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lighti(GLLightName light, GLLightParameter pname, int param)
		{
			LightiNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightivNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[306])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[306])(light, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lightiv(GLLightName light, GLLightParameter pname, int* @params)
		{
			LightivNative(light, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lightiv(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				LightivNative(light, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Lightiv(GLLightName light, GLLightParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				LightivNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LineStippleNative(int factor, ushort pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[307])(factor, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[307])(factor, pattern);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LineStipple(int factor, ushort pattern)
		{
			LineStippleNative(factor, pattern);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LineWidthNative(float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[308])(width);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[308])(width);
			#endif
		}

		/// <summary>
		/// Specify the width of rasterized lines
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void LineWidth(float width)
		{
			LineWidthNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LinkProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[309])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[309])(program);
			#endif
		}

		/// <summary>
		/// Links a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void LinkProgram(uint program)
		{
			LinkProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ListBaseNative(uint baseValue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[310])(baseValue);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[310])(baseValue);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void ListBase(uint baseValue)
		{
			ListBaseNative(baseValue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadIdentityNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[311])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[311])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadIdentity()
		{
			LoadIdentityNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[312])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[312])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadMatrixd(double* m)
		{
			LoadMatrixdNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				LoadMatrixdNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[313])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[313])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadMatrixf(float* m)
		{
			LoadMatrixfNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadNameNative(uint name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[314])(name);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[314])(name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadName(uint name)
		{
			LoadNameNative(name);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadTransposeMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[315])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[315])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadTransposeMatrixd(double* m)
		{
			LoadTransposeMatrixdNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadTransposeMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				LoadTransposeMatrixdNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadTransposeMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadTransposeMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadTransposeMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[316])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[316])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadTransposeMatrixf(float* m)
		{
			LoadTransposeMatrixfNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadTransposeMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				LoadTransposeMatrixfNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void LoadTransposeMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadTransposeMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LogicOpNative(GLLogicOp opcode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[317])(opcode);
			#else
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[317])(opcode);
			#endif
		}

		/// <summary>
		/// Specify a logical pixel operation for rendering
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void LogicOp(GLLogicOp opcode)
		{
			LogicOpNative(opcode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Map1dNative(GLMapTarget target, double u1, double u2, int stride, int order, double* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double*, void>)funcTable[318])(target, u1, u2, stride, order, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, nint, void>)funcTable[318])(target, u1, u2, stride, order, (nint)points);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, double* points)
		{
			Map1dNative(target, u1, u2, stride, order, points);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, Span<double> points)
		{
			fixed (double* ppoints0 = points)
			{
				Map1dNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, ref double points)
		{
			fixed (double* ppoints0 = &points)
			{
				Map1dNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Map1fNative(GLMapTarget target, float u1, float u2, int stride, int order, float* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float*, void>)funcTable[319])(target, u1, u2, stride, order, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, nint, void>)funcTable[319])(target, u1, u2, stride, order, (nint)points);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, float* points)
		{
			Map1fNative(target, u1, u2, stride, order, points);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, Span<float> points)
		{
			fixed (float* ppoints0 = points)
			{
				Map1fNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, ref float points)
		{
			fixed (float* ppoints0 = &points)
			{
				Map1fNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Map2dNative(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double, double, int, int, double*, void>)funcTable[320])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double, double, int, int, nint, void>)funcTable[320])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (nint)points);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
		{
			Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, Span<double> points)
		{
			fixed (double* ppoints0 = points)
			{
				Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ref double points)
		{
			fixed (double* ppoints0 = &points)
			{
				Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Map2fNative(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float, float, int, int, float*, void>)funcTable[321])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float, float, int, int, nint, void>)funcTable[321])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (nint)points);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
		{
			Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, Span<float> points)
		{
			fixed (float* ppoints0 = points)
			{
				Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ref float points)
		{
			fixed (float* ppoints0 = &points)
			{
				Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void* MapBufferNative(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, void*>)funcTable[322])(target, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, nint>)funcTable[322])(target, access);
			#endif
		}

		/// <summary>
		/// Map all of a buffer object's data store into the client's address space
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void* MapBuffer(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			void* ret = MapBufferNative(target, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void* MapBufferRangeNative(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, void*>)funcTable[323])(target, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, nint>)funcTable[323])(target, offset, length, access);
			#endif
		}

		/// <summary>
		/// Map all or part of a buffer object's data store into the client's address space
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_map_buffer_range</remarks>
		public void* MapBufferRange(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapBufferRangeNative(target, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MapGrid1dNative(int un, double u1, double u2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[324])(un, u1, u2);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[324])(un, u1, u2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MapGrid1d(int un, double u1, double u2)
		{
			MapGrid1dNative(un, u1, u2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MapGrid1fNative(int un, float u1, float u2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[325])(un, u1, u2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[325])(un, u1, u2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MapGrid1f(int un, float u1, float u2)
		{
			MapGrid1fNative(un, u1, u2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MapGrid2dNative(int un, double u1, double u2, int vn, double v1, double v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, int, double, double, void>)funcTable[326])(un, u1, u2, vn, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, int, double, double, void>)funcTable[326])(un, u1, u2, vn, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2)
		{
			MapGrid2dNative(un, u1, u2, vn, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MapGrid2fNative(int un, float u1, float u2, int vn, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, int, float, float, void>)funcTable[327])(un, u1, u2, vn, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, int, float, float, void>)funcTable[327])(un, u1, u2, vn, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2)
		{
			MapGrid2fNative(un, u1, u2, vn, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialfNative(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[328])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[328])(face, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materialf(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			MaterialfNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialfvNative(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float*, void>)funcTable[329])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[329])(face, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materialfv(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			MaterialfvNative(face, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materialfv(GLTriangleFace face, GLMaterialParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				MaterialfvNative(face, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materialfv(GLTriangleFace face, GLMaterialParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				MaterialfvNative(face, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialiNative(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[330])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[330])(face, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materiali(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			MaterialiNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialivNative(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[331])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[331])(face, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materialiv(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			MaterialivNative(face, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materialiv(GLTriangleFace face, GLMaterialParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				MaterialivNative(face, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Materialiv(GLTriangleFace face, GLMaterialParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MaterialivNative(face, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MatrixModeNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[332])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[332])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MatrixMode(GLMatrixMode mode)
		{
			MatrixModeNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[333])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[333])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultMatrixd(double* m)
		{
			MultMatrixdNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MultMatrixdNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MultMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[334])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[334])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultMatrixf(float* m)
		{
			MultMatrixfNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MultMatrixfNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultTransposeMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[335])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[335])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultTransposeMatrixd(double* m)
		{
			MultTransposeMatrixdNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultTransposeMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MultTransposeMatrixdNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultTransposeMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MultTransposeMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultTransposeMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[336])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[336])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultTransposeMatrixf(float* m)
		{
			MultTransposeMatrixfNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultTransposeMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MultTransposeMatrixfNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultTransposeMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultTransposeMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawArraysNative(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, int*, int, void>)funcTable[337])(mode, first, count, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, void>)funcTable[337])(mode, (nint)first, (nint)count, drawcount);
			#endif
		}

		/// <summary>
		/// Render multiple sets of primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			MultiDrawArraysNative(mode, first, count, drawcount);
		}

		/// <summary>
		/// Render multiple sets of primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, ref int first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, int* first, Span<int> count, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, int* first, ref int count, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, Span<int> count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				fixed (int* pcount1 = count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		/// <summary>
		/// Render multiple sets of primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, ref int first, ref int count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				fixed (int* pcount1 = &count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawElementsNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, void>)funcTable[338])(mode, count, type, indices, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, void>)funcTable[338])(mode, (nint)count, type, (nint)indices, drawcount);
			#endif
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawElements(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			MultiDrawElementsNative(mode, count, type, indices, drawcount);
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawElements(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void MultiDrawElements(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawElementsBaseVertexNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, int*, void>)funcTable[339])(mode, count, type, indices, drawcount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, nint, void>)funcTable[339])(mode, (nint)count, type, (nint)indices, drawcount, (nint)basevertex);
			#endif
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, basevertex);
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pbasevertex0 = basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pbasevertex0 = &basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pcount0 = count)
			{
				fixed (int* pbasevertex1 = basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		/// <summary>
		/// Render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (int* pbasevertex1 = &basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1dNative(GLTextureUnit target, double s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[340])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[340])(target, s);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1d(GLTextureUnit target, double s)
		{
			MultiTexCoord1dNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[341])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[341])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord1dvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord1dvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord1dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1fNative(GLTextureUnit target, float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[342])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[342])(target, s);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1f(GLTextureUnit target, float s)
		{
			MultiTexCoord1fNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[343])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[343])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord1fvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord1fvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord1fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1iNative(GLTextureUnit target, int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[344])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[344])(target, s);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1i(GLTextureUnit target, int s)
		{
			MultiTexCoord1iNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[345])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[345])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord1ivNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord1ivNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord1ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1sNative(GLTextureUnit target, short s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[346])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[346])(target, s);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1s(GLTextureUnit target, short s)
		{
			MultiTexCoord1sNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord1svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[347])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[347])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord1svNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord1svNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord1sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord1svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2dNative(GLTextureUnit target, double s, double t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[348])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[348])(target, s, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2d(GLTextureUnit target, double s, double t)
		{
			MultiTexCoord2dNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[349])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[349])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord2dvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord2dvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord2dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2fNative(GLTextureUnit target, float s, float t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[350])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[350])(target, s, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2f(GLTextureUnit target, float s, float t)
		{
			MultiTexCoord2fNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[351])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[351])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord2fvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord2fvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord2fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2iNative(GLTextureUnit target, int s, int t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[352])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[352])(target, s, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2i(GLTextureUnit target, int s, int t)
		{
			MultiTexCoord2iNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[353])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[353])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord2ivNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord2ivNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord2ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2sNative(GLTextureUnit target, short s, short t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[354])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[354])(target, s, t);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2s(GLTextureUnit target, short s, short t)
		{
			MultiTexCoord2sNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord2svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[355])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[355])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord2svNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord2svNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord2sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord2svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3dNative(GLTextureUnit target, double s, double t, double r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[356])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[356])(target, s, t, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3d(GLTextureUnit target, double s, double t, double r)
		{
			MultiTexCoord3dNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[357])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[357])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord3dvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord3dvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord3dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3fNative(GLTextureUnit target, float s, float t, float r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[358])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[358])(target, s, t, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3f(GLTextureUnit target, float s, float t, float r)
		{
			MultiTexCoord3fNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[359])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[359])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord3fvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord3fvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord3fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3iNative(GLTextureUnit target, int s, int t, int r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[360])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[360])(target, s, t, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3i(GLTextureUnit target, int s, int t, int r)
		{
			MultiTexCoord3iNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[361])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[361])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord3ivNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord3ivNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord3ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3sNative(GLTextureUnit target, short s, short t, short r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[362])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[362])(target, s, t, r);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3s(GLTextureUnit target, short s, short t, short r)
		{
			MultiTexCoord3sNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord3svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[363])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[363])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord3svNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord3svNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord3sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord3svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4dNative(GLTextureUnit target, double s, double t, double r, double q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[364])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[364])(target, s, t, r, q);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4d(GLTextureUnit target, double s, double t, double r, double q)
		{
			MultiTexCoord4dNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[365])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[365])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord4dvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord4dvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord4dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4fNative(GLTextureUnit target, float s, float t, float r, float q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[366])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[366])(target, s, t, r, q);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4f(GLTextureUnit target, float s, float t, float r, float q)
		{
			MultiTexCoord4fNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[367])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[367])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord4fvNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord4fvNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord4fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4iNative(GLTextureUnit target, int s, int t, int r, int q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[368])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[368])(target, s, t, r, q);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4i(GLTextureUnit target, int s, int t, int r, int q)
		{
			MultiTexCoord4iNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[369])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[369])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord4ivNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord4ivNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord4ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4sNative(GLTextureUnit target, short s, short t, short r, short q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, short, void>)funcTable[370])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, short, void>)funcTable[370])(target, s, t, r, q);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4s(GLTextureUnit target, short s, short t, short r, short q)
		{
			MultiTexCoord4sNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[371])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[371])(target, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord4svNative(target, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord4svNative(target, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.3 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void MultiTexCoord4sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord4svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP1uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[372])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[372])(texture, type, coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP1ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP1uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP1uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[373])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[373])(texture, type, (nint)coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP1uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP1uivNative(texture, type, coords);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP1uiv(GLTextureUnit texture, GLTexCoordPointerType type, Span<uint> coords)
		{
			fixed (uint* pcoords0 = coords)
			{
				MultiTexCoordP1uivNative(texture, type, pcoords0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP1uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP1uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP2uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[374])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[374])(texture, type, coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP2ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP2uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP2uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[375])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[375])(texture, type, (nint)coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP2uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP2uivNative(texture, type, coords);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP2uiv(GLTextureUnit texture, GLTexCoordPointerType type, Span<uint> coords)
		{
			fixed (uint* pcoords0 = coords)
			{
				MultiTexCoordP2uivNative(texture, type, pcoords0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP2uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP2uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP3uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[376])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[376])(texture, type, coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP3ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP3uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP3uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[377])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[377])(texture, type, (nint)coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP3uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP3uivNative(texture, type, coords);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP3uiv(GLTextureUnit texture, GLTexCoordPointerType type, Span<uint> coords)
		{
			fixed (uint* pcoords0 = coords)
			{
				MultiTexCoordP3uivNative(texture, type, pcoords0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP3uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP3uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP4uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[378])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[378])(texture, type, coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP4ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP4uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoordP4uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[379])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[379])(texture, type, (nint)coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP4uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP4uivNative(texture, type, coords);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP4uiv(GLTextureUnit texture, GLTexCoordPointerType type, Span<uint> coords)
		{
			fixed (uint* pcoords0 = coords)
			{
				MultiTexCoordP4uivNative(texture, type, pcoords0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void MultiTexCoordP4uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP4uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NewListNative(uint list, GLListMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLListMode, void>)funcTable[380])(list, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLListMode, void>)funcTable[380])(list, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void NewList(uint list, GLListMode mode)
		{
			NewListNative(list, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3bNative(sbyte nx, sbyte ny, sbyte nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[381])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[381])(nx, ny, nz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3b(sbyte nx, sbyte ny, sbyte nz)
		{
			Normal3bNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3bvNative(sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte*, void>)funcTable[382])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[382])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3bv(sbyte* v)
		{
			Normal3bvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3bv(Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				Normal3bvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3bv(ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				Normal3bvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3dNative(double nx, double ny, double nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[383])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[383])(nx, ny, nz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3d(double nx, double ny, double nz)
		{
			Normal3dNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[384])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[384])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3dv(double* v)
		{
			Normal3dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				Normal3dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Normal3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3fNative(float nx, float ny, float nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[385])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[385])(nx, ny, nz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3f(float nx, float ny, float nz)
		{
			Normal3fNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[386])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[386])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3fv(float* v)
		{
			Normal3fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				Normal3fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Normal3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3iNative(int nx, int ny, int nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[387])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[387])(nx, ny, nz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3i(int nx, int ny, int nz)
		{
			Normal3iNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[388])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[388])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3iv(int* v)
		{
			Normal3ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				Normal3ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Normal3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3sNative(short nx, short ny, short nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[389])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[389])(nx, ny, nz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3s(short nx, short ny, short nz)
		{
			Normal3sNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[390])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[390])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3sv(short* v)
		{
			Normal3svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				Normal3svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Normal3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Normal3svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NormalP3uiNative(GLNormalPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, uint, void>)funcTable[391])(type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, uint, void>)funcTable[391])(type, coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void NormalP3ui(GLNormalPointerType type, uint coords)
		{
			NormalP3uiNative(type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NormalP3uivNative(GLNormalPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, uint*, void>)funcTable[392])(type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, nint, void>)funcTable[392])(type, (nint)coords);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void NormalP3uiv(GLNormalPointerType type, uint* coords)
		{
			NormalP3uivNative(type, coords);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void NormalP3uiv(GLNormalPointerType type, Span<uint> coords)
		{
			fixed (uint* pcoords0 = coords)
			{
				NormalP3uivNative(type, pcoords0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void NormalP3uiv(GLNormalPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				NormalP3uivNative(type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NormalPointerNative(GLNormalPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, int, void*, void>)funcTable[393])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, int, nint, void>)funcTable[393])(type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void NormalPointer(GLNormalPointerType type, int stride, void* pointer)
		{
			NormalPointerNative(type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void NormalPointer(GLNormalPointerType type, int stride, nint pointer)
		{
			NormalPointerNative(type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void NormalPointer<TPointer>(GLNormalPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				NormalPointerNative(type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void OrthoNative(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[394])(left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[394])(left, right, bottom, top, zNear, zFar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void Ortho(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			OrthoNative(left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PassThroughNative(float token)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[395])(token);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[395])(token);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PassThrough(float token)
		{
			PassThroughNative(token);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelMapfvNative(GLPixelMap map, int mapsize, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, float*, void>)funcTable[396])(map, mapsize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[396])(map, mapsize, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapfv(GLPixelMap map, int mapsize, float* values)
		{
			PixelMapfvNative(map, mapsize, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapfv(GLPixelMap map, int mapsize, Span<float> values)
		{
			fixed (float* pvalues0 = values)
			{
				PixelMapfvNative(map, mapsize, pvalues0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapfv(GLPixelMap map, int mapsize, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				PixelMapfvNative(map, mapsize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelMapuivNative(GLPixelMap map, int mapsize, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, uint*, void>)funcTable[397])(map, mapsize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[397])(map, mapsize, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapuiv(GLPixelMap map, int mapsize, uint* values)
		{
			PixelMapuivNative(map, mapsize, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapuiv(GLPixelMap map, int mapsize, Span<uint> values)
		{
			fixed (uint* pvalues0 = values)
			{
				PixelMapuivNative(map, mapsize, pvalues0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapuiv(GLPixelMap map, int mapsize, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				PixelMapuivNative(map, mapsize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelMapusvNative(GLPixelMap map, int mapsize, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, ushort*, void>)funcTable[398])(map, mapsize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[398])(map, mapsize, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapusv(GLPixelMap map, int mapsize, ushort* values)
		{
			PixelMapusvNative(map, mapsize, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapusv(GLPixelMap map, int mapsize, Span<ushort> values)
		{
			fixed (ushort* pvalues0 = values)
			{
				PixelMapusvNative(map, mapsize, pvalues0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelMapusv(GLPixelMap map, int mapsize, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				PixelMapusvNative(map, mapsize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelStorefNative(GLPixelStoreParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[399])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[399])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void PixelStoref(GLPixelStoreParameter pname, float param)
		{
			PixelStorefNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelStoreiNative(GLPixelStoreParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[400])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[400])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void PixelStorei(GLPixelStoreParameter pname, int param)
		{
			PixelStoreiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelTransferfNative(GLPixelTransferParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, float, void>)funcTable[401])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, float, void>)funcTable[401])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelTransferf(GLPixelTransferParameter pname, float param)
		{
			PixelTransferfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelTransferiNative(GLPixelTransferParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, int, void>)funcTable[402])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, int, void>)funcTable[402])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelTransferi(GLPixelTransferParameter pname, int param)
		{
			PixelTransferiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelZoomNative(float xfactor, float yfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[403])(xfactor, yfactor);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[403])(xfactor, yfactor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PixelZoom(float xfactor, float yfactor)
		{
			PixelZoomNative(xfactor, yfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterfNative(GLPointParameterNameARB pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[404])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[404])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameterf(GLPointParameterNameARB pname, float param)
		{
			PointParameterfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterfvNative(GLPointParameterNameARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float*, void>)funcTable[405])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[405])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameterfv(GLPointParameterNameARB pname, float* @params)
		{
			PointParameterfvNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameterfv(GLPointParameterNameARB pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				PointParameterfvNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameterfv(GLPointParameterNameARB pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				PointParameterfvNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameteriNative(GLPointParameterNameARB pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[406])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[406])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameteri(GLPointParameterNameARB pname, int param)
		{
			PointParameteriNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterivNative(GLPointParameterNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int*, void>)funcTable[407])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[407])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameteriv(GLPointParameterNameARB pname, int* @params)
		{
			PointParameterivNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameteriv(GLPointParameterNameARB pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				PointParameterivNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PointParameteriv(GLPointParameterNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				PointParameterivNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointSizeNative(float size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[408])(size);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[408])(size);
			#endif
		}

		/// <summary>
		/// Specify the diameter of rasterized points
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void PointSize(float size)
		{
			PointSizeNative(size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PolygonModeNative(GLTriangleFace face, GLPolygonMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[409])(face, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[409])(face, mode);
			#endif
		}

		/// <summary>
		/// Select a polygon rasterization mode
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void PolygonMode(GLTriangleFace face, GLPolygonMode mode)
		{
			PolygonModeNative(face, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PolygonOffsetNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[410])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[410])(factor, units);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public void PolygonOffset(float factor, float units)
		{
			PolygonOffsetNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PolygonStippleNative(byte* mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[411])(mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[411])((nint)mask);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PolygonStipple(byte* mask)
		{
			PolygonStippleNative(mask);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PolygonStipple(string mask)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mask != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mask);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mask, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PolygonStippleNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PolygonStipple(Span<byte> mask)
		{
			fixed (byte* pmask0 = mask)
			{
				PolygonStippleNative(pmask0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PolygonStipple(ref byte mask)
		{
			fixed (byte* pmask0 = &mask)
			{
				PolygonStippleNative(pmask0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PopAttribNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[412])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[412])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PopAttrib()
		{
			PopAttribNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PopClientAttribNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[413])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[413])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PopClientAttrib()
		{
			PopClientAttribNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PopMatrixNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[414])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[414])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PopMatrix()
		{
			PopMatrixNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PopNameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[415])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[415])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PopName()
		{
			PopNameNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PrimitiveRestartIndexNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[416])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[416])(index);
			#endif
		}

		/// <summary>
		/// Specify the primitive restart index
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X</remarks>
		public void PrimitiveRestartIndex(uint index)
		{
			PrimitiveRestartIndexNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PrioritizeTexturesNative(int n, uint* textures, float* priorities)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, float*, void>)funcTable[417])(n, textures, priorities);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, nint, void>)funcTable[417])(n, (nint)textures, (nint)priorities);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PrioritizeTextures(int n, uint* textures, float* priorities)
		{
			PrioritizeTexturesNative(n, textures, priorities);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PrioritizeTextures(int n, Span<uint> textures, float* priorities)
		{
			fixed (uint* ptextures0 = textures)
			{
				PrioritizeTexturesNative(n, ptextures0, priorities);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PrioritizeTextures(int n, ref uint textures, float* priorities)
		{
			fixed (uint* ptextures0 = &textures)
			{
				PrioritizeTexturesNative(n, ptextures0, priorities);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PrioritizeTextures(int n, uint* textures, Span<float> priorities)
		{
			fixed (float* ppriorities0 = priorities)
			{
				PrioritizeTexturesNative(n, textures, ppriorities0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PrioritizeTextures(int n, uint* textures, ref float priorities)
		{
			fixed (float* ppriorities0 = &priorities)
			{
				PrioritizeTexturesNative(n, textures, ppriorities0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PrioritizeTextures(int n, Span<uint> textures, Span<float> priorities)
		{
			fixed (uint* ptextures0 = textures)
			{
				fixed (float* ppriorities1 = priorities)
				{
					PrioritizeTexturesNative(n, ptextures0, ppriorities1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void PrioritizeTextures(int n, ref uint textures, ref float priorities)
		{
			fixed (uint* ptextures0 = &textures)
			{
				fixed (float* ppriorities1 = &priorities)
				{
					PrioritizeTexturesNative(n, ptextures0, ppriorities1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProvokingVertexNative(GLVertexProvokingMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexProvokingMode, void>)funcTable[418])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexProvokingMode, void>)funcTable[418])(mode);
			#endif
		}

		/// <summary>
		/// Specifiy the vertex to be used as the source of data for flat shaded varyings
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_provoking_vertex</remarks>
		public void ProvokingVertex(GLVertexProvokingMode mode)
		{
			ProvokingVertexNative(mode);
		}
	}
}
