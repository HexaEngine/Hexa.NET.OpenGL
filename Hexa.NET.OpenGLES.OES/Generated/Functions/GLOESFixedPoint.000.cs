// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES.OES
{
	public static unsafe partial class GLOESFixedPoint
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AccumxOESNative(GLEnum op, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[0])(op, value);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[0])(op, value);
			#endif
		}

		public static void AccumxOES(GLEnum op, int value)
		{
			AccumxOESNative(op, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlphaFuncxOESNative(GLAlphaFunction func, int reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[1])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[1])(func, reference);
			#endif
		}

		public static void AlphaFuncxOES(GLAlphaFunction func, int reference)
		{
			AlphaFuncxOESNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BitmapxOESNative(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, byte*, void>)funcTable[2])(width, height, xorig, yorig, xmove, ymove, bitmap);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, nint, void>)funcTable[2])(width, height, xorig, yorig, xmove, ymove, (nint)bitmap);
			#endif
		}

		public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, byte* bitmap)
		{
			BitmapxOESNative(width, height, xorig, yorig, xmove, ymove, bitmap);
		}

		public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, string bitmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (bitmap != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(bitmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(bitmap, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BitmapxOESNative(width, height, xorig, yorig, xmove, ymove, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, ReadOnlySpan<byte> bitmap)
		{
			fixed (byte* pbitmap0 = bitmap)
			{
				BitmapxOESNative(width, height, xorig, yorig, xmove, ymove, pbitmap0);
			}
		}

		public static void BitmapxOES(int width, int height, int xorig, int yorig, int xmove, int ymove, ref byte bitmap)
		{
			fixed (byte* pbitmap0 = &bitmap)
			{
				BitmapxOESNative(width, height, xorig, yorig, xmove, ymove, pbitmap0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorxOESNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[3])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[3])(red, green, blue, alpha);
			#endif
		}

		public static void BlendColorxOES(int red, int green, int blue, int alpha)
		{
			BlendColorxOESNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearAccumxOESNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[4])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[4])(red, green, blue, alpha);
			#endif
		}

		public static void ClearAccumxOES(int red, int green, int blue, int alpha)
		{
			ClearAccumxOESNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorxOESNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[5])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[5])(red, green, blue, alpha);
			#endif
		}

		public static void ClearColorxOES(int red, int green, int blue, int alpha)
		{
			ClearColorxOESNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthxOESNative(int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[6])(depth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[6])(depth);
			#endif
		}

		public static void ClearDepthxOES(int depth)
		{
			ClearDepthxOESNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipPlanexOESNative(GLClipPlaneName plane, int* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, int*, void>)funcTable[7])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[7])(plane, (nint)equation);
			#endif
		}

		public static void ClipPlanexOES(GLClipPlaneName plane, int* equation)
		{
			ClipPlanexOESNative(plane, equation);
		}

		public static void ClipPlanexOES(GLClipPlaneName plane, ref int equation)
		{
			fixed (int* pequation0 = &equation)
			{
				ClipPlanexOESNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3xOESNative(int red, int green, int blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[8])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[8])(red, green, blue);
			#endif
		}

		public static void Color3xOES(int red, int green, int blue)
		{
			Color3xOESNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3xvOESNative(int* components)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[9])(components);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[9])((nint)components);
			#endif
		}

		public static void Color3xvOES(int* components)
		{
			Color3xvOESNative(components);
		}

		public static void Color3xvOES(ref int components)
		{
			fixed (int* pcomponents0 = &components)
			{
				Color3xvOESNative(pcomponents0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4xOESNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[10])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[10])(red, green, blue, alpha);
			#endif
		}

		public static void Color4xOES(int red, int green, int blue, int alpha)
		{
			Color4xOESNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4xvOESNative(int* components)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[11])(components);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[11])((nint)components);
			#endif
		}

		public static void Color4xvOES(int* components)
		{
			Color4xvOESNative(components);
		}

		public static void Color4xvOES(ref int components)
		{
			fixed (int* pcomponents0 = &components)
			{
				Color4xvOESNative(pcomponents0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterxOESNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int, void>)funcTable[12])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int, void>)funcTable[12])(target, pname, param);
			#endif
		}

		public static void ConvolutionParameterxOES(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int param)
		{
			ConvolutionParameterxOESNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterxvOESNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int*, void>)funcTable[13])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[13])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameterxvOES(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			ConvolutionParameterxvOESNative(target, pname, @params);
		}

		public static void ConvolutionParameterxvOES(GLConvolutionTargetEXT target, GLConvolutionParameter pname, out int @params)
		{
			int pparams;
			ConvolutionParameterxvOESNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void ConvolutionParameterxvOES(GLConvolutionTargetEXT target, GLConvolutionParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				ConvolutionParameterxvOESNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangexOESNative(int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[14])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[14])(n, f);
			#endif
		}

		public static void DepthRangexOES(int n, int f)
		{
			DepthRangexOESNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1xOESNative(int u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[15])(u);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[15])(u);
			#endif
		}

		public static void EvalCoord1xOES(int u)
		{
			EvalCoord1xOESNative(u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[16])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[16])((nint)coords);
			#endif
		}

		public static void EvalCoord1xvOES(int* coords)
		{
			EvalCoord1xvOESNative(coords);
		}

		public static void EvalCoord1xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				EvalCoord1xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2xOESNative(int u, int v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[17])(u, v);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[17])(u, v);
			#endif
		}

		public static void EvalCoord2xOES(int u, int v)
		{
			EvalCoord2xOESNative(u, v);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[18])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[18])((nint)coords);
			#endif
		}

		public static void EvalCoord2xvOES(int* coords)
		{
			EvalCoord2xvOESNative(coords);
		}

		public static void EvalCoord2xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				EvalCoord2xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FeedbackBufferxOESNative(int n, GLEnum type, int* buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLEnum, int*, void>)funcTable[19])(n, type, buffer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLEnum, nint, void>)funcTable[19])(n, type, (nint)buffer);
			#endif
		}

		public static void FeedbackBufferxOES(int n, GLEnum type, int* buffer)
		{
			FeedbackBufferxOESNative(n, type, buffer);
		}

		public static void FeedbackBufferxOES(int n, GLEnum type, ref int buffer)
		{
			fixed (int* pbuffer0 = &buffer)
			{
				FeedbackBufferxOESNative(n, type, pbuffer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogxOESNative(GLFogPName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogPName, int, void>)funcTable[20])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogPName, int, void>)funcTable[20])(pname, param);
			#endif
		}

		public static void FogxOES(GLFogPName pname, int param)
		{
			FogxOESNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogxvOESNative(GLFogPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogPName, int*, void>)funcTable[21])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogPName, nint, void>)funcTable[21])(pname, (nint)param);
			#endif
		}

		public static void FogxvOES(GLFogPName pname, int* param)
		{
			FogxvOESNative(pname, param);
		}

		public static void FogxvOES(GLFogPName pname, out int param)
		{
			int pparam;
			FogxvOESNative(pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrustumxOESNative(int l, int r, int b, int t, int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[22])(l, r, b, t, n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[22])(l, r, b, t, n, f);
			#endif
		}

		public static void FrustumxOES(int l, int r, int b, int t, int n, int f)
		{
			FrustumxOESNative(l, r, b, t, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetClipPlanexOESNative(GLClipPlaneName plane, int* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, int*, void>)funcTable[23])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[23])(plane, (nint)equation);
			#endif
		}

		public static void GetClipPlanexOES(GLClipPlaneName plane, int* equation)
		{
			GetClipPlanexOESNative(plane, equation);
		}

		public static void GetClipPlanexOES(GLClipPlaneName plane, ref int equation)
		{
			fixed (int* pequation0 = &equation)
			{
				GetClipPlanexOESNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterxvOESNative(GLEnum target, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, int*, void>)funcTable[24])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, nint, void>)funcTable[24])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameterxvOES(GLEnum target, GLEnum pname, int* @params)
		{
			GetConvolutionParameterxvOESNative(target, pname, @params);
		}

		public static void GetConvolutionParameterxvOES(GLEnum target, GLEnum pname, out int @params)
		{
			int pparams;
			GetConvolutionParameterxvOESNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetConvolutionParameterxvOES(GLEnum target, GLEnum pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetConvolutionParameterxvOESNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFixedvOESNative(GLGetPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, int*, void>)funcTable[25])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[25])(pname, (nint)@params);
			#endif
		}

		public static void GetFixedvOES(GLGetPName pname, int* @params)
		{
			GetFixedvOESNative(pname, @params);
		}

		public static void GetFixedvOES(GLGetPName pname, out int @params)
		{
			int pparams;
			GetFixedvOESNative(pname, &pparams);
			@params = pparams;
		}

		public static void GetFixedvOES(GLGetPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetFixedvOESNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterxvOESNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, int*, void>)funcTable[26])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[26])(target, pname, (nint)@params);
			#endif
		}

		public static void GetHistogramParameterxvOES(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			GetHistogramParameterxvOESNative(target, pname, @params);
		}

		public static void GetHistogramParameterxvOES(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, out int @params)
		{
			int pparams;
			GetHistogramParameterxvOESNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetHistogramParameterxvOES(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetHistogramParameterxvOESNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightxOESNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[27])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[27])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightxOES(GLLightName light, GLLightParameter pname, int* @params)
		{
			GetLightxOESNative(light, pname, @params);
		}

		public static void GetLightxOES(GLLightName light, GLLightParameter pname, out int @params)
		{
			int pparams;
			GetLightxOESNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void GetLightxOES(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetLightxOESNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightxvOESNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[28])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[28])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightxvOES(GLLightName light, GLLightParameter pname, int* @params)
		{
			GetLightxvOESNative(light, pname, @params);
		}

		public static void GetLightxvOES(GLLightName light, GLLightParameter pname, out int @params)
		{
			int pparams;
			GetLightxvOESNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void GetLightxvOES(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetLightxvOESNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapxvOESNative(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, int*, void>)funcTable[29])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[29])(target, query, (nint)v);
			#endif
		}

		public static void GetMapxvOES(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			GetMapxvOESNative(target, query, v);
		}

		public static void GetMapxvOES(GLMapTarget target, GLGetMapQuery query, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				GetMapxvOESNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialxOESNative(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[30])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[30])(face, pname, param);
			#endif
		}

		public static void GetMaterialxOES(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			GetMaterialxOESNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialxvOESNative(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[31])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[31])(face, pname, (nint)@params);
			#endif
		}

		public static void GetMaterialxvOES(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			GetMaterialxvOESNative(face, pname, @params);
		}

		public static void GetMaterialxvOES(GLTriangleFace face, GLMaterialParameter pname, out int @params)
		{
			int pparams;
			GetMaterialxvOESNative(face, pname, &pparams);
			@params = pparams;
		}

		public static void GetMaterialxvOES(GLTriangleFace face, GLMaterialParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMaterialxvOESNative(face, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapxvNative(GLPixelMap map, int size, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, int*, void>)funcTable[32])(map, size, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[32])(map, size, (nint)values);
			#endif
		}

		public static void GetPixelMapxv(GLPixelMap map, int size, int* values)
		{
			GetPixelMapxvNative(map, size, values);
		}

		public static void GetPixelMapxv(GLPixelMap map, int size, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetPixelMapxvNative(map, size, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvxvOESNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[33])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[33])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexEnvxvOES(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetTexEnvxvOESNative(target, pname, @params);
		}

		public static void GetTexEnvxvOES(GLTextureEnvTarget target, GLTextureEnvParameter pname, out int @params)
		{
			int pparams;
			GetTexEnvxvOESNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexEnvxvOES(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexEnvxvOESNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGenxvOESNative(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[34])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[34])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGenxvOES(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			GetTexGenxvOESNative(coord, pname, @params);
		}

		public static void GetTexGenxvOES(GLTextureCoordName coord, GLTextureGenParameter pname, out int @params)
		{
			int pparams;
			GetTexGenxvOESNative(coord, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexGenxvOES(GLTextureCoordName coord, GLTextureGenParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexGenxvOESNative(coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterxvOESNative(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[35])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[35])(target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTexLevelParameterxvOES(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTexLevelParameterxvOESNative(target, level, pname, @params);
		}

		public static void GetTexLevelParameterxvOES(GLTextureTarget target, int level, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexLevelParameterxvOESNative(target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexLevelParameterxvOES(GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexLevelParameterxvOESNative(target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterxvOESNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[36])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[36])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterxvOES(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterxvOESNative(target, pname, @params);
		}

		public static void GetTexParameterxvOES(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexParameterxvOESNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexParameterxvOES(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexParameterxvOESNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexxOESNative(int component)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[37])(component);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[37])(component);
			#endif
		}

		public static void IndexxOES(int component)
		{
			IndexxOESNative(component);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexxvOESNative(int* component)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[38])(component);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[38])((nint)component);
			#endif
		}

		public static void IndexxvOES(int* component)
		{
			IndexxvOESNative(component);
		}

		public static void IndexxvOES(ref int component)
		{
			fixed (int* pcomponent0 = &component)
			{
				IndexxvOESNative(pcomponent0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelxOESNative(GLLightModelParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[39])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[39])(pname, param);
			#endif
		}

		public static void LightModelxOES(GLLightModelParameter pname, int param)
		{
			LightModelxOESNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelxvOESNative(GLLightModelParameter pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int*, void>)funcTable[40])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[40])(pname, (nint)param);
			#endif
		}

		public static void LightModelxvOES(GLLightModelParameter pname, int* param)
		{
			LightModelxvOESNative(pname, param);
		}

		public static void LightModelxvOES(GLLightModelParameter pname, out int param)
		{
			int pparam;
			LightModelxvOESNative(pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightxOESNative(GLLightName light, GLLightParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[41])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[41])(light, pname, param);
			#endif
		}

		public static void LightxOES(GLLightName light, GLLightParameter pname, int param)
		{
			LightxOESNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightxvOESNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[42])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[42])(light, pname, (nint)@params);
			#endif
		}

		public static void LightxvOES(GLLightName light, GLLightParameter pname, int* @params)
		{
			LightxvOESNative(light, pname, @params);
		}

		public static void LightxvOES(GLLightName light, GLLightParameter pname, out int @params)
		{
			int pparams;
			LightxvOESNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void LightxvOES(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				LightxvOESNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineWidthxOESNative(int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[43])(width);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[43])(width);
			#endif
		}

		public static void LineWidthxOES(int width)
		{
			LineWidthxOESNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadMatrixxOESNative(int* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[44])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[44])((nint)m);
			#endif
		}

		public static void LoadMatrixxOES(int* m)
		{
			LoadMatrixxOESNative(m);
		}

		public static void LoadMatrixxOES(ref int m)
		{
			fixed (int* pm0 = &m)
			{
				LoadMatrixxOESNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixxOESNative(int* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[45])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[45])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixxOES(int* m)
		{
			LoadTransposeMatrixxOESNative(m);
		}

		public static void LoadTransposeMatrixxOES(ref int m)
		{
			fixed (int* pm0 = &m)
			{
				LoadTransposeMatrixxOESNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map1xOESNative(GLMapTarget target, int u1, int u2, int stride, int order, int points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, int, int, int, int, int, void>)funcTable[46])(target, u1, u2, stride, order, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, int, int, int, int, int, void>)funcTable[46])(target, u1, u2, stride, order, points);
			#endif
		}

		public static void Map1xOES(GLMapTarget target, int u1, int u2, int stride, int order, int points)
		{
			Map1xOESNative(target, u1, u2, stride, order, points);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map2xOESNative(GLMapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, int, int, int, int, int, int, int, int, int, void>)funcTable[47])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, int, int, int, int, int, int, int, int, int, void>)funcTable[47])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#endif
		}

		public static void Map2xOES(GLMapTarget target, int u1, int u2, int ustride, int uorder, int v1, int v2, int vstride, int vorder, int points)
		{
			Map2xOESNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid1xOESNative(int n, int u1, int u2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[48])(n, u1, u2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[48])(n, u1, u2);
			#endif
		}

		public static void MapGrid1xOES(int n, int u1, int u2)
		{
			MapGrid1xOESNative(n, u1, u2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid2xOESNative(int n, int u1, int u2, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[49])(n, u1, u2, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[49])(n, u1, u2, v1, v2);
			#endif
		}

		public static void MapGrid2xOES(int n, int u1, int u2, int v1, int v2)
		{
			MapGrid2xOESNative(n, u1, u2, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialxOESNative(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[50])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[50])(face, pname, param);
			#endif
		}

		public static void MaterialxOES(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			MaterialxOESNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialxvOESNative(GLTriangleFace face, GLMaterialParameter pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[51])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[51])(face, pname, (nint)param);
			#endif
		}

		public static void MaterialxvOES(GLTriangleFace face, GLMaterialParameter pname, int* param)
		{
			MaterialxvOESNative(face, pname, param);
		}

		public static void MaterialxvOES(GLTriangleFace face, GLMaterialParameter pname, out int param)
		{
			int pparam;
			MaterialxvOESNative(face, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultMatrixxOESNative(int* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[52])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[52])((nint)m);
			#endif
		}

		public static void MultMatrixxOES(int* m)
		{
			MultMatrixxOESNative(m);
		}

		public static void MultMatrixxOES(ref int m)
		{
			fixed (int* pm0 = &m)
			{
				MultMatrixxOESNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultTransposeMatrixxOESNative(int* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[53])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[53])((nint)m);
			#endif
		}

		public static void MultTransposeMatrixxOES(int* m)
		{
			MultTransposeMatrixxOESNative(m);
		}

		public static void MultTransposeMatrixxOES(ref int m)
		{
			fixed (int* pm0 = &m)
			{
				MultTransposeMatrixxOESNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1xOESNative(GLTextureUnit texture, int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[54])(texture, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[54])(texture, s);
			#endif
		}

		public static void MultiTexCoord1xOES(GLTextureUnit texture, int s)
		{
			MultiTexCoord1xOESNative(texture, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1xvOESNative(GLTextureUnit texture, int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[55])(texture, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[55])(texture, (nint)coords);
			#endif
		}

		public static void MultiTexCoord1xvOES(GLTextureUnit texture, int* coords)
		{
			MultiTexCoord1xvOESNative(texture, coords);
		}

		public static void MultiTexCoord1xvOES(GLTextureUnit texture, ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				MultiTexCoord1xvOESNative(texture, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2xOESNative(GLTextureUnit texture, int s, int t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[56])(texture, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[56])(texture, s, t);
			#endif
		}

		public static void MultiTexCoord2xOES(GLTextureUnit texture, int s, int t)
		{
			MultiTexCoord2xOESNative(texture, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2xvOESNative(GLTextureUnit texture, int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[57])(texture, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[57])(texture, (nint)coords);
			#endif
		}

		public static void MultiTexCoord2xvOES(GLTextureUnit texture, int* coords)
		{
			MultiTexCoord2xvOESNative(texture, coords);
		}

		public static void MultiTexCoord2xvOES(GLTextureUnit texture, ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				MultiTexCoord2xvOESNative(texture, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3xOESNative(GLTextureUnit texture, int s, int t, int r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[58])(texture, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[58])(texture, s, t, r);
			#endif
		}

		public static void MultiTexCoord3xOES(GLTextureUnit texture, int s, int t, int r)
		{
			MultiTexCoord3xOESNative(texture, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3xvOESNative(GLTextureUnit texture, int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[59])(texture, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[59])(texture, (nint)coords);
			#endif
		}

		public static void MultiTexCoord3xvOES(GLTextureUnit texture, int* coords)
		{
			MultiTexCoord3xvOESNative(texture, coords);
		}

		public static void MultiTexCoord3xvOES(GLTextureUnit texture, ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				MultiTexCoord3xvOESNative(texture, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4xOESNative(GLTextureUnit texture, int s, int t, int r, int q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[60])(texture, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[60])(texture, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4xOES(GLTextureUnit texture, int s, int t, int r, int q)
		{
			MultiTexCoord4xOESNative(texture, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4xvOESNative(GLTextureUnit texture, int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[61])(texture, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[61])(texture, (nint)coords);
			#endif
		}

		public static void MultiTexCoord4xvOES(GLTextureUnit texture, int* coords)
		{
			MultiTexCoord4xvOESNative(texture, coords);
		}

		public static void MultiTexCoord4xvOES(GLTextureUnit texture, ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				MultiTexCoord4xvOESNative(texture, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3xOESNative(int nx, int ny, int nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[62])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[62])(nx, ny, nz);
			#endif
		}

		public static void Normal3xOES(int nx, int ny, int nz)
		{
			Normal3xOESNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[63])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[63])((nint)coords);
			#endif
		}

		public static void Normal3xvOES(int* coords)
		{
			Normal3xvOESNative(coords);
		}

		public static void Normal3xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				Normal3xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OrthoxOESNative(int l, int r, int b, int t, int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[64])(l, r, b, t, n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[64])(l, r, b, t, n, f);
			#endif
		}

		public static void OrthoxOES(int l, int r, int b, int t, int n, int f)
		{
			OrthoxOESNative(l, r, b, t, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PassThroughxOESNative(int token)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[65])(token);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[65])(token);
			#endif
		}

		public static void PassThroughxOES(int token)
		{
			PassThroughxOESNative(token);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelMapxNative(GLPixelMap map, int size, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, int*, void>)funcTable[66])(map, size, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[66])(map, size, (nint)values);
			#endif
		}

		public static void PixelMapx(GLPixelMap map, int size, int* values)
		{
			PixelMapxNative(map, size, values);
		}

		public static void PixelMapx(GLPixelMap map, int size, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				PixelMapxNative(map, size, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelStorexNative(GLPixelStoreParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[67])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[67])(pname, param);
			#endif
		}

		public static void PixelStorex(GLPixelStoreParameter pname, int param)
		{
			PixelStorexNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelTransferxOESNative(GLPixelTransferParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, int, void>)funcTable[68])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, int, void>)funcTable[68])(pname, param);
			#endif
		}

		public static void PixelTransferxOES(GLPixelTransferParameter pname, int param)
		{
			PixelTransferxOESNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelZoomxOESNative(int xfactor, int yfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[69])(xfactor, yfactor);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[69])(xfactor, yfactor);
			#endif
		}

		public static void PixelZoomxOES(int xfactor, int yfactor)
		{
			PixelZoomxOESNative(xfactor, yfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterxOESNative(GLPointParameterNameARB pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[70])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[70])(pname, param);
			#endif
		}

		public static void PointParameterxOES(GLPointParameterNameARB pname, int param)
		{
			PointParameterxOESNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterxvOESNative(GLPointParameterNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int*, void>)funcTable[71])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[71])(pname, (nint)@params);
			#endif
		}

		public static void PointParameterxvOES(GLPointParameterNameARB pname, int* @params)
		{
			PointParameterxvOESNative(pname, @params);
		}

		public static void PointParameterxvOES(GLPointParameterNameARB pname, out int @params)
		{
			int pparams;
			PointParameterxvOESNative(pname, &pparams);
			@params = pparams;
		}

		public static void PointParameterxvOES(GLPointParameterNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				PointParameterxvOESNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointSizexOESNative(int size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[72])(size);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[72])(size);
			#endif
		}

		public static void PointSizexOES(int size)
		{
			PointSizexOESNative(size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonOffsetxOESNative(int factor, int units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[73])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[73])(factor, units);
			#endif
		}

		public static void PolygonOffsetxOES(int factor, int units)
		{
			PolygonOffsetxOESNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PrioritizeTexturesxOESNative(int n, uint* textures, int* priorities)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, int*, void>)funcTable[74])(n, textures, priorities);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, nint, void>)funcTable[74])(n, (nint)textures, (nint)priorities);
			#endif
		}

		public static void PrioritizeTexturesxOES(int n, uint* textures, int* priorities)
		{
			PrioritizeTexturesxOESNative(n, textures, priorities);
		}

		public static void PrioritizeTexturesxOES(int n, ref uint textures, int* priorities)
		{
			fixed (uint* ptextures0 = &textures)
			{
				PrioritizeTexturesxOESNative(n, ptextures0, priorities);
			}
		}

		public static void PrioritizeTexturesxOES(int n, uint* textures, ref int priorities)
		{
			fixed (int* ppriorities0 = &priorities)
			{
				PrioritizeTexturesxOESNative(n, textures, ppriorities0);
			}
		}

		public static void PrioritizeTexturesxOES(int n, ref uint textures, ref int priorities)
		{
			fixed (uint* ptextures0 = &textures)
			{
				fixed (int* ppriorities1 = &priorities)
				{
					PrioritizeTexturesxOESNative(n, ptextures0, ppriorities1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2xOESNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[75])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[75])(x, y);
			#endif
		}

		public static void RasterPos2xOES(int x, int y)
		{
			RasterPos2xOESNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[76])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[76])((nint)coords);
			#endif
		}

		public static void RasterPos2xvOES(int* coords)
		{
			RasterPos2xvOESNative(coords);
		}

		public static void RasterPos2xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				RasterPos2xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3xOESNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[77])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[77])(x, y, z);
			#endif
		}

		public static void RasterPos3xOES(int x, int y, int z)
		{
			RasterPos3xOESNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[78])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[78])((nint)coords);
			#endif
		}

		public static void RasterPos3xvOES(int* coords)
		{
			RasterPos3xvOESNative(coords);
		}

		public static void RasterPos3xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				RasterPos3xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4xOESNative(int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[79])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[79])(x, y, z, w);
			#endif
		}

		public static void RasterPos4xOES(int x, int y, int z, int w)
		{
			RasterPos4xOESNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[80])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[80])((nint)coords);
			#endif
		}

		public static void RasterPos4xvOES(int* coords)
		{
			RasterPos4xvOESNative(coords);
		}

		public static void RasterPos4xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				RasterPos4xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectxOESNative(int x1, int y1, int x2, int y2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[81])(x1, y1, x2, y2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[81])(x1, y1, x2, y2);
			#endif
		}

		public static void RectxOES(int x1, int y1, int x2, int y2)
		{
			RectxOESNative(x1, y1, x2, y2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectxvOESNative(int* v1, int* v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, int*, void>)funcTable[82])(v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[82])((nint)v1, (nint)v2);
			#endif
		}

		public static void RectxvOES(int* v1, int* v2)
		{
			RectxvOESNative(v1, v2);
		}

		public static void RectxvOES(ref int v1, int* v2)
		{
			fixed (int* pv10 = &v1)
			{
				RectxvOESNative(pv10, v2);
			}
		}

		public static void RectxvOES(int* v1, ref int v2)
		{
			fixed (int* pv20 = &v2)
			{
				RectxvOESNative(v1, pv20);
			}
		}

		public static void RectxvOES(ref int v1, ref int v2)
		{
			fixed (int* pv10 = &v1)
			{
				fixed (int* pv21 = &v2)
				{
					RectxvOESNative(pv10, pv21);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RotatexOESNative(int angle, int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[83])(angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[83])(angle, x, y, z);
			#endif
		}

		public static void RotatexOES(int angle, int x, int y, int z)
		{
			RotatexOESNative(angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SampleCoveragexOESNative(int value, byte invert)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte, void>)funcTable[84])(value, invert);
			#else
			((delegate* unmanaged[Cdecl]<int, byte, void>)funcTable[84])(value, invert);
			#endif
		}

		public static void SampleCoveragexOES(int value, byte invert)
		{
			SampleCoveragexOESNative(value, invert);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScalexOESNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[85])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[85])(x, y, z);
			#endif
		}

		public static void ScalexOES(int x, int y, int z)
		{
			ScalexOESNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord1xOESNative(int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[86])(s);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[86])(s);
			#endif
		}

		public static void TexCoord1xOES(int s)
		{
			TexCoord1xOESNative(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord1xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[87])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[87])((nint)coords);
			#endif
		}

		public static void TexCoord1xvOES(int* coords)
		{
			TexCoord1xvOESNative(coords);
		}

		public static void TexCoord1xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				TexCoord1xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord2xOESNative(int s, int t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[88])(s, t);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[88])(s, t);
			#endif
		}

		public static void TexCoord2xOES(int s, int t)
		{
			TexCoord2xOESNative(s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord2xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[89])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[89])((nint)coords);
			#endif
		}

		public static void TexCoord2xvOES(int* coords)
		{
			TexCoord2xvOESNative(coords);
		}

		public static void TexCoord2xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				TexCoord2xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord3xOESNative(int s, int t, int r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[90])(s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[90])(s, t, r);
			#endif
		}

		public static void TexCoord3xOES(int s, int t, int r)
		{
			TexCoord3xOESNative(s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord3xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[91])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[91])((nint)coords);
			#endif
		}

		public static void TexCoord3xvOES(int* coords)
		{
			TexCoord3xvOESNative(coords);
		}

		public static void TexCoord3xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				TexCoord3xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord4xOESNative(int s, int t, int r, int q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[92])(s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[92])(s, t, r, q);
			#endif
		}

		public static void TexCoord4xOES(int s, int t, int r, int q)
		{
			TexCoord4xOESNative(s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord4xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[93])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[93])((nint)coords);
			#endif
		}

		public static void TexCoord4xvOES(int* coords)
		{
			TexCoord4xvOESNative(coords);
		}

		public static void TexCoord4xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				TexCoord4xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexEnvxOESNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[94])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[94])(target, pname, param);
			#endif
		}

		public static void TexEnvxOES(GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			TexEnvxOESNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexEnvxvOESNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[95])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[95])(target, pname, (nint)@params);
			#endif
		}

		public static void TexEnvxvOES(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			TexEnvxvOESNative(target, pname, @params);
		}

		public static void TexEnvxvOES(GLTextureEnvTarget target, GLTextureEnvParameter pname, out int @params)
		{
			int pparams;
			TexEnvxvOESNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void TexEnvxvOES(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TexEnvxvOESNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexGenxOESNative(GLTextureCoordName coord, GLTextureGenParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, int, void>)funcTable[96])(coord, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, int, void>)funcTable[96])(coord, pname, param);
			#endif
		}

		public static void TexGenxOES(GLTextureCoordName coord, GLTextureGenParameter pname, int param)
		{
			TexGenxOESNative(coord, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexGenxvOESNative(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[97])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[97])(coord, pname, (nint)@params);
			#endif
		}

		public static void TexGenxvOES(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			TexGenxvOESNative(coord, pname, @params);
		}

		public static void TexGenxvOES(GLTextureCoordName coord, GLTextureGenParameter pname, out int @params)
		{
			int pparams;
			TexGenxvOESNative(coord, pname, &pparams);
			@params = pparams;
		}

		public static void TexGenxvOES(GLTextureCoordName coord, GLTextureGenParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TexGenxvOESNative(coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterxOESNative(GLTextureTarget target, GLGetTextureParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int, void>)funcTable[98])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int, void>)funcTable[98])(target, pname, param);
			#endif
		}

		public static void TexParameterxOES(GLTextureTarget target, GLGetTextureParameter pname, int param)
		{
			TexParameterxOESNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterxvOESNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[99])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[99])(target, pname, (nint)@params);
			#endif
		}

		public static void TexParameterxvOES(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			TexParameterxvOESNative(target, pname, @params);
		}

		public static void TexParameterxvOES(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			TexParameterxvOESNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void TexParameterxvOES(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TexParameterxvOESNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TranslatexOESNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[100])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[100])(x, y, z);
			#endif
		}

		public static void TranslatexOES(int x, int y, int z)
		{
			TranslatexOESNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2xOESNative(int x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[101])(x);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[101])(x);
			#endif
		}

		public static void Vertex2xOES(int x)
		{
			Vertex2xOESNative(x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[102])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[102])((nint)coords);
			#endif
		}

		public static void Vertex2xvOES(int* coords)
		{
			Vertex2xvOESNative(coords);
		}

		public static void Vertex2xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				Vertex2xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3xOESNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[103])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[103])(x, y);
			#endif
		}

		public static void Vertex3xOES(int x, int y)
		{
			Vertex3xOESNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[104])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[104])((nint)coords);
			#endif
		}

		public static void Vertex3xvOES(int* coords)
		{
			Vertex3xvOESNative(coords);
		}

		public static void Vertex3xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				Vertex3xvOESNative(pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4xOESNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[105])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[105])(x, y, z);
			#endif
		}

		public static void Vertex4xOES(int x, int y, int z)
		{
			Vertex4xOESNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4xvOESNative(int* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[106])(coords);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[106])((nint)coords);
			#endif
		}

		public static void Vertex4xvOES(int* coords)
		{
			Vertex4xvOESNative(coords);
		}

		public static void Vertex4xvOES(ref int coords)
		{
			fixed (int* pcoords0 = &coords)
			{
				Vertex4xvOESNative(pcoords0);
			}
		}

	}
}
