// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AccumNative(GLAccumOp op, float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAccumOp, float, void>)funcTable[0])(op, value);
			#else
			((delegate* unmanaged[Cdecl]<GLAccumOp, float, void>)funcTable[0])(op, value);
			#endif
		}

		public static void Accum(GLAccumOp op, float value)
		{
			AccumNative(op, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#endif
		}

		public static void ActiveTexture(GLTextureUnit texture)
		{
			ActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AlphaFuncNative(GLAlphaFunction func, float reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#endif
		}

		public static void AlphaFunc(GLAlphaFunction func, float reference)
		{
			AlphaFuncNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AreTexturesResidentNative(int n, uint* textures, byte* residences)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint*, byte*, byte>)funcTable[3])(n, textures, residences);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, nint, nint, byte>)funcTable[3])(n, (nint)textures, (nint)residences);
			#endif
		}

		public static bool AreTexturesResident(int n, uint* textures, byte* residences)
		{
			byte ret = AreTexturesResidentNative(n, textures, residences);
			return ret != 0;
		}

		public static bool AreTexturesResident(int n, ref uint textures, byte* residences)
		{
			fixed (uint* ptextures0 = &textures)
			{
				byte ret = AreTexturesResidentNative(n, ptextures0, residences);
				return ret != 0;
			}
		}

		public static bool AreTexturesResident(int n, uint* textures, string residences)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (residences != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(residences);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(residences, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = AreTexturesResidentNative(n, textures, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool AreTexturesResident(int n, uint* textures, ReadOnlySpan<byte> residences)
		{
			fixed (byte* presidences0 = residences)
			{
				byte ret = AreTexturesResidentNative(n, textures, presidences0);
				return ret != 0;
			}
		}

		public static bool AreTexturesResident(int n, uint* textures, ref byte residences)
		{
			fixed (byte* presidences0 = &residences)
			{
				byte ret = AreTexturesResidentNative(n, textures, presidences0);
				return ret != 0;
			}
		}

		public static bool AreTexturesResident(int n, ref uint textures, ref byte residences)
		{
			fixed (uint* ptextures0 = &textures)
			{
				fixed (byte* presidences1 = &residences)
				{
					byte ret = AreTexturesResidentNative(n, ptextures0, presidences1);
					return ret != 0;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ArrayElementNative(int i)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[4])(i);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[4])(i);
			#endif
		}

		public static void ArrayElement(int i)
		{
			ArrayElementNative(i);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AttachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[5])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[5])(program, shader);
			#endif
		}

		public static void AttachShader(uint program, uint shader)
		{
			AttachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginNative(GLPrimitiveType mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[6])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[6])(mode);
			#endif
		}

		public static void Begin(GLPrimitiveType mode)
		{
			BeginNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryNative(GLQueryTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[7])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[7])(target, id);
			#endif
		}

		public static void BeginQuery(GLQueryTarget target, uint id)
		{
			BeginQueryNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindAttribLocationNative(uint program, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[8])(program, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[8])(program, index, (nint)name);
			#endif
		}

		public static void BindAttribLocation(uint program, uint index, byte* name)
		{
			BindAttribLocationNative(program, index, name);
		}

		public static void BindAttribLocation(uint program, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindAttribLocationNative(program, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindAttribLocation(uint program, uint index, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		public static void BindAttribLocation(uint program, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferNative(GLBufferTargetARB target, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[9])(target, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[9])(target, buffer);
			#endif
		}

		public static void BindBuffer(GLBufferTargetARB target, uint buffer)
		{
			BindBufferNative(target, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTextureNative(GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[10])(target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[10])(target, texture);
			#endif
		}

		public static void BindTexture(GLTextureTarget target, uint texture)
		{
			BindTextureNative(target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BitmapNative(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float, float, float, float, byte*, void>)funcTable[11])(width, height, xorig, yorig, xmove, ymove, bitmap);
			#else
			((delegate* unmanaged[Cdecl]<int, int, float, float, float, float, nint, void>)funcTable[11])(width, height, xorig, yorig, xmove, ymove, (nint)bitmap);
			#endif
		}

		public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap)
		{
			BitmapNative(width, height, xorig, yorig, xmove, ymove, bitmap);
		}

		public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, string bitmap)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (bitmap != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(bitmap);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(bitmap, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BitmapNative(width, height, xorig, yorig, xmove, ymove, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, ReadOnlySpan<byte> bitmap)
		{
			fixed (byte* pbitmap0 = bitmap)
			{
				BitmapNative(width, height, xorig, yorig, xmove, ymove, pbitmap0);
			}
		}

		public static void Bitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, ref byte bitmap)
		{
			fixed (byte* pbitmap0 = &bitmap)
			{
				BitmapNative(width, height, xorig, yorig, xmove, ymove, pbitmap0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[12])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[12])(red, green, blue, alpha);
			#endif
		}

		public static void BlendColor(float red, float green, float blue, float alpha)
		{
			BlendColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[13])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[13])(mode);
			#endif
		}

		public static void BlendEquation(GLBlendEquationModeEXT mode)
		{
			BlendEquationNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateNative(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[14])(modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[14])(modeRGB, modeAlpha);
			#endif
		}

		public static void BlendEquationSeparate(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateNative(modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncNative(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[15])(sfactor, dfactor);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[15])(sfactor, dfactor);
			#endif
		}

		public static void BlendFunc(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			BlendFuncNative(sfactor, dfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateNative(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[16])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[16])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#endif
		}

		public static void BlendFuncSeparate(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			BlendFuncSeparateNative(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferDataNative(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, void*, GLBufferUsageARB, void>)funcTable[17])(target, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLBufferUsageARB, void>)funcTable[17])(target, size, (nint)data, usage);
			#endif
		}

		public static void BufferData(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			BufferDataNative(target, size, data, usage);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[18])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[18])(target, offset, size, (nint)data);
			#endif
		}

		public static void BufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			BufferSubDataNative(target, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CallListNative(uint list)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[19])(list);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[19])(list);
			#endif
		}

		public static void CallList(uint list)
		{
			CallListNative(list);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CallListsNative(int n, GLListNameType type, void* lists)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLListNameType, void*, void>)funcTable[20])(n, type, lists);
			#else
			((delegate* unmanaged[Cdecl]<int, GLListNameType, nint, void>)funcTable[20])(n, type, (nint)lists);
			#endif
		}

		public static void CallLists(int n, GLListNameType type, void* lists)
		{
			CallListsNative(n, type, lists);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNative(GLClearBufferMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[21])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[21])(mask);
			#endif
		}

		public static void Clear(GLClearBufferMask mask)
		{
			ClearNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearAccumNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[22])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[22])(red, green, blue, alpha);
			#endif
		}

		public static void ClearAccum(float red, float green, float blue, float alpha)
		{
			ClearAccumNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[23])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[23])(red, green, blue, alpha);
			#endif
		}

		public static void ClearColor(float red, float green, float blue, float alpha)
		{
			ClearColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthNative(double depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[24])(depth);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[24])(depth);
			#endif
		}

		public static void ClearDepth(double depth)
		{
			ClearDepthNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearIndexNative(float c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[25])(c);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[25])(c);
			#endif
		}

		public static void ClearIndex(float c)
		{
			ClearIndexNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearStencilNative(int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[26])(s);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[26])(s);
			#endif
		}

		public static void ClearStencil(int s)
		{
			ClearStencilNative(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[27])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[27])(texture);
			#endif
		}

		public static void ClientActiveTexture(GLTextureUnit texture)
		{
			ClientActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipPlaneNative(GLClipPlaneName plane, double* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, double*, void>)funcTable[28])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[28])(plane, (nint)equation);
			#endif
		}

		public static void ClipPlane(GLClipPlaneName plane, double* equation)
		{
			ClipPlaneNative(plane, equation);
		}

		public static void ClipPlane(GLClipPlaneName plane, ref double equation)
		{
			fixed (double* pequation0 = &equation)
			{
				ClipPlaneNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3bNative(sbyte red, sbyte green, sbyte blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[29])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[29])(red, green, blue);
			#endif
		}

		public static void Color3b(sbyte red, sbyte green, sbyte blue)
		{
			Color3bNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3bvNative(sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte*, void>)funcTable[30])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[30])((nint)v);
			#endif
		}

		public static void Color3bv(sbyte* v)
		{
			Color3bvNative(v);
		}

		public static void Color3bv(ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				Color3bvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3dNative(double red, double green, double blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[31])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[31])(red, green, blue);
			#endif
		}

		public static void Color3d(double red, double green, double blue)
		{
			Color3dNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[32])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[32])((nint)v);
			#endif
		}

		public static void Color3dv(double* v)
		{
			Color3dvNative(v);
		}

		public static void Color3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Color3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3fNative(float red, float green, float blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[33])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[33])(red, green, blue);
			#endif
		}

		public static void Color3f(float red, float green, float blue)
		{
			Color3fNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[34])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[34])((nint)v);
			#endif
		}

		public static void Color3fv(float* v)
		{
			Color3fvNative(v);
		}

		public static void Color3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Color3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3iNative(int red, int green, int blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[35])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[35])(red, green, blue);
			#endif
		}

		public static void Color3i(int red, int green, int blue)
		{
			Color3iNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[36])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[36])((nint)v);
			#endif
		}

		public static void Color3iv(int* v)
		{
			Color3ivNative(v);
		}

		public static void Color3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Color3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3sNative(short red, short green, short blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[37])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[37])(red, green, blue);
			#endif
		}

		public static void Color3s(short red, short green, short blue)
		{
			Color3sNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[38])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[38])((nint)v);
			#endif
		}

		public static void Color3sv(short* v)
		{
			Color3svNative(v);
		}

		public static void Color3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Color3svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3ubNative(byte red, byte green, byte blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, void>)funcTable[39])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, void>)funcTable[39])(red, green, blue);
			#endif
		}

		public static void Color3ub(byte red, byte green, byte blue)
		{
			Color3ubNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3ubvNative(byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[40])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[40])((nint)v);
			#endif
		}

		public static void Color3ubv(byte* v)
		{
			Color3ubvNative(v);
		}

		public static void Color3ubv(string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Color3ubvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Color3ubv(ReadOnlySpan<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				Color3ubvNative(pv0);
			}
		}

		public static void Color3ubv(ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				Color3ubvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3uiNative(uint red, uint green, uint blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[41])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[41])(red, green, blue);
			#endif
		}

		public static void Color3ui(uint red, uint green, uint blue)
		{
			Color3uiNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3uivNative(uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, void>)funcTable[42])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[42])((nint)v);
			#endif
		}

		public static void Color3uiv(uint* v)
		{
			Color3uivNative(v);
		}

		public static void Color3uiv(ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				Color3uivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3usNative(ushort red, ushort green, ushort blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, void>)funcTable[43])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, void>)funcTable[43])(red, green, blue);
			#endif
		}

		public static void Color3us(ushort red, ushort green, ushort blue)
		{
			Color3usNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color3usvNative(ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort*, void>)funcTable[44])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[44])((nint)v);
			#endif
		}

		public static void Color3usv(ushort* v)
		{
			Color3usvNative(v);
		}

		public static void Color3usv(ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				Color3usvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4bNative(sbyte red, sbyte green, sbyte blue, sbyte alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte, void>)funcTable[45])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, sbyte, void>)funcTable[45])(red, green, blue, alpha);
			#endif
		}

		public static void Color4b(sbyte red, sbyte green, sbyte blue, sbyte alpha)
		{
			Color4bNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4bvNative(sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte*, void>)funcTable[46])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[46])((nint)v);
			#endif
		}

		public static void Color4bv(sbyte* v)
		{
			Color4bvNative(v);
		}

		public static void Color4bv(ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				Color4bvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4dNative(double red, double green, double blue, double alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[47])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[47])(red, green, blue, alpha);
			#endif
		}

		public static void Color4d(double red, double green, double blue, double alpha)
		{
			Color4dNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[48])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[48])((nint)v);
			#endif
		}

		public static void Color4dv(double* v)
		{
			Color4dvNative(v);
		}

		public static void Color4dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Color4dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4fNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[49])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[49])(red, green, blue, alpha);
			#endif
		}

		public static void Color4f(float red, float green, float blue, float alpha)
		{
			Color4fNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[50])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[50])((nint)v);
			#endif
		}

		public static void Color4fv(float* v)
		{
			Color4fvNative(v);
		}

		public static void Color4fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Color4fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4iNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[51])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[51])(red, green, blue, alpha);
			#endif
		}

		public static void Color4i(int red, int green, int blue, int alpha)
		{
			Color4iNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[52])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[52])((nint)v);
			#endif
		}

		public static void Color4iv(int* v)
		{
			Color4ivNative(v);
		}

		public static void Color4iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Color4ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4sNative(short red, short green, short blue, short alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[53])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[53])(red, green, blue, alpha);
			#endif
		}

		public static void Color4s(short red, short green, short blue, short alpha)
		{
			Color4sNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[54])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[54])((nint)v);
			#endif
		}

		public static void Color4sv(short* v)
		{
			Color4svNative(v);
		}

		public static void Color4sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Color4svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4ubNative(byte red, byte green, byte blue, byte alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[55])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[55])(red, green, blue, alpha);
			#endif
		}

		public static void Color4ub(byte red, byte green, byte blue, byte alpha)
		{
			Color4ubNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4ubvNative(byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[56])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[56])((nint)v);
			#endif
		}

		public static void Color4ubv(byte* v)
		{
			Color4ubvNative(v);
		}

		public static void Color4ubv(string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			Color4ubvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Color4ubv(ReadOnlySpan<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				Color4ubvNative(pv0);
			}
		}

		public static void Color4ubv(ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				Color4ubvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4uiNative(uint red, uint green, uint blue, uint alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[57])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[57])(red, green, blue, alpha);
			#endif
		}

		public static void Color4ui(uint red, uint green, uint blue, uint alpha)
		{
			Color4uiNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4uivNative(uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, void>)funcTable[58])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[58])((nint)v);
			#endif
		}

		public static void Color4uiv(uint* v)
		{
			Color4uivNative(v);
		}

		public static void Color4uiv(ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				Color4uivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4usNative(ushort red, ushort green, ushort blue, ushort alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, void>)funcTable[59])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, ushort, void>)funcTable[59])(red, green, blue, alpha);
			#endif
		}

		public static void Color4us(ushort red, ushort green, ushort blue, ushort alpha)
		{
			Color4usNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Color4usvNative(ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort*, void>)funcTable[60])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[60])((nint)v);
			#endif
		}

		public static void Color4usv(ushort* v)
		{
			Color4usvNative(v);
		}

		public static void Color4usv(ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				Color4usvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaskNative(byte red, byte green, byte blue, byte alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[61])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[61])(red, green, blue, alpha);
			#endif
		}

		public static void ColorMask(byte red, byte green, byte blue, byte alpha)
		{
			ColorMaskNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaterialNative(GLTriangleFace face, GLColorMaterialParameter mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLColorMaterialParameter, void>)funcTable[62])(face, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLColorMaterialParameter, void>)funcTable[62])(face, mode);
			#endif
		}

		public static void ColorMaterial(GLTriangleFace face, GLColorMaterialParameter mode)
		{
			ColorMaterialNative(face, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorPointerNative(int size, GLColorPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void*, void>)funcTable[63])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, nint, void>)funcTable[63])(size, type, stride, (nint)pointer);
			#endif
		}

		public static void ColorPointer(int size, GLColorPointerType type, int stride, void* pointer)
		{
			ColorPointerNative(size, type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[64])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[64])(shader);
			#endif
		}

		public static void CompileShader(uint shader)
		{
			CompileShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[65])(target, level, internalformat, width, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[65])(target, level, internalformat, width, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[66])(target, level, internalformat, width, height, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[66])(target, level, internalformat, width, height, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage3DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[67])(target, level, internalformat, width, height, depth, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[67])(target, level, internalformat, width, height, depth, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[68])(target, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[68])(target, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[69])(target, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[69])(target, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[70])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[70])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyPixelsNative(int x, int y, int width, int height, GLPixelCopyType type)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelCopyType, void>)funcTable[71])(x, y, width, height, type);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelCopyType, void>)funcTable[71])(x, y, width, height, type);
			#endif
		}

		public static void CopyPixels(int x, int y, int width, int height, GLPixelCopyType type)
		{
			CopyPixelsNative(x, y, width, height, type);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[72])(target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[72])(target, level, internalformat, x, y, width, border);
			#endif
		}

		public static void CopyTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTexImage1DNative(target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[73])(target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[73])(target, level, internalformat, x, y, width, height, border);
			#endif
		}

		public static void CopyTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTexImage2DNative(target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[74])(target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[74])(target, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyTexSubImage1D(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTexSubImage1DNative(target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[75])(target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[75])(target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage2DNative(target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[76])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[76])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateProgramNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[77])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[77])();
			#endif
		}

		public static uint CreateProgram()
		{
			uint ret = CreateProgramNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderNative(GLShaderType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[78])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[78])(type);
			#endif
		}

		public static uint CreateShader(GLShaderType type)
		{
			uint ret = CreateShaderNative(type);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CullFaceNative(GLTriangleFace mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[79])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[79])(mode);
			#endif
		}

		public static void CullFace(GLTriangleFace mode)
		{
			CullFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[80])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[80])(n, (nint)buffers);
			#endif
		}

		public static void DeleteBuffers(int n, uint* buffers)
		{
			DeleteBuffersNative(n, buffers);
		}

		public static void DeleteBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteListsNative(uint list, int range)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[81])(list, range);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[81])(list, range);
			#endif
		}

		public static void DeleteLists(uint list, int range)
		{
			DeleteListsNative(list, range);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[82])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[82])(program);
			#endif
		}

		public static void DeleteProgram(uint program)
		{
			DeleteProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[83])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[83])(n, (nint)ids);
			#endif
		}

		public static void DeleteQueries(int n, uint* ids)
		{
			DeleteQueriesNative(n, ids);
		}

		public static void DeleteQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[84])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[84])(shader);
			#endif
		}

		public static void DeleteShader(uint shader)
		{
			DeleteShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[85])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[85])(n, (nint)textures);
			#endif
		}

		public static void DeleteTextures(int n, uint* textures)
		{
			DeleteTexturesNative(n, textures);
		}

		public static void DeleteTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthFuncNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[86])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[86])(func);
			#endif
		}

		public static void DepthFunc(GLDepthFunction func)
		{
			DepthFuncNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthMaskNative(byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[87])(flag);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[87])(flag);
			#endif
		}

		public static void DepthMask(byte flag)
		{
			DepthMaskNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeNative(double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[88])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[88])(n, f);
			#endif
		}

		public static void DepthRange(double n, double f)
		{
			DepthRangeNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[89])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[89])(program, shader);
			#endif
		}

		public static void DetachShader(uint program, uint shader)
		{
			DetachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[90])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[90])(cap);
			#endif
		}

		public static void Disable(GLEnableCap cap)
		{
			DisableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[91])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[91])(array);
			#endif
		}

		public static void DisableClientState(GLEnableCap array)
		{
			DisableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[92])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[92])(index);
			#endif
		}

		public static void DisableVertexAttribArray(uint index)
		{
			DisableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysNative(GLPrimitiveType mode, int first, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[93])(mode, first, count);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[93])(mode, first, count);
			#endif
		}

		public static void DrawArrays(GLPrimitiveType mode, int first, int count)
		{
			DrawArraysNative(mode, first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBufferNative(GLDrawBufferMode buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[94])(buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[94])(buf);
			#endif
		}

		public static void DrawBuffer(GLDrawBufferMode buf)
		{
			DrawBufferNative(buf);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersNative(int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[95])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[95])(n, bufs);
			#endif
		}

		public static void DrawBuffers(int n, GLDrawBufferMode bufs)
		{
			DrawBuffersNative(n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, void>)funcTable[96])(mode, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, void>)funcTable[96])(mode, count, type, (nint)indices);
			#endif
		}

		public static void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			DrawElementsNative(mode, count, type, indices);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPixelsNative(int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[97])(width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[97])(width, height, format, type, (nint)pixels);
			#endif
		}

		public static void DrawPixels(int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			DrawPixelsNative(width, height, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, void>)funcTable[98])(mode, start, end, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, void>)funcTable[98])(mode, start, end, count, type, (nint)indices);
			#endif
		}

		public static void DrawRangeElements(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			DrawRangeElementsNative(mode, start, end, count, type, indices);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagNative(byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[99])(flag);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[99])(flag);
			#endif
		}

		public static void EdgeFlag(byte flag)
		{
			EdgeFlagNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagPointerNative(int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void*, void>)funcTable[100])(stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[100])(stride, (nint)pointer);
			#endif
		}

		public static void EdgeFlagPointer(int stride, void* pointer)
		{
			EdgeFlagPointerNative(stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagvNative(byte* flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[101])(flag);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[101])((nint)flag);
			#endif
		}

		public static void EdgeFlagv(byte* flag)
		{
			EdgeFlagvNative(flag);
		}

		public static void EdgeFlagv(string flag)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (flag != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(flag);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(flag, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			EdgeFlagvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void EdgeFlagv(ReadOnlySpan<byte> flag)
		{
			fixed (byte* pflag0 = flag)
			{
				EdgeFlagvNative(pflag0);
			}
		}

		public static void EdgeFlagv(ref byte flag)
		{
			fixed (byte* pflag0 = &flag)
			{
				EdgeFlagvNative(pflag0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[102])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[102])(cap);
			#endif
		}

		public static void Enable(GLEnableCap cap)
		{
			EnableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[103])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[103])(array);
			#endif
		}

		public static void EnableClientState(GLEnableCap array)
		{
			EnableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[104])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[104])(index);
			#endif
		}

		public static void EnableVertexAttribArray(uint index)
		{
			EnableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[105])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[105])();
			#endif
		}

		public static void End()
		{
			EndNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndListNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[106])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[106])();
			#endif
		}

		public static void EndList()
		{
			EndListNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryNative(GLQueryTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[107])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[107])(target);
			#endif
		}

		public static void EndQuery(GLQueryTarget target)
		{
			EndQueryNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1dNative(double u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[108])(u);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[108])(u);
			#endif
		}

		public static void EvalCoord1d(double u)
		{
			EvalCoord1dNative(u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1dvNative(double* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[109])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[109])((nint)u);
			#endif
		}

		public static void EvalCoord1dv(double* u)
		{
			EvalCoord1dvNative(u);
		}

		public static void EvalCoord1dv(ref double u)
		{
			fixed (double* pu0 = &u)
			{
				EvalCoord1dvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1fNative(float u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[110])(u);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[110])(u);
			#endif
		}

		public static void EvalCoord1f(float u)
		{
			EvalCoord1fNative(u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1fvNative(float* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[111])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[111])((nint)u);
			#endif
		}

		public static void EvalCoord1fv(float* u)
		{
			EvalCoord1fvNative(u);
		}

		public static void EvalCoord1fv(ref float u)
		{
			fixed (float* pu0 = &u)
			{
				EvalCoord1fvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2dNative(double u, double v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[112])(u, v);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[112])(u, v);
			#endif
		}

		public static void EvalCoord2d(double u, double v)
		{
			EvalCoord2dNative(u, v);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2dvNative(double* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[113])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[113])((nint)u);
			#endif
		}

		public static void EvalCoord2dv(double* u)
		{
			EvalCoord2dvNative(u);
		}

		public static void EvalCoord2dv(ref double u)
		{
			fixed (double* pu0 = &u)
			{
				EvalCoord2dvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2fNative(float u, float v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[114])(u, v);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[114])(u, v);
			#endif
		}

		public static void EvalCoord2f(float u, float v)
		{
			EvalCoord2fNative(u, v);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2fvNative(float* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[115])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[115])((nint)u);
			#endif
		}

		public static void EvalCoord2fv(float* u)
		{
			EvalCoord2fvNative(u);
		}

		public static void EvalCoord2fv(ref float u)
		{
			fixed (float* pu0 = &u)
			{
				EvalCoord2fvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalMesh1Native(GLMeshMode1 mode, int i1, int i2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMeshMode1, int, int, void>)funcTable[116])(mode, i1, i2);
			#else
			((delegate* unmanaged[Cdecl]<GLMeshMode1, int, int, void>)funcTable[116])(mode, i1, i2);
			#endif
		}

		public static void EvalMesh1(GLMeshMode1 mode, int i1, int i2)
		{
			EvalMesh1Native(mode, i1, i2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalMesh2Native(GLMeshMode2 mode, int i1, int i2, int j1, int j2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMeshMode2, int, int, int, int, void>)funcTable[117])(mode, i1, i2, j1, j2);
			#else
			((delegate* unmanaged[Cdecl]<GLMeshMode2, int, int, int, int, void>)funcTable[117])(mode, i1, i2, j1, j2);
			#endif
		}

		public static void EvalMesh2(GLMeshMode2 mode, int i1, int i2, int j1, int j2)
		{
			EvalMesh2Native(mode, i1, i2, j1, j2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalPoint1Native(int i)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[118])(i);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[118])(i);
			#endif
		}

		public static void EvalPoint1(int i)
		{
			EvalPoint1Native(i);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalPoint2Native(int i, int j)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[119])(i, j);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[119])(i, j);
			#endif
		}

		public static void EvalPoint2(int i, int j)
		{
			EvalPoint2Native(i, j);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FeedbackBufferNative(int size, GLFeedbackType type, float* buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLFeedbackType, float*, void>)funcTable[120])(size, type, buffer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLFeedbackType, nint, void>)funcTable[120])(size, type, (nint)buffer);
			#endif
		}

		public static void FeedbackBuffer(int size, GLFeedbackType type, float* buffer)
		{
			FeedbackBufferNative(size, type, buffer);
		}

		public static void FeedbackBuffer(int size, GLFeedbackType type, ref float buffer)
		{
			fixed (float* pbuffer0 = &buffer)
			{
				FeedbackBufferNative(size, type, pbuffer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FinishNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[121])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[121])();
			#endif
		}

		public static void Finish()
		{
			FinishNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[122])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[122])();
			#endif
		}

		public static void Flush()
		{
			FlushNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordPointerNative(GLFogPointerTypeEXT type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogPointerTypeEXT, int, void*, void>)funcTable[123])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLFogPointerTypeEXT, int, nint, void>)funcTable[123])(type, stride, (nint)pointer);
			#endif
		}

		public static void FogCoordPointer(GLFogPointerTypeEXT type, int stride, void* pointer)
		{
			FogCoordPointerNative(type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoorddNative(double coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[124])(coord);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[124])(coord);
			#endif
		}

		public static void FogCoordd(double coord)
		{
			FogCoorddNative(coord);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoorddvNative(double* coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[125])(coord);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[125])((nint)coord);
			#endif
		}

		public static void FogCoorddv(double* coord)
		{
			FogCoorddvNative(coord);
		}

		public static void FogCoorddv(ref double coord)
		{
			fixed (double* pcoord0 = &coord)
			{
				FogCoorddvNative(pcoord0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordfNative(float coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[126])(coord);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[126])(coord);
			#endif
		}

		public static void FogCoordf(float coord)
		{
			FogCoordfNative(coord);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordfvNative(float* coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[127])(coord);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[127])((nint)coord);
			#endif
		}

		public static void FogCoordfv(float* coord)
		{
			FogCoordfvNative(coord);
		}

		public static void FogCoordfv(ref float coord)
		{
			fixed (float* pcoord0 = &coord)
			{
				FogCoordfvNative(pcoord0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogfNative(GLFogParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, float, void>)funcTable[128])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, float, void>)funcTable[128])(pname, param);
			#endif
		}

		public static void Fogf(GLFogParameter pname, float param)
		{
			FogfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogfvNative(GLFogParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, float*, void>)funcTable[129])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, nint, void>)funcTable[129])(pname, (nint)@params);
			#endif
		}

		public static void Fogfv(GLFogParameter pname, float* @params)
		{
			FogfvNative(pname, @params);
		}

		public static void Fogfv(GLFogParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				FogfvNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogiNative(GLFogParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, int, void>)funcTable[130])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, int, void>)funcTable[130])(pname, param);
			#endif
		}

		public static void Fogi(GLFogParameter pname, int param)
		{
			FogiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogivNative(GLFogParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, int*, void>)funcTable[131])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, nint, void>)funcTable[131])(pname, (nint)@params);
			#endif
		}

		public static void Fogiv(GLFogParameter pname, int* @params)
		{
			FogivNative(pname, @params);
		}

		public static void Fogiv(GLFogParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				FogivNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrontFaceNative(GLFrontFaceDirection mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[132])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[132])(mode);
			#endif
		}

		public static void FrontFace(GLFrontFaceDirection mode)
		{
			FrontFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrustumNative(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[133])(left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[133])(left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void Frustum(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			FrustumNative(left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[134])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[134])(n, (nint)buffers);
			#endif
		}

		public static void GenBuffers(int n, uint* buffers)
		{
			GenBuffersNative(n, buffers);
		}

		public static void GenBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				GenBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenListsNative(int range)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[135])(range);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[135])(range);
			#endif
		}

		public static uint GenLists(int range)
		{
			uint ret = GenListsNative(range);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[136])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[136])(n, (nint)ids);
			#endif
		}

		public static void GenQueries(int n, uint* ids)
		{
			GenQueriesNative(n, ids);
		}

		public static void GenQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[137])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[137])(n, (nint)textures);
			#endif
		}

		public static void GenTextures(int n, uint* textures)
		{
			GenTexturesNative(n, textures);
		}

		public static void GenTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				GenTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAttribNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[138])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[138])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetActiveAttribNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveAttribNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveAttribNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveAttribNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNative(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLUniformType, byte*, void>)funcTable[139])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLUniformType, nint, void>)funcTable[139])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			GetActiveUniformNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveUniformNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAttachedShadersNative(uint program, int maxCount, int* count, uint* shaders)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, uint*, void>)funcTable[140])(program, maxCount, count, shaders);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[140])(program, maxCount, (nint)count, (nint)shaders);
			#endif
		}

		public static void GetAttachedShaders(uint program, int maxCount, int* count, uint* shaders)
		{
			GetAttachedShadersNative(program, maxCount, count, shaders);
		}

		public static void GetAttachedShaders(uint program, int maxCount, ref int count, uint* shaders)
		{
			fixed (int* pcount0 = &count)
			{
				GetAttachedShadersNative(program, maxCount, pcount0, shaders);
			}
		}

		public static void GetAttachedShaders(uint program, int maxCount, int* count, ref uint shaders)
		{
			fixed (uint* pshaders0 = &shaders)
			{
				GetAttachedShadersNative(program, maxCount, count, pshaders0);
			}
		}

		public static void GetAttachedShaders(uint program, int maxCount, ref int count, ref uint shaders)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (uint* pshaders1 = &shaders)
				{
					GetAttachedShadersNative(program, maxCount, pcount0, pshaders1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAttribLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[141])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[141])(program, (nint)name);
			#endif
		}

		public static int GetAttribLocation(uint program, byte* name)
		{
			int ret = GetAttribLocationNative(program, name);
			return ret;
		}

		public static int GetAttribLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetAttribLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetAttribLocation(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetAttribLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanvNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[142])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[142])(pname, (nint)data);
			#endif
		}

		public static void GetBooleanv(GLGetPName pname, byte* data)
		{
			GetBooleanvNative(pname, data);
		}

		public static void GetBooleanv(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanvNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameterivNative(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, int*, void>)funcTable[143])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[143])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			GetBufferParameterivNative(target, pname, @params);
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetBufferParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferPointervNative(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, void**, void>)funcTable[144])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, nint, void>)funcTable[144])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferPointerv(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			GetBufferPointervNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[145])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[145])(target, offset, size, (nint)data);
			#endif
		}

		public static void GetBufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			GetBufferSubDataNative(target, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetClipPlaneNative(GLClipPlaneName plane, double* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, double*, void>)funcTable[146])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[146])(plane, (nint)equation);
			#endif
		}

		public static void GetClipPlane(GLClipPlaneName plane, double* equation)
		{
			GetClipPlaneNative(plane, equation);
		}

		public static void GetClipPlane(GLClipPlaneName plane, ref double equation)
		{
			fixed (double* pequation0 = &equation)
			{
				GetClipPlaneNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTexImageNative(GLTextureTarget target, int level, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, void*, void>)funcTable[147])(target, level, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[147])(target, level, (nint)img);
			#endif
		}

		public static void GetCompressedTexImage(GLTextureTarget target, int level, void* img)
		{
			GetCompressedTexImageNative(target, level, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublevNative(GLGetPName pname, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, double*, void>)funcTable[148])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[148])(pname, (nint)data);
			#endif
		}

		public static void GetDoublev(GLGetPName pname, double* data)
		{
			GetDoublevNative(pname, data);
		}

		public static void GetDoublev(GLGetPName pname, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoublevNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[149])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[149])();
			#endif
		}

		public static GLEnum GetError()
		{
			GLEnum ret = GetErrorNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloatvNative(GLGetPName pname, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, float*, void>)funcTable[150])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[150])(pname, (nint)data);
			#endif
		}

		public static void GetFloatv(GLGetPName pname, float* data)
		{
			GetFloatvNative(pname, data);
		}

		public static void GetFloatv(GLGetPName pname, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloatvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegervNative(GLGetPName pname, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, int*, void>)funcTable[151])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[151])(pname, (nint)data);
			#endif
		}

		public static void GetIntegerv(GLGetPName pname, int* data)
		{
			GetIntegervNative(pname, data);
		}

		public static void GetIntegerv(GLGetPName pname, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegervNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[152])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[152])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			GetLightfvNative(light, pname, @params);
		}

		public static void GetLightfv(GLLightName light, GLLightParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetLightfvNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightivNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[153])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[153])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightiv(GLLightName light, GLLightParameter pname, int* @params)
		{
			GetLightivNative(light, pname, @params);
		}

		public static void GetLightiv(GLLightName light, GLLightParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetLightivNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapdvNative(GLMapTarget target, GLGetMapQuery query, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, double*, void>)funcTable[154])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[154])(target, query, (nint)v);
			#endif
		}

		public static void GetMapdv(GLMapTarget target, GLGetMapQuery query, double* v)
		{
			GetMapdvNative(target, query, v);
		}

		public static void GetMapdv(GLMapTarget target, GLGetMapQuery query, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				GetMapdvNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapfvNative(GLMapTarget target, GLGetMapQuery query, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, float*, void>)funcTable[155])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[155])(target, query, (nint)v);
			#endif
		}

		public static void GetMapfv(GLMapTarget target, GLGetMapQuery query, float* v)
		{
			GetMapfvNative(target, query, v);
		}

		public static void GetMapfv(GLMapTarget target, GLGetMapQuery query, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetMapfvNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapivNative(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, int*, void>)funcTable[156])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[156])(target, query, (nint)v);
			#endif
		}

		public static void GetMapiv(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			GetMapivNative(target, query, v);
		}

		public static void GetMapiv(GLMapTarget target, GLGetMapQuery query, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				GetMapivNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialfvNative(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float*, void>)funcTable[157])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[157])(face, pname, (nint)@params);
			#endif
		}

		public static void GetMaterialfv(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			GetMaterialfvNative(face, pname, @params);
		}

		public static void GetMaterialfv(GLTriangleFace face, GLMaterialParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMaterialfvNative(face, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialivNative(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[158])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[158])(face, pname, (nint)@params);
			#endif
		}

		public static void GetMaterialiv(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			GetMaterialivNative(face, pname, @params);
		}

		public static void GetMaterialiv(GLTriangleFace face, GLMaterialParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMaterialivNative(face, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapfvNative(GLPixelMap map, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, float*, void>)funcTable[159])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[159])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapfv(GLPixelMap map, float* values)
		{
			GetPixelMapfvNative(map, values);
		}

		public static void GetPixelMapfv(GLPixelMap map, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				GetPixelMapfvNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapuivNative(GLPixelMap map, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, uint*, void>)funcTable[160])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[160])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapuiv(GLPixelMap map, uint* values)
		{
			GetPixelMapuivNative(map, values);
		}

		public static void GetPixelMapuiv(GLPixelMap map, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				GetPixelMapuivNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapusvNative(GLPixelMap map, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, ushort*, void>)funcTable[161])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[161])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapusv(GLPixelMap map, ushort* values)
		{
			GetPixelMapusvNative(map, values);
		}

		public static void GetPixelMapusv(GLPixelMap map, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				GetPixelMapusvNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointervNative(GLGetPointervPName pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, void**, void>)funcTable[162])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, nint, void>)funcTable[162])(pname, (nint)@params);
			#endif
		}

		public static void GetPointerv(GLGetPointervPName pname, void** @params)
		{
			GetPointervNative(pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPolygonStippleNative(byte* mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[163])(mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[163])((nint)mask);
			#endif
		}

		public static void GetPolygonStipple(byte* mask)
		{
			GetPolygonStippleNative(mask);
		}

		public static void GetPolygonStipple(string mask)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mask != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mask);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mask, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetPolygonStippleNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetPolygonStipple(ReadOnlySpan<byte> mask)
		{
			fixed (byte* pmask0 = mask)
			{
				GetPolygonStippleNative(pmask0);
			}
		}

		public static void GetPolygonStipple(ref byte mask)
		{
			fixed (byte* pmask0 = &mask)
			{
				GetPolygonStippleNative(pmask0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInfoLogNative(uint program, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[164])(program, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[164])(program, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, byte* infoLog)
		{
			GetProgramInfoLogNative(program, bufSize, length, infoLog);
		}

		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramInfoLogNative(program, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramivNative(uint program, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, int*, void>)funcTable[165])(program, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, nint, void>)funcTable[165])(program, pname, (nint)@params);
			#endif
		}

		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, int* @params)
		{
			GetProgramivNative(program, pname, @params);
		}

		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramivNative(program, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectivNative(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, int*, void>)funcTable[166])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[166])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			GetQueryObjectivNative(id, pname, @params);
		}

		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryObjectivNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectuivNative(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, uint*, void>)funcTable[167])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[167])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			GetQueryObjectuivNative(id, pname, @params);
		}

		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetQueryObjectuivNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryivNative(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, int*, void>)funcTable[168])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, nint, void>)funcTable[168])(target, pname, (nint)@params);
			#endif
		}

		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			GetQueryivNative(target, pname, @params);
		}

		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderInfoLogNative(uint shader, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[169])(shader, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[169])(shader, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, byte* infoLog)
		{
			GetShaderInfoLogNative(shader, bufSize, length, infoLog);
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderInfoLogNative(shader, bufSize, plength0, infoLog);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderInfoLogNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetShaderInfoLogNative(shader, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderSourceNative(uint shader, int bufSize, int* length, byte* source)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[170])(shader, bufSize, length, source);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[170])(shader, bufSize, (nint)length, (nint)source);
			#endif
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, byte* source)
		{
			GetShaderSourceNative(shader, bufSize, length, source);
		}

		public static void GetShaderSource(uint shader, int bufSize, ref int length, byte* source)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderSourceNative(shader, bufSize, plength0, source);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderSourceNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, ReadOnlySpan<byte> source)
		{
			fixed (byte* psource0 = source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, ref byte source)
		{
			fixed (byte* psource0 = &source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, ref int length, ref byte source)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* psource1 = &source)
				{
					GetShaderSourceNative(shader, bufSize, plength0, psource1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderivNative(uint shader, GLShaderParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, int*, void>)funcTable[171])(shader, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, nint, void>)funcTable[171])(shader, pname, (nint)@params);
			#endif
		}

		public static void GetShaderiv(uint shader, GLShaderParameterName pname, int* @params)
		{
			GetShaderivNative(shader, pname, @params);
		}

		public static void GetShaderiv(uint shader, GLShaderParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetShaderivNative(shader, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringNative(GLStringName name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLStringName, byte*>)funcTable[172])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GLStringName, nint>)funcTable[172])(name);
			#endif
		}

		public static byte* GetString(GLStringName name)
		{
			byte* ret = GetStringNative(name);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvfvNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[173])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[173])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			GetTexEnvfvNative(target, pname, @params);
		}

		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexEnvfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvivNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[174])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[174])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetTexEnvivNative(target, pname, @params);
		}

		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexEnvivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGendvNative(GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[175])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[175])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGendv(GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			GetTexGendvNative(coord, pname, @params);
		}

		public static void GetTexGendv(GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetTexGendvNative(coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGenfvNative(GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[176])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[176])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGenfv(GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			GetTexGenfvNative(coord, pname, @params);
		}

		public static void GetTexGenfv(GLTextureCoordName coord, GLTextureGenParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexGenfvNative(coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGenivNative(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[177])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[177])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGeniv(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			GetTexGenivNative(coord, pname, @params);
		}

		public static void GetTexGeniv(GLTextureCoordName coord, GLTextureGenParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexGenivNative(coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexImageNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[178])(target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[178])(target, level, format, type, (nint)pixels);
			#endif
		}

		public static void GetTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetTexImageNative(target, level, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterfvNative(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[179])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[179])(target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTexLevelParameterfvNative(target, level, pname, @params);
		}

		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexLevelParameterfvNative(target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterivNative(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[180])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[180])(target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTexLevelParameterivNative(target, level, pname, @params);
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexLevelParameterivNative(target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterfvNative(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[181])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[181])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTexParameterfvNative(target, pname, @params);
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[182])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[182])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterivNative(target, pname, @params);
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUniformLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[183])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[183])(program, (nint)name);
			#endif
		}

		public static int GetUniformLocation(uint program, byte* name)
		{
			int ret = GetUniformLocationNative(program, name);
			return ret;
		}

		public static int GetUniformLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetUniformLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetUniformLocation(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetUniformLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformfvNative(uint program, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[184])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[184])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformfv(uint program, int location, float* @params)
		{
			GetUniformfvNative(program, location, @params);
		}

		public static void GetUniformfv(uint program, int location, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetUniformfvNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformivNative(uint program, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[185])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[185])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformiv(uint program, int location, int* @params)
		{
			GetUniformivNative(program, location, @params);
		}

		public static void GetUniformiv(uint program, int location, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetUniformivNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[186])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[186])(index, pname, (nint)pointer);
			#endif
		}

		public static void GetVertexAttribPointerv(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[187])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[187])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvNative(index, pname, @params);
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[188])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[188])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvNative(index, pname, @params);
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetVertexAttribfvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[189])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[189])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivNative(index, pname, @params);
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVertexAttribivNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HintNative(GLHintTarget target, GLHintMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[190])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[190])(target, mode);
			#endif
		}

		public static void Hint(GLHintTarget target, GLHintMode mode)
		{
			HintNative(target, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[191])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[191])(mask);
			#endif
		}

		public static void IndexMask(uint mask)
		{
			IndexMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexPointerNative(GLIndexPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, void*, void>)funcTable[192])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, nint, void>)funcTable[192])(type, stride, (nint)pointer);
			#endif
		}

		public static void IndexPointer(GLIndexPointerType type, int stride, void* pointer)
		{
			IndexPointerNative(type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexdNative(double c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[193])(c);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[193])(c);
			#endif
		}

		public static void Indexd(double c)
		{
			IndexdNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexdvNative(double* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[194])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[194])((nint)c);
			#endif
		}

		public static void Indexdv(double* c)
		{
			IndexdvNative(c);
		}

		public static void Indexdv(ref double c)
		{
			fixed (double* pc0 = &c)
			{
				IndexdvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexfNative(float c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[195])(c);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[195])(c);
			#endif
		}

		public static void Indexf(float c)
		{
			IndexfNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexfvNative(float* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[196])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[196])((nint)c);
			#endif
		}

		public static void Indexfv(float* c)
		{
			IndexfvNative(c);
		}

		public static void Indexfv(ref float c)
		{
			fixed (float* pc0 = &c)
			{
				IndexfvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexiNative(int c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[197])(c);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[197])(c);
			#endif
		}

		public static void Indexi(int c)
		{
			IndexiNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexivNative(int* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[198])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[198])((nint)c);
			#endif
		}

		public static void Indexiv(int* c)
		{
			IndexivNative(c);
		}

		public static void Indexiv(ref int c)
		{
			fixed (int* pc0 = &c)
			{
				IndexivNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexsNative(short c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[199])(c);
			#else
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[199])(c);
			#endif
		}

		public static void Indexs(short c)
		{
			IndexsNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexsvNative(short* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[200])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[200])((nint)c);
			#endif
		}

		public static void Indexsv(short* c)
		{
			IndexsvNative(c);
		}

		public static void Indexsv(ref short c)
		{
			fixed (short* pc0 = &c)
			{
				IndexsvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexubNative(byte c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[201])(c);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[201])(c);
			#endif
		}

		public static void Indexub(byte c)
		{
			IndexubNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexubvNative(byte* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[202])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[202])((nint)c);
			#endif
		}

		public static void Indexubv(byte* c)
		{
			IndexubvNative(c);
		}

		public static void Indexubv(string c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (c != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(c);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(c, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IndexubvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Indexubv(ReadOnlySpan<byte> c)
		{
			fixed (byte* pc0 = c)
			{
				IndexubvNative(pc0);
			}
		}

		public static void Indexubv(ref byte c)
		{
			fixed (byte* pc0 = &c)
			{
				IndexubvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitNamesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[203])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[203])();
			#endif
		}

		public static void InitNames()
		{
			InitNamesNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InterleavedArraysNative(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, void*, void>)funcTable[204])(format, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, nint, void>)funcTable[204])(format, stride, (nint)pointer);
			#endif
		}

		public static void InterleavedArrays(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			InterleavedArraysNative(format, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[205])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[205])(buffer);
			#endif
		}

		public static bool IsBuffer(uint buffer)
		{
			byte ret = IsBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnabledNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[206])(cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[206])(cap);
			#endif
		}

		public static bool IsEnabled(GLEnableCap cap)
		{
			byte ret = IsEnabledNative(cap);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsListNative(uint list)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[207])(list);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[207])(list);
			#endif
		}

		public static bool IsList(uint list)
		{
			byte ret = IsListNative(list);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[208])(program);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[208])(program);
			#endif
		}

		public static bool IsProgram(uint program)
		{
			byte ret = IsProgramNative(program);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQueryNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[209])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[209])(id);
			#endif
		}

		public static bool IsQuery(uint id)
		{
			byte ret = IsQueryNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[210])(shader);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[210])(shader);
			#endif
		}

		public static bool IsShader(uint shader)
		{
			byte ret = IsShaderNative(shader);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[211])(texture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[211])(texture);
			#endif
		}

		public static bool IsTexture(uint texture)
		{
			byte ret = IsTextureNative(texture);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfNative(GLLightModelParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[212])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[212])(pname, param);
			#endif
		}

		public static void LightModelf(GLLightModelParameter pname, float param)
		{
			LightModelfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfvNative(GLLightModelParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float*, void>)funcTable[213])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[213])(pname, (nint)@params);
			#endif
		}

		public static void LightModelfv(GLLightModelParameter pname, float* @params)
		{
			LightModelfvNative(pname, @params);
		}

		public static void LightModelfv(GLLightModelParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				LightModelfvNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModeliNative(GLLightModelParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[214])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[214])(pname, param);
			#endif
		}

		public static void LightModeli(GLLightModelParameter pname, int param)
		{
			LightModeliNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelivNative(GLLightModelParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int*, void>)funcTable[215])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[215])(pname, (nint)@params);
			#endif
		}

		public static void LightModeliv(GLLightModelParameter pname, int* @params)
		{
			LightModelivNative(pname, @params);
		}

		public static void LightModeliv(GLLightModelParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				LightModelivNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfNative(GLLightName light, GLLightParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[216])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[216])(light, pname, param);
			#endif
		}

		public static void Lightf(GLLightName light, GLLightParameter pname, float param)
		{
			LightfNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[217])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[217])(light, pname, (nint)@params);
			#endif
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			LightfvNative(light, pname, @params);
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				LightfvNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightiNative(GLLightName light, GLLightParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[218])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[218])(light, pname, param);
			#endif
		}

		public static void Lighti(GLLightName light, GLLightParameter pname, int param)
		{
			LightiNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightivNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[219])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[219])(light, pname, (nint)@params);
			#endif
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, int* @params)
		{
			LightivNative(light, pname, @params);
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				LightivNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineStippleNative(int factor, ushort pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[220])(factor, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[220])(factor, pattern);
			#endif
		}

		public static void LineStipple(int factor, ushort pattern)
		{
			LineStippleNative(factor, pattern);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineWidthNative(float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[221])(width);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[221])(width);
			#endif
		}

		public static void LineWidth(float width)
		{
			LineWidthNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LinkProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[222])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[222])(program);
			#endif
		}

		public static void LinkProgram(uint program)
		{
			LinkProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ListBaseNative(uint baseValue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[223])(baseValue);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[223])(baseValue);
			#endif
		}

		public static void ListBase(uint baseValue)
		{
			ListBaseNative(baseValue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadIdentityNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[224])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[224])();
			#endif
		}

		public static void LoadIdentity()
		{
			LoadIdentityNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[225])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[225])((nint)m);
			#endif
		}

		public static void LoadMatrixd(double* m)
		{
			LoadMatrixdNative(m);
		}

		public static void LoadMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[226])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[226])((nint)m);
			#endif
		}

		public static void LoadMatrixf(float* m)
		{
			LoadMatrixfNative(m);
		}

		public static void LoadMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadNameNative(uint name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[227])(name);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[227])(name);
			#endif
		}

		public static void LoadName(uint name)
		{
			LoadNameNative(name);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[228])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[228])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixd(double* m)
		{
			LoadTransposeMatrixdNative(m);
		}

		public static void LoadTransposeMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadTransposeMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[229])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[229])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixf(float* m)
		{
			LoadTransposeMatrixfNative(m);
		}

		public static void LoadTransposeMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadTransposeMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogicOpNative(GLLogicOp opcode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[230])(opcode);
			#else
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[230])(opcode);
			#endif
		}

		public static void LogicOp(GLLogicOp opcode)
		{
			LogicOpNative(opcode);
		}
	}
}
