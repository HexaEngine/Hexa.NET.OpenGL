// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexLevelParameterivNative(target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexLevelParameterivNative(target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterfvNative(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[181])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[181])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTexParameterfvNative(target, pname, @params);
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTexParameterfvNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[182])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[182])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterivNative(target, pname, @params);
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUniformLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[183])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[183])(program, (nint)name);
			#endif
		}

		public static int GetUniformLocation(uint program, byte* name)
		{
			int ret = GetUniformLocationNative(program, name);
			return ret;
		}

		public static int GetUniformLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetUniformLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetUniformLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetUniformLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformfvNative(uint program, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[184])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[184])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformfv(uint program, int location, float* @params)
		{
			GetUniformfvNative(program, location, @params);
		}

		public static void GetUniformfv(uint program, int location, out float @params)
		{
			float pparams;
			GetUniformfvNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformfv(uint program, int location, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetUniformfvNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformivNative(uint program, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[185])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[185])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformiv(uint program, int location, int* @params)
		{
			GetUniformivNative(program, location, @params);
		}

		public static void GetUniformiv(uint program, int location, out int @params)
		{
			int pparams;
			GetUniformivNative(program, location, &pparams);
			@params = pparams;
		}

		public static void GetUniformiv(uint program, int location, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetUniformivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[186])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[186])(index, pname, (nint)pointer);
			#endif
		}

		public static void GetVertexAttribPointerv(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[187])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[187])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvNative(index, pname, @params);
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[188])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[188])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvNative(index, pname, @params);
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, out float @params)
		{
			float pparams;
			GetVertexAttribfvNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetVertexAttribfvNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[189])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[189])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivNative(index, pname, @params);
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, out int @params)
		{
			int pparams;
			GetVertexAttribivNative(index, pname, &pparams);
			@params = pparams;
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HintNative(GLHintTarget target, GLHintMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[190])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[190])(target, mode);
			#endif
		}

		public static void Hint(GLHintTarget target, GLHintMode mode)
		{
			HintNative(target, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[191])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[191])(mask);
			#endif
		}

		public static void IndexMask(uint mask)
		{
			IndexMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexPointerNative(GLIndexPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, void*, void>)funcTable[192])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLIndexPointerType, int, nint, void>)funcTable[192])(type, stride, (nint)pointer);
			#endif
		}

		public static void IndexPointer(GLIndexPointerType type, int stride, void* pointer)
		{
			IndexPointerNative(type, stride, pointer);
		}

		public static void IndexPointer(GLIndexPointerType type, int stride, nint pointer)
		{
			IndexPointerNative(type, stride, (void*)pointer);
		}

		public static void IndexPointer<TPointer>(GLIndexPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				IndexPointerNative(type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexdNative(double c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[193])(c);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[193])(c);
			#endif
		}

		public static void Indexd(double c)
		{
			IndexdNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexdvNative(double* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[194])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[194])((nint)c);
			#endif
		}

		public static void Indexdv(double* c)
		{
			IndexdvNative(c);
		}

		public static void Indexdv(Span<double> c)
		{
			fixed (double* pc0 = c)
			{
				IndexdvNative(pc0);
			}
		}

		public static void Indexdv(ref double c)
		{
			fixed (double* pc0 = &c)
			{
				IndexdvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexfNative(float c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[195])(c);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[195])(c);
			#endif
		}

		public static void Indexf(float c)
		{
			IndexfNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexfvNative(float* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[196])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[196])((nint)c);
			#endif
		}

		public static void Indexfv(float* c)
		{
			IndexfvNative(c);
		}

		public static void Indexfv(Span<float> c)
		{
			fixed (float* pc0 = c)
			{
				IndexfvNative(pc0);
			}
		}

		public static void Indexfv(ref float c)
		{
			fixed (float* pc0 = &c)
			{
				IndexfvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexiNative(int c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[197])(c);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[197])(c);
			#endif
		}

		public static void Indexi(int c)
		{
			IndexiNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexivNative(int* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[198])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[198])((nint)c);
			#endif
		}

		public static void Indexiv(int* c)
		{
			IndexivNative(c);
		}

		public static void Indexiv(Span<int> c)
		{
			fixed (int* pc0 = c)
			{
				IndexivNative(pc0);
			}
		}

		public static void Indexiv(ref int c)
		{
			fixed (int* pc0 = &c)
			{
				IndexivNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexsNative(short c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[199])(c);
			#else
			((delegate* unmanaged[Cdecl]<short, void>)funcTable[199])(c);
			#endif
		}

		public static void Indexs(short c)
		{
			IndexsNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexsvNative(short* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[200])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[200])((nint)c);
			#endif
		}

		public static void Indexsv(short* c)
		{
			IndexsvNative(c);
		}

		public static void Indexsv(Span<short> c)
		{
			fixed (short* pc0 = c)
			{
				IndexsvNative(pc0);
			}
		}

		public static void Indexsv(ref short c)
		{
			fixed (short* pc0 = &c)
			{
				IndexsvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexubNative(bool c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[201])(*((byte*)(&c)));
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[201])(*((byte*)(&c)));
			#endif
		}

		public static void Indexub(bool c)
		{
			IndexubNative(c);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void IndexubvNative(byte* c)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[202])(c);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[202])((nint)c);
			#endif
		}

		public static void Indexubv(byte* c)
		{
			IndexubvNative(c);
		}

		public static void Indexubv(string c)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (c != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(c);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(c, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			IndexubvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void Indexubv(Span<byte> c)
		{
			fixed (byte* pc0 = c)
			{
				IndexubvNative(pc0);
			}
		}

		public static void Indexubv(ref byte c)
		{
			fixed (byte* pc0 = &c)
			{
				IndexubvNative(pc0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InitNamesNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[203])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[203])();
			#endif
		}

		public static void InitNames()
		{
			InitNamesNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InterleavedArraysNative(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, void*, void>)funcTable[204])(format, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLInterleavedArrayFormat, int, nint, void>)funcTable[204])(format, stride, (nint)pointer);
			#endif
		}

		public static void InterleavedArrays(GLInterleavedArrayFormat format, int stride, void* pointer)
		{
			InterleavedArraysNative(format, stride, pointer);
		}

		public static void InterleavedArrays(GLInterleavedArrayFormat format, int stride, nint pointer)
		{
			InterleavedArraysNative(format, stride, (void*)pointer);
		}

		public static void InterleavedArrays<TPointer>(GLInterleavedArrayFormat format, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				InterleavedArraysNative(format, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[205])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[205])(buffer);
			#endif
		}

		public static bool IsBuffer(uint buffer)
		{
			byte ret = IsBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnabledNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[206])(cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[206])(cap);
			#endif
		}

		public static bool IsEnabled(GLEnableCap cap)
		{
			byte ret = IsEnabledNative(cap);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsListNative(uint list)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[207])(list);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[207])(list);
			#endif
		}

		public static bool IsList(uint list)
		{
			byte ret = IsListNative(list);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[208])(program);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[208])(program);
			#endif
		}

		public static bool IsProgram(uint program)
		{
			byte ret = IsProgramNative(program);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQueryNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[209])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[209])(id);
			#endif
		}

		public static bool IsQuery(uint id)
		{
			byte ret = IsQueryNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[210])(shader);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[210])(shader);
			#endif
		}

		public static bool IsShader(uint shader)
		{
			byte ret = IsShaderNative(shader);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[211])(texture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[211])(texture);
			#endif
		}

		public static bool IsTexture(uint texture)
		{
			byte ret = IsTextureNative(texture);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfNative(GLLightModelParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[212])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[212])(pname, param);
			#endif
		}

		public static void LightModelf(GLLightModelParameter pname, float param)
		{
			LightModelfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfvNative(GLLightModelParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float*, void>)funcTable[213])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[213])(pname, (nint)@params);
			#endif
		}

		public static void LightModelfv(GLLightModelParameter pname, float* @params)
		{
			LightModelfvNative(pname, @params);
		}

		public static void LightModelfv(GLLightModelParameter pname, out float @params)
		{
			float pparams;
			LightModelfvNative(pname, &pparams);
			@params = pparams;
		}

		public static void LightModelfv(GLLightModelParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				LightModelfvNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModeliNative(GLLightModelParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[214])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[214])(pname, param);
			#endif
		}

		public static void LightModeli(GLLightModelParameter pname, int param)
		{
			LightModeliNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelivNative(GLLightModelParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int*, void>)funcTable[215])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[215])(pname, (nint)@params);
			#endif
		}

		public static void LightModeliv(GLLightModelParameter pname, int* @params)
		{
			LightModelivNative(pname, @params);
		}

		public static void LightModeliv(GLLightModelParameter pname, out int @params)
		{
			int pparams;
			LightModelivNative(pname, &pparams);
			@params = pparams;
		}

		public static void LightModeliv(GLLightModelParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				LightModelivNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfNative(GLLightName light, GLLightParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[216])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[216])(light, pname, param);
			#endif
		}

		public static void Lightf(GLLightName light, GLLightParameter pname, float param)
		{
			LightfNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[217])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[217])(light, pname, (nint)@params);
			#endif
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			LightfvNative(light, pname, @params);
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, out float @params)
		{
			float pparams;
			LightfvNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void Lightfv(GLLightName light, GLLightParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				LightfvNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightiNative(GLLightName light, GLLightParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[218])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[218])(light, pname, param);
			#endif
		}

		public static void Lighti(GLLightName light, GLLightParameter pname, int param)
		{
			LightiNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightivNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[219])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[219])(light, pname, (nint)@params);
			#endif
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, int* @params)
		{
			LightivNative(light, pname, @params);
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, out int @params)
		{
			int pparams;
			LightivNative(light, pname, &pparams);
			@params = pparams;
		}

		public static void Lightiv(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				LightivNative(light, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineStippleNative(int factor, ushort pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[220])(factor, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, ushort, void>)funcTable[220])(factor, pattern);
			#endif
		}

		public static void LineStipple(int factor, ushort pattern)
		{
			LineStippleNative(factor, pattern);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LineWidthNative(float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[221])(width);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[221])(width);
			#endif
		}

		public static void LineWidth(float width)
		{
			LineWidthNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LinkProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[222])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[222])(program);
			#endif
		}

		public static void LinkProgram(uint program)
		{
			LinkProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ListBaseNative(uint baseValue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[223])(baseValue);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[223])(baseValue);
			#endif
		}

		public static void ListBase(uint baseValue)
		{
			ListBaseNative(baseValue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadIdentityNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[224])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[224])();
			#endif
		}

		public static void LoadIdentity()
		{
			LoadIdentityNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[225])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[225])((nint)m);
			#endif
		}

		public static void LoadMatrixd(double* m)
		{
			LoadMatrixdNative(m);
		}

		public static void LoadMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				LoadMatrixdNative(pm0);
			}
		}

		public static void LoadMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[226])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[226])((nint)m);
			#endif
		}

		public static void LoadMatrixf(float* m)
		{
			LoadMatrixfNative(m);
		}

		public static void LoadMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		public static void LoadMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadNameNative(uint name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[227])(name);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[227])(name);
			#endif
		}

		public static void LoadName(uint name)
		{
			LoadNameNative(name);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[228])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[228])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixd(double* m)
		{
			LoadTransposeMatrixdNative(m);
		}

		public static void LoadTransposeMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				LoadTransposeMatrixdNative(pm0);
			}
		}

		public static void LoadTransposeMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadTransposeMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[229])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[229])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixf(float* m)
		{
			LoadTransposeMatrixfNative(m);
		}

		public static void LoadTransposeMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				LoadTransposeMatrixfNative(pm0);
			}
		}

		public static void LoadTransposeMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadTransposeMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LogicOpNative(GLLogicOp opcode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[230])(opcode);
			#else
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[230])(opcode);
			#endif
		}

		public static void LogicOp(GLLogicOp opcode)
		{
			LogicOpNative(opcode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map1dNative(GLMapTarget target, double u1, double u2, int stride, int order, double* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double*, void>)funcTable[231])(target, u1, u2, stride, order, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, nint, void>)funcTable[231])(target, u1, u2, stride, order, (nint)points);
			#endif
		}

		public static void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, double* points)
		{
			Map1dNative(target, u1, u2, stride, order, points);
		}

		public static void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, Span<double> points)
		{
			fixed (double* ppoints0 = points)
			{
				Map1dNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		public static void Map1d(GLMapTarget target, double u1, double u2, int stride, int order, ref double points)
		{
			fixed (double* ppoints0 = &points)
			{
				Map1dNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map1fNative(GLMapTarget target, float u1, float u2, int stride, int order, float* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float*, void>)funcTable[232])(target, u1, u2, stride, order, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, nint, void>)funcTable[232])(target, u1, u2, stride, order, (nint)points);
			#endif
		}

		public static void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, float* points)
		{
			Map1fNative(target, u1, u2, stride, order, points);
		}

		public static void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, Span<float> points)
		{
			fixed (float* ppoints0 = points)
			{
				Map1fNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		public static void Map1f(GLMapTarget target, float u1, float u2, int stride, int order, ref float points)
		{
			fixed (float* ppoints0 = &points)
			{
				Map1fNative(target, u1, u2, stride, order, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map2dNative(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double, double, int, int, double*, void>)funcTable[233])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, double, double, int, int, double, double, int, int, nint, void>)funcTable[233])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (nint)points);
			#endif
		}

		public static void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points)
		{
			Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		}

		public static void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, Span<double> points)
		{
			fixed (double* ppoints0 = points)
			{
				Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		public static void Map2d(GLMapTarget target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, ref double points)
		{
			fixed (double* ppoints0 = &points)
			{
				Map2dNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Map2fNative(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float, float, int, int, float*, void>)funcTable[234])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, float, float, int, int, float, float, int, int, nint, void>)funcTable[234])(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (nint)points);
			#endif
		}

		public static void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points)
		{
			Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
		}

		public static void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, Span<float> points)
		{
			fixed (float* ppoints0 = points)
			{
				Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		public static void Map2f(GLMapTarget target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, ref float points)
		{
			fixed (float* ppoints0 = &points)
			{
				Map2fNative(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, ppoints0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferNative(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, void*>)funcTable[235])(target, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, nint>)funcTable[235])(target, access);
			#endif
		}

		public static void* MapBuffer(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			void* ret = MapBufferNative(target, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid1dNative(int un, double u1, double u2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[236])(un, u1, u2);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, void>)funcTable[236])(un, u1, u2);
			#endif
		}

		public static void MapGrid1d(int un, double u1, double u2)
		{
			MapGrid1dNative(un, u1, u2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid1fNative(int un, float u1, float u2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[237])(un, u1, u2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[237])(un, u1, u2);
			#endif
		}

		public static void MapGrid1f(int un, float u1, float u2)
		{
			MapGrid1fNative(un, u1, u2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid2dNative(int un, double u1, double u2, int vn, double v1, double v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, double, double, int, double, double, void>)funcTable[238])(un, u1, u2, vn, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, double, double, int, double, double, void>)funcTable[238])(un, u1, u2, vn, v1, v2);
			#endif
		}

		public static void MapGrid2d(int un, double u1, double u2, int vn, double v1, double v2)
		{
			MapGrid2dNative(un, u1, u2, vn, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MapGrid2fNative(int un, float u1, float u2, int vn, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, int, float, float, void>)funcTable[239])(un, u1, u2, vn, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, int, float, float, void>)funcTable[239])(un, u1, u2, vn, v1, v2);
			#endif
		}

		public static void MapGrid2f(int un, float u1, float u2, int vn, float v1, float v2)
		{
			MapGrid2fNative(un, u1, u2, vn, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialfNative(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[240])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[240])(face, pname, param);
			#endif
		}

		public static void Materialf(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			MaterialfNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialfvNative(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float*, void>)funcTable[241])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[241])(face, pname, (nint)@params);
			#endif
		}

		public static void Materialfv(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			MaterialfvNative(face, pname, @params);
		}

		public static void Materialfv(GLTriangleFace face, GLMaterialParameter pname, out float @params)
		{
			float pparams;
			MaterialfvNative(face, pname, &pparams);
			@params = pparams;
		}

		public static void Materialfv(GLTriangleFace face, GLMaterialParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				MaterialfvNative(face, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialiNative(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[242])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[242])(face, pname, param);
			#endif
		}

		public static void Materiali(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			MaterialiNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaterialivNative(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[243])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[243])(face, pname, (nint)@params);
			#endif
		}

		public static void Materialiv(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			MaterialivNative(face, pname, @params);
		}

		public static void Materialiv(GLTriangleFace face, GLMaterialParameter pname, out int @params)
		{
			int pparams;
			MaterialivNative(face, pname, &pparams);
			@params = pparams;
		}

		public static void Materialiv(GLTriangleFace face, GLMaterialParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				MaterialivNative(face, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixModeNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[244])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[244])(mode);
			#endif
		}

		public static void MatrixMode(GLMatrixMode mode)
		{
			MatrixModeNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[245])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[245])((nint)m);
			#endif
		}

		public static void MultMatrixd(double* m)
		{
			MultMatrixdNative(m);
		}

		public static void MultMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MultMatrixdNative(pm0);
			}
		}

		public static void MultMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MultMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[246])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[246])((nint)m);
			#endif
		}

		public static void MultMatrixf(float* m)
		{
			MultMatrixfNative(m);
		}

		public static void MultMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MultMatrixfNative(pm0);
			}
		}

		public static void MultMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultTransposeMatrixdNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[247])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[247])((nint)m);
			#endif
		}

		public static void MultTransposeMatrixd(double* m)
		{
			MultTransposeMatrixdNative(m);
		}

		public static void MultTransposeMatrixd(Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MultTransposeMatrixdNative(pm0);
			}
		}

		public static void MultTransposeMatrixd(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MultTransposeMatrixdNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultTransposeMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[248])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[248])((nint)m);
			#endif
		}

		public static void MultTransposeMatrixf(float* m)
		{
			MultTransposeMatrixfNative(m);
		}

		public static void MultTransposeMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MultTransposeMatrixfNative(pm0);
			}
		}

		public static void MultTransposeMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultTransposeMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysNative(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, int*, int, void>)funcTable[249])(mode, first, count, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, void>)funcTable[249])(mode, (nint)first, (nint)count, drawcount);
			#endif
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			MultiDrawArraysNative(mode, first, count, drawcount);
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, ref int first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, Span<int> count, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, int* first, ref int count, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, Span<int> count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				fixed (int* pcount1 = count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		public static void MultiDrawArrays(GLPrimitiveType mode, ref int first, ref int count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				fixed (int* pcount1 = &count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, void>)funcTable[250])(mode, count, type, indices, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, void>)funcTable[250])(mode, (nint)count, type, (nint)indices, drawcount);
			#endif
		}

		public static void MultiDrawElements(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			MultiDrawElementsNative(mode, count, type, indices, drawcount);
		}

		public static void MultiDrawElements(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		public static void MultiDrawElements(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1dNative(GLTextureUnit target, double s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[251])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[251])(target, s);
			#endif
		}

		public static void MultiTexCoord1d(GLTextureUnit target, double s)
		{
			MultiTexCoord1dNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[252])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[252])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord1dvNative(target, v);
		}

		public static void MultiTexCoord1dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord1dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord1dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord1dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1fNative(GLTextureUnit target, float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[253])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[253])(target, s);
			#endif
		}

		public static void MultiTexCoord1f(GLTextureUnit target, float s)
		{
			MultiTexCoord1fNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[254])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[254])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord1fvNative(target, v);
		}

		public static void MultiTexCoord1fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord1fvNative(target, pv0);
			}
		}

		public static void MultiTexCoord1fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord1fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1iNative(GLTextureUnit target, int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[255])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[255])(target, s);
			#endif
		}

		public static void MultiTexCoord1i(GLTextureUnit target, int s)
		{
			MultiTexCoord1iNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[256])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[256])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord1ivNative(target, v);
		}

		public static void MultiTexCoord1iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord1ivNative(target, pv0);
			}
		}

		public static void MultiTexCoord1iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord1ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1sNative(GLTextureUnit target, short s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[257])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[257])(target, s);
			#endif
		}

		public static void MultiTexCoord1s(GLTextureUnit target, short s)
		{
			MultiTexCoord1sNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[258])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[258])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord1svNative(target, v);
		}

		public static void MultiTexCoord1sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord1svNative(target, pv0);
			}
		}

		public static void MultiTexCoord1sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord1svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2dNative(GLTextureUnit target, double s, double t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[259])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[259])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2d(GLTextureUnit target, double s, double t)
		{
			MultiTexCoord2dNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[260])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[260])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord2dvNative(target, v);
		}

		public static void MultiTexCoord2dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord2dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord2dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord2dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2fNative(GLTextureUnit target, float s, float t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[261])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[261])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2f(GLTextureUnit target, float s, float t)
		{
			MultiTexCoord2fNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[262])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[262])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord2fvNative(target, v);
		}

		public static void MultiTexCoord2fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord2fvNative(target, pv0);
			}
		}

		public static void MultiTexCoord2fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord2fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2iNative(GLTextureUnit target, int s, int t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[263])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[263])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2i(GLTextureUnit target, int s, int t)
		{
			MultiTexCoord2iNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[264])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[264])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord2ivNative(target, v);
		}

		public static void MultiTexCoord2iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord2ivNative(target, pv0);
			}
		}

		public static void MultiTexCoord2iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord2ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2sNative(GLTextureUnit target, short s, short t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[265])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[265])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2s(GLTextureUnit target, short s, short t)
		{
			MultiTexCoord2sNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[266])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[266])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord2svNative(target, v);
		}

		public static void MultiTexCoord2sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord2svNative(target, pv0);
			}
		}

		public static void MultiTexCoord2sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord2svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3dNative(GLTextureUnit target, double s, double t, double r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[267])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[267])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3d(GLTextureUnit target, double s, double t, double r)
		{
			MultiTexCoord3dNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[268])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[268])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord3dvNative(target, v);
		}

		public static void MultiTexCoord3dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord3dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord3dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord3dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3fNative(GLTextureUnit target, float s, float t, float r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[269])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[269])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3f(GLTextureUnit target, float s, float t, float r)
		{
			MultiTexCoord3fNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[270])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[270])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord3fvNative(target, v);
		}

		public static void MultiTexCoord3fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord3fvNative(target, pv0);
			}
		}

		public static void MultiTexCoord3fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord3fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3iNative(GLTextureUnit target, int s, int t, int r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[271])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[271])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3i(GLTextureUnit target, int s, int t, int r)
		{
			MultiTexCoord3iNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[272])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[272])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord3ivNative(target, v);
		}

		public static void MultiTexCoord3iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord3ivNative(target, pv0);
			}
		}

		public static void MultiTexCoord3iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord3ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3sNative(GLTextureUnit target, short s, short t, short r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[273])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[273])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3s(GLTextureUnit target, short s, short t, short r)
		{
			MultiTexCoord3sNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[274])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[274])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord3svNative(target, v);
		}

		public static void MultiTexCoord3sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord3svNative(target, pv0);
			}
		}

		public static void MultiTexCoord3sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord3svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4dNative(GLTextureUnit target, double s, double t, double r, double q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[275])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[275])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4d(GLTextureUnit target, double s, double t, double r, double q)
		{
			MultiTexCoord4dNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4dvNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[276])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[276])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4dv(GLTextureUnit target, double* v)
		{
			MultiTexCoord4dvNative(target, v);
		}

		public static void MultiTexCoord4dv(GLTextureUnit target, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				MultiTexCoord4dvNative(target, pv0);
			}
		}

		public static void MultiTexCoord4dv(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord4dvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4fNative(GLTextureUnit target, float s, float t, float r, float q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[277])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[277])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4f(GLTextureUnit target, float s, float t, float r, float q)
		{
			MultiTexCoord4fNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4fvNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[278])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[278])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4fv(GLTextureUnit target, float* v)
		{
			MultiTexCoord4fvNative(target, v);
		}

		public static void MultiTexCoord4fv(GLTextureUnit target, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				MultiTexCoord4fvNative(target, pv0);
			}
		}

		public static void MultiTexCoord4fv(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord4fvNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4iNative(GLTextureUnit target, int s, int t, int r, int q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[279])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[279])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4i(GLTextureUnit target, int s, int t, int r, int q)
		{
			MultiTexCoord4iNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4ivNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[280])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[280])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4iv(GLTextureUnit target, int* v)
		{
			MultiTexCoord4ivNative(target, v);
		}

		public static void MultiTexCoord4iv(GLTextureUnit target, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				MultiTexCoord4ivNative(target, pv0);
			}
		}

		public static void MultiTexCoord4iv(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord4ivNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4sNative(GLTextureUnit target, short s, short t, short r, short q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, short, void>)funcTable[281])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, short, void>)funcTable[281])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4s(GLTextureUnit target, short s, short t, short r, short q)
		{
			MultiTexCoord4sNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4svNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[282])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[282])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4sv(GLTextureUnit target, short* v)
		{
			MultiTexCoord4svNative(target, v);
		}

		public static void MultiTexCoord4sv(GLTextureUnit target, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				MultiTexCoord4svNative(target, pv0);
			}
		}

		public static void MultiTexCoord4sv(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord4svNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NewListNative(uint list, GLListMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLListMode, void>)funcTable[283])(list, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLListMode, void>)funcTable[283])(list, mode);
			#endif
		}

		public static void NewList(uint list, GLListMode mode)
		{
			NewListNative(list, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3bNative(sbyte nx, sbyte ny, sbyte nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[284])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[284])(nx, ny, nz);
			#endif
		}

		public static void Normal3b(sbyte nx, sbyte ny, sbyte nz)
		{
			Normal3bNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3bvNative(sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte*, void>)funcTable[285])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[285])((nint)v);
			#endif
		}

		public static void Normal3bv(sbyte* v)
		{
			Normal3bvNative(v);
		}

		public static void Normal3bv(Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				Normal3bvNative(pv0);
			}
		}

		public static void Normal3bv(ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				Normal3bvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3dNative(double nx, double ny, double nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[286])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[286])(nx, ny, nz);
			#endif
		}

		public static void Normal3d(double nx, double ny, double nz)
		{
			Normal3dNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[287])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[287])((nint)v);
			#endif
		}

		public static void Normal3dv(double* v)
		{
			Normal3dvNative(v);
		}

		public static void Normal3dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				Normal3dvNative(pv0);
			}
		}

		public static void Normal3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Normal3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3fNative(float nx, float ny, float nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[288])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[288])(nx, ny, nz);
			#endif
		}

		public static void Normal3f(float nx, float ny, float nz)
		{
			Normal3fNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[289])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[289])((nint)v);
			#endif
		}

		public static void Normal3fv(float* v)
		{
			Normal3fvNative(v);
		}

		public static void Normal3fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				Normal3fvNative(pv0);
			}
		}

		public static void Normal3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Normal3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3iNative(int nx, int ny, int nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[290])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[290])(nx, ny, nz);
			#endif
		}

		public static void Normal3i(int nx, int ny, int nz)
		{
			Normal3iNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[291])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[291])((nint)v);
			#endif
		}

		public static void Normal3iv(int* v)
		{
			Normal3ivNative(v);
		}

		public static void Normal3iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				Normal3ivNative(pv0);
			}
		}

		public static void Normal3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Normal3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3sNative(short nx, short ny, short nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[292])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[292])(nx, ny, nz);
			#endif
		}

		public static void Normal3s(short nx, short ny, short nz)
		{
			Normal3sNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Normal3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[293])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[293])((nint)v);
			#endif
		}

		public static void Normal3sv(short* v)
		{
			Normal3svNative(v);
		}

		public static void Normal3sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				Normal3svNative(pv0);
			}
		}

		public static void Normal3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Normal3svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NormalPointerNative(GLNormalPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, int, void*, void>)funcTable[294])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, int, nint, void>)funcTable[294])(type, stride, (nint)pointer);
			#endif
		}

		public static void NormalPointer(GLNormalPointerType type, int stride, void* pointer)
		{
			NormalPointerNative(type, stride, pointer);
		}

		public static void NormalPointer(GLNormalPointerType type, int stride, nint pointer)
		{
			NormalPointerNative(type, stride, (void*)pointer);
		}

		public static void NormalPointer<TPointer>(GLNormalPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				NormalPointerNative(type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void OrthoNative(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[295])(left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[295])(left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void Ortho(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			OrthoNative(left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PassThroughNative(float token)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[296])(token);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[296])(token);
			#endif
		}

		public static void PassThrough(float token)
		{
			PassThroughNative(token);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelMapfvNative(GLPixelMap map, int mapsize, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, float*, void>)funcTable[297])(map, mapsize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[297])(map, mapsize, (nint)values);
			#endif
		}

		public static void PixelMapfv(GLPixelMap map, int mapsize, float* values)
		{
			PixelMapfvNative(map, mapsize, values);
		}

		public static void PixelMapfv(GLPixelMap map, int mapsize, Span<float> values)
		{
			fixed (float* pvalues0 = values)
			{
				PixelMapfvNative(map, mapsize, pvalues0);
			}
		}

		public static void PixelMapfv(GLPixelMap map, int mapsize, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				PixelMapfvNative(map, mapsize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelMapuivNative(GLPixelMap map, int mapsize, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, uint*, void>)funcTable[298])(map, mapsize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[298])(map, mapsize, (nint)values);
			#endif
		}

		public static void PixelMapuiv(GLPixelMap map, int mapsize, uint* values)
		{
			PixelMapuivNative(map, mapsize, values);
		}

		public static void PixelMapuiv(GLPixelMap map, int mapsize, Span<uint> values)
		{
			fixed (uint* pvalues0 = values)
			{
				PixelMapuivNative(map, mapsize, pvalues0);
			}
		}

		public static void PixelMapuiv(GLPixelMap map, int mapsize, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				PixelMapuivNative(map, mapsize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelMapusvNative(GLPixelMap map, int mapsize, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, ushort*, void>)funcTable[299])(map, mapsize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[299])(map, mapsize, (nint)values);
			#endif
		}

		public static void PixelMapusv(GLPixelMap map, int mapsize, ushort* values)
		{
			PixelMapusvNative(map, mapsize, values);
		}

		public static void PixelMapusv(GLPixelMap map, int mapsize, Span<ushort> values)
		{
			fixed (ushort* pvalues0 = values)
			{
				PixelMapusvNative(map, mapsize, pvalues0);
			}
		}

		public static void PixelMapusv(GLPixelMap map, int mapsize, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				PixelMapusvNative(map, mapsize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelStorefNative(GLPixelStoreParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[300])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[300])(pname, param);
			#endif
		}

		public static void PixelStoref(GLPixelStoreParameter pname, float param)
		{
			PixelStorefNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelStoreiNative(GLPixelStoreParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[301])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[301])(pname, param);
			#endif
		}

		public static void PixelStorei(GLPixelStoreParameter pname, int param)
		{
			PixelStoreiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelTransferfNative(GLPixelTransferParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, float, void>)funcTable[302])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, float, void>)funcTable[302])(pname, param);
			#endif
		}

		public static void PixelTransferf(GLPixelTransferParameter pname, float param)
		{
			PixelTransferfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelTransferiNative(GLPixelTransferParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, int, void>)funcTable[303])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelTransferParameter, int, void>)funcTable[303])(pname, param);
			#endif
		}

		public static void PixelTransferi(GLPixelTransferParameter pname, int param)
		{
			PixelTransferiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PixelZoomNative(float xfactor, float yfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[304])(xfactor, yfactor);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[304])(xfactor, yfactor);
			#endif
		}

		public static void PixelZoom(float xfactor, float yfactor)
		{
			PixelZoomNative(xfactor, yfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterfNative(GLPointParameterNameARB pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[305])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[305])(pname, param);
			#endif
		}

		public static void PointParameterf(GLPointParameterNameARB pname, float param)
		{
			PointParameterfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterfvNative(GLPointParameterNameARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float*, void>)funcTable[306])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[306])(pname, (nint)@params);
			#endif
		}

		public static void PointParameterfv(GLPointParameterNameARB pname, float* @params)
		{
			PointParameterfvNative(pname, @params);
		}

		public static void PointParameterfv(GLPointParameterNameARB pname, out float @params)
		{
			float pparams;
			PointParameterfvNative(pname, &pparams);
			@params = pparams;
		}

		public static void PointParameterfv(GLPointParameterNameARB pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				PointParameterfvNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameteriNative(GLPointParameterNameARB pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[307])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[307])(pname, param);
			#endif
		}

		public static void PointParameteri(GLPointParameterNameARB pname, int param)
		{
			PointParameteriNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointParameterivNative(GLPointParameterNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int*, void>)funcTable[308])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[308])(pname, (nint)@params);
			#endif
		}

		public static void PointParameteriv(GLPointParameterNameARB pname, int* @params)
		{
			PointParameterivNative(pname, @params);
		}

		public static void PointParameteriv(GLPointParameterNameARB pname, out int @params)
		{
			int pparams;
			PointParameterivNative(pname, &pparams);
			@params = pparams;
		}

		public static void PointParameteriv(GLPointParameterNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				PointParameterivNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PointSizeNative(float size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[309])(size);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[309])(size);
			#endif
		}

		public static void PointSize(float size)
		{
			PointSizeNative(size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonModeNative(GLTriangleFace face, GLPolygonMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[310])(face, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[310])(face, mode);
			#endif
		}

		public static void PolygonMode(GLTriangleFace face, GLPolygonMode mode)
		{
			PolygonModeNative(face, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonOffsetNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[311])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[311])(factor, units);
			#endif
		}

		public static void PolygonOffset(float factor, float units)
		{
			PolygonOffsetNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonStippleNative(byte* mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[312])(mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[312])((nint)mask);
			#endif
		}

		public static void PolygonStipple(byte* mask)
		{
			PolygonStippleNative(mask);
		}

		public static void PolygonStipple(string mask)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mask != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mask);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mask, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PolygonStippleNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PolygonStipple(Span<byte> mask)
		{
			fixed (byte* pmask0 = mask)
			{
				PolygonStippleNative(pmask0);
			}
		}

		public static void PolygonStipple(ref byte mask)
		{
			fixed (byte* pmask0 = &mask)
			{
				PolygonStippleNative(pmask0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopAttribNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[313])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[313])();
			#endif
		}

		public static void PopAttrib()
		{
			PopAttribNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopClientAttribNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[314])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[314])();
			#endif
		}

		public static void PopClientAttrib()
		{
			PopClientAttribNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopMatrixNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[315])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[315])();
			#endif
		}

		public static void PopMatrix()
		{
			PopMatrixNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopNameNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[316])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[316])();
			#endif
		}

		public static void PopName()
		{
			PopNameNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PrioritizeTexturesNative(int n, uint* textures, float* priorities)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, float*, void>)funcTable[317])(n, textures, priorities);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, nint, void>)funcTable[317])(n, (nint)textures, (nint)priorities);
			#endif
		}

		public static void PrioritizeTextures(int n, uint* textures, float* priorities)
		{
			PrioritizeTexturesNative(n, textures, priorities);
		}

		public static void PrioritizeTextures(int n, Span<uint> textures, float* priorities)
		{
			fixed (uint* ptextures0 = textures)
			{
				PrioritizeTexturesNative(n, ptextures0, priorities);
			}
		}

		public static void PrioritizeTextures(int n, ref uint textures, float* priorities)
		{
			fixed (uint* ptextures0 = &textures)
			{
				PrioritizeTexturesNative(n, ptextures0, priorities);
			}
		}

		public static void PrioritizeTextures(int n, uint* textures, Span<float> priorities)
		{
			fixed (float* ppriorities0 = priorities)
			{
				PrioritizeTexturesNative(n, textures, ppriorities0);
			}
		}

		public static void PrioritizeTextures(int n, uint* textures, ref float priorities)
		{
			fixed (float* ppriorities0 = &priorities)
			{
				PrioritizeTexturesNative(n, textures, ppriorities0);
			}
		}

		public static void PrioritizeTextures(int n, Span<uint> textures, Span<float> priorities)
		{
			fixed (uint* ptextures0 = textures)
			{
				fixed (float* ppriorities1 = priorities)
				{
					PrioritizeTexturesNative(n, ptextures0, ppriorities1);
				}
			}
		}

		public static void PrioritizeTextures(int n, ref uint textures, ref float priorities)
		{
			fixed (uint* ptextures0 = &textures)
			{
				fixed (float* ppriorities1 = &priorities)
				{
					PrioritizeTexturesNative(n, ptextures0, ppriorities1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushAttribNative(GLAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAttribMask, void>)funcTable[318])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLAttribMask, void>)funcTable[318])(mask);
			#endif
		}

		public static void PushAttrib(GLAttribMask mask)
		{
			PushAttribNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushClientAttribNative(GLClientAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[319])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[319])(mask);
			#endif
		}

		public static void PushClientAttrib(GLClientAttribMask mask)
		{
			PushClientAttribNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushMatrixNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[320])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[320])();
			#endif
		}

		public static void PushMatrix()
		{
			PushMatrixNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushNameNative(uint name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[321])(name);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[321])(name);
			#endif
		}

		public static void PushName(uint name)
		{
			PushNameNative(name);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2dNative(double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[322])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[322])(x, y);
			#endif
		}

		public static void RasterPos2d(double x, double y)
		{
			RasterPos2dNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[323])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[323])((nint)v);
			#endif
		}

		public static void RasterPos2dv(double* v)
		{
			RasterPos2dvNative(v);
		}

		public static void RasterPos2dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				RasterPos2dvNative(pv0);
			}
		}

		public static void RasterPos2dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				RasterPos2dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2fNative(float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[324])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[324])(x, y);
			#endif
		}

		public static void RasterPos2f(float x, float y)
		{
			RasterPos2fNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[325])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[325])((nint)v);
			#endif
		}

		public static void RasterPos2fv(float* v)
		{
			RasterPos2fvNative(v);
		}

		public static void RasterPos2fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				RasterPos2fvNative(pv0);
			}
		}

		public static void RasterPos2fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				RasterPos2fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2iNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[326])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[326])(x, y);
			#endif
		}

		public static void RasterPos2i(int x, int y)
		{
			RasterPos2iNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[327])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[327])((nint)v);
			#endif
		}

		public static void RasterPos2iv(int* v)
		{
			RasterPos2ivNative(v);
		}

		public static void RasterPos2iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				RasterPos2ivNative(pv0);
			}
		}

		public static void RasterPos2iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				RasterPos2ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2sNative(short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[328])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[328])(x, y);
			#endif
		}

		public static void RasterPos2s(short x, short y)
		{
			RasterPos2sNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos2svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[329])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[329])((nint)v);
			#endif
		}

		public static void RasterPos2sv(short* v)
		{
			RasterPos2svNative(v);
		}

		public static void RasterPos2sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				RasterPos2svNative(pv0);
			}
		}

		public static void RasterPos2sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				RasterPos2svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3dNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[330])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[330])(x, y, z);
			#endif
		}

		public static void RasterPos3d(double x, double y, double z)
		{
			RasterPos3dNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[331])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[331])((nint)v);
			#endif
		}

		public static void RasterPos3dv(double* v)
		{
			RasterPos3dvNative(v);
		}

		public static void RasterPos3dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				RasterPos3dvNative(pv0);
			}
		}

		public static void RasterPos3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				RasterPos3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3fNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[332])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[332])(x, y, z);
			#endif
		}

		public static void RasterPos3f(float x, float y, float z)
		{
			RasterPos3fNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[333])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[333])((nint)v);
			#endif
		}

		public static void RasterPos3fv(float* v)
		{
			RasterPos3fvNative(v);
		}

		public static void RasterPos3fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				RasterPos3fvNative(pv0);
			}
		}

		public static void RasterPos3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				RasterPos3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3iNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[334])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[334])(x, y, z);
			#endif
		}

		public static void RasterPos3i(int x, int y, int z)
		{
			RasterPos3iNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[335])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[335])((nint)v);
			#endif
		}

		public static void RasterPos3iv(int* v)
		{
			RasterPos3ivNative(v);
		}

		public static void RasterPos3iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				RasterPos3ivNative(pv0);
			}
		}

		public static void RasterPos3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				RasterPos3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3sNative(short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[336])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[336])(x, y, z);
			#endif
		}

		public static void RasterPos3s(short x, short y, short z)
		{
			RasterPos3sNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[337])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[337])((nint)v);
			#endif
		}

		public static void RasterPos3sv(short* v)
		{
			RasterPos3svNative(v);
		}

		public static void RasterPos3sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				RasterPos3svNative(pv0);
			}
		}

		public static void RasterPos3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				RasterPos3svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4dNative(double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[338])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[338])(x, y, z, w);
			#endif
		}

		public static void RasterPos4d(double x, double y, double z, double w)
		{
			RasterPos4dNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[339])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[339])((nint)v);
			#endif
		}

		public static void RasterPos4dv(double* v)
		{
			RasterPos4dvNative(v);
		}

		public static void RasterPos4dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				RasterPos4dvNative(pv0);
			}
		}

		public static void RasterPos4dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				RasterPos4dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4fNative(float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[340])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[340])(x, y, z, w);
			#endif
		}

		public static void RasterPos4f(float x, float y, float z, float w)
		{
			RasterPos4fNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[341])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[341])((nint)v);
			#endif
		}

		public static void RasterPos4fv(float* v)
		{
			RasterPos4fvNative(v);
		}

		public static void RasterPos4fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				RasterPos4fvNative(pv0);
			}
		}

		public static void RasterPos4fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				RasterPos4fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4iNative(int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[342])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[342])(x, y, z, w);
			#endif
		}

		public static void RasterPos4i(int x, int y, int z, int w)
		{
			RasterPos4iNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[343])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[343])((nint)v);
			#endif
		}

		public static void RasterPos4iv(int* v)
		{
			RasterPos4ivNative(v);
		}

		public static void RasterPos4iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				RasterPos4ivNative(pv0);
			}
		}

		public static void RasterPos4iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				RasterPos4ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4sNative(short x, short y, short z, short w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[344])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[344])(x, y, z, w);
			#endif
		}

		public static void RasterPos4s(short x, short y, short z, short w)
		{
			RasterPos4sNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterPos4svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[345])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[345])((nint)v);
			#endif
		}

		public static void RasterPos4sv(short* v)
		{
			RasterPos4svNative(v);
		}

		public static void RasterPos4sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				RasterPos4svNative(pv0);
			}
		}

		public static void RasterPos4sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				RasterPos4svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadBufferNative(GLReadBufferMode src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, void>)funcTable[346])(src);
			#else
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, void>)funcTable[346])(src);
			#endif
		}

		public static void ReadBuffer(GLReadBufferMode src)
		{
			ReadBufferNative(src);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadPixelsNative(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[347])(x, y, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[347])(x, y, width, height, format, type, (nint)pixels);
			#endif
		}

		public static void ReadPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			ReadPixelsNative(x, y, width, height, format, type, pixels);
		}

		public static void ReadPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			ReadPixelsNative(x, y, width, height, format, type, (void*)pixels);
		}

		public static void ReadPixels<TPixels>(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				ReadPixelsNative(x, y, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectdNative(double x1, double y1, double x2, double y2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[348])(x1, y1, x2, y2);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[348])(x1, y1, x2, y2);
			#endif
		}

		public static void Rectd(double x1, double y1, double x2, double y2)
		{
			RectdNative(x1, y1, x2, y2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectdvNative(double* v1, double* v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, double*, void>)funcTable[349])(v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[349])((nint)v1, (nint)v2);
			#endif
		}

		public static void Rectdv(double* v1, double* v2)
		{
			RectdvNative(v1, v2);
		}

		public static void Rectdv(Span<double> v1, double* v2)
		{
			fixed (double* pv10 = v1)
			{
				RectdvNative(pv10, v2);
			}
		}

		public static void Rectdv(ref double v1, double* v2)
		{
			fixed (double* pv10 = &v1)
			{
				RectdvNative(pv10, v2);
			}
		}

		public static void Rectdv(double* v1, Span<double> v2)
		{
			fixed (double* pv20 = v2)
			{
				RectdvNative(v1, pv20);
			}
		}

		public static void Rectdv(double* v1, ref double v2)
		{
			fixed (double* pv20 = &v2)
			{
				RectdvNative(v1, pv20);
			}
		}

		public static void Rectdv(Span<double> v1, Span<double> v2)
		{
			fixed (double* pv10 = v1)
			{
				fixed (double* pv21 = v2)
				{
					RectdvNative(pv10, pv21);
				}
			}
		}

		public static void Rectdv(ref double v1, ref double v2)
		{
			fixed (double* pv10 = &v1)
			{
				fixed (double* pv21 = &v2)
				{
					RectdvNative(pv10, pv21);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectfNative(float x1, float y1, float x2, float y2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[350])(x1, y1, x2, y2);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[350])(x1, y1, x2, y2);
			#endif
		}

		public static void Rectf(float x1, float y1, float x2, float y2)
		{
			RectfNative(x1, y1, x2, y2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectfvNative(float* v1, float* v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, float*, void>)funcTable[351])(v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[351])((nint)v1, (nint)v2);
			#endif
		}

		public static void Rectfv(float* v1, float* v2)
		{
			RectfvNative(v1, v2);
		}

		public static void Rectfv(Span<float> v1, float* v2)
		{
			fixed (float* pv10 = v1)
			{
				RectfvNative(pv10, v2);
			}
		}

		public static void Rectfv(ref float v1, float* v2)
		{
			fixed (float* pv10 = &v1)
			{
				RectfvNative(pv10, v2);
			}
		}

		public static void Rectfv(float* v1, Span<float> v2)
		{
			fixed (float* pv20 = v2)
			{
				RectfvNative(v1, pv20);
			}
		}

		public static void Rectfv(float* v1, ref float v2)
		{
			fixed (float* pv20 = &v2)
			{
				RectfvNative(v1, pv20);
			}
		}

		public static void Rectfv(Span<float> v1, Span<float> v2)
		{
			fixed (float* pv10 = v1)
			{
				fixed (float* pv21 = v2)
				{
					RectfvNative(pv10, pv21);
				}
			}
		}

		public static void Rectfv(ref float v1, ref float v2)
		{
			fixed (float* pv10 = &v1)
			{
				fixed (float* pv21 = &v2)
				{
					RectfvNative(pv10, pv21);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectiNative(int x1, int y1, int x2, int y2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[352])(x1, y1, x2, y2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[352])(x1, y1, x2, y2);
			#endif
		}

		public static void Recti(int x1, int y1, int x2, int y2)
		{
			RectiNative(x1, y1, x2, y2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectivNative(int* v1, int* v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, int*, void>)funcTable[353])(v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[353])((nint)v1, (nint)v2);
			#endif
		}

		public static void Rectiv(int* v1, int* v2)
		{
			RectivNative(v1, v2);
		}

		public static void Rectiv(Span<int> v1, int* v2)
		{
			fixed (int* pv10 = v1)
			{
				RectivNative(pv10, v2);
			}
		}

		public static void Rectiv(ref int v1, int* v2)
		{
			fixed (int* pv10 = &v1)
			{
				RectivNative(pv10, v2);
			}
		}

		public static void Rectiv(int* v1, Span<int> v2)
		{
			fixed (int* pv20 = v2)
			{
				RectivNative(v1, pv20);
			}
		}

		public static void Rectiv(int* v1, ref int v2)
		{
			fixed (int* pv20 = &v2)
			{
				RectivNative(v1, pv20);
			}
		}

		public static void Rectiv(Span<int> v1, Span<int> v2)
		{
			fixed (int* pv10 = v1)
			{
				fixed (int* pv21 = v2)
				{
					RectivNative(pv10, pv21);
				}
			}
		}

		public static void Rectiv(ref int v1, ref int v2)
		{
			fixed (int* pv10 = &v1)
			{
				fixed (int* pv21 = &v2)
				{
					RectivNative(pv10, pv21);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectsNative(short x1, short y1, short x2, short y2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[354])(x1, y1, x2, y2);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[354])(x1, y1, x2, y2);
			#endif
		}

		public static void Rects(short x1, short y1, short x2, short y2)
		{
			RectsNative(x1, y1, x2, y2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RectsvNative(short* v1, short* v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, short*, void>)funcTable[355])(v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[355])((nint)v1, (nint)v2);
			#endif
		}

		public static void Rectsv(short* v1, short* v2)
		{
			RectsvNative(v1, v2);
		}

		public static void Rectsv(Span<short> v1, short* v2)
		{
			fixed (short* pv10 = v1)
			{
				RectsvNative(pv10, v2);
			}
		}

		public static void Rectsv(ref short v1, short* v2)
		{
			fixed (short* pv10 = &v1)
			{
				RectsvNative(pv10, v2);
			}
		}

		public static void Rectsv(short* v1, Span<short> v2)
		{
			fixed (short* pv20 = v2)
			{
				RectsvNative(v1, pv20);
			}
		}

		public static void Rectsv(short* v1, ref short v2)
		{
			fixed (short* pv20 = &v2)
			{
				RectsvNative(v1, pv20);
			}
		}

		public static void Rectsv(Span<short> v1, Span<short> v2)
		{
			fixed (short* pv10 = v1)
			{
				fixed (short* pv21 = v2)
				{
					RectsvNative(pv10, pv21);
				}
			}
		}

		public static void Rectsv(ref short v1, ref short v2)
		{
			fixed (short* pv10 = &v1)
			{
				fixed (short* pv21 = &v2)
				{
					RectsvNative(pv10, pv21);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int RenderModeNative(GLRenderingMode mode)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLRenderingMode, int>)funcTable[356])(mode);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GLRenderingMode, int>)funcTable[356])(mode);
			#endif
		}

		public static int RenderMode(GLRenderingMode mode)
		{
			int ret = RenderModeNative(mode);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RotatedNative(double angle, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[357])(angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[357])(angle, x, y, z);
			#endif
		}

		public static void Rotated(double angle, double x, double y, double z)
		{
			RotatedNative(angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RotatefNative(float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[358])(angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[358])(angle, x, y, z);
			#endif
		}

		public static void Rotatef(float angle, float x, float y, float z)
		{
			RotatefNative(angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SampleCoverageNative(float value, bool invert)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, byte, void>)funcTable[359])(value, *((byte*)(&invert)));
			#else
			((delegate* unmanaged[Cdecl]<float, byte, void>)funcTable[359])(value, *((byte*)(&invert)));
			#endif
		}

		public static void SampleCoverage(float value, bool invert)
		{
			SampleCoverageNative(value, invert);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScaledNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[360])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[360])(x, y, z);
			#endif
		}

		public static void Scaled(double x, double y, double z)
		{
			ScaledNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScalefNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[361])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[361])(x, y, z);
			#endif
		}

		public static void Scalef(float x, float y, float z)
		{
			ScalefNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[362])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[362])(x, y, width, height);
			#endif
		}

		public static void Scissor(int x, int y, int width, int height)
		{
			ScissorNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3bNative(sbyte red, sbyte green, sbyte blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[363])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[363])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3b(sbyte red, sbyte green, sbyte blue)
		{
			SecondaryColor3bNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3bvNative(sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte*, void>)funcTable[364])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[364])((nint)v);
			#endif
		}

		public static void SecondaryColor3bv(sbyte* v)
		{
			SecondaryColor3bvNative(v);
		}

		public static void SecondaryColor3bv(Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				SecondaryColor3bvNative(pv0);
			}
		}

		public static void SecondaryColor3bv(ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				SecondaryColor3bvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3dNative(double red, double green, double blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[365])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[365])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3d(double red, double green, double blue)
		{
			SecondaryColor3dNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[366])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[366])((nint)v);
			#endif
		}

		public static void SecondaryColor3dv(double* v)
		{
			SecondaryColor3dvNative(v);
		}

		public static void SecondaryColor3dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				SecondaryColor3dvNative(pv0);
			}
		}

		public static void SecondaryColor3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				SecondaryColor3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3fNative(float red, float green, float blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[367])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[367])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3f(float red, float green, float blue)
		{
			SecondaryColor3fNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[368])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[368])((nint)v);
			#endif
		}

		public static void SecondaryColor3fv(float* v)
		{
			SecondaryColor3fvNative(v);
		}

		public static void SecondaryColor3fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				SecondaryColor3fvNative(pv0);
			}
		}

		public static void SecondaryColor3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				SecondaryColor3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3iNative(int red, int green, int blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[369])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[369])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3i(int red, int green, int blue)
		{
			SecondaryColor3iNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[370])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[370])((nint)v);
			#endif
		}

		public static void SecondaryColor3iv(int* v)
		{
			SecondaryColor3ivNative(v);
		}

		public static void SecondaryColor3iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				SecondaryColor3ivNative(pv0);
			}
		}

		public static void SecondaryColor3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				SecondaryColor3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3sNative(short red, short green, short blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[371])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[371])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3s(short red, short green, short blue)
		{
			SecondaryColor3sNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[372])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[372])((nint)v);
			#endif
		}

		public static void SecondaryColor3sv(short* v)
		{
			SecondaryColor3svNative(v);
		}

		public static void SecondaryColor3sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				SecondaryColor3svNative(pv0);
			}
		}

		public static void SecondaryColor3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				SecondaryColor3svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3ubNative(bool red, bool green, bool blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, void>)funcTable[373])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)));
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, void>)funcTable[373])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)));
			#endif
		}

		public static void SecondaryColor3ub(bool red, bool green, bool blue)
		{
			SecondaryColor3ubNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3ubvNative(byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[374])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[374])((nint)v);
			#endif
		}

		public static void SecondaryColor3ubv(byte* v)
		{
			SecondaryColor3ubvNative(v);
		}

		public static void SecondaryColor3ubv(string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			SecondaryColor3ubvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void SecondaryColor3ubv(Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				SecondaryColor3ubvNative(pv0);
			}
		}

		public static void SecondaryColor3ubv(ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				SecondaryColor3ubvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3uiNative(uint red, uint green, uint blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[375])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[375])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3ui(uint red, uint green, uint blue)
		{
			SecondaryColor3uiNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3uivNative(uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint*, void>)funcTable[376])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[376])((nint)v);
			#endif
		}

		public static void SecondaryColor3uiv(uint* v)
		{
			SecondaryColor3uivNative(v);
		}

		public static void SecondaryColor3uiv(Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				SecondaryColor3uivNative(pv0);
			}
		}

		public static void SecondaryColor3uiv(ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				SecondaryColor3uivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3usNative(ushort red, ushort green, ushort blue)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, void>)funcTable[377])(red, green, blue);
			#else
			((delegate* unmanaged[Cdecl]<ushort, ushort, ushort, void>)funcTable[377])(red, green, blue);
			#endif
		}

		public static void SecondaryColor3us(ushort red, ushort green, ushort blue)
		{
			SecondaryColor3usNative(red, green, blue);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColor3usvNative(ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ushort*, void>)funcTable[378])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[378])((nint)v);
			#endif
		}

		public static void SecondaryColor3usv(ushort* v)
		{
			SecondaryColor3usvNative(v);
		}

		public static void SecondaryColor3usv(Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				SecondaryColor3usvNative(pv0);
			}
		}

		public static void SecondaryColor3usv(ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				SecondaryColor3usvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SecondaryColorPointerNative(int size, GLColorPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void*, void>)funcTable[379])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, nint, void>)funcTable[379])(size, type, stride, (nint)pointer);
			#endif
		}

		public static void SecondaryColorPointer(int size, GLColorPointerType type, int stride, void* pointer)
		{
			SecondaryColorPointerNative(size, type, stride, pointer);
		}

		public static void SecondaryColorPointer(int size, GLColorPointerType type, int stride, nint pointer)
		{
			SecondaryColorPointerNative(size, type, stride, (void*)pointer);
		}

		public static void SecondaryColorPointer<TPointer>(int size, GLColorPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				SecondaryColorPointerNative(size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SelectBufferNative(int size, uint* buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[380])(size, buffer);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[380])(size, (nint)buffer);
			#endif
		}

		public static void SelectBuffer(int size, uint* buffer)
		{
			SelectBufferNative(size, buffer);
		}

		public static void SelectBuffer(int size, Span<uint> buffer)
		{
			fixed (uint* pbuffer0 = buffer)
			{
				SelectBufferNative(size, pbuffer0);
			}
		}

		public static void SelectBuffer(int size, ref uint buffer)
		{
			fixed (uint* pbuffer0 = &buffer)
			{
				SelectBufferNative(size, pbuffer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadeModelNative(GLShadingModel mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShadingModel, void>)funcTable[381])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLShadingModel, void>)funcTable[381])(mode);
			#endif
		}

		public static void ShadeModel(GLShadingModel mode)
		{
			ShadeModelNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShaderSourceNative(uint shader, int count, byte** str, int* length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, int*, void>)funcTable[382])(shader, count, str, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[382])(shader, count, (nint)str, (nint)length);
			#endif
		}

		public static void ShaderSource(uint shader, int count, byte** str, int* length)
		{
			ShaderSourceNative(shader, count, str, length);
		}

		public static void ShaderSource(uint shader, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShaderSourceNative(shader, 1, &pStr0, &pStrSize0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void ShaderSource(uint shader, string[] sources)
		{
			byte** pStrArray0 = null;
			int* pStrArraySizes0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(sources) + sources.Length * sizeof(int);
			if (sources != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArraySizes0 = (int*)Utils.Alloc<int>(sources.Length);
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArraySizesStack0 = stackalloc byte[sources.Length * sizeof(int)];
					pStrArraySizes0 = (int*)pStrArraySizesStack0;
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < sources.Length; i++)
			{
				pStrArraySizes0[i] = Utils.GetByteCountUTF8(sources[i]);
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(sources[i]);
			}
			ShaderSourceNative(shader, sources.Length, pStrArray0, pStrArraySizes0);
			for (int i = 0; i < sources.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
				Utils.Free(pStrArraySizes0);
			}
		}

		public static void ShaderSource(uint shader, int count, byte** str, Span<int> length)
		{
			fixed (int* plength0 = length)
			{
				ShaderSourceNative(shader, count, str, plength0);
			}
		}

		public static void ShaderSource(uint shader, int count, byte** str, ref int length)
		{
			fixed (int* plength0 = &length)
			{
				ShaderSourceNative(shader, count, str, plength0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFuncNative(GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[383])(func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[383])(func, reference, mask);
			#endif
		}

		public static void StencilFunc(GLStencilFunction func, int reference, uint mask)
		{
			StencilFuncNative(func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFuncSeparateNative(GLTriangleFace face, GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilFunction, int, uint, void>)funcTable[384])(face, func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilFunction, int, uint, void>)funcTable[384])(face, func, reference, mask);
			#endif
		}

		public static void StencilFuncSeparate(GLTriangleFace face, GLStencilFunction func, int reference, uint mask)
		{
			StencilFuncSeparateNative(face, func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilMaskNative(uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[385])(mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[385])(mask);
			#endif
		}

		public static void StencilMask(uint mask)
		{
			StencilMaskNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilMaskSeparateNative(GLTriangleFace face, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, uint, void>)funcTable[386])(face, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, uint, void>)funcTable[386])(face, mask);
			#endif
		}

		public static void StencilMaskSeparate(GLTriangleFace face, uint mask)
		{
			StencilMaskSeparateNative(face, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilOpNative(GLStencilOp fail, GLStencilOp zfail, GLStencilOp zpass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[387])(fail, zfail, zpass);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[387])(fail, zfail, zpass);
			#endif
		}

		public static void StencilOp(GLStencilOp fail, GLStencilOp zfail, GLStencilOp zpass)
		{
			StencilOpNative(fail, zfail, zpass);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilOpSeparateNative(GLTriangleFace face, GLStencilOp sfail, GLStencilOp dpfail, GLStencilOp dppass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[388])(face, sfail, dpfail, dppass);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLStencilOp, GLStencilOp, GLStencilOp, void>)funcTable[388])(face, sfail, dpfail, dppass);
			#endif
		}

		public static void StencilOpSeparate(GLTriangleFace face, GLStencilOp sfail, GLStencilOp dpfail, GLStencilOp dppass)
		{
			StencilOpSeparateNative(face, sfail, dpfail, dppass);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexCoord1dNative(double s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[389])(s);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[389])(s);
			#endif
		}

		public static void TexCoord1d(double s)
		{
			TexCoord1dNative(s);
		}
	}
}
