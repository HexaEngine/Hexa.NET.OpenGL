// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		/// <summary>
		/// Specify a one-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage1DNative(target, level, xoffset, width, format, type, (void*)pixels);
		}

		/// <summary>
		/// Specify a one-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage1D<TPixels>(GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage1DNative(target, level, xoffset, width, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[440])(target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[440])(target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage2D<TPixels>(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[441])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[441])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.2 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.2 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.2 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void TexSubImage3D<TPixels>(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TranslatedNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[442])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[442])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Translated(double x, double y, double z)
		{
			TranslatedNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TranslatefNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[443])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[443])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Translatef(float x, float y, float z)
		{
			TranslatefNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1fNative(int location, float v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[444])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, float, void>)funcTable[444])(location, v0);
			#endif
		}

		/// <summary>
		/// Specify the value of a uniform variable for the current program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1f(int location, float v0)
		{
			Uniform1fNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[445])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[445])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1fv(int location, int count, float* value)
		{
			Uniform1fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform1fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform1fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1iNative(int location, int v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[446])(location, v0);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[446])(location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1i(int location, int v0)
		{
			Uniform1iNative(location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[447])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[447])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1iv(int location, int count, int* value)
		{
			Uniform1ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform1ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform1iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform1ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2fNative(int location, float v0, float v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[448])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, void>)funcTable[448])(location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2f(int location, float v0, float v1)
		{
			Uniform2fNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[449])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[449])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2fv(int location, int count, float* value)
		{
			Uniform2fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform2fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform2fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2iNative(int location, int v0, int v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[450])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[450])(location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2i(int location, int v0, int v1)
		{
			Uniform2iNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[451])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[451])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2iv(int location, int count, int* value)
		{
			Uniform2ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform2ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform2iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform2ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3fNative(int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[452])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, void>)funcTable[452])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3f(int location, float v0, float v1, float v2)
		{
			Uniform3fNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[453])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[453])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3fv(int location, int count, float* value)
		{
			Uniform3fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform3fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3iNative(int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[454])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[454])(location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3i(int location, int v0, int v1, int v2)
		{
			Uniform3iNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[455])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[455])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3iv(int location, int count, int* value)
		{
			Uniform3ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform3iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform3ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4fNative(int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[456])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, float, float, float, float, void>)funcTable[456])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4f(int location, float v0, float v1, float v2, float v3)
		{
			Uniform4fNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4fvNative(int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, float*, void>)funcTable[457])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[457])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4fv(int location, int count, float* value)
		{
			Uniform4fvNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4fv(int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4fv(int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				Uniform4fvNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4iNative(int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[458])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, void>)funcTable[458])(location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4i(int location, int v0, int v1, int v2, int v3)
		{
			Uniform4iNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4ivNative(int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, void>)funcTable[459])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[459])(location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4iv(int location, int count, int* value)
		{
			Uniform4ivNative(location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4iv(int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Uniform4iv(int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				Uniform4ivNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[460])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[460])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[461])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[461])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[462])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[462])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix2x4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix2x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[463])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[463])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[464])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[464])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[465])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[465])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix3x4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix3x4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[466])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[466])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix4fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix4fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UniformMatrix4fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x2fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[467])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[467])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x2fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x2fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x2fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x2fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x2fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x3fvNative(int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[468])(location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[468])(location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x3fv(int location, int count, bool transpose, float* value)
		{
			UniformMatrix4x3fvNative(location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x3fv(int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 2.1<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void UniformMatrix4x3fv(int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x3fvNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnmapBufferNative(GLBufferTargetARB target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[469])(target);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, byte>)funcTable[469])(target);
			#endif
		}

		/// <summary>
		/// Release the mapping of a buffer object's data store into the client's address space
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static bool UnmapBuffer(GLBufferTargetARB target)
		{
			byte ret = UnmapBufferNative(target);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[470])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[470])(program);
			#endif
		}

		/// <summary>
		/// Installs a program object as part of current rendering state
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void UseProgram(uint program)
		{
			UseProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ValidateProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[471])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[471])(program);
			#endif
		}

		/// <summary>
		/// Validates a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void ValidateProgram(uint program)
		{
			ValidateProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2dNative(double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[472])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[472])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2d(double x, double y)
		{
			Vertex2dNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[473])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[473])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2dv(double* v)
		{
			Vertex2dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				Vertex2dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Vertex2dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2fNative(float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[474])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[474])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2f(float x, float y)
		{
			Vertex2fNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[475])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[475])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2fv(float* v)
		{
			Vertex2fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				Vertex2fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Vertex2fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2iNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[476])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[476])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2i(int x, int y)
		{
			Vertex2iNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[477])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[477])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2iv(int* v)
		{
			Vertex2ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				Vertex2ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Vertex2ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2sNative(short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[478])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[478])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2s(short x, short y)
		{
			Vertex2sNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex2svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[479])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[479])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2sv(short* v)
		{
			Vertex2svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				Vertex2svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex2sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Vertex2svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3dNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[480])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[480])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3d(double x, double y, double z)
		{
			Vertex3dNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[481])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[481])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3dv(double* v)
		{
			Vertex3dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				Vertex3dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Vertex3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3fNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[482])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[482])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3f(float x, float y, float z)
		{
			Vertex3fNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[483])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[483])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3fv(float* v)
		{
			Vertex3fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				Vertex3fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Vertex3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3iNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[484])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[484])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3i(int x, int y, int z)
		{
			Vertex3iNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[485])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[485])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3iv(int* v)
		{
			Vertex3ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				Vertex3ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Vertex3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3sNative(short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[486])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[486])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3s(short x, short y, short z)
		{
			Vertex3sNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[487])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[487])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3sv(short* v)
		{
			Vertex3svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				Vertex3svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Vertex3svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4dNative(double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[488])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, void>)funcTable[488])(x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4d(double x, double y, double z, double w)
		{
			Vertex4dNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[489])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[489])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4dv(double* v)
		{
			Vertex4dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				Vertex4dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Vertex4dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4fNative(float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[490])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[490])(x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4f(float x, float y, float z, float w)
		{
			Vertex4fNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[491])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[491])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4fv(float* v)
		{
			Vertex4fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				Vertex4fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Vertex4fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4iNative(int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[492])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[492])(x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4i(int x, int y, int z, int w)
		{
			Vertex4iNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[493])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[493])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4iv(int* v)
		{
			Vertex4ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				Vertex4ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Vertex4ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4sNative(short x, short y, short z, short w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[494])(x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, short, void>)funcTable[494])(x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4s(short x, short y, short z, short w)
		{
			Vertex4sNative(x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Vertex4svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[495])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[495])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4sv(short* v)
		{
			Vertex4svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				Vertex4svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Vertex4sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Vertex4svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1dNative(uint index, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[496])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[496])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1d(uint index, double x)
		{
			VertexAttrib1dNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[497])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[497])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1dv(uint index, double* v)
		{
			VertexAttrib1dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib1dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1fNative(uint index, float x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[498])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, void>)funcTable[498])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1f(uint index, float x)
		{
			VertexAttrib1fNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[499])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[499])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1fv(uint index, float* v)
		{
			VertexAttrib1fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib1fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1sNative(uint index, short x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[500])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, void>)funcTable[500])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1s(uint index, short x)
		{
			VertexAttrib1sNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib1svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[501])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[501])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1sv(uint index, short* v)
		{
			VertexAttrib1svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib1sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib1svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2dNative(uint index, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[502])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[502])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2d(uint index, double x, double y)
		{
			VertexAttrib2dNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[503])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[503])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2dv(uint index, double* v)
		{
			VertexAttrib2dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib2dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2fNative(uint index, float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[504])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[504])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2f(uint index, float x, float y)
		{
			VertexAttrib2fNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[505])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[505])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2fv(uint index, float* v)
		{
			VertexAttrib2fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib2fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2sNative(uint index, short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[506])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, void>)funcTable[506])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2s(uint index, short x, short y)
		{
			VertexAttrib2sNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib2svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[507])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[507])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2sv(uint index, short* v)
		{
			VertexAttrib2svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib2sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib2svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3dNative(uint index, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[508])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[508])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3d(uint index, double x, double y, double z)
		{
			VertexAttrib3dNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[509])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[509])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3dv(uint index, double* v)
		{
			VertexAttrib3dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib3dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3fNative(uint index, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[510])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, void>)funcTable[510])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3f(uint index, float x, float y, float z)
		{
			VertexAttrib3fNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[511])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[511])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3fv(uint index, float* v)
		{
			VertexAttrib3fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib3fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3sNative(uint index, short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[512])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, void>)funcTable[512])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3s(uint index, short x, short y, short z)
		{
			VertexAttrib3sNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib3svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[513])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[513])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3sv(uint index, short* v)
		{
			VertexAttrib3svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib3sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib3svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NbvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[514])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[514])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nbv(uint index, sbyte* v)
		{
			VertexAttrib4NbvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nbv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nbv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttrib4NbvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[515])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[515])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Niv(uint index, int* v)
		{
			VertexAttrib4NivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Niv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Niv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4NivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NsvNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[516])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[516])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nsv(uint index, short* v)
		{
			VertexAttrib4NsvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nsv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nsv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4NsvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NubNative(uint index, bool x, bool y, bool z, bool w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[517])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[517])(index, *((byte*)(&x)), *((byte*)(&y)), *((byte*)(&z)), *((byte*)(&w)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nub(uint index, bool x, bool y, bool z, bool w)
		{
			VertexAttrib4NubNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[518])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[518])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, byte* v)
		{
			VertexAttrib4NubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4NubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4NubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NuivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[519])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[519])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nuiv(uint index, uint* v)
		{
			VertexAttrib4NuivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nuiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nuiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4NuivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4NusvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[520])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[520])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nusv(uint index, ushort* v)
		{
			VertexAttrib4NusvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nusv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4Nusv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4NusvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4bvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[521])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[521])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4bv(uint index, sbyte* v)
		{
			VertexAttrib4bvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4bv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttrib4bvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4bv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttrib4bvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4dNative(uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[522])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[522])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4d(uint index, double x, double y, double z, double w)
		{
			VertexAttrib4dNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[523])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[523])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4dv(uint index, double* v)
		{
			VertexAttrib4dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttrib4dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttrib4dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4fNative(uint index, float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[524])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[524])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4f(uint index, float x, float y, float z, float w)
		{
			VertexAttrib4fNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[525])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[525])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4fv(uint index, float* v)
		{
			VertexAttrib4fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[526])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[526])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4iv(uint index, int* v)
		{
			VertexAttrib4ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4sNative(uint index, short x, short y, short z, short w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[527])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[527])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4s(uint index, short x, short y, short z, short w)
		{
			VertexAttrib4sNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[528])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[528])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4sv(uint index, short* v)
		{
			VertexAttrib4svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4ubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[529])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[529])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, byte* v)
		{
			VertexAttrib4ubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4ubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4ubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[530])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[530])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4uiv(uint index, uint* v)
		{
			VertexAttrib4uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttrib4usvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[531])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[531])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4usv(uint index, ushort* v)
		{
			VertexAttrib4usvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4usv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttrib4usv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribPointerNative(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, void*, void>)funcTable[532])(index, size, type, *((byte*)(&normalized)), stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[532])(index, size, type, *((byte*)(&normalized)), stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, pointer);
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, (void*)pointer);
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void VertexAttribPointer<TPointer>(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribPointerNative(index, size, type, normalized, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexPointerNative(int size, GLVertexPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLVertexPointerType, int, void*, void>)funcTable[533])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLVertexPointerType, int, nint, void>)funcTable[533])(size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void VertexPointer(int size, GLVertexPointerType type, int stride, void* pointer)
		{
			VertexPointerNative(size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void VertexPointer(int size, GLVertexPointerType type, int stride, nint pointer)
		{
			VertexPointerNative(size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void VertexPointer<TPointer>(int size, GLVertexPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexPointerNative(size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[534])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[534])(x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Viewport(int x, int y, int width, int height)
		{
			ViewportNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2dNative(double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[535])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[535])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2d(double x, double y)
		{
			WindowPos2dNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[536])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[536])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2dv(double* v)
		{
			WindowPos2dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				WindowPos2dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				WindowPos2dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2fNative(float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[537])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[537])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2f(float x, float y)
		{
			WindowPos2fNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[538])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[538])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2fv(float* v)
		{
			WindowPos2fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				WindowPos2fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				WindowPos2fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2iNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[539])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[539])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2i(int x, int y)
		{
			WindowPos2iNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[540])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[540])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2iv(int* v)
		{
			WindowPos2ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				WindowPos2ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				WindowPos2ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2sNative(short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[541])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[541])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2s(short x, short y)
		{
			WindowPos2sNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos2svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[542])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[542])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2sv(short* v)
		{
			WindowPos2svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				WindowPos2svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos2sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				WindowPos2svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3dNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[543])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[543])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3d(double x, double y, double z)
		{
			WindowPos3dNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[544])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[544])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3dv(double* v)
		{
			WindowPos3dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				WindowPos3dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				WindowPos3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3fNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[545])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[545])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3f(float x, float y, float z)
		{
			WindowPos3fNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[546])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[546])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3fv(float* v)
		{
			WindowPos3fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				WindowPos3fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				WindowPos3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3iNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[547])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[547])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3i(int x, int y, int z)
		{
			WindowPos3iNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[548])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[548])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3iv(int* v)
		{
			WindowPos3ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				WindowPos3ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				WindowPos3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3sNative(short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[549])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[549])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3s(short x, short y, short z)
		{
			WindowPos3sNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowPos3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[550])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[550])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3sv(short* v)
		{
			WindowPos3svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				WindowPos3svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void WindowPos3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				WindowPos3svNative(pv0);
			}
		}

	}
}
