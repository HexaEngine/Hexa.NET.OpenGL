// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES.NV
{
	public static unsafe partial class GLNVPathRendering
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyPathNVNative(uint resultPath, uint srcPath)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(resultPath, srcPath);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(resultPath, srcPath);
			#endif
		}

		public static void CopyPathNV(uint resultPath, uint srcPath)
		{
			CopyPathNVNative(resultPath, srcPath);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[1])(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[1])(numPaths, pathNameType, (nint)paths, pathBase, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverFillPathInstancedNVNative(numPaths, pathNameType, (void*)paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverFillPathInstancedNV<TPaths>(int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				CoverFillPathInstancedNVNative(numPaths, pathNameType, ppaths0, pathBase, coverMode, transformType, transformValues);
			}
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, Span<float> transformValues)
		{
			fixed (float* ptransformValues0 = transformValues)
			{
				CoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				CoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverFillPathNVNative(uint path, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[2])(path, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[2])(path, coverMode);
			#endif
		}

		public static void CoverFillPathNV(uint path, GLPathCoverMode coverMode)
		{
			CoverFillPathNVNative(path, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[3])(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[3])(numPaths, pathNameType, (nint)paths, pathBase, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverStrokePathInstancedNVNative(numPaths, pathNameType, (void*)paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverStrokePathInstancedNV<TPaths>(int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				CoverStrokePathInstancedNVNative(numPaths, pathNameType, ppaths0, pathBase, coverMode, transformType, transformValues);
			}
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, Span<float> transformValues)
		{
			fixed (float* ptransformValues0 = transformValues)
			{
				CoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				CoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverStrokePathNVNative(uint path, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[4])(path, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[4])(path, coverMode);
			#endif
		}

		public static void CoverStrokePathNV(uint path, GLPathCoverMode coverMode)
		{
			CoverStrokePathNVNative(path, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeletePathsNVNative(uint path, int range)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[5])(path, range);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[5])(path, range);
			#endif
		}

		public static void DeletePathsNV(uint path, int range)
		{
			DeletePathsNVNative(path, range);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenPathsNVNative(int range)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[6])(range);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[6])(range);
			#endif
		}

		public static uint GenPathsNV(int range)
		{
			uint ret = GenPathsNVNative(range);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathColorGenfvNVNative(GLPathColor color, GLPathGenMode pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, float*, void>)funcTable[7])(color, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, nint, void>)funcTable[7])(color, pname, (nint)value);
			#endif
		}

		public static void GetPathColorGenfvNV(GLPathColor color, GLPathGenMode pname, float* value)
		{
			GetPathColorGenfvNVNative(color, pname, value);
		}

		public static void GetPathColorGenfvNV(GLPathColor color, GLPathGenMode pname, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				GetPathColorGenfvNVNative(color, pname, pvalue0);
			}
		}

		public static void GetPathColorGenfvNV(GLPathColor color, GLPathGenMode pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathColorGenfvNVNative(color, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathColorGenivNVNative(GLPathColor color, GLPathGenMode pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int*, void>)funcTable[8])(color, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, nint, void>)funcTable[8])(color, pname, (nint)value);
			#endif
		}

		public static void GetPathColorGenivNV(GLPathColor color, GLPathGenMode pname, int* value)
		{
			GetPathColorGenivNVNative(color, pname, value);
		}

		public static void GetPathColorGenivNV(GLPathColor color, GLPathGenMode pname, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				GetPathColorGenivNVNative(color, pname, pvalue0);
			}
		}

		public static void GetPathColorGenivNV(GLPathColor color, GLPathGenMode pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathColorGenivNVNative(color, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathCommandsNVNative(uint path, GLPathCoordType commands)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoordType, void>)funcTable[9])(path, commands);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoordType, void>)funcTable[9])(path, commands);
			#endif
		}

		public static void GetPathCommandsNV(uint path, GLPathCoordType commands)
		{
			GetPathCommandsNVNative(path, commands);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathCoordsNVNative(uint path, float* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[10])(path, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[10])(path, (nint)coords);
			#endif
		}

		public static void GetPathCoordsNV(uint path, float* coords)
		{
			GetPathCoordsNVNative(path, coords);
		}

		public static void GetPathCoordsNV(uint path, Span<float> coords)
		{
			fixed (float* pcoords0 = coords)
			{
				GetPathCoordsNVNative(path, pcoords0);
			}
		}

		public static void GetPathCoordsNV(uint path, ref float coords)
		{
			fixed (float* pcoords0 = &coords)
			{
				GetPathCoordsNVNative(path, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathDashArrayNVNative(uint path, float* dashArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[11])(path, dashArray);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[11])(path, (nint)dashArray);
			#endif
		}

		public static void GetPathDashArrayNV(uint path, float* dashArray)
		{
			GetPathDashArrayNVNative(path, dashArray);
		}

		public static void GetPathDashArrayNV(uint path, Span<float> dashArray)
		{
			fixed (float* pdashArray0 = dashArray)
			{
				GetPathDashArrayNVNative(path, pdashArray0);
			}
		}

		public static void GetPathDashArrayNV(uint path, ref float dashArray)
		{
			fixed (float* pdashArray0 = &dashArray)
			{
				GetPathDashArrayNVNative(path, pdashArray0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetPathLengthNVNative(uint path, int startSegment, int numSegments)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, float>)funcTable[12])(path, startSegment, numSegments);
			#else
			return (float)((delegate* unmanaged[Cdecl]<uint, int, int, float>)funcTable[12])(path, startSegment, numSegments);
			#endif
		}

		public static float GetPathLengthNV(uint path, int startSegment, int numSegments)
		{
			float ret = GetPathLengthNVNative(path, startSegment, numSegments);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathMetricRangeNVNative(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, uint, int, int, float*, void>)funcTable[13])(metricQueryMask, firstPathName, numPaths, stride, metrics);
			#else
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, uint, int, int, nint, void>)funcTable[13])(metricQueryMask, firstPathName, numPaths, stride, (nint)metrics);
			#endif
		}

		public static void GetPathMetricRangeNV(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics)
		{
			GetPathMetricRangeNVNative(metricQueryMask, firstPathName, numPaths, stride, metrics);
		}

		public static void GetPathMetricRangeNV(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, Span<float> metrics)
		{
			fixed (float* pmetrics0 = metrics)
			{
				GetPathMetricRangeNVNative(metricQueryMask, firstPathName, numPaths, stride, pmetrics0);
			}
		}

		public static void GetPathMetricRangeNV(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, ref float metrics)
		{
			fixed (float* pmetrics0 = &metrics)
			{
				GetPathMetricRangeNVNative(metricQueryMask, firstPathName, numPaths, stride, pmetrics0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathMetricsNVNative(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, int, GLPathElementType, void*, uint, int, float*, void>)funcTable[14])(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
			#else
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, int, GLPathElementType, nint, uint, int, nint, void>)funcTable[14])(metricQueryMask, numPaths, pathNameType, (nint)paths, pathBase, stride, (nint)metrics);
			#endif
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics)
		{
			GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, int stride, float* metrics)
		{
			GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, (void*)paths, pathBase, stride, metrics);
		}

		public static void GetPathMetricsNV<TPaths>(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, int stride, float* metrics) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, ppaths0, pathBase, stride, metrics);
			}
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, Span<float> metrics)
		{
			fixed (float* pmetrics0 = metrics)
			{
				GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, pmetrics0);
			}
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, ref float metrics)
		{
			fixed (float* pmetrics0 = &metrics)
			{
				GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, pmetrics0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathParameterfvNVNative(uint path, GLPathParameter pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float*, void>)funcTable[15])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[15])(path, pname, (nint)value);
			#endif
		}

		public static void GetPathParameterfvNV(uint path, GLPathParameter pname, float* value)
		{
			GetPathParameterfvNVNative(path, pname, value);
		}

		public static void GetPathParameterfvNV(uint path, GLPathParameter pname, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				GetPathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		public static void GetPathParameterfvNV(uint path, GLPathParameter pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathParameterivNVNative(uint path, GLPathParameter pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int*, void>)funcTable[16])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[16])(path, pname, (nint)value);
			#endif
		}

		public static void GetPathParameterivNV(uint path, GLPathParameter pname, int* value)
		{
			GetPathParameterivNVNative(path, pname, value);
		}

		public static void GetPathParameterivNV(uint path, GLPathParameter pname, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				GetPathParameterivNVNative(path, pname, pvalue0);
			}
		}

		public static void GetPathParameterivNV(uint path, GLPathParameter pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathParameterivNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathSpacingNVNative(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathListMode, int, GLPathElementType, void*, uint, float, float, GLPathTransformType, float*, void>)funcTable[17])(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
			#else
			((delegate* unmanaged[Cdecl]<GLPathListMode, int, GLPathElementType, nint, uint, float, float, GLPathTransformType, nint, void>)funcTable[17])(pathListMode, numPaths, pathNameType, (nint)paths, pathBase, advanceScale, kerningScale, transformType, (nint)returnedSpacing);
			#endif
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing)
		{
			GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing)
		{
			GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, (void*)paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
		}

		public static void GetPathSpacingNV<TPaths>(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, ppaths0, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
			}
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, Span<float> returnedSpacing)
		{
			fixed (float* preturnedSpacing0 = returnedSpacing)
			{
				GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, preturnedSpacing0);
			}
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, ref float returnedSpacing)
		{
			fixed (float* preturnedSpacing0 = &returnedSpacing)
			{
				GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, preturnedSpacing0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathTexGenfvNVNative(GLTextureUnit texCoordSet, GLPathGenMode pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, float*, void>)funcTable[18])(texCoordSet, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, nint, void>)funcTable[18])(texCoordSet, pname, (nint)value);
			#endif
		}

		public static void GetPathTexGenfvNV(GLTextureUnit texCoordSet, GLPathGenMode pname, float* value)
		{
			GetPathTexGenfvNVNative(texCoordSet, pname, value);
		}

		public static void GetPathTexGenfvNV(GLTextureUnit texCoordSet, GLPathGenMode pname, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				GetPathTexGenfvNVNative(texCoordSet, pname, pvalue0);
			}
		}

		public static void GetPathTexGenfvNV(GLTextureUnit texCoordSet, GLPathGenMode pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathTexGenfvNVNative(texCoordSet, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathTexGenivNVNative(GLTextureUnit texCoordSet, GLPathGenMode pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, int*, void>)funcTable[19])(texCoordSet, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, nint, void>)funcTable[19])(texCoordSet, pname, (nint)value);
			#endif
		}

		public static void GetPathTexGenivNV(GLTextureUnit texCoordSet, GLPathGenMode pname, int* value)
		{
			GetPathTexGenivNVNative(texCoordSet, pname, value);
		}

		public static void GetPathTexGenivNV(GLTextureUnit texCoordSet, GLPathGenMode pname, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				GetPathTexGenivNVNative(texCoordSet, pname, pvalue0);
			}
		}

		public static void GetPathTexGenivNV(GLTextureUnit texCoordSet, GLPathGenMode pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathTexGenivNVNative(texCoordSet, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourcefvNVNative(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLEnum*, int, int*, float*, void>)funcTable[20])(program, programInterface, index, propCount, props, count, length, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, nint, int, nint, nint, void>)funcTable[20])(program, programInterface, index, propCount, (nint)props, count, (nint)length, (nint)@params);
			#endif
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, float* @params)
		{
			GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, length, @params);
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, out float @params)
		{
			float pparams;
			GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, length, &pparams);
			@params = pparams;
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, length, pparams);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, Span<GLEnum> props, int count, int* length, float* @params)
		{
			fixed (GLEnum* pprops0 = props)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, length, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, int* length, float* @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, length, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, Span<int> length, float* @params)
		{
			fixed (int* plength0 = length)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, ref int length, float* @params)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, Span<GLEnum> props, int count, Span<int> length, float* @params)
		{
			fixed (GLEnum* pprops0 = props)
			{
				fixed (int* plength1 = length)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, plength1, @params);
				}
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, ref int length, float* @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				fixed (int* plength1 = &length)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, plength1, @params);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InterpolatePathsNVNative(uint resultPath, uint pathA, uint pathB, float weight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, float, void>)funcTable[21])(resultPath, pathA, pathB, weight);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, float, void>)funcTable[21])(resultPath, pathA, pathB, weight);
			#endif
		}

		public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight)
		{
			InterpolatePathsNVNative(resultPath, pathA, pathB, weight);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPathNVNative(uint path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[22])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[22])(path);
			#endif
		}

		public static bool IsPathNV(uint path)
		{
			byte ret = IsPathNVNative(path);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPointInFillPathNVNative(uint path, uint mask, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, float, float, byte>)funcTable[23])(path, mask, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, uint, float, float, byte>)funcTable[23])(path, mask, x, y);
			#endif
		}

		public static bool IsPointInFillPathNV(uint path, uint mask, float x, float y)
		{
			byte ret = IsPointInFillPathNVNative(path, mask, x, y);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPointInStrokePathNVNative(uint path, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, float, float, byte>)funcTable[24])(path, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, float, float, byte>)funcTable[24])(path, x, y);
			#endif
		}

		public static bool IsPointInStrokePathNV(uint path, float x, float y)
		{
			byte ret = IsPointInStrokePathNVNative(path, x, y);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixFrustumEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[25])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[25])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixFrustumEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixFrustumEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoad3x2fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[26])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[26])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoad3x2fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoad3x2fNVNative(matrixMode, m);
		}

		public static void MatrixLoad3x2fNV(GLEnum matrixMode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixLoad3x2fNVNative(matrixMode, pm0);
			}
		}

		public static void MatrixLoad3x2fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoad3x2fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoad3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[27])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[27])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoad3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoad3x3fNVNative(matrixMode, m);
		}

		public static void MatrixLoad3x3fNV(GLEnum matrixMode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixLoad3x3fNVNative(matrixMode, pm0);
			}
		}

		public static void MatrixLoad3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoad3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadIdentityEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[28])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[28])(mode);
			#endif
		}

		public static void MatrixLoadIdentityEXT(GLMatrixMode mode)
		{
			MatrixLoadIdentityEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTranspose3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[29])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[29])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoadTranspose3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoadTranspose3x3fNVNative(matrixMode, m);
		}

		public static void MatrixLoadTranspose3x3fNV(GLEnum matrixMode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixLoadTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		public static void MatrixLoadTranspose3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[30])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[30])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoadTransposedEXTNative(mode, m);
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixLoadTransposedEXTNative(mode, pm0);
			}
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoadTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[31])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[31])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadTransposefEXTNative(mode, m);
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixLoadTransposefEXTNative(mode, pm0);
			}
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoaddEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[32])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[32])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoaddEXTNative(mode, m);
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixLoaddEXTNative(mode, pm0);
			}
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoaddEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[33])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[33])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadfEXTNative(mode, m);
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixLoadfEXTNative(mode, pm0);
			}
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMult3x2fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[34])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[34])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMult3x2fNV(GLEnum matrixMode, float* m)
		{
			MatrixMult3x2fNVNative(matrixMode, m);
		}

		public static void MatrixMult3x2fNV(GLEnum matrixMode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixMult3x2fNVNative(matrixMode, pm0);
			}
		}

		public static void MatrixMult3x2fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMult3x2fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMult3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[35])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[35])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMult3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixMult3x3fNVNative(matrixMode, m);
		}

		public static void MatrixMult3x3fNV(GLEnum matrixMode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixMult3x3fNVNative(matrixMode, pm0);
			}
		}

		public static void MatrixMult3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMult3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTranspose3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[36])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[36])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMultTranspose3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixMultTranspose3x3fNVNative(matrixMode, m);
		}

		public static void MatrixMultTranspose3x3fNV(GLEnum matrixMode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixMultTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		public static void MatrixMultTranspose3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[37])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[37])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultTransposedEXTNative(mode, m);
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixMultTransposedEXTNative(mode, pm0);
			}
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[38])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[38])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultTransposefEXTNative(mode, m);
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixMultTransposefEXTNative(mode, pm0);
			}
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultdEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[39])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[39])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultdEXTNative(mode, m);
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixMultdEXTNative(mode, pm0);
			}
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultdEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[40])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[40])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultfEXTNative(mode, m);
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixMultfEXTNative(mode, pm0);
			}
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixOrthoEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[41])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[41])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixOrthoEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixOrthoEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPopEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[42])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[42])(mode);
			#endif
		}

		public static void MatrixPopEXT(GLMatrixMode mode)
		{
			MatrixPopEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPushEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[43])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[43])(mode);
			#endif
		}

		public static void MatrixPushEXT(GLMatrixMode mode)
		{
			MatrixPushEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatedEXTNative(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[44])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[44])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatedEXT(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			MatrixRotatedEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatefEXTNative(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[45])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[45])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatefEXT(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			MatrixRotatefEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScaledEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[46])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[46])(mode, x, y, z);
			#endif
		}

		public static void MatrixScaledEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixScaledEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScalefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[47])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[47])(mode, x, y, z);
			#endif
		}

		public static void MatrixScalefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixScalefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatedEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[48])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[48])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatedEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixTranslatedEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[49])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[49])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixTranslatefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathColorGenNVNative(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, GLPathColorFormat, float*, void>)funcTable[50])(color, genMode, colorFormat, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, GLPathColorFormat, nint, void>)funcTable[50])(color, genMode, colorFormat, (nint)coeffs);
			#endif
		}

		public static void PathColorGenNV(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, float* coeffs)
		{
			PathColorGenNVNative(color, genMode, colorFormat, coeffs);
		}

		public static void PathColorGenNV(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, Span<float> coeffs)
		{
			fixed (float* pcoeffs0 = coeffs)
			{
				PathColorGenNVNative(color, genMode, colorFormat, pcoeffs0);
			}
		}

		public static void PathColorGenNV(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				PathColorGenNVNative(color, genMode, colorFormat, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCommandsNVNative(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, int, GLPathCoordType, void*, void>)funcTable[51])(path, numCommands, commands, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, int, GLPathCoordType, nint, void>)funcTable[51])(path, numCommands, commands, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathCommandsNV(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathCommandsNVNative(path, numCommands, commands, numCoords, coordType, coords);
		}

		public static void PathCommandsNV(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, nint coords)
		{
			PathCommandsNVNative(path, numCommands, commands, numCoords, coordType, (void*)coords);
		}

		public static void PathCommandsNV<TCoords>(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, Span<TCoords> coords) where TCoords : unmanaged
		{
			fixed (TCoords* pcoords0 = coords)
			{
				PathCommandsNVNative(path, numCommands, commands, numCoords, coordType, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCoordsNVNative(uint path, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, void*, void>)funcTable[52])(path, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, nint, void>)funcTable[52])(path, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathCoordsNV(uint path, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathCoordsNVNative(path, numCoords, coordType, coords);
		}

		public static void PathCoordsNV(uint path, int numCoords, GLPathCoordType coordType, nint coords)
		{
			PathCoordsNVNative(path, numCoords, coordType, (void*)coords);
		}

		public static void PathCoordsNV<TCoords>(uint path, int numCoords, GLPathCoordType coordType, Span<TCoords> coords) where TCoords : unmanaged
		{
			fixed (TCoords* pcoords0 = coords)
			{
				PathCoordsNVNative(path, numCoords, coordType, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCoverDepthFuncNVNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[53])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[53])(func);
			#endif
		}

		public static void PathCoverDepthFuncNV(GLDepthFunction func)
		{
			PathCoverDepthFuncNVNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathDashArrayNVNative(uint path, int dashCount, float* dashArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[54])(path, dashCount, dashArray);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[54])(path, dashCount, (nint)dashArray);
			#endif
		}

		public static void PathDashArrayNV(uint path, int dashCount, float* dashArray)
		{
			PathDashArrayNVNative(path, dashCount, dashArray);
		}

		public static void PathDashArrayNV(uint path, int dashCount, Span<float> dashArray)
		{
			fixed (float* pdashArray0 = dashArray)
			{
				PathDashArrayNVNative(path, dashCount, pdashArray0);
			}
		}

		public static void PathDashArrayNV(uint path, int dashCount, ref float dashArray)
		{
			fixed (float* pdashArray0 = &dashArray)
			{
				PathDashArrayNVNative(path, dashCount, pdashArray0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathFogGenNVNative(GLPathGenMode genMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathGenMode, void>)funcTable[55])(genMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPathGenMode, void>)funcTable[55])(genMode);
			#endif
		}

		public static void PathFogGenNV(GLPathGenMode genMode)
		{
			PathFogGenNVNative(genMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathGlyphIndexArrayNVNative(uint firstPathName, GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLEnum, void*, GLPathFontStyle, uint, int, uint, float, GLEnum>)funcTable[56])(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, GLPathFontStyle, uint, int, uint, float, GLEnum>)funcTable[56])(firstPathName, fontTarget, (nint)fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static GLEnum PathGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathGlyphIndexArrayNVNative(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		public static GLEnum PathGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, nint fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathGlyphIndexArrayNVNative(firstPathName, fontTarget, (void*)fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		public static GLEnum PathGlyphIndexArrayNV<TFontName>(uint firstPathName, GLEnum fontTarget, Span<TFontName> fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) where TFontName : unmanaged
		{
			fixed (TFontName* pfontName0 = fontName)
			{
				GLEnum ret = PathGlyphIndexArrayNVNative(firstPathName, fontTarget, pfontName0, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathGlyphIndexRangeNVNative(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum, void*, GLPathFontStyle, uint, float, uint*, GLEnum>)funcTable[57])(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum, nint, GLPathFontStyle, uint, float, nint, GLEnum>)funcTable[57])(fontTarget, (nint)fontName, fontStyle, pathParameterTemplate, emScale, (nint)baseAndCount);
			#endif
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
		{
			GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
			return ret;
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, nint fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
		{
			GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, (void*)fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
			return ret;
		}

		public static GLEnum PathGlyphIndexRangeNV<TFontName>(GLEnum fontTarget, Span<TFontName> fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount) where TFontName : unmanaged
		{
			fixed (TFontName* pfontName0 = fontName)
			{
				GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, pfontName0, fontStyle, pathParameterTemplate, emScale, baseAndCount);
				return ret;
			}
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, Span<uint> baseAndCount)
		{
			fixed (uint* pbaseAndCount0 = baseAndCount)
			{
				GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, pbaseAndCount0);
				return ret;
			}
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount)
		{
			fixed (uint* pbaseAndCount0 = &baseAndCount)
			{
				GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, pbaseAndCount0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathGlyphRangeNVNative(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, void*, GLPathFontStyle, uint, int, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[58])(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, nint, GLPathFontStyle, uint, int, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[58])(firstPathName, fontTarget, (nint)fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static void PathGlyphRangeNV(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphRangeNVNative(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		public static void PathGlyphRangeNV(uint firstPathName, GLPathFontTarget fontTarget, nint fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphRangeNVNative(firstPathName, fontTarget, (void*)fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		public static void PathGlyphRangeNV<TFontName>(uint firstPathName, GLPathFontTarget fontTarget, Span<TFontName> fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) where TFontName : unmanaged
		{
			fixed (TFontName* pfontName0 = fontName)
			{
				PathGlyphRangeNVNative(firstPathName, fontTarget, pfontName0, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathGlyphsNVNative(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, void*, GLPathFontStyle, int, GLPathElementType, void*, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[59])(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, nint, GLPathFontStyle, int, GLPathElementType, nint, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[59])(firstPathName, fontTarget, (nint)fontName, fontStyle, numGlyphs, type, (nint)charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static void PathGlyphsNV(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphsNVNative(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		public static void PathGlyphsNV(uint firstPathName, GLPathFontTarget fontTarget, nint fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphsNVNative(firstPathName, fontTarget, (void*)fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		public static void PathGlyphsNV<TFontName>(uint firstPathName, GLPathFontTarget fontTarget, Span<TFontName> fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) where TFontName : unmanaged
		{
			fixed (TFontName* pfontName0 = fontName)
			{
				PathGlyphsNVNative(firstPathName, fontTarget, pfontName0, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
			}
		}

		public static void PathGlyphsNV(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, nint charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphsNVNative(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, (void*)charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		public static void PathGlyphsNV<TCharcodes>(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, Span<TCharcodes> charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) where TCharcodes : unmanaged
		{
			fixed (TCharcodes* pcharcodes0 = charcodes)
			{
				PathGlyphsNVNative(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, pcharcodes0, handleMissingGlyphs, pathParameterTemplate, emScale);
			}
		}

		public static void PathGlyphsNV(uint firstPathName, GLPathFontTarget fontTarget, nint fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, nint charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphsNVNative(firstPathName, fontTarget, (void*)fontName, fontStyle, numGlyphs, type, (void*)charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		public static void PathGlyphsNV<TFontName, TCharcodes>(uint firstPathName, GLPathFontTarget fontTarget, Span<TFontName> fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, Span<TCharcodes> charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale) where TFontName : unmanaged where TCharcodes : unmanaged
		{
			fixed (TFontName* pfontName0 = fontName)
			{
				fixed (TCharcodes* pcharcodes1 = charcodes)
				{
					PathGlyphsNVNative(firstPathName, fontTarget, pfontName0, fontStyle, numGlyphs, type, pcharcodes1, handleMissingGlyphs, pathParameterTemplate, emScale);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathMemoryGlyphIndexArrayNVNative(uint firstPathName, GLEnum fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void*, int, uint, int, uint, float, GLEnum>)funcTable[60])(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, nint, int, uint, int, uint, float, GLEnum>)funcTable[60])(firstPathName, fontTarget, fontSize, (nint)fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static GLEnum PathMemoryGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathMemoryGlyphIndexArrayNVNative(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		public static GLEnum PathMemoryGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, nint fontSize, nint fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathMemoryGlyphIndexArrayNVNative(firstPathName, fontTarget, fontSize, (void*)fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		public static GLEnum PathMemoryGlyphIndexArrayNV<TFontData>(uint firstPathName, GLEnum fontTarget, nint fontSize, Span<TFontData> fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) where TFontData : unmanaged
		{
			fixed (TFontData* pfontData0 = fontData)
			{
				GLEnum ret = PathMemoryGlyphIndexArrayNVNative(firstPathName, fontTarget, fontSize, pfontData0, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterfNVNative(uint path, GLPathParameter pname, float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float, void>)funcTable[61])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float, void>)funcTable[61])(path, pname, value);
			#endif
		}

		public static void PathParameterfNV(uint path, GLPathParameter pname, float value)
		{
			PathParameterfNVNative(path, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterfvNVNative(uint path, GLPathParameter pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float*, void>)funcTable[62])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[62])(path, pname, (nint)value);
			#endif
		}

		public static void PathParameterfvNV(uint path, GLPathParameter pname, float* value)
		{
			PathParameterfvNVNative(path, pname, value);
		}

		public static void PathParameterfvNV(uint path, GLPathParameter pname, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				PathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		public static void PathParameterfvNV(uint path, GLPathParameter pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				PathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameteriNVNative(uint path, GLPathParameter pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int, void>)funcTable[63])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int, void>)funcTable[63])(path, pname, value);
			#endif
		}

		public static void PathParameteriNV(uint path, GLPathParameter pname, int value)
		{
			PathParameteriNVNative(path, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterivNVNative(uint path, GLPathParameter pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int*, void>)funcTable[64])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[64])(path, pname, (nint)value);
			#endif
		}

		public static void PathParameterivNV(uint path, GLPathParameter pname, int* value)
		{
			PathParameterivNVNative(path, pname, value);
		}

		public static void PathParameterivNV(uint path, GLPathParameter pname, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				PathParameterivNVNative(path, pname, pvalue0);
			}
		}

		public static void PathParameterivNV(uint path, GLPathParameter pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				PathParameterivNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStencilDepthOffsetNVNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[65])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[65])(factor, units);
			#endif
		}

		public static void PathStencilDepthOffsetNV(float factor, float units)
		{
			PathStencilDepthOffsetNVNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStencilFuncNVNative(GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[66])(func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[66])(func, reference, mask);
			#endif
		}

		public static void PathStencilFuncNV(GLStencilFunction func, int reference, uint mask)
		{
			PathStencilFuncNVNative(func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStringNVNative(uint path, GLPathStringFormat format, int length, void* pathString)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathStringFormat, int, void*, void>)funcTable[67])(path, format, length, pathString);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathStringFormat, int, nint, void>)funcTable[67])(path, format, length, (nint)pathString);
			#endif
		}

		public static void PathStringNV(uint path, GLPathStringFormat format, int length, void* pathString)
		{
			PathStringNVNative(path, format, length, pathString);
		}

		public static void PathStringNV(uint path, GLPathStringFormat format, int length, nint pathString)
		{
			PathStringNVNative(path, format, length, (void*)pathString);
		}

		public static void PathStringNV<TPathString>(uint path, GLPathStringFormat format, int length, Span<TPathString> pathString) where TPathString : unmanaged
		{
			fixed (TPathString* ppathString0 = pathString)
			{
				PathStringNVNative(path, format, length, ppathString0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathSubCommandsNVNative(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPathCoordType, int, GLPathCoordType, void*, void>)funcTable[68])(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPathCoordType, int, GLPathCoordType, nint, void>)funcTable[68])(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathSubCommandsNVNative(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
		}

		public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, nint coords)
		{
			PathSubCommandsNVNative(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, (void*)coords);
		}

		public static void PathSubCommandsNV<TCoords>(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, Span<TCoords> coords) where TCoords : unmanaged
		{
			fixed (TCoords* pcoords0 = coords)
			{
				PathSubCommandsNVNative(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathSubCoordsNVNative(uint path, int coordStart, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, GLPathCoordType, void*, void>)funcTable[69])(path, coordStart, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, GLPathCoordType, nint, void>)funcTable[69])(path, coordStart, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathSubCoordsNVNative(path, coordStart, numCoords, coordType, coords);
		}

		public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, GLPathCoordType coordType, nint coords)
		{
			PathSubCoordsNVNative(path, coordStart, numCoords, coordType, (void*)coords);
		}

		public static void PathSubCoordsNV<TCoords>(uint path, int coordStart, int numCoords, GLPathCoordType coordType, Span<TCoords> coords) where TCoords : unmanaged
		{
			fixed (TCoords* pcoords0 = coords)
			{
				PathSubCoordsNVNative(path, coordStart, numCoords, coordType, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathTexGenNVNative(GLPathColor texCoordSet, GLPathGenMode genMode, int components, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int, float*, void>)funcTable[70])(texCoordSet, genMode, components, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int, nint, void>)funcTable[70])(texCoordSet, genMode, components, (nint)coeffs);
			#endif
		}

		public static void PathTexGenNV(GLPathColor texCoordSet, GLPathGenMode genMode, int components, float* coeffs)
		{
			PathTexGenNVNative(texCoordSet, genMode, components, coeffs);
		}

		public static void PathTexGenNV(GLPathColor texCoordSet, GLPathGenMode genMode, int components, Span<float> coeffs)
		{
			fixed (float* pcoeffs0 = coeffs)
			{
				PathTexGenNVNative(texCoordSet, genMode, components, pcoeffs0);
			}
		}

		public static void PathTexGenNV(GLPathColor texCoordSet, GLPathGenMode genMode, int components, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				PathTexGenNVNative(texCoordSet, genMode, components, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PointAlongPathNVNative(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, float, float*, float*, float*, float*, byte>)funcTable[71])(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, int, int, float, nint, nint, nint, nint, byte>)funcTable[71])(path, startSegment, numSegments, distance, (nint)x, (nint)y, (nint)tangentX, (nint)tangentY);
			#endif
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY)
		{
			byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
			return ret != 0;
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, float* y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = x)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, Span<float> y, float* tangentX, float* tangentY)
		{
			fixed (float* py0 = y)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, float* tangentX, float* tangentY)
		{
			fixed (float* py0 = &y)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, Span<float> y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = x)
			{
				fixed (float* py1 = y)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, Span<float> tangentX, float* tangentY)
		{
			fixed (float* ptangentX0 = tangentX)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, ref float tangentX, float* tangentY)
		{
			fixed (float* ptangentX0 = &tangentX)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, float* y, Span<float> tangentX, float* tangentY)
		{
			fixed (float* px0 = x)
			{
				fixed (float* ptangentX1 = tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, ref float tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, Span<float> y, Span<float> tangentX, float* tangentY)
		{
			fixed (float* py0 = y)
			{
				fixed (float* ptangentX1 = tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, ref float tangentX, float* tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, Span<float> y, Span<float> tangentX, float* tangentY)
		{
			fixed (float* px0 = x)
			{
				fixed (float* py1 = y)
				{
					fixed (float* ptangentX2 = tangentX)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, tangentY);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentX2 = &tangentX)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, tangentY);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, Span<float> tangentY)
		{
			fixed (float* ptangentY0 = tangentY)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, tangentX, ptangentY0);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, ref float tangentY)
		{
			fixed (float* ptangentY0 = &tangentY)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, tangentX, ptangentY0);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, float* y, float* tangentX, Span<float> tangentY)
		{
			fixed (float* px0 = x)
			{
				fixed (float* ptangentY1 = tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, float* tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, Span<float> y, float* tangentX, Span<float> tangentY)
		{
			fixed (float* py0 = y)
			{
				fixed (float* ptangentY1 = tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, float* tangentX, ref float tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, Span<float> y, float* tangentX, Span<float> tangentY)
		{
			fixed (float* px0 = x)
			{
				fixed (float* py1 = y)
				{
					fixed (float* ptangentY2 = tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, float* tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, Span<float> tangentX, Span<float> tangentY)
		{
			fixed (float* ptangentX0 = tangentX)
			{
				fixed (float* ptangentY1 = tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, ref float tangentX, ref float tangentY)
		{
			fixed (float* ptangentX0 = &tangentX)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, float* y, Span<float> tangentX, Span<float> tangentY)
		{
			fixed (float* px0 = x)
			{
				fixed (float* ptangentX1 = tangentX)
				{
					fixed (float* ptangentY2 = tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, ref float tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, Span<float> y, Span<float> tangentX, Span<float> tangentY)
		{
			fixed (float* py0 = y)
			{
				fixed (float* ptangentX1 = tangentX)
				{
					fixed (float* ptangentY2 = tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, ref float tangentX, ref float tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, Span<float> x, Span<float> y, Span<float> tangentX, Span<float> tangentY)
		{
			fixed (float* px0 = x)
			{
				fixed (float* py1 = y)
				{
					fixed (float* ptangentX2 = tangentX)
					{
						fixed (float* ptangentY3 = tangentY)
						{
							byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, ptangentY3);
							return ret != 0;
						}
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentX2 = &tangentX)
					{
						fixed (float* ptangentY3 = &tangentY)
						{
							byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, ptangentY3);
							return ret != 0;
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramPathFragmentInputGenNVNative(uint program, int location, GLEnum genMode, int components, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLEnum, int, float*, void>)funcTable[72])(program, location, genMode, components, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLEnum, int, nint, void>)funcTable[72])(program, location, genMode, components, (nint)coeffs);
			#endif
		}

		public static void ProgramPathFragmentInputGenNV(uint program, int location, GLEnum genMode, int components, float* coeffs)
		{
			ProgramPathFragmentInputGenNVNative(program, location, genMode, components, coeffs);
		}

		public static void ProgramPathFragmentInputGenNV(uint program, int location, GLEnum genMode, int components, Span<float> coeffs)
		{
			fixed (float* pcoeffs0 = coeffs)
			{
				ProgramPathFragmentInputGenNVNative(program, location, genMode, components, pcoeffs0);
			}
		}

		public static void ProgramPathFragmentInputGenNV(uint program, int location, GLEnum genMode, int components, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				ProgramPathFragmentInputGenNVNative(program, location, genMode, components, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLPathFillMode, uint, GLPathTransformType, float*, void>)funcTable[73])(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLPathFillMode, uint, GLPathTransformType, nint, void>)funcTable[73])(numPaths, pathNameType, (nint)paths, pathBase, fillMode, mask, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilFillPathInstancedNVNative(numPaths, pathNameType, (void*)paths, pathBase, fillMode, mask, transformType, transformValues);
		}

		public static void StencilFillPathInstancedNV<TPaths>(int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				StencilFillPathInstancedNVNative(numPaths, pathNameType, ppaths0, pathBase, fillMode, mask, transformType, transformValues);
			}
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, Span<float> transformValues)
		{
			fixed (float* ptransformValues0 = transformValues)
			{
				StencilFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, ptransformValues0);
			}
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFillPathNVNative(uint path, GLPathFillMode fillMode, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, void>)funcTable[74])(path, fillMode, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, void>)funcTable[74])(path, fillMode, mask);
			#endif
		}

		public static void StencilFillPathNV(uint path, GLPathFillMode fillMode, uint mask)
		{
			StencilFillPathNVNative(path, fillMode, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, int, uint, GLPathTransformType, float*, void>)funcTable[75])(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, int, uint, GLPathTransformType, nint, void>)funcTable[75])(numPaths, pathNameType, (nint)paths, pathBase, reference, mask, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilStrokePathInstancedNVNative(numPaths, pathNameType, (void*)paths, pathBase, reference, mask, transformType, transformValues);
		}

		public static void StencilStrokePathInstancedNV<TPaths>(int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				StencilStrokePathInstancedNVNative(numPaths, pathNameType, ppaths0, pathBase, reference, mask, transformType, transformValues);
			}
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, Span<float> transformValues)
		{
			fixed (float* ptransformValues0 = transformValues)
			{
				StencilStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, ptransformValues0);
			}
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilStrokePathNVNative(uint path, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[76])(path, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[76])(path, reference, mask);
			#endif
		}

		public static void StencilStrokePathNV(uint path, int reference, uint mask)
		{
			StencilStrokePathNVNative(path, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLPathFillMode, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[77])(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLPathFillMode, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[77])(numPaths, pathNameType, (nint)paths, pathBase, fillMode, mask, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, (void*)paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverFillPathInstancedNV<TPaths>(int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, ppaths0, pathBase, fillMode, mask, coverMode, transformType, transformValues);
			}
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, Span<float> transformValues)
		{
			fixed (float* ptransformValues0 = transformValues)
			{
				StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, ptransformValues0);
			}
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverFillPathNVNative(uint path, GLPathFillMode fillMode, uint mask, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, GLPathCoverMode, void>)funcTable[78])(path, fillMode, mask, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, GLPathCoverMode, void>)funcTable[78])(path, fillMode, mask, coverMode);
			#endif
		}

		public static void StencilThenCoverFillPathNV(uint path, GLPathFillMode fillMode, uint mask, GLPathCoverMode coverMode)
		{
			StencilThenCoverFillPathNVNative(path, fillMode, mask, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, int, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[79])(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, int, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[79])(numPaths, pathNameType, (nint)paths, pathBase, reference, mask, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, nint paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, (void*)paths, pathBase, reference, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverStrokePathInstancedNV<TPaths>(int numPaths, GLPathElementType pathNameType, Span<TPaths> paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues) where TPaths : unmanaged
		{
			fixed (TPaths* ppaths0 = paths)
			{
				StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, ppaths0, pathBase, reference, mask, coverMode, transformType, transformValues);
			}
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, Span<float> transformValues)
		{
			fixed (float* ptransformValues0 = transformValues)
			{
				StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, ptransformValues0);
			}
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverStrokePathNVNative(uint path, int reference, uint mask, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, GLPathCoverMode, void>)funcTable[80])(path, reference, mask, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, GLPathCoverMode, void>)funcTable[80])(path, reference, mask, coverMode);
			#endif
		}

		public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, GLPathCoverMode coverMode)
		{
			StencilThenCoverStrokePathNVNative(path, reference, mask, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformPathNVNative(uint resultPath, uint srcPath, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLPathTransformType, float*, void>)funcTable[81])(resultPath, srcPath, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLPathTransformType, nint, void>)funcTable[81])(resultPath, srcPath, transformType, (nint)transformValues);
			#endif
		}

		public static void TransformPathNV(uint resultPath, uint srcPath, GLPathTransformType transformType, float* transformValues)
		{
			TransformPathNVNative(resultPath, srcPath, transformType, transformValues);
		}

		public static void TransformPathNV(uint resultPath, uint srcPath, GLPathTransformType transformType, Span<float> transformValues)
		{
			fixed (float* ptransformValues0 = transformValues)
			{
				TransformPathNVNative(resultPath, srcPath, transformType, ptransformValues0);
			}
		}

		public static void TransformPathNV(uint resultPath, uint srcPath, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				TransformPathNVNative(resultPath, srcPath, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WeightPathsNVNative(uint resultPath, int numPaths, uint* paths, float* weights)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, float*, void>)funcTable[82])(resultPath, numPaths, paths, weights);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[82])(resultPath, numPaths, (nint)paths, (nint)weights);
			#endif
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights)
		{
			WeightPathsNVNative(resultPath, numPaths, paths, weights);
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, Span<uint> paths, float* weights)
		{
			fixed (uint* ppaths0 = paths)
			{
				WeightPathsNVNative(resultPath, numPaths, ppaths0, weights);
			}
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, ref uint paths, float* weights)
		{
			fixed (uint* ppaths0 = &paths)
			{
				WeightPathsNVNative(resultPath, numPaths, ppaths0, weights);
			}
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, Span<float> weights)
		{
			fixed (float* pweights0 = weights)
			{
				WeightPathsNVNative(resultPath, numPaths, paths, pweights0);
			}
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, ref float weights)
		{
			fixed (float* pweights0 = &weights)
			{
				WeightPathsNVNative(resultPath, numPaths, paths, pweights0);
			}
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, Span<uint> paths, Span<float> weights)
		{
			fixed (uint* ppaths0 = paths)
			{
				fixed (float* pweights1 = weights)
				{
					WeightPathsNVNative(resultPath, numPaths, ppaths0, pweights1);
				}
			}
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, ref uint paths, ref float weights)
		{
			fixed (uint* ppaths0 = &paths)
			{
				fixed (float* pweights1 = &weights)
				{
					WeightPathsNVNative(resultPath, numPaths, ppaths0, pweights1);
				}
			}
		}

	}
}
