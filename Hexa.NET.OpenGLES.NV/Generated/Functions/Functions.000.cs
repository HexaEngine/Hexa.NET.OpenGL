// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES.NV
{
	public static unsafe partial class GLNv
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginConditionalRenderNVNative(uint id, GLConditionalRenderMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[0])(id, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[0])(id, mode);
			#endif
		}

		public static void BeginConditionalRenderNV(uint id, GLConditionalRenderMode mode)
		{
			BeginConditionalRenderNVNative(id, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindShadingRateImageNVNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[1])(texture);
			#endif
		}

		public static void BindShadingRateImageNV(uint texture)
		{
			BindShadingRateImageNVNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendBarrierNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[2])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[2])();
			#endif
		}

		public static void BlendBarrierNV()
		{
			BlendBarrierNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendParameteriNVNative(GLEnum pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[3])(pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[3])(pname, value);
			#endif
		}

		public static void BlendParameteriNV(GLEnum pname, int value)
		{
			BlendParameteriNVNative(pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferNVNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[4])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[4])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitFramebufferNV(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferNVNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferAttachMemoryNVNative(GLBufferTargetARB target, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, ulong, void>)funcTable[5])(target, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, ulong, void>)funcTable[5])(target, memory, offset);
			#endif
		}

		public static void BufferAttachMemoryNV(GLBufferTargetARB target, uint memory, ulong offset)
		{
			BufferAttachMemoryNVNative(target, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferPageCommitmentMemNVNative(GLBufferStorageTarget target, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, uint, ulong, byte, void>)funcTable[6])(target, offset, size, memory, memOffset, commit);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, uint, ulong, byte, void>)funcTable[6])(target, offset, size, memory, memOffset, commit);
			#endif
		}

		public static void BufferPageCommitmentMemNV(GLBufferStorageTarget target, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			BufferPageCommitmentMemNVNative(target, offset, size, memory, memOffset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConservativeRasterParameteriNVNative(GLEnum pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[7])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, void>)funcTable[7])(pname, param);
			#endif
		}

		public static void ConservativeRasterParameteriNV(GLEnum pname, int param)
		{
			ConservativeRasterParameteriNVNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyBufferSubDataNVNative(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[8])(readTarget, writeTarget, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[8])(readTarget, writeTarget, readOffset, writeOffset, size);
			#endif
		}

		public static void CopyBufferSubDataNV(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			CopyBufferSubDataNVNative(readTarget, writeTarget, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyPathNVNative(uint resultPath, uint srcPath)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[9])(resultPath, srcPath);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[9])(resultPath, srcPath);
			#endif
		}

		public static void CopyPathNV(uint resultPath, uint srcPath)
		{
			CopyPathNVNative(resultPath, srcPath);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[10])(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[10])(numPaths, pathNameType, (nint)paths, pathBase, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				CoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverFillPathNVNative(uint path, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[11])(path, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[11])(path, coverMode);
			#endif
		}

		public static void CoverFillPathNV(uint path, GLPathCoverMode coverMode)
		{
			CoverFillPathNVNative(path, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[12])(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[12])(numPaths, pathNameType, (nint)paths, pathBase, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			CoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
		}

		public static void CoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				CoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverStrokePathNVNative(uint path, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[13])(path, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoverMode, void>)funcTable[13])(path, coverMode);
			#endif
		}

		public static void CoverStrokePathNV(uint path, GLPathCoverMode coverMode)
		{
			CoverStrokePathNVNative(path, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverageMaskNVNative(byte mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[14])(mask);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[14])(mask);
			#endif
		}

		public static void CoverageMaskNV(byte mask)
		{
			CoverageMaskNVNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverageModulationNVNative(GLEnum components)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[15])(components);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[15])(components);
			#endif
		}

		public static void CoverageModulationNV(GLEnum components)
		{
			CoverageModulationNVNative(components);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverageModulationTableNVNative(int n, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float*, void>)funcTable[16])(n, v);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[16])(n, (nint)v);
			#endif
		}

		public static void CoverageModulationTableNV(int n, float* v)
		{
			CoverageModulationTableNVNative(n, v);
		}

		public static void CoverageModulationTableNV(int n, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				CoverageModulationTableNVNative(n, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CoverageOperationNVNative(GLEnum operation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[17])(operation);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[17])(operation);
			#endif
		}

		public static void CoverageOperationNV(GLEnum operation)
		{
			CoverageOperationNVNative(operation);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateSemaphoresNVNative(int n, uint* semaphores)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[18])(n, semaphores);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[18])(n, (nint)semaphores);
			#endif
		}

		public static void CreateSemaphoresNV(int n, uint* semaphores)
		{
			CreateSemaphoresNVNative(n, semaphores);
		}

		public static void CreateSemaphoresNV(int n, ref uint semaphores)
		{
			fixed (uint* psemaphores0 = &semaphores)
			{
				CreateSemaphoresNVNative(n, psemaphores0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteFencesNVNative(int n, uint* fences)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[19])(n, fences);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[19])(n, (nint)fences);
			#endif
		}

		public static void DeleteFencesNV(int n, uint* fences)
		{
			DeleteFencesNVNative(n, fences);
		}

		public static void DeleteFencesNV(int n, ref uint fences)
		{
			fixed (uint* pfences0 = &fences)
			{
				DeleteFencesNVNative(n, pfences0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeletePathsNVNative(uint path, int range)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[20])(path, range);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[20])(path, range);
			#endif
		}

		public static void DeletePathsNV(uint path, int range)
		{
			DeletePathsNVNative(path, range);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeArrayfvNVNative(uint first, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[21])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[21])(first, count, (nint)v);
			#endif
		}

		public static void DepthRangeArrayfvNV(uint first, int count, float* v)
		{
			DepthRangeArrayfvNVNative(first, count, v);
		}

		public static void DepthRangeArrayfvNV(uint first, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				DepthRangeArrayfvNVNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeIndexedfNVNative(uint index, float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[22])(index, n, f);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[22])(index, n, f);
			#endif
		}

		public static void DepthRangeIndexedfNV(uint index, float n, float f)
		{
			DepthRangeIndexedfNVNative(index, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableiNVNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[23])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[23])(target, index);
			#endif
		}

		public static void DisableiNV(GLEnableCap target, uint index)
		{
			DisableiNVNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedNVNative(GLPrimitiveType mode, int first, int count, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[24])(mode, first, count, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[24])(mode, first, count, primcount);
			#endif
		}

		public static void DrawArraysInstancedNV(GLPrimitiveType mode, int first, int count, int primcount)
		{
			DrawArraysInstancedNVNative(mode, first, count, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersNVNative(int n, GLEnum* bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLEnum*, void>)funcTable[25])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[25])(n, (nint)bufs);
			#endif
		}

		public static void DrawBuffersNV(int n, GLEnum* bufs)
		{
			DrawBuffersNVNative(n, bufs);
		}

		public static void DrawBuffersNV(int n, ref GLEnum bufs)
		{
			fixed (GLEnum* pbufs0 = &bufs)
			{
				DrawBuffersNVNative(n, pbufs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedNVNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[26])(mode, count, type, indices, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[26])(mode, count, type, (nint)indices, primcount);
			#endif
		}

		public static void DrawElementsInstancedNV(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			DrawElementsInstancedNVNative(mode, count, type, indices, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawMeshTasksNVNative(uint first, uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[27])(first, count);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[27])(first, count);
			#endif
		}

		public static void DrawMeshTasksNV(uint first, uint count)
		{
			DrawMeshTasksNVNative(first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawMeshTasksIndirectNVNative(nint indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[28])(indirect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[28])(indirect);
			#endif
		}

		public static void DrawMeshTasksIndirectNV(nint indirect)
		{
			DrawMeshTasksIndirectNVNative(indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableiNVNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[29])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[29])(target, index);
			#endif
		}

		public static void EnableiNV(GLEnableCap target, uint index)
		{
			EnableiNVNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndConditionalRenderNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[30])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[30])();
			#endif
		}

		public static void EndConditionalRenderNV()
		{
			EndConditionalRenderNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FinishFenceNVNative(uint fence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[31])(fence);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[31])(fence);
			#endif
		}

		public static void FinishFenceNV(uint fence)
		{
			FinishFenceNVNative(fence);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FragmentCoverageColorNVNative(uint color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[32])(color);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[32])(color);
			#endif
		}

		public static void FragmentCoverageColorNV(uint color)
		{
			FragmentCoverageColorNVNative(color);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferSampleLocationsfvNVNative(GLFramebufferTarget target, uint start, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, int, float*, void>)funcTable[33])(target, start, count, v);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, int, nint, void>)funcTable[33])(target, start, count, (nint)v);
			#endif
		}

		public static void FramebufferSampleLocationsfvNV(GLFramebufferTarget target, uint start, int count, float* v)
		{
			FramebufferSampleLocationsfvNVNative(target, start, count, v);
		}

		public static void FramebufferSampleLocationsfvNV(GLFramebufferTarget target, uint start, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				FramebufferSampleLocationsfvNVNative(target, start, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenFencesNVNative(int n, uint* fences)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[34])(n, fences);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[34])(n, (nint)fences);
			#endif
		}

		public static void GenFencesNV(int n, uint* fences)
		{
			GenFencesNVNative(n, fences);
		}

		public static void GenFencesNV(int n, ref uint fences)
		{
			fixed (uint* pfences0 = &fences)
			{
				GenFencesNVNative(n, pfences0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenPathsNVNative(int range)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[35])(range);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[35])(range);
			#endif
		}

		public static uint GenPathsNV(int range)
		{
			uint ret = GenPathsNVNative(range);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCoverageModulationTableNVNative(int bufSize, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, float*, void>)funcTable[36])(bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[36])(bufSize, (nint)v);
			#endif
		}

		public static void GetCoverageModulationTableNV(int bufSize, float* v)
		{
			GetCoverageModulationTableNVNative(bufSize, v);
		}

		public static void GetCoverageModulationTableNV(int bufSize, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetCoverageModulationTableNVNative(bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFenceivNVNative(uint fence, GLFenceParameterNameNV pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFenceParameterNameNV, int*, void>)funcTable[37])(fence, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFenceParameterNameNV, nint, void>)funcTable[37])(fence, pname, (nint)@params);
			#endif
		}

		public static void GetFenceivNV(uint fence, GLFenceParameterNameNV pname, int* @params)
		{
			GetFenceivNVNative(fence, pname, @params);
		}

		public static void GetFenceivNV(uint fence, GLFenceParameterNameNV pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFenceivNVNative(fence, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloati_vNVNative(GLGetPName target, uint index, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[38])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[38])(target, index, (nint)data);
			#endif
		}

		public static void GetFloati_vNV(GLGetPName target, uint index, float* data)
		{
			GetFloati_vNVNative(target, index, data);
		}

		public static void GetFloati_vNV(GLGetPName target, uint index, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloati_vNVNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetImageHandleNVNative(uint texture, int level, byte layered, int layer, GLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, byte, int, GLPixelFormat, ulong>)funcTable[39])(texture, level, layered, layer, format);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, int, byte, int, GLPixelFormat, ulong>)funcTable[39])(texture, level, layered, layer, format);
			#endif
		}

		public static ulong GetImageHandleNV(uint texture, int level, byte layered, int layer, GLPixelFormat format)
		{
			ulong ret = GetImageHandleNVNative(texture, level, layered, layer, format);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformatSampleivNVNative(GLTextureTarget target, GLInternalFormat internalformat, int samples, GLInternalFormatPName pname, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, int, GLInternalFormatPName, int, int*, void>)funcTable[40])(target, internalformat, samples, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, int, GLInternalFormatPName, int, nint, void>)funcTable[40])(target, internalformat, samples, pname, count, (nint)@params);
			#endif
		}

		public static void GetInternalformatSampleivNV(GLTextureTarget target, GLInternalFormat internalformat, int samples, GLInternalFormatPName pname, int count, int* @params)
		{
			GetInternalformatSampleivNVNative(target, internalformat, samples, pname, count, @params);
		}

		public static void GetInternalformatSampleivNV(GLTextureTarget target, GLInternalFormat internalformat, int samples, GLInternalFormatPName pname, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetInternalformatSampleivNVNative(target, internalformat, samples, pname, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMemoryObjectDetachedResourcesuivNVNative(uint memory, GLEnum pname, int first, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, int, uint*, void>)funcTable[41])(memory, pname, first, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, int, nint, void>)funcTable[41])(memory, pname, first, count, (nint)@params);
			#endif
		}

		public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, GLEnum pname, int first, int count, uint* @params)
		{
			GetMemoryObjectDetachedResourcesuivNVNative(memory, pname, first, count, @params);
		}

		public static void GetMemoryObjectDetachedResourcesuivNV(uint memory, GLEnum pname, int first, int count, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetMemoryObjectDetachedResourcesuivNVNative(memory, pname, first, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathColorGenfvNVNative(GLPathColor color, GLPathGenMode pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, float*, void>)funcTable[42])(color, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, nint, void>)funcTable[42])(color, pname, (nint)value);
			#endif
		}

		public static void GetPathColorGenfvNV(GLPathColor color, GLPathGenMode pname, float* value)
		{
			GetPathColorGenfvNVNative(color, pname, value);
		}

		public static void GetPathColorGenfvNV(GLPathColor color, GLPathGenMode pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathColorGenfvNVNative(color, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathColorGenivNVNative(GLPathColor color, GLPathGenMode pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int*, void>)funcTable[43])(color, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, nint, void>)funcTable[43])(color, pname, (nint)value);
			#endif
		}

		public static void GetPathColorGenivNV(GLPathColor color, GLPathGenMode pname, int* value)
		{
			GetPathColorGenivNVNative(color, pname, value);
		}

		public static void GetPathColorGenivNV(GLPathColor color, GLPathGenMode pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathColorGenivNVNative(color, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathCommandsNVNative(uint path, GLPathCoordType commands)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathCoordType, void>)funcTable[44])(path, commands);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathCoordType, void>)funcTable[44])(path, commands);
			#endif
		}

		public static void GetPathCommandsNV(uint path, GLPathCoordType commands)
		{
			GetPathCommandsNVNative(path, commands);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathCoordsNVNative(uint path, float* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[45])(path, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[45])(path, (nint)coords);
			#endif
		}

		public static void GetPathCoordsNV(uint path, float* coords)
		{
			GetPathCoordsNVNative(path, coords);
		}

		public static void GetPathCoordsNV(uint path, ref float coords)
		{
			fixed (float* pcoords0 = &coords)
			{
				GetPathCoordsNVNative(path, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathDashArrayNVNative(uint path, float* dashArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[46])(path, dashArray);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[46])(path, (nint)dashArray);
			#endif
		}

		public static void GetPathDashArrayNV(uint path, float* dashArray)
		{
			GetPathDashArrayNVNative(path, dashArray);
		}

		public static void GetPathDashArrayNV(uint path, ref float dashArray)
		{
			fixed (float* pdashArray0 = &dashArray)
			{
				GetPathDashArrayNVNative(path, pdashArray0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float GetPathLengthNVNative(uint path, int startSegment, int numSegments)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, float>)funcTable[47])(path, startSegment, numSegments);
			#else
			return (float)((delegate* unmanaged[Cdecl]<uint, int, int, float>)funcTable[47])(path, startSegment, numSegments);
			#endif
		}

		public static float GetPathLengthNV(uint path, int startSegment, int numSegments)
		{
			float ret = GetPathLengthNVNative(path, startSegment, numSegments);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathMetricRangeNVNative(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, uint, int, int, float*, void>)funcTable[48])(metricQueryMask, firstPathName, numPaths, stride, metrics);
			#else
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, uint, int, int, nint, void>)funcTable[48])(metricQueryMask, firstPathName, numPaths, stride, (nint)metrics);
			#endif
		}

		public static void GetPathMetricRangeNV(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics)
		{
			GetPathMetricRangeNVNative(metricQueryMask, firstPathName, numPaths, stride, metrics);
		}

		public static void GetPathMetricRangeNV(GLPathMetricMask metricQueryMask, uint firstPathName, int numPaths, int stride, ref float metrics)
		{
			fixed (float* pmetrics0 = &metrics)
			{
				GetPathMetricRangeNVNative(metricQueryMask, firstPathName, numPaths, stride, pmetrics0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathMetricsNVNative(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, int, GLPathElementType, void*, uint, int, float*, void>)funcTable[49])(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
			#else
			((delegate* unmanaged[Cdecl]<GLPathMetricMask, int, GLPathElementType, nint, uint, int, nint, void>)funcTable[49])(metricQueryMask, numPaths, pathNameType, (nint)paths, pathBase, stride, (nint)metrics);
			#endif
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, float* metrics)
		{
			GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
		}

		public static void GetPathMetricsNV(GLPathMetricMask metricQueryMask, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int stride, ref float metrics)
		{
			fixed (float* pmetrics0 = &metrics)
			{
				GetPathMetricsNVNative(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, pmetrics0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathParameterfvNVNative(uint path, GLPathParameter pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float*, void>)funcTable[50])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[50])(path, pname, (nint)value);
			#endif
		}

		public static void GetPathParameterfvNV(uint path, GLPathParameter pname, float* value)
		{
			GetPathParameterfvNVNative(path, pname, value);
		}

		public static void GetPathParameterfvNV(uint path, GLPathParameter pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathParameterivNVNative(uint path, GLPathParameter pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int*, void>)funcTable[51])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[51])(path, pname, (nint)value);
			#endif
		}

		public static void GetPathParameterivNV(uint path, GLPathParameter pname, int* value)
		{
			GetPathParameterivNVNative(path, pname, value);
		}

		public static void GetPathParameterivNV(uint path, GLPathParameter pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathParameterivNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathSpacingNVNative(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathListMode, int, GLPathElementType, void*, uint, float, float, GLPathTransformType, float*, void>)funcTable[52])(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
			#else
			((delegate* unmanaged[Cdecl]<GLPathListMode, int, GLPathElementType, nint, uint, float, float, GLPathTransformType, nint, void>)funcTable[52])(pathListMode, numPaths, pathNameType, (nint)paths, pathBase, advanceScale, kerningScale, transformType, (nint)returnedSpacing);
			#endif
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, float* returnedSpacing)
		{
			GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
		}

		public static void GetPathSpacingNV(GLPathListMode pathListMode, int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, float advanceScale, float kerningScale, GLPathTransformType transformType, ref float returnedSpacing)
		{
			fixed (float* preturnedSpacing0 = &returnedSpacing)
			{
				GetPathSpacingNVNative(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, preturnedSpacing0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathTexGenfvNVNative(GLTextureUnit texCoordSet, GLPathGenMode pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, float*, void>)funcTable[53])(texCoordSet, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, nint, void>)funcTable[53])(texCoordSet, pname, (nint)value);
			#endif
		}

		public static void GetPathTexGenfvNV(GLTextureUnit texCoordSet, GLPathGenMode pname, float* value)
		{
			GetPathTexGenfvNVNative(texCoordSet, pname, value);
		}

		public static void GetPathTexGenfvNV(GLTextureUnit texCoordSet, GLPathGenMode pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				GetPathTexGenfvNVNative(texCoordSet, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPathTexGenivNVNative(GLTextureUnit texCoordSet, GLPathGenMode pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, int*, void>)funcTable[54])(texCoordSet, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLPathGenMode, nint, void>)funcTable[54])(texCoordSet, pname, (nint)value);
			#endif
		}

		public static void GetPathTexGenivNV(GLTextureUnit texCoordSet, GLPathGenMode pname, int* value)
		{
			GetPathTexGenivNVNative(texCoordSet, pname, value);
		}

		public static void GetPathTexGenivNV(GLTextureUnit texCoordSet, GLPathGenMode pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				GetPathTexGenivNVNative(texCoordSet, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourcefvNVNative(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLEnum*, int, int*, float*, void>)funcTable[55])(program, programInterface, index, propCount, props, count, length, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, nint, int, nint, nint, void>)funcTable[55])(program, programInterface, index, propCount, (nint)props, count, (nint)length, (nint)@params);
			#endif
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, float* @params)
		{
			GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, length, @params);
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, int* length, float* @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, length, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, ref int length, float* @params)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, ref int length, float* @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				fixed (int* plength1 = &length)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, plength1, @params);
				}
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, int* length, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, length, pparams0);
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, int* length, ref float @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				fixed (float* pparams1 = &@params)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, length, pparams1);
				}
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, GLEnum* props, int count, ref int length, ref float @params)
		{
			fixed (int* plength0 = &length)
			{
				fixed (float* pparams1 = &@params)
				{
					GetProgramResourcefvNVNative(program, programInterface, index, propCount, props, count, plength0, pparams1);
				}
			}
		}

		public static void GetProgramResourcefvNV(uint program, GLProgramInterface programInterface, uint index, int propCount, ref GLEnum props, int count, ref int length, ref float @params)
		{
			fixed (GLEnum* pprops0 = &props)
			{
				fixed (int* plength1 = &length)
				{
					fixed (float* pparams2 = &@params)
					{
						GetProgramResourcefvNVNative(program, programInterface, index, propCount, pprops0, count, plength1, pparams2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSemaphoreParameterivNVNative(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, int*, void>)funcTable[56])(semaphore, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, nint, void>)funcTable[56])(semaphore, pname, (nint)@params);
			#endif
		}

		public static void GetSemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			GetSemaphoreParameterivNVNative(semaphore, pname, @params);
		}

		public static void GetSemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetSemaphoreParameterivNVNative(semaphore, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShadingRateImagePaletteNVNative(uint viewport, uint entry, GLEnum* rate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum*, void>)funcTable[57])(viewport, entry, rate);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[57])(viewport, entry, (nint)rate);
			#endif
		}

		public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, GLEnum* rate)
		{
			GetShadingRateImagePaletteNVNative(viewport, entry, rate);
		}

		public static void GetShadingRateImagePaletteNV(uint viewport, uint entry, ref GLEnum rate)
		{
			fixed (GLEnum* prate0 = &rate)
			{
				GetShadingRateImagePaletteNVNative(viewport, entry, prate0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShadingRateSampleLocationivNVNative(GLEnum rate, uint samples, uint index, int* location)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, uint, int*, void>)funcTable[58])(rate, samples, index, location);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, uint, nint, void>)funcTable[58])(rate, samples, index, (nint)location);
			#endif
		}

		public static void GetShadingRateSampleLocationivNV(GLEnum rate, uint samples, uint index, int* location)
		{
			GetShadingRateSampleLocationivNVNative(rate, samples, index, location);
		}

		public static void GetShadingRateSampleLocationivNV(GLEnum rate, uint samples, uint index, ref int location)
		{
			fixed (int* plocation0 = &location)
			{
				GetShadingRateSampleLocationivNVNative(rate, samples, index, plocation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTextureHandleNVNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ulong>)funcTable[59])(texture);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, ulong>)funcTable[59])(texture);
			#endif
		}

		public static ulong GetTextureHandleNV(uint texture)
		{
			ulong ret = GetTextureHandleNVNative(texture);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTextureSamplerHandleNVNative(uint texture, uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, ulong>)funcTable[60])(texture, sampler);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, uint, ulong>)funcTable[60])(texture, sampler);
			#endif
		}

		public static ulong GetTextureSamplerHandleNV(uint texture, uint sampler)
		{
			ulong ret = GetTextureSamplerHandleNVNative(texture, sampler);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformi64vNVNative(uint program, int location, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long*, void>)funcTable[61])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[61])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformi64vNV(uint program, int location, long* @params)
		{
			GetUniformi64vNVNative(program, location, @params);
		}

		public static void GetUniformi64vNV(uint program, int location, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetUniformi64vNVNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InterpolatePathsNVNative(uint resultPath, uint pathA, uint pathB, float weight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, float, void>)funcTable[62])(resultPath, pathA, pathB, weight);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, float, void>)funcTable[62])(resultPath, pathA, pathB, weight);
			#endif
		}

		public static void InterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight)
		{
			InterpolatePathsNVNative(resultPath, pathA, pathB, weight);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnablediNVNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[63])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[63])(target, index);
			#endif
		}

		public static bool IsEnablediNV(GLEnableCap target, uint index)
		{
			byte ret = IsEnablediNVNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFenceNVNative(uint fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[64])(fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[64])(fence);
			#endif
		}

		public static bool IsFenceNV(uint fence)
		{
			byte ret = IsFenceNVNative(fence);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsImageHandleResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[65])(handle);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[65])(handle);
			#endif
		}

		public static bool IsImageHandleResidentNV(ulong handle)
		{
			byte ret = IsImageHandleResidentNVNative(handle);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPathNVNative(uint path)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[66])(path);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[66])(path);
			#endif
		}

		public static bool IsPathNV(uint path)
		{
			byte ret = IsPathNVNative(path);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPointInFillPathNVNative(uint path, uint mask, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, float, float, byte>)funcTable[67])(path, mask, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, uint, float, float, byte>)funcTable[67])(path, mask, x, y);
			#endif
		}

		public static bool IsPointInFillPathNV(uint path, uint mask, float x, float y)
		{
			byte ret = IsPointInFillPathNVNative(path, mask, x, y);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsPointInStrokePathNVNative(uint path, float x, float y)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, float, float, byte>)funcTable[68])(path, x, y);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, float, float, byte>)funcTable[68])(path, x, y);
			#endif
		}

		public static bool IsPointInStrokePathNV(uint path, float x, float y)
		{
			byte ret = IsPointInStrokePathNVNative(path, x, y);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureHandleResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[69])(handle);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[69])(handle);
			#endif
		}

		public static bool IsTextureHandleResidentNV(ulong handle)
		{
			byte ret = IsTextureHandleResidentNVNative(handle);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeImageHandleNonResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[70])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[70])(handle);
			#endif
		}

		public static void MakeImageHandleNonResidentNV(ulong handle)
		{
			MakeImageHandleNonResidentNVNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeImageHandleResidentNVNative(ulong handle, GLEnum access)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, GLEnum, void>)funcTable[71])(handle, access);
			#else
			((delegate* unmanaged[Cdecl]<ulong, GLEnum, void>)funcTable[71])(handle, access);
			#endif
		}

		public static void MakeImageHandleResidentNV(ulong handle, GLEnum access)
		{
			MakeImageHandleResidentNVNative(handle, access);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTextureHandleNonResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[72])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[72])(handle);
			#endif
		}

		public static void MakeTextureHandleNonResidentNV(ulong handle)
		{
			MakeTextureHandleNonResidentNVNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTextureHandleResidentNVNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[73])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[73])(handle);
			#endif
		}

		public static void MakeTextureHandleResidentNV(ulong handle)
		{
			MakeTextureHandleResidentNVNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixFrustumEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[74])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[74])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixFrustumEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixFrustumEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoad3x2fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[75])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[75])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoad3x2fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoad3x2fNVNative(matrixMode, m);
		}

		public static void MatrixLoad3x2fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoad3x2fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoad3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[76])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[76])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoad3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoad3x3fNVNative(matrixMode, m);
		}

		public static void MatrixLoad3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoad3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadIdentityEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[77])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[77])(mode);
			#endif
		}

		public static void MatrixLoadIdentityEXT(GLMatrixMode mode)
		{
			MatrixLoadIdentityEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTranspose3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[78])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[78])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixLoadTranspose3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixLoadTranspose3x3fNVNative(matrixMode, m);
		}

		public static void MatrixLoadTranspose3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[79])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[79])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoadTransposedEXTNative(mode, m);
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoadTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[80])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[80])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadTransposefEXTNative(mode, m);
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoaddEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[81])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[81])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoaddEXTNative(mode, m);
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoaddEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[82])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[82])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadfEXTNative(mode, m);
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMult3x2fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[83])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[83])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMult3x2fNV(GLEnum matrixMode, float* m)
		{
			MatrixMult3x2fNVNative(matrixMode, m);
		}

		public static void MatrixMult3x2fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMult3x2fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMult3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[84])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[84])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMult3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixMult3x3fNVNative(matrixMode, m);
		}

		public static void MatrixMult3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMult3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTranspose3x3fNVNative(GLEnum matrixMode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, float*, void>)funcTable[85])(matrixMode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, void>)funcTable[85])(matrixMode, (nint)m);
			#endif
		}

		public static void MatrixMultTranspose3x3fNV(GLEnum matrixMode, float* m)
		{
			MatrixMultTranspose3x3fNVNative(matrixMode, m);
		}

		public static void MatrixMultTranspose3x3fNV(GLEnum matrixMode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTranspose3x3fNVNative(matrixMode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[86])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[86])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultTransposedEXTNative(mode, m);
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[87])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[87])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultTransposefEXTNative(mode, m);
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultdEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[88])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[88])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultdEXTNative(mode, m);
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultdEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[89])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[89])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultfEXTNative(mode, m);
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixOrthoEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[90])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[90])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixOrthoEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixOrthoEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPopEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[91])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[91])(mode);
			#endif
		}

		public static void MatrixPopEXT(GLMatrixMode mode)
		{
			MatrixPopEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPushEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[92])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[92])(mode);
			#endif
		}

		public static void MatrixPushEXT(GLMatrixMode mode)
		{
			MatrixPushEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatedEXTNative(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[93])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[93])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatedEXT(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			MatrixRotatedEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatefEXTNative(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[94])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[94])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatefEXT(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			MatrixRotatefEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScaledEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[95])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[95])(mode, x, y, z);
			#endif
		}

		public static void MatrixScaledEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixScaledEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScalefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[96])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[96])(mode, x, y, z);
			#endif
		}

		public static void MatrixScalefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixScalefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatedEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[97])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[97])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatedEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixTranslatedEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[98])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[98])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixTranslatefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawMeshTasksIndirectNVNative(nint indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[99])(indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, int, void>)funcTable[99])(indirect, drawcount, stride);
			#endif
		}

		public static void MultiDrawMeshTasksIndirectNV(nint indirect, int drawcount, int stride)
		{
			MultiDrawMeshTasksIndirectNVNative(indirect, drawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawMeshTasksIndirectCountNVNative(nint indirect, nint drawcount, int maxdrawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)funcTable[100])(indirect, drawcount, maxdrawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, int, int, void>)funcTable[100])(indirect, drawcount, maxdrawcount, stride);
			#endif
		}

		public static void MultiDrawMeshTasksIndirectCountNV(nint indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawMeshTasksIndirectCountNVNative(indirect, drawcount, maxdrawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferAttachMemoryNVNative(uint buffer, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[101])(buffer, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[101])(buffer, memory, offset);
			#endif
		}

		public static void NamedBufferAttachMemoryNV(uint buffer, uint memory, ulong offset)
		{
			NamedBufferAttachMemoryNVNative(buffer, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferPageCommitmentMemNVNative(uint buffer, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, uint, ulong, byte, void>)funcTable[102])(buffer, offset, size, memory, memOffset, commit);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, uint, ulong, byte, void>)funcTable[102])(buffer, offset, size, memory, memOffset, commit);
			#endif
		}

		public static void NamedBufferPageCommitmentMemNV(uint buffer, nint offset, nint size, uint memory, ulong memOffset, byte commit)
		{
			NamedBufferPageCommitmentMemNVNative(buffer, offset, size, memory, memOffset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferSampleLocationsfvNVNative(uint framebuffer, uint start, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, float*, void>)funcTable[103])(framebuffer, start, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[103])(framebuffer, start, count, (nint)v);
			#endif
		}

		public static void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, float* v)
		{
			NamedFramebufferSampleLocationsfvNVNative(framebuffer, start, count, v);
		}

		public static void NamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				NamedFramebufferSampleLocationsfvNVNative(framebuffer, start, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathColorGenNVNative(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, GLPathColorFormat, float*, void>)funcTable[104])(color, genMode, colorFormat, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, GLPathColorFormat, nint, void>)funcTable[104])(color, genMode, colorFormat, (nint)coeffs);
			#endif
		}

		public static void PathColorGenNV(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, float* coeffs)
		{
			PathColorGenNVNative(color, genMode, colorFormat, coeffs);
		}

		public static void PathColorGenNV(GLPathColor color, GLPathGenMode genMode, GLPathColorFormat colorFormat, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				PathColorGenNVNative(color, genMode, colorFormat, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCommandsNVNative(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, int, GLPathCoordType, void*, void>)funcTable[105])(path, numCommands, commands, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, int, GLPathCoordType, nint, void>)funcTable[105])(path, numCommands, commands, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathCommandsNV(uint path, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathCommandsNVNative(path, numCommands, commands, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCoordsNVNative(uint path, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, void*, void>)funcTable[106])(path, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPathCoordType, nint, void>)funcTable[106])(path, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathCoordsNV(uint path, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathCoordsNVNative(path, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathCoverDepthFuncNVNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[107])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[107])(func);
			#endif
		}

		public static void PathCoverDepthFuncNV(GLDepthFunction func)
		{
			PathCoverDepthFuncNVNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathDashArrayNVNative(uint path, int dashCount, float* dashArray)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[108])(path, dashCount, dashArray);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[108])(path, dashCount, (nint)dashArray);
			#endif
		}

		public static void PathDashArrayNV(uint path, int dashCount, float* dashArray)
		{
			PathDashArrayNVNative(path, dashCount, dashArray);
		}

		public static void PathDashArrayNV(uint path, int dashCount, ref float dashArray)
		{
			fixed (float* pdashArray0 = &dashArray)
			{
				PathDashArrayNVNative(path, dashCount, pdashArray0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathFogGenNVNative(GLPathGenMode genMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathGenMode, void>)funcTable[109])(genMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPathGenMode, void>)funcTable[109])(genMode);
			#endif
		}

		public static void PathFogGenNV(GLPathGenMode genMode)
		{
			PathFogGenNVNative(genMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathGlyphIndexArrayNVNative(uint firstPathName, GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLEnum, void*, GLPathFontStyle, uint, int, uint, float, GLEnum>)funcTable[110])(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, GLPathFontStyle, uint, int, uint, float, GLEnum>)funcTable[110])(firstPathName, fontTarget, (nint)fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static GLEnum PathGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathGlyphIndexArrayNVNative(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathGlyphIndexRangeNVNative(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum, void*, GLPathFontStyle, uint, float, uint*, GLEnum>)funcTable[111])(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum, nint, GLPathFontStyle, uint, float, nint, GLEnum>)funcTable[111])(fontTarget, (nint)fontName, fontStyle, pathParameterTemplate, emScale, (nint)baseAndCount);
			#endif
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, uint* baseAndCount)
		{
			GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
			return ret;
		}

		public static GLEnum PathGlyphIndexRangeNV(GLEnum fontTarget, void* fontName, GLPathFontStyle fontStyle, uint pathParameterTemplate, float emScale, ref uint baseAndCount)
		{
			fixed (uint* pbaseAndCount0 = &baseAndCount)
			{
				GLEnum ret = PathGlyphIndexRangeNVNative(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, pbaseAndCount0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathGlyphRangeNVNative(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, void*, GLPathFontStyle, uint, int, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[112])(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, nint, GLPathFontStyle, uint, int, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[112])(firstPathName, fontTarget, (nint)fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static void PathGlyphRangeNV(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, uint firstGlyph, int numGlyphs, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphRangeNVNative(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathGlyphsNVNative(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, void*, GLPathFontStyle, int, GLPathElementType, void*, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[113])(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFontTarget, nint, GLPathFontStyle, int, GLPathElementType, nint, GLPathHandleMissingGlyphs, uint, float, void>)funcTable[113])(firstPathName, fontTarget, (nint)fontName, fontStyle, numGlyphs, type, (nint)charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static void PathGlyphsNV(uint firstPathName, GLPathFontTarget fontTarget, void* fontName, GLPathFontStyle fontStyle, int numGlyphs, GLPathElementType type, void* charcodes, GLPathHandleMissingGlyphs handleMissingGlyphs, uint pathParameterTemplate, float emScale)
		{
			PathGlyphsNVNative(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum PathMemoryGlyphIndexArrayNVNative(uint firstPathName, GLEnum fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void*, int, uint, int, uint, float, GLEnum>)funcTable[114])(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, nint, int, uint, int, uint, float, GLEnum>)funcTable[114])(firstPathName, fontTarget, fontSize, (nint)fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			#endif
		}

		public static GLEnum PathMemoryGlyphIndexArrayNV(uint firstPathName, GLEnum fontTarget, nint fontSize, void* fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale)
		{
			GLEnum ret = PathMemoryGlyphIndexArrayNVNative(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterfNVNative(uint path, GLPathParameter pname, float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float, void>)funcTable[115])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float, void>)funcTable[115])(path, pname, value);
			#endif
		}

		public static void PathParameterfNV(uint path, GLPathParameter pname, float value)
		{
			PathParameterfNVNative(path, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterfvNVNative(uint path, GLPathParameter pname, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, float*, void>)funcTable[116])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[116])(path, pname, (nint)value);
			#endif
		}

		public static void PathParameterfvNV(uint path, GLPathParameter pname, float* value)
		{
			PathParameterfvNVNative(path, pname, value);
		}

		public static void PathParameterfvNV(uint path, GLPathParameter pname, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				PathParameterfvNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameteriNVNative(uint path, GLPathParameter pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int, void>)funcTable[117])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int, void>)funcTable[117])(path, pname, value);
			#endif
		}

		public static void PathParameteriNV(uint path, GLPathParameter pname, int value)
		{
			PathParameteriNVNative(path, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathParameterivNVNative(uint path, GLPathParameter pname, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, int*, void>)funcTable[118])(path, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathParameter, nint, void>)funcTable[118])(path, pname, (nint)value);
			#endif
		}

		public static void PathParameterivNV(uint path, GLPathParameter pname, int* value)
		{
			PathParameterivNVNative(path, pname, value);
		}

		public static void PathParameterivNV(uint path, GLPathParameter pname, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				PathParameterivNVNative(path, pname, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStencilDepthOffsetNVNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[119])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[119])(factor, units);
			#endif
		}

		public static void PathStencilDepthOffsetNV(float factor, float units)
		{
			PathStencilDepthOffsetNVNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStencilFuncNVNative(GLStencilFunction func, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[120])(func, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<GLStencilFunction, int, uint, void>)funcTable[120])(func, reference, mask);
			#endif
		}

		public static void PathStencilFuncNV(GLStencilFunction func, int reference, uint mask)
		{
			PathStencilFuncNVNative(func, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathStringNVNative(uint path, GLPathStringFormat format, int length, void* pathString)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathStringFormat, int, void*, void>)funcTable[121])(path, format, length, pathString);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathStringFormat, int, nint, void>)funcTable[121])(path, format, length, (nint)pathString);
			#endif
		}

		public static void PathStringNV(uint path, GLPathStringFormat format, int length, void* pathString)
		{
			PathStringNVNative(path, format, length, pathString);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathSubCommandsNVNative(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPathCoordType, int, GLPathCoordType, void*, void>)funcTable[122])(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLPathCoordType, int, GLPathCoordType, nint, void>)funcTable[122])(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, GLPathCoordType commands, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathSubCommandsNVNative(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathSubCoordsNVNative(uint path, int coordStart, int numCoords, GLPathCoordType coordType, void* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, GLPathCoordType, void*, void>)funcTable[123])(path, coordStart, numCoords, coordType, coords);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, GLPathCoordType, nint, void>)funcTable[123])(path, coordStart, numCoords, coordType, (nint)coords);
			#endif
		}

		public static void PathSubCoordsNV(uint path, int coordStart, int numCoords, GLPathCoordType coordType, void* coords)
		{
			PathSubCoordsNVNative(path, coordStart, numCoords, coordType, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PathTexGenNVNative(GLPathColor texCoordSet, GLPathGenMode genMode, int components, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int, float*, void>)funcTable[124])(texCoordSet, genMode, components, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<GLPathColor, GLPathGenMode, int, nint, void>)funcTable[124])(texCoordSet, genMode, components, (nint)coeffs);
			#endif
		}

		public static void PathTexGenNV(GLPathColor texCoordSet, GLPathGenMode genMode, int components, float* coeffs)
		{
			PathTexGenNVNative(texCoordSet, genMode, components, coeffs);
		}

		public static void PathTexGenNV(GLPathColor texCoordSet, GLPathGenMode genMode, int components, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				PathTexGenNVNative(texCoordSet, genMode, components, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte PointAlongPathNVNative(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int, float, float*, float*, float*, float*, byte>)funcTable[125])(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, int, int, float, nint, nint, nint, nint, byte>)funcTable[125])(path, startSegment, numSegments, distance, (nint)x, (nint)y, (nint)tangentX, (nint)tangentY);
			#endif
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY)
		{
			byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
			return ret != 0;
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, float* tangentX, float* tangentY)
		{
			fixed (float* py0 = &y)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, float* tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, ref float tangentX, float* tangentY)
		{
			fixed (float* ptangentX0 = &tangentX)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, tangentY);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, ref float tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, ref float tangentX, float* tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, tangentY);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, float* tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentX2 = &tangentX)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, tangentY);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, ref float tangentY)
		{
			fixed (float* ptangentY0 = &tangentY)
			{
				byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, tangentX, ptangentY0);
				return ret != 0;
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, float* tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, float* tangentX, ref float tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, tangentX, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, float* tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, tangentX, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, ref float tangentX, ref float tangentY)
		{
			fixed (float* ptangentX0 = &tangentX)
			{
				fixed (float* ptangentY1 = &tangentY)
				{
					byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, y, ptangentX0, ptangentY1);
					return ret != 0;
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, float* y, ref float tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, y, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, ref float y, ref float tangentX, ref float tangentY)
		{
			fixed (float* py0 = &y)
			{
				fixed (float* ptangentX1 = &tangentX)
				{
					fixed (float* ptangentY2 = &tangentY)
					{
						byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, x, py0, ptangentX1, ptangentY2);
						return ret != 0;
					}
				}
			}
		}

		public static bool PointAlongPathNV(uint path, int startSegment, int numSegments, float distance, ref float x, ref float y, ref float tangentX, ref float tangentY)
		{
			fixed (float* px0 = &x)
			{
				fixed (float* py1 = &y)
				{
					fixed (float* ptangentX2 = &tangentX)
					{
						fixed (float* ptangentY3 = &tangentY)
						{
							byte ret = PointAlongPathNVNative(path, startSegment, numSegments, distance, px0, py1, ptangentX2, ptangentY3);
							return ret != 0;
						}
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonModeNVNative(GLTriangleFace face, GLPolygonMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[126])(face, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[126])(face, mode);
			#endif
		}

		public static void PolygonModeNV(GLTriangleFace face, GLPolygonMode mode)
		{
			PolygonModeNVNative(face, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramPathFragmentInputGenNVNative(uint program, int location, GLEnum genMode, int components, float* coeffs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLEnum, int, float*, void>)funcTable[127])(program, location, genMode, components, coeffs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLEnum, int, nint, void>)funcTable[127])(program, location, genMode, components, (nint)coeffs);
			#endif
		}

		public static void ProgramPathFragmentInputGenNV(uint program, int location, GLEnum genMode, int components, float* coeffs)
		{
			ProgramPathFragmentInputGenNVNative(program, location, genMode, components, coeffs);
		}

		public static void ProgramPathFragmentInputGenNV(uint program, int location, GLEnum genMode, int components, ref float coeffs)
		{
			fixed (float* pcoeffs0 = &coeffs)
			{
				ProgramPathFragmentInputGenNVNative(program, location, genMode, components, pcoeffs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1i64NVNative(uint program, int location, long x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, void>)funcTable[128])(program, location, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, void>)funcTable[128])(program, location, x);
			#endif
		}

		public static void ProgramUniform1i64NV(uint program, int location, long x)
		{
			ProgramUniform1i64NVNative(program, location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[129])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[129])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform1i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform1i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform1i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1ui64NVNative(uint program, int location, ulong x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[130])(program, location, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[130])(program, location, x);
			#endif
		}

		public static void ProgramUniform1ui64NV(uint program, int location, ulong x)
		{
			ProgramUniform1ui64NVNative(program, location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[131])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[131])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform1ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform1ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform1ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2i64NVNative(uint program, int location, long x, long y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, long, void>)funcTable[132])(program, location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, long, void>)funcTable[132])(program, location, x, y);
			#endif
		}

		public static void ProgramUniform2i64NV(uint program, int location, long x, long y)
		{
			ProgramUniform2i64NVNative(program, location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[133])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[133])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform2i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform2i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform2i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2ui64NVNative(uint program, int location, ulong x, ulong y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, void>)funcTable[134])(program, location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, void>)funcTable[134])(program, location, x, y);
			#endif
		}

		public static void ProgramUniform2ui64NV(uint program, int location, ulong x, ulong y)
		{
			ProgramUniform2ui64NVNative(program, location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[135])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[135])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform2ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform2ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform2ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3i64NVNative(uint program, int location, long x, long y, long z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, void>)funcTable[136])(program, location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, void>)funcTable[136])(program, location, x, y, z);
			#endif
		}

		public static void ProgramUniform3i64NV(uint program, int location, long x, long y, long z)
		{
			ProgramUniform3i64NVNative(program, location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[137])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[137])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform3i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform3i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform3i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3ui64NVNative(uint program, int location, ulong x, ulong y, ulong z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, void>)funcTable[138])(program, location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, void>)funcTable[138])(program, location, x, y, z);
			#endif
		}

		public static void ProgramUniform3ui64NV(uint program, int location, ulong x, ulong y, ulong z)
		{
			ProgramUniform3ui64NVNative(program, location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[139])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[139])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform3ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform3ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform3ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4i64NVNative(uint program, int location, long x, long y, long z, long w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, long, void>)funcTable[140])(program, location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, long, long, long, long, void>)funcTable[140])(program, location, x, y, z, w);
			#endif
		}

		public static void ProgramUniform4i64NV(uint program, int location, long x, long y, long z, long w)
		{
			ProgramUniform4i64NVNative(program, location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4i64vNVNative(uint program, int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[141])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[141])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4i64vNV(uint program, int location, int count, long* value)
		{
			ProgramUniform4i64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform4i64vNV(uint program, int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				ProgramUniform4i64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4ui64NVNative(uint program, int location, ulong x, ulong y, ulong z, ulong w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, ulong, void>)funcTable[142])(program, location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, ulong, ulong, ulong, void>)funcTable[142])(program, location, x, y, z, w);
			#endif
		}

		public static void ProgramUniform4ui64NV(uint program, int location, ulong x, ulong y, ulong z, ulong w)
		{
			ProgramUniform4ui64NVNative(program, location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4ui64vNVNative(uint program, int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[143])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[143])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4ui64vNV(uint program, int location, int count, ulong* value)
		{
			ProgramUniform4ui64vNVNative(program, location, count, value);
		}

		public static void ProgramUniform4ui64vNV(uint program, int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				ProgramUniform4ui64vNVNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformHandleui64NVNative(uint program, int location, ulong value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[144])(program, location, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, ulong, void>)funcTable[144])(program, location, value);
			#endif
		}

		public static void ProgramUniformHandleui64NV(uint program, int location, ulong value)
		{
			ProgramUniformHandleui64NVNative(program, location, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformHandleui64vNVNative(uint program, int location, int count, ulong* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[145])(program, location, count, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[145])(program, location, count, (nint)values);
			#endif
		}

		public static void ProgramUniformHandleui64vNV(uint program, int location, int count, ulong* values)
		{
			ProgramUniformHandleui64vNVNative(program, location, count, values);
		}

		public static void ProgramUniformHandleui64vNV(uint program, int location, int count, ref ulong values)
		{
			fixed (ulong* pvalues0 = &values)
			{
				ProgramUniformHandleui64vNVNative(program, location, count, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterSamplesEXTNative(uint samples, byte fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[146])(samples, fixedsamplelocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[146])(samples, fixedsamplelocations);
			#endif
		}

		public static void RasterSamplesEXT(uint samples, byte fixedsamplelocations)
		{
			RasterSamplesEXTNative(samples, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadBufferNVNative(GLEnum mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[147])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[147])(mode);
			#endif
		}

		public static void ReadBufferNV(GLEnum mode)
		{
			ReadBufferNVNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderbufferStorageMultisampleNVNative(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[148])(target, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[148])(target, samples, internalformat, width, height);
			#endif
		}

		public static void RenderbufferStorageMultisampleNV(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			RenderbufferStorageMultisampleNVNative(target, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetMemoryObjectParameterNVNative(uint memory, GLEnum pname)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[149])(memory, pname);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void>)funcTable[149])(memory, pname);
			#endif
		}

		public static void ResetMemoryObjectParameterNV(uint memory, GLEnum pname)
		{
			ResetMemoryObjectParameterNVNative(memory, pname);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResolveDepthValuesNVNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[150])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[150])();
			#endif
		}

		public static void ResolveDepthValuesNV()
		{
			ResolveDepthValuesNVNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorArrayvNVNative(uint first, int count, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[151])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[151])(first, count, (nint)v);
			#endif
		}

		public static void ScissorArrayvNV(uint first, int count, int* v)
		{
			ScissorArrayvNVNative(first, count, v);
		}

		public static void ScissorArrayvNV(uint first, int count, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				ScissorArrayvNVNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorExclusiveArrayvNVNative(uint first, int count, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[152])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[152])(first, count, (nint)v);
			#endif
		}

		public static void ScissorExclusiveArrayvNV(uint first, int count, int* v)
		{
			ScissorExclusiveArrayvNVNative(first, count, v);
		}

		public static void ScissorExclusiveArrayvNV(uint first, int count, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				ScissorExclusiveArrayvNVNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorExclusiveNVNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[153])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[153])(x, y, width, height);
			#endif
		}

		public static void ScissorExclusiveNV(int x, int y, int width, int height)
		{
			ScissorExclusiveNVNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorIndexedNVNative(uint index, int left, int bottom, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[154])(index, left, bottom, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[154])(index, left, bottom, width, height);
			#endif
		}

		public static void ScissorIndexedNV(uint index, int left, int bottom, int width, int height)
		{
			ScissorIndexedNVNative(index, left, bottom, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ScissorIndexedvNVNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[155])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[155])(index, (nint)v);
			#endif
		}

		public static void ScissorIndexedvNV(uint index, int* v)
		{
			ScissorIndexedvNVNative(index, v);
		}

		public static void ScissorIndexedvNV(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				ScissorIndexedvNVNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SemaphoreParameterivNVNative(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, int*, void>)funcTable[156])(semaphore, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, nint, void>)funcTable[156])(semaphore, pname, (nint)@params);
			#endif
		}

		public static void SemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, int* @params)
		{
			SemaphoreParameterivNVNative(semaphore, pname, @params);
		}

		public static void SemaphoreParameterivNV(uint semaphore, GLSemaphoreParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				SemaphoreParameterivNVNative(semaphore, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetFenceNVNative(uint fence, GLFenceConditionNV condition)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFenceConditionNV, void>)funcTable[157])(fence, condition);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFenceConditionNV, void>)funcTable[157])(fence, condition);
			#endif
		}

		public static void SetFenceNV(uint fence, GLFenceConditionNV condition)
		{
			SetFenceNVNative(fence, condition);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateImageBarrierNVNative(byte synchronize)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[158])(synchronize);
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[158])(synchronize);
			#endif
		}

		public static void ShadingRateImageBarrierNV(byte synchronize)
		{
			ShadingRateImageBarrierNVNative(synchronize);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateImagePaletteNVNative(uint viewport, uint first, int count, GLEnum* rates)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLEnum*, void>)funcTable[159])(viewport, first, count, rates);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[159])(viewport, first, count, (nint)rates);
			#endif
		}

		public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, GLEnum* rates)
		{
			ShadingRateImagePaletteNVNative(viewport, first, count, rates);
		}

		public static void ShadingRateImagePaletteNV(uint viewport, uint first, int count, ref GLEnum rates)
		{
			fixed (GLEnum* prates0 = &rates)
			{
				ShadingRateImagePaletteNVNative(viewport, first, count, prates0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateSampleOrderNVNative(GLEnum order)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[160])(order);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, void>)funcTable[160])(order);
			#endif
		}

		public static void ShadingRateSampleOrderNV(GLEnum order)
		{
			ShadingRateSampleOrderNVNative(order);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateSampleOrderCustomNVNative(GLEnum rate, uint samples, int* locations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int*, void>)funcTable[161])(rate, samples, locations);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[161])(rate, samples, (nint)locations);
			#endif
		}

		public static void ShadingRateSampleOrderCustomNV(GLEnum rate, uint samples, int* locations)
		{
			ShadingRateSampleOrderCustomNVNative(rate, samples, locations);
		}

		public static void ShadingRateSampleOrderCustomNV(GLEnum rate, uint samples, ref int locations)
		{
			fixed (int* plocations0 = &locations)
			{
				ShadingRateSampleOrderCustomNVNative(rate, samples, plocations0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLPathFillMode, uint, GLPathTransformType, float*, void>)funcTable[162])(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLPathFillMode, uint, GLPathTransformType, nint, void>)funcTable[162])(numPaths, pathNameType, (nint)paths, pathBase, fillMode, mask, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
		}

		public static void StencilFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilFillPathNVNative(uint path, GLPathFillMode fillMode, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, void>)funcTable[163])(path, fillMode, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, void>)funcTable[163])(path, fillMode, mask);
			#endif
		}

		public static void StencilFillPathNV(uint path, GLPathFillMode fillMode, uint mask)
		{
			StencilFillPathNVNative(path, fillMode, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, int, uint, GLPathTransformType, float*, void>)funcTable[164])(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, int, uint, GLPathTransformType, nint, void>)funcTable[164])(numPaths, pathNameType, (nint)paths, pathBase, reference, mask, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, float* transformValues)
		{
			StencilStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
		}

		public static void StencilStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilStrokePathNVNative(uint path, int reference, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[165])(path, reference, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[165])(path, reference, mask);
			#endif
		}

		public static void StencilStrokePathNV(uint path, int reference, uint mask)
		{
			StencilStrokePathNVNative(path, reference, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverFillPathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, GLPathFillMode, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[166])(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, GLPathFillMode, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[166])(numPaths, pathNameType, (nint)paths, pathBase, fillMode, mask, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverFillPathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, GLPathFillMode fillMode, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilThenCoverFillPathInstancedNVNative(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverFillPathNVNative(uint path, GLPathFillMode fillMode, uint mask, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, GLPathCoverMode, void>)funcTable[167])(path, fillMode, mask, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPathFillMode, uint, GLPathCoverMode, void>)funcTable[167])(path, fillMode, mask, coverMode);
			#endif
		}

		public static void StencilThenCoverFillPathNV(uint path, GLPathFillMode fillMode, uint mask, GLPathCoverMode coverMode)
		{
			StencilThenCoverFillPathNVNative(path, fillMode, mask, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverStrokePathInstancedNVNative(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, void*, uint, int, uint, GLInstancedPathCoverMode, GLPathTransformType, float*, void>)funcTable[168])(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<int, GLPathElementType, nint, uint, int, uint, GLInstancedPathCoverMode, GLPathTransformType, nint, void>)funcTable[168])(numPaths, pathNameType, (nint)paths, pathBase, reference, mask, coverMode, transformType, (nint)transformValues);
			#endif
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, float* transformValues)
		{
			StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
		}

		public static void StencilThenCoverStrokePathInstancedNV(int numPaths, GLPathElementType pathNameType, void* paths, uint pathBase, int reference, uint mask, GLInstancedPathCoverMode coverMode, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				StencilThenCoverStrokePathInstancedNVNative(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void StencilThenCoverStrokePathNVNative(uint path, int reference, uint mask, GLPathCoverMode coverMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, GLPathCoverMode, void>)funcTable[169])(path, reference, mask, coverMode);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, GLPathCoverMode, void>)funcTable[169])(path, reference, mask, coverMode);
			#endif
		}

		public static void StencilThenCoverStrokePathNV(uint path, int reference, uint mask, GLPathCoverMode coverMode)
		{
			StencilThenCoverStrokePathNVNative(path, reference, mask, coverMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SubpixelPrecisionBiasNVNative(uint xbits, uint ybits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[170])(xbits, ybits);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[170])(xbits, ybits);
			#endif
		}

		public static void SubpixelPrecisionBiasNV(uint xbits, uint ybits)
		{
			SubpixelPrecisionBiasNVNative(xbits, ybits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte TestFenceNVNative(uint fence)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[171])(fence);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[171])(fence);
			#endif
		}

		public static bool TestFenceNV(uint fence)
		{
			byte ret = TestFenceNVNative(fence);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexAttachMemoryNVNative(GLTextureTarget target, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, ulong, void>)funcTable[172])(target, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, ulong, void>)funcTable[172])(target, memory, offset);
			#endif
		}

		public static void TexAttachMemoryNV(GLTextureTarget target, uint memory, ulong offset)
		{
			TexAttachMemoryNVNative(target, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexPageCommitmentMemNVNative(GLTextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[173])(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[173])(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#endif
		}

		public static void TexPageCommitmentMemNV(GLTextureTarget target, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			TexPageCommitmentMemNVNative(target, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureAttachMemoryNVNative(uint texture, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[174])(texture, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, ulong, void>)funcTable[174])(texture, memory, offset);
			#endif
		}

		public static void TextureAttachMemoryNV(uint texture, uint memory, ulong offset)
		{
			TextureAttachMemoryNVNative(texture, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexturePageCommitmentMemNVNative(uint texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[175])(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, uint, ulong, byte, void>)funcTable[175])(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
			#endif
		}

		public static void TexturePageCommitmentMemNV(uint texture, int layer, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, uint memory, ulong offset, byte commit)
		{
			TexturePageCommitmentMemNVNative(texture, layer, level, xoffset, yoffset, zoffset, width, height, depth, memory, offset, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TransformPathNVNative(uint resultPath, uint srcPath, GLPathTransformType transformType, float* transformValues)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLPathTransformType, float*, void>)funcTable[176])(resultPath, srcPath, transformType, transformValues);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLPathTransformType, nint, void>)funcTable[176])(resultPath, srcPath, transformType, (nint)transformValues);
			#endif
		}

		public static void TransformPathNV(uint resultPath, uint srcPath, GLPathTransformType transformType, float* transformValues)
		{
			TransformPathNVNative(resultPath, srcPath, transformType, transformValues);
		}

		public static void TransformPathNV(uint resultPath, uint srcPath, GLPathTransformType transformType, ref float transformValues)
		{
			fixed (float* ptransformValues0 = &transformValues)
			{
				TransformPathNVNative(resultPath, srcPath, transformType, ptransformValues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1i64NVNative(int location, long x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, void>)funcTable[177])(location, x);
			#else
			((delegate* unmanaged[Cdecl]<int, long, void>)funcTable[177])(location, x);
			#endif
		}

		public static void Uniform1i64NV(int location, long x)
		{
			Uniform1i64NVNative(location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[178])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[178])(location, count, (nint)value);
			#endif
		}

		public static void Uniform1i64vNV(int location, int count, long* value)
		{
			Uniform1i64vNVNative(location, count, value);
		}

		public static void Uniform1i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform1i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1ui64NVNative(int location, ulong x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[179])(location, x);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[179])(location, x);
			#endif
		}

		public static void Uniform1ui64NV(int location, ulong x)
		{
			Uniform1ui64NVNative(location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform1ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[180])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[180])(location, count, (nint)value);
			#endif
		}

		public static void Uniform1ui64vNV(int location, int count, ulong* value)
		{
			Uniform1ui64vNVNative(location, count, value);
		}

		public static void Uniform1ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform1ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2i64NVNative(int location, long x, long y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, long, void>)funcTable[181])(location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, long, long, void>)funcTable[181])(location, x, y);
			#endif
		}

		public static void Uniform2i64NV(int location, long x, long y)
		{
			Uniform2i64NVNative(location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[182])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[182])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2i64vNV(int location, int count, long* value)
		{
			Uniform2i64vNVNative(location, count, value);
		}

		public static void Uniform2i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform2i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2ui64NVNative(int location, ulong x, ulong y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, void>)funcTable[183])(location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, void>)funcTable[183])(location, x, y);
			#endif
		}

		public static void Uniform2ui64NV(int location, ulong x, ulong y)
		{
			Uniform2ui64NVNative(location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[184])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[184])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2ui64vNV(int location, int count, ulong* value)
		{
			Uniform2ui64vNVNative(location, count, value);
		}

		public static void Uniform2ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform2ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3i64NVNative(int location, long x, long y, long z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, long, long, void>)funcTable[185])(location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, long, long, long, void>)funcTable[185])(location, x, y, z);
			#endif
		}

		public static void Uniform3i64NV(int location, long x, long y, long z)
		{
			Uniform3i64NVNative(location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[186])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[186])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3i64vNV(int location, int count, long* value)
		{
			Uniform3i64vNVNative(location, count, value);
		}

		public static void Uniform3i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform3i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3ui64NVNative(int location, ulong x, ulong y, ulong z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, void>)funcTable[187])(location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, void>)funcTable[187])(location, x, y, z);
			#endif
		}

		public static void Uniform3ui64NV(int location, ulong x, ulong y, ulong z)
		{
			Uniform3ui64NVNative(location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[188])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[188])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3ui64vNV(int location, int count, ulong* value)
		{
			Uniform3ui64vNVNative(location, count, value);
		}

		public static void Uniform3ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform3ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4i64NVNative(int location, long x, long y, long z, long w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, long, long, long, long, void>)funcTable[189])(location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, long, long, long, long, void>)funcTable[189])(location, x, y, z, w);
			#endif
		}

		public static void Uniform4i64NV(int location, long x, long y, long z, long w)
		{
			Uniform4i64NVNative(location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4i64vNVNative(int location, int count, long* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, long*, void>)funcTable[190])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[190])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4i64vNV(int location, int count, long* value)
		{
			Uniform4i64vNVNative(location, count, value);
		}

		public static void Uniform4i64vNV(int location, int count, ref long value)
		{
			fixed (long* pvalue0 = &value)
			{
				Uniform4i64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4ui64NVNative(int location, ulong x, ulong y, ulong z, ulong w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, ulong, void>)funcTable[191])(location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, ulong, ulong, ulong, void>)funcTable[191])(location, x, y, z, w);
			#endif
		}

		public static void Uniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w)
		{
			Uniform4ui64NVNative(location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4ui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[192])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[192])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4ui64vNV(int location, int count, ulong* value)
		{
			Uniform4ui64vNVNative(location, count, value);
		}

		public static void Uniform4ui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				Uniform4ui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformHandleui64NVNative(int location, ulong value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[193])(location, value);
			#else
			((delegate* unmanaged[Cdecl]<int, ulong, void>)funcTable[193])(location, value);
			#endif
		}

		public static void UniformHandleui64NV(int location, ulong value)
		{
			UniformHandleui64NVNative(location, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformHandleui64vNVNative(int location, int count, ulong* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, ulong*, void>)funcTable[194])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[194])(location, count, (nint)value);
			#endif
		}

		public static void UniformHandleui64vNV(int location, int count, ulong* value)
		{
			UniformHandleui64vNVNative(location, count, value);
		}

		public static void UniformHandleui64vNV(int location, int count, ref ulong value)
		{
			fixed (ulong* pvalue0 = &value)
			{
				UniformHandleui64vNVNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x3fvNVNative(int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[195])(location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[195])(location, count, transpose, (nint)value);
			#endif
		}

		public static void UniformMatrix2x3fvNV(int location, int count, byte transpose, float* value)
		{
			UniformMatrix2x3fvNVNative(location, count, transpose, value);
		}

		public static void UniformMatrix2x3fvNV(int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x3fvNVNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix2x4fvNVNative(int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[196])(location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[196])(location, count, transpose, (nint)value);
			#endif
		}

		public static void UniformMatrix2x4fvNV(int location, int count, byte transpose, float* value)
		{
			UniformMatrix2x4fvNVNative(location, count, transpose, value);
		}

		public static void UniformMatrix2x4fvNV(int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix2x4fvNVNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x2fvNVNative(int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[197])(location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[197])(location, count, transpose, (nint)value);
			#endif
		}

		public static void UniformMatrix3x2fvNV(int location, int count, byte transpose, float* value)
		{
			UniformMatrix3x2fvNVNative(location, count, transpose, value);
		}

		public static void UniformMatrix3x2fvNV(int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x2fvNVNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix3x4fvNVNative(int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[198])(location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[198])(location, count, transpose, (nint)value);
			#endif
		}

		public static void UniformMatrix3x4fvNV(int location, int count, byte transpose, float* value)
		{
			UniformMatrix3x4fvNVNative(location, count, transpose, value);
		}

		public static void UniformMatrix3x4fvNV(int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix3x4fvNVNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x2fvNVNative(int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[199])(location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[199])(location, count, transpose, (nint)value);
			#endif
		}

		public static void UniformMatrix4x2fvNV(int location, int count, byte transpose, float* value)
		{
			UniformMatrix4x2fvNVNative(location, count, transpose, value);
		}

		public static void UniformMatrix4x2fvNV(int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x2fvNVNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformMatrix4x3fvNVNative(int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte, float*, void>)funcTable[200])(location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, byte, nint, void>)funcTable[200])(location, count, transpose, (nint)value);
			#endif
		}

		public static void UniformMatrix4x3fvNV(int location, int count, byte transpose, float* value)
		{
			UniformMatrix4x3fvNVNative(location, count, transpose, value);
		}

		public static void UniformMatrix4x3fvNV(int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				UniformMatrix4x3fvNVNative(location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribDivisorNVNative(uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[201])(index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[201])(index, divisor);
			#endif
		}

		public static void VertexAttribDivisorNV(uint index, uint divisor)
		{
			VertexAttribDivisorNVNative(index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportArrayvNVNative(uint first, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[202])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[202])(first, count, (nint)v);
			#endif
		}

		public static void ViewportArrayvNV(uint first, int count, float* v)
		{
			ViewportArrayvNVNative(first, count, v);
		}

		public static void ViewportArrayvNV(uint first, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ViewportArrayvNVNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportIndexedfNVNative(uint index, float x, float y, float w, float h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[203])(index, x, y, w, h);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[203])(index, x, y, w, h);
			#endif
		}

		public static void ViewportIndexedfNV(uint index, float x, float y, float w, float h)
		{
			ViewportIndexedfNVNative(index, x, y, w, h);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportIndexedfvNVNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[204])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[204])(index, (nint)v);
			#endif
		}

		public static void ViewportIndexedfvNV(uint index, float* v)
		{
			ViewportIndexedfvNVNative(index, v);
		}

		public static void ViewportIndexedfvNV(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ViewportIndexedfvNVNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportPositionWScaleNVNative(uint index, float xcoeff, float ycoeff)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[205])(index, xcoeff, ycoeff);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, void>)funcTable[205])(index, xcoeff, ycoeff);
			#endif
		}

		public static void ViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff)
		{
			ViewportPositionWScaleNVNative(index, xcoeff, ycoeff);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ViewportSwizzleNVNative(uint index, GLEnum swizzlex, GLEnum swizzley, GLEnum swizzlez, GLEnum swizzlew)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, GLEnum, GLEnum, GLEnum, void>)funcTable[206])(index, swizzlex, swizzley, swizzlez, swizzlew);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, GLEnum, GLEnum, GLEnum, void>)funcTable[206])(index, swizzlex, swizzley, swizzlez, swizzlew);
			#endif
		}

		public static void ViewportSwizzleNV(uint index, GLEnum swizzlex, GLEnum swizzley, GLEnum swizzlez, GLEnum swizzlew)
		{
			ViewportSwizzleNVNative(index, swizzlex, swizzley, swizzlez, swizzlew);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WeightPathsNVNative(uint resultPath, int numPaths, uint* paths, float* weights)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, float*, void>)funcTable[207])(resultPath, numPaths, paths, weights);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[207])(resultPath, numPaths, (nint)paths, (nint)weights);
			#endif
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights)
		{
			WeightPathsNVNative(resultPath, numPaths, paths, weights);
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, ref uint paths, float* weights)
		{
			fixed (uint* ppaths0 = &paths)
			{
				WeightPathsNVNative(resultPath, numPaths, ppaths0, weights);
			}
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, uint* paths, ref float weights)
		{
			fixed (float* pweights0 = &weights)
			{
				WeightPathsNVNative(resultPath, numPaths, paths, pweights0);
			}
		}

		public static void WeightPathsNV(uint resultPath, int numPaths, ref uint paths, ref float weights)
		{
			fixed (uint* ppaths0 = &paths)
			{
				fixed (float* pweights1 = &weights)
				{
					WeightPathsNVNative(resultPath, numPaths, ppaths0, pweights1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawVkImageNVNative(ulong vkImage, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, uint, float, float, float, float, float, float, float, float, float, void>)funcTable[208])(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
			#else
			((delegate* unmanaged[Cdecl]<ulong, uint, float, float, float, float, float, float, float, float, float, void>)funcTable[208])(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
			#endif
		}

		public static void DrawVkImageNV(ulong vkImage, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1)
		{
			DrawVkImageNVNative(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLVulkanProcNV GetVkProcAddrNVNative(byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<byte*, GLVulkanProcNV>)funcTable[209])(name);
			#else
			return (GLVulkanProcNV)((delegate* unmanaged[Cdecl]<nint, GLVulkanProcNV>)funcTable[209])((nint)name);
			#endif
		}

		public static GLVulkanProcNV GetVkProcAddrNV(byte* name)
		{
			GLVulkanProcNV ret = GetVkProcAddrNVNative(name);
			return ret;
		}

		public static GLVulkanProcNV GetVkProcAddrNV(string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GLVulkanProcNV ret = GetVkProcAddrNVNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static GLVulkanProcNV GetVkProcAddrNV(ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GLVulkanProcNV ret = GetVkProcAddrNVNative(pname0);
				return ret;
			}
		}

		public static GLVulkanProcNV GetVkProcAddrNV(ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GLVulkanProcNV ret = GetVkProcAddrNVNative(pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitVkSemaphoreNVNative(ulong vkSemaphore)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[210])(vkSemaphore);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[210])(vkSemaphore);
			#endif
		}

		public static void WaitVkSemaphoreNV(ulong vkSemaphore)
		{
			WaitVkSemaphoreNVNative(vkSemaphore);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalVkSemaphoreNVNative(ulong vkSemaphore)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[211])(vkSemaphore);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[211])(vkSemaphore);
			#endif
		}

		public static void SignalVkSemaphoreNV(ulong vkSemaphore)
		{
			SignalVkSemaphoreNVNative(vkSemaphore);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalVkFenceNVNative(ulong vkFence)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[212])(vkFence);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[212])(vkFence);
			#endif
		}

		public static void SignalVkFenceNV(ulong vkFence)
		{
			SignalVkFenceNVNative(vkFence);
		}

	}
}
