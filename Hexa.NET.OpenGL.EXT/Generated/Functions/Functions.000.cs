// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public static unsafe partial class GLExt
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveProgramEXTNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(program);
			#endif
		}

		public static void ActiveProgramEXT(uint program)
		{
			ActiveProgramEXTNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveShaderProgramEXTNative(uint pipeline, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1])(pipeline, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1])(pipeline, program);
			#endif
		}

		public static void ActiveShaderProgramEXT(uint pipeline, uint program)
		{
			ActiveShaderProgramEXTNative(pipeline, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveStencilFaceEXTNative(GLTriangleFace face)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[2])(face);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[2])(face);
			#endif
		}

		public static void ActiveStencilFaceEXT(GLTriangleFace face)
		{
			ActiveStencilFaceEXTNative(face);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ApplyTextureEXTNative(GLLightTextureModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightTextureModeEXT, void>)funcTable[3])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLLightTextureModeEXT, void>)funcTable[3])(mode);
			#endif
		}

		public static void ApplyTextureEXT(GLLightTextureModeEXT mode)
		{
			ApplyTextureEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AcquireKeyedMutexWin32EXTNative(uint memory, ulong key, uint timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ulong, uint, byte>)funcTable[4])(memory, key, timeout);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, ulong, uint, byte>)funcTable[4])(memory, key, timeout);
			#endif
		}

		public static bool AcquireKeyedMutexWin32EXT(uint memory, ulong key, uint timeout)
		{
			byte ret = AcquireKeyedMutexWin32EXTNative(memory, key, timeout);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AreTexturesResidentEXTNative(int n, uint* textures, byte* residences)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint*, byte*, byte>)funcTable[5])(n, textures, residences);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, nint, nint, byte>)funcTable[5])(n, (nint)textures, (nint)residences);
			#endif
		}

		public static bool AreTexturesResidentEXT(int n, uint* textures, byte* residences)
		{
			byte ret = AreTexturesResidentEXTNative(n, textures, residences);
			return ret != 0;
		}

		public static bool AreTexturesResidentEXT(int n, ref uint textures, byte* residences)
		{
			fixed (uint* ptextures0 = &textures)
			{
				byte ret = AreTexturesResidentEXTNative(n, ptextures0, residences);
				return ret != 0;
			}
		}

		public static bool AreTexturesResidentEXT(int n, uint* textures, string residences)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (residences != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(residences);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(residences, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = AreTexturesResidentEXTNative(n, textures, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool AreTexturesResidentEXT(int n, uint* textures, ReadOnlySpan<byte> residences)
		{
			fixed (byte* presidences0 = residences)
			{
				byte ret = AreTexturesResidentEXTNative(n, textures, presidences0);
				return ret != 0;
			}
		}

		public static bool AreTexturesResidentEXT(int n, uint* textures, ref byte residences)
		{
			fixed (byte* presidences0 = &residences)
			{
				byte ret = AreTexturesResidentEXTNative(n, textures, presidences0);
				return ret != 0;
			}
		}

		public static bool AreTexturesResidentEXT(int n, ref uint textures, ref byte residences)
		{
			fixed (uint* ptextures0 = &textures)
			{
				fixed (byte* presidences1 = &residences)
				{
					byte ret = AreTexturesResidentEXTNative(n, ptextures0, presidences1);
					return ret != 0;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ArrayElementEXTNative(int i)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[6])(i);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[6])(i);
			#endif
		}

		public static void ArrayElementEXT(int i)
		{
			ArrayElementEXTNative(i);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginTransformFeedbackEXTNative(GLPrimitiveType primitiveMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[7])(primitiveMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[7])(primitiveMode);
			#endif
		}

		public static void BeginTransformFeedbackEXT(GLPrimitiveType primitiveMode)
		{
			BeginTransformFeedbackEXTNative(primitiveMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginVertexShaderEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[8])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[8])();
			#endif
		}

		public static void BeginVertexShaderEXT()
		{
			BeginVertexShaderEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferBaseEXTNative(GLBufferTargetARB target, uint index, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[9])(target, index, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[9])(target, index, buffer);
			#endif
		}

		public static void BindBufferBaseEXT(GLBufferTargetARB target, uint index, uint buffer)
		{
			BindBufferBaseEXTNative(target, index, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferOffsetEXTNative(GLBufferTargetARB target, uint index, uint buffer, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, void>)funcTable[10])(target, index, buffer, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, void>)funcTable[10])(target, index, buffer, offset);
			#endif
		}

		public static void BindBufferOffsetEXT(GLBufferTargetARB target, uint index, uint buffer, nint offset)
		{
			BindBufferOffsetEXTNative(target, index, buffer, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferRangeEXTNative(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[11])(target, index, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[11])(target, index, buffer, offset, size);
			#endif
		}

		public static void BindBufferRangeEXT(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			BindBufferRangeEXTNative(target, index, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationEXTNative(uint program, uint color, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[12])(program, color, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[12])(program, color, (nint)name);
			#endif
		}

		public static void BindFragDataLocationEXT(uint program, uint color, byte* name)
		{
			BindFragDataLocationEXTNative(program, color, name);
		}

		public static void BindFragDataLocationEXT(uint program, uint color, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationEXTNative(program, color, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindFragDataLocationEXT(uint program, uint color, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationEXTNative(program, color, pname0);
			}
		}

		public static void BindFragDataLocationEXT(uint program, uint color, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationEXTNative(program, color, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFramebufferEXTNative(GLFramebufferTarget target, uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[13])(target, framebuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[13])(target, framebuffer);
			#endif
		}

		public static void BindFramebufferEXT(GLFramebufferTarget target, uint framebuffer)
		{
			BindFramebufferEXTNative(target, framebuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindImageTextureEXTNative(uint index, uint texture, int level, byte layered, int layer, GLBufferAccessARB access, int format)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, int, void>)funcTable[14])(index, texture, level, layered, layer, access, format);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, int, void>)funcTable[14])(index, texture, level, layered, layer, access, format);
			#endif
		}

		public static void BindImageTextureEXT(uint index, uint texture, int level, byte layered, int layer, GLBufferAccessARB access, int format)
		{
			BindImageTextureEXTNative(index, texture, level, layered, layer, access, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindLightParameterEXTNative(GLLightName light, GLLightParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, uint>)funcTable[15])(light, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, uint>)funcTable[15])(light, value);
			#endif
		}

		public static uint BindLightParameterEXT(GLLightName light, GLLightParameter value)
		{
			uint ret = BindLightParameterEXTNative(light, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindMaterialParameterEXTNative(GLTriangleFace face, GLMaterialParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, uint>)funcTable[16])(face, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, uint>)funcTable[16])(face, value);
			#endif
		}

		public static uint BindMaterialParameterEXT(GLTriangleFace face, GLMaterialParameter value)
		{
			uint ret = BindMaterialParameterEXTNative(face, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindMultiTextureEXTNative(GLTextureUnit texunit, GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[17])(texunit, target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[17])(texunit, target, texture);
			#endif
		}

		public static void BindMultiTextureEXT(GLTextureUnit texunit, GLTextureTarget target, uint texture)
		{
			BindMultiTextureEXTNative(texunit, target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindParameterEXTNative(GLVertexShaderParameterEXT value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLVertexShaderParameterEXT, uint>)funcTable[18])(value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLVertexShaderParameterEXT, uint>)funcTable[18])(value);
			#endif
		}

		public static uint BindParameterEXT(GLVertexShaderParameterEXT value)
		{
			uint ret = BindParameterEXTNative(value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindProgramPipelineEXTNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[19])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[19])(pipeline);
			#endif
		}

		public static void BindProgramPipelineEXT(uint pipeline)
		{
			BindProgramPipelineEXTNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindRenderbufferEXTNative(GLRenderbufferTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[20])(target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[20])(target, renderbuffer);
			#endif
		}

		public static void BindRenderbufferEXT(GLRenderbufferTarget target, uint renderbuffer)
		{
			BindRenderbufferEXTNative(target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindTexGenParameterEXTNative(GLTextureUnit unit, GLTextureCoordName coord, GLTextureGenParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, uint>)funcTable[21])(unit, coord, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, uint>)funcTable[21])(unit, coord, value);
			#endif
		}

		public static uint BindTexGenParameterEXT(GLTextureUnit unit, GLTextureCoordName coord, GLTextureGenParameter value)
		{
			uint ret = BindTexGenParameterEXTNative(unit, coord, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTextureEXTNative(GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[22])(target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[22])(target, texture);
			#endif
		}

		public static void BindTextureEXT(GLTextureTarget target, uint texture)
		{
			BindTextureEXTNative(target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindTextureUnitParameterEXTNative(GLTextureUnit unit, GLVertexShaderTextureUnitParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLTextureUnit, GLVertexShaderTextureUnitParameter, uint>)funcTable[23])(unit, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLTextureUnit, GLVertexShaderTextureUnitParameter, uint>)funcTable[23])(unit, value);
			#endif
		}

		public static uint BindTextureUnitParameterEXT(GLTextureUnit unit, GLVertexShaderTextureUnitParameter value)
		{
			uint ret = BindTextureUnitParameterEXTNative(unit, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexShaderEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[24])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[24])(id);
			#endif
		}

		public static void BindVertexShaderEXT(uint id)
		{
			BindVertexShaderEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3bEXTNative(sbyte bx, sbyte by, sbyte bz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[25])(bx, by, bz);
			#else
			((delegate* unmanaged[Cdecl]<sbyte, sbyte, sbyte, void>)funcTable[25])(bx, by, bz);
			#endif
		}

		public static void Binormal3bEXT(sbyte bx, sbyte by, sbyte bz)
		{
			Binormal3bEXTNative(bx, by, bz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3bvEXTNative(sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<sbyte*, void>)funcTable[26])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[26])((nint)v);
			#endif
		}

		public static void Binormal3bvEXT(sbyte* v)
		{
			Binormal3bvEXTNative(v);
		}

		public static void Binormal3bvEXT(ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				Binormal3bvEXTNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3dEXTNative(double bx, double by, double bz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[27])(bx, by, bz);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[27])(bx, by, bz);
			#endif
		}

		public static void Binormal3dEXT(double bx, double by, double bz)
		{
			Binormal3dEXTNative(bx, by, bz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3dvEXTNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[28])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[28])((nint)v);
			#endif
		}

		public static void Binormal3dvEXT(double* v)
		{
			Binormal3dvEXTNative(v);
		}

		public static void Binormal3dvEXT(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				Binormal3dvEXTNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3fEXTNative(float bx, float by, float bz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[29])(bx, by, bz);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[29])(bx, by, bz);
			#endif
		}

		public static void Binormal3fEXT(float bx, float by, float bz)
		{
			Binormal3fEXTNative(bx, by, bz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3fvEXTNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[30])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[30])((nint)v);
			#endif
		}

		public static void Binormal3fvEXT(float* v)
		{
			Binormal3fvEXTNative(v);
		}

		public static void Binormal3fvEXT(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				Binormal3fvEXTNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3iEXTNative(int bx, int by, int bz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[31])(bx, by, bz);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[31])(bx, by, bz);
			#endif
		}

		public static void Binormal3iEXT(int bx, int by, int bz)
		{
			Binormal3iEXTNative(bx, by, bz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3ivEXTNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[32])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[32])((nint)v);
			#endif
		}

		public static void Binormal3ivEXT(int* v)
		{
			Binormal3ivEXTNative(v);
		}

		public static void Binormal3ivEXT(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				Binormal3ivEXTNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3sEXTNative(short bx, short by, short bz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[33])(bx, by, bz);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[33])(bx, by, bz);
			#endif
		}

		public static void Binormal3sEXT(short bx, short by, short bz)
		{
			Binormal3sEXTNative(bx, by, bz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Binormal3svEXTNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[34])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[34])((nint)v);
			#endif
		}

		public static void Binormal3svEXT(short* v)
		{
			Binormal3svEXTNative(v);
		}

		public static void Binormal3svEXT(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				Binormal3svEXTNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BinormalPointerEXTNative(GLBinormalPointerTypeEXT type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBinormalPointerTypeEXT, int, void*, void>)funcTable[35])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLBinormalPointerTypeEXT, int, nint, void>)funcTable[35])(type, stride, (nint)pointer);
			#endif
		}

		public static void BinormalPointerEXT(GLBinormalPointerTypeEXT type, int stride, void* pointer)
		{
			BinormalPointerEXTNative(type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorEXTNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[36])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[36])(red, green, blue, alpha);
			#endif
		}

		public static void BlendColorEXT(float red, float green, float blue, float alpha)
		{
			BlendColorEXTNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationEXTNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[37])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[37])(mode);
			#endif
		}

		public static void BlendEquationEXT(GLBlendEquationModeEXT mode)
		{
			BlendEquationEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateEXTNative(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[38])(modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[38])(modeRGB, modeAlpha);
			#endif
		}

		public static void BlendEquationSeparateEXT(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateEXTNative(modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateEXTNative(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#endif
		}

		public static void BlendFuncSeparateEXT(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			BlendFuncSeparateEXTNative(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferEXTNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[40])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[40])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferEXTNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferLayerEXTNative(int srcX0, int srcY0, int srcX1, int srcY1, int srcLayer, int dstX0, int dstY0, int dstX1, int dstY1, int dstLayer, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
			#endif
		}

		public static void BlitFramebufferLayerEXT(int srcX0, int srcY0, int srcX1, int srcY1, int srcLayer, int dstX0, int dstY0, int dstX1, int dstY1, int dstLayer, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferLayerEXTNative(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferLayersEXTNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[42])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[42])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitFramebufferLayersEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferLayersEXTNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageExternalEXTNative(GLEnum target, nint offset, nint size, GLeglClientBufferEXT clientBuffer, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, GLeglClientBufferEXT, GLBufferStorageMask, void>)funcTable[43])(target, offset, size, clientBuffer, flags);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, GLeglClientBufferEXT, GLBufferStorageMask, void>)funcTable[43])(target, offset, size, clientBuffer, flags);
			#endif
		}

		public static void BufferStorageExternalEXT(GLEnum target, nint offset, nint size, GLeglClientBufferEXT clientBuffer, GLBufferStorageMask flags)
		{
			BufferStorageExternalEXTNative(target, offset, size, clientBuffer, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageMemEXTNative(GLBufferTargetARB target, nint size, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, uint, ulong, void>)funcTable[44])(target, size, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, uint, ulong, void>)funcTable[44])(target, size, memory, offset);
			#endif
		}

		public static void BufferStorageMemEXT(GLBufferTargetARB target, nint size, uint memory, ulong offset)
		{
			BufferStorageMemEXTNative(target, size, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckFramebufferStatusEXTNative(GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[45])(target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[45])(target);
			#endif
		}

		public static GLEnum CheckFramebufferStatusEXT(GLFramebufferTarget target)
		{
			GLEnum ret = CheckFramebufferStatusEXTNative(target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckNamedFramebufferStatusEXTNative(uint framebuffer, GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[46])(framebuffer, target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[46])(framebuffer, target);
			#endif
		}

		public static GLEnum CheckNamedFramebufferStatusEXT(uint framebuffer, GLFramebufferTarget target)
		{
			GLEnum ret = CheckNamedFramebufferStatusEXTNative(framebuffer, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorIiEXTNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[47])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[47])(red, green, blue, alpha);
			#endif
		}

		public static void ClearColorIiEXT(int red, int green, int blue, int alpha)
		{
			ClearColorIiEXTNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearColorIuiEXTNative(uint red, uint green, uint blue, uint alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[48])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[48])(red, green, blue, alpha);
			#endif
		}

		public static void ClearColorIuiEXT(uint red, uint green, uint blue, uint alpha)
		{
			ClearColorIuiEXTNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferDataEXTNative(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[49])(buffer, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[49])(buffer, internalformat, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferDataEXT(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferDataEXTNative(buffer, internalformat, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferSubDataEXTNative(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[50])(buffer, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[50])(buffer, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferSubDataEXT(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferSubDataEXTNative(buffer, internalformat, offset, size, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientAttribDefaultEXTNative(GLClientAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[51])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[51])(mask);
			#endif
		}

		public static void ClientAttribDefaultEXT(GLClientAttribMask mask)
		{
			ClientAttribDefaultEXTNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaskIndexedEXTNative(uint index, byte r, byte g, byte b, byte a)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[52])(index, r, g, b, a);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[52])(index, r, g, b, a);
			#endif
		}

		public static void ColorMaskIndexedEXT(uint index, byte r, byte g, byte b, byte a)
		{
			ColorMaskIndexedEXTNative(index, r, g, b, a);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorPointerEXTNative(int size, GLColorPointerType type, int stride, int count, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, int, void*, void>)funcTable[53])(size, type, stride, count, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, int, nint, void>)funcTable[53])(size, type, stride, count, (nint)pointer);
			#endif
		}

		public static void ColorPointerEXT(int size, GLColorPointerType type, int stride, int count, void* pointer)
		{
			ColorPointerEXTNative(size, type, stride, count, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorSubTableEXTNative(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[54])(target, start, count, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[54])(target, start, count, format, type, (nint)data);
			#endif
		}

		public static void ColorSubTableEXT(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			ColorSubTableEXTNative(target, start, count, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableEXTNative(GLColorTableTarget target, GLInternalFormat internalFormat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[55])(target, internalFormat, width, format, type, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[55])(target, internalFormat, width, format, type, (nint)table);
			#endif
		}

		public static void ColorTableEXT(GLColorTableTarget target, GLInternalFormat internalFormat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			ColorTableEXTNative(target, internalFormat, width, format, type, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[56])(texunit, target, level, internalformat, width, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[56])(texunit, target, level, internalformat, width, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[57])(texunit, target, level, internalformat, width, height, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[57])(texunit, target, level, internalformat, width, height, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[58])(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[58])(texunit, target, level, internalformat, width, height, depth, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[59])(texunit, target, level, xoffset, width, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[59])(texunit, target, level, xoffset, width, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[60])(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[60])(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[61])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[61])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[62])(texture, target, level, internalformat, width, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[62])(texture, target, level, internalformat, width, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			CompressedTextureImage1DEXTNative(texture, target, level, internalformat, width, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[63])(texture, target, level, internalformat, width, height, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[63])(texture, target, level, internalformat, width, height, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			CompressedTextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage3DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[64])(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[64])(texture, target, level, internalformat, width, height, depth, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			CompressedTextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[65])(texture, target, level, xoffset, width, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[65])(texture, target, level, xoffset, width, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[66])(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[66])(texture, target, level, xoffset, yoffset, width, height, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[67])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[67])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter1DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[68])(target, internalformat, width, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[68])(target, internalformat, width, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter1DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter1DEXTNative(target, internalformat, width, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter2DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[69])(target, internalformat, width, height, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[69])(target, internalformat, width, height, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter2DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter2DEXTNative(target, internalformat, width, height, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float, void>)funcTable[70])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float, void>)funcTable[70])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameterfEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float @params)
		{
			ConvolutionParameterfEXTNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfvEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float*, void>)funcTable[71])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[71])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			ConvolutionParameterfvEXTNative(target, pname, @params);
		}

		public static void ConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ConvolutionParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameteriEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int, void>)funcTable[72])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int, void>)funcTable[72])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameteriEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int @params)
		{
			ConvolutionParameteriEXTNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterivEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int*, void>)funcTable[73])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[73])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			ConvolutionParameterivEXTNative(target, pname, @params);
		}

		public static void ConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ConvolutionParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyColorSubTableEXTNative(GLColorTableTarget target, int start, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[74])(target, start, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[74])(target, start, x, y, width);
			#endif
		}

		public static void CopyColorSubTableEXT(GLColorTableTarget target, int start, int x, int y, int width)
		{
			CopyColorSubTableEXTNative(target, start, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter1DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, void>)funcTable[75])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, void>)funcTable[75])(target, internalformat, x, y, width);
			#endif
		}

		public static void CopyConvolutionFilter1DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyConvolutionFilter1DEXTNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter2DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, int, void>)funcTable[76])(target, internalformat, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, int, void>)funcTable[76])(target, internalformat, x, y, width, height);
			#endif
		}

		public static void CopyConvolutionFilter2DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			CopyConvolutionFilter2DEXTNative(target, internalformat, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[77])(texunit, target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[77])(texunit, target, level, internalformat, x, y, width, border);
			#endif
		}

		public static void CopyMultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyMultiTexImage1DEXTNative(texunit, target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[78])(texunit, target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[78])(texunit, target, level, internalformat, x, y, width, height, border);
			#endif
		}

		public static void CopyMultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyMultiTexImage2DEXTNative(texunit, target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, void>)funcTable[79])(texunit, target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, void>)funcTable[79])(texunit, target, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyMultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[80])(texunit, target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[80])(texunit, target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyMultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[81])(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[81])(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyMultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage1DEXTNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[82])(target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[82])(target, level, internalformat, x, y, width, border);
			#endif
		}

		public static void CopyTexImage1DEXT(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTexImage1DEXTNative(target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexImage2DEXTNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[83])(target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[83])(target, level, internalformat, x, y, width, height, border);
			#endif
		}

		public static void CopyTexImage2DEXT(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTexImage2DEXTNative(target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage1DEXTNative(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[84])(target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[84])(target, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyTexSubImage1DEXT(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTexSubImage1DEXTNative(target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage2DEXTNative(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[85])(target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[85])(target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyTexSubImage2DEXT(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage2DEXTNative(target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTexSubImage3DEXTNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[86])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[86])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyTexSubImage3DEXT(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage3DEXTNative(target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[87])(texture, target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[87])(texture, target, level, internalformat, x, y, width, border);
			#endif
		}

		public static void CopyTextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTextureImage1DEXTNative(texture, target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[88])(texture, target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[88])(texture, target, level, internalformat, x, y, width, height, border);
			#endif
		}

		public static void CopyTextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTextureImage2DEXTNative(texture, target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, void>)funcTable[89])(texture, target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, void>)funcTable[89])(texture, target, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyTextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTextureSubImage1DEXTNative(texture, target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[90])(texture, target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[90])(texture, target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[91])(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[91])(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateMemoryObjectsEXTNative(int n, uint* memoryObjects)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[92])(n, memoryObjects);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[92])(n, (nint)memoryObjects);
			#endif
		}

		public static void CreateMemoryObjectsEXT(int n, uint* memoryObjects)
		{
			CreateMemoryObjectsEXTNative(n, memoryObjects);
		}

		public static void CreateMemoryObjectsEXT(int n, ref uint memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = &memoryObjects)
			{
				CreateMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderProgramEXTNative(GLShaderType type, byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, byte*, uint>)funcTable[93])(type, str);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, nint, uint>)funcTable[93])(type, (nint)str);
			#endif
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, byte* str)
		{
			uint ret = CreateShaderProgramEXTNative(type, str);
			return ret;
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = CreateShaderProgramEXTNative(type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr0 = str)
			{
				uint ret = CreateShaderProgramEXTNative(type, pstr0);
				return ret;
			}
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, ref byte str)
		{
			fixed (byte* pstr0 = &str)
			{
				uint ret = CreateShaderProgramEXTNative(type, pstr0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderProgramvEXTNative(GLShaderType type, int count, byte** strings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, int, byte**, uint>)funcTable[94])(type, count, strings);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, uint>)funcTable[94])(type, count, (nint)strings);
			#endif
		}

		public static uint CreateShaderProgramvEXT(GLShaderType type, int count, byte** strings)
		{
			uint ret = CreateShaderProgramvEXTNative(type, count, strings);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CullParameterdvEXTNative(GLCullParameterEXT pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCullParameterEXT, double*, void>)funcTable[95])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCullParameterEXT, nint, void>)funcTable[95])(pname, (nint)@params);
			#endif
		}

		public static void CullParameterdvEXT(GLCullParameterEXT pname, double* @params)
		{
			CullParameterdvEXTNative(pname, @params);
		}

		public static void CullParameterdvEXT(GLCullParameterEXT pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				CullParameterdvEXTNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CullParameterfvEXTNative(GLCullParameterEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCullParameterEXT, float*, void>)funcTable[96])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLCullParameterEXT, nint, void>)funcTable[96])(pname, (nint)@params);
			#endif
		}

		public static void CullParameterfvEXT(GLCullParameterEXT pname, float* @params)
		{
			CullParameterfvEXTNative(pname, @params);
		}

		public static void CullParameterfvEXT(GLCullParameterEXT pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				CullParameterfvEXTNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteFramebuffersEXTNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[97])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[97])(n, (nint)framebuffers);
			#endif
		}

		public static void DeleteFramebuffersEXT(int n, uint* framebuffers)
		{
			DeleteFramebuffersEXTNative(n, framebuffers);
		}

		public static void DeleteFramebuffersEXT(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				DeleteFramebuffersEXTNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteMemoryObjectsEXTNative(int n, uint* memoryObjects)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[98])(n, memoryObjects);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[98])(n, (nint)memoryObjects);
			#endif
		}

		public static void DeleteMemoryObjectsEXT(int n, uint* memoryObjects)
		{
			DeleteMemoryObjectsEXTNative(n, memoryObjects);
		}

		public static void DeleteMemoryObjectsEXT(int n, ref uint memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = &memoryObjects)
			{
				DeleteMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramPipelinesEXTNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[99])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[99])(n, (nint)pipelines);
			#endif
		}

		public static void DeleteProgramPipelinesEXT(int n, uint* pipelines)
		{
			DeleteProgramPipelinesEXTNative(n, pipelines);
		}

		public static void DeleteProgramPipelinesEXT(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				DeleteProgramPipelinesEXTNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteRenderbuffersEXTNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[100])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[100])(n, (nint)renderbuffers);
			#endif
		}

		public static void DeleteRenderbuffersEXT(int n, uint* renderbuffers)
		{
			DeleteRenderbuffersEXTNative(n, renderbuffers);
		}

		public static void DeleteRenderbuffersEXT(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				DeleteRenderbuffersEXTNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSemaphoresEXTNative(int n, uint* semaphores)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[101])(n, semaphores);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[101])(n, (nint)semaphores);
			#endif
		}

		public static void DeleteSemaphoresEXT(int n, uint* semaphores)
		{
			DeleteSemaphoresEXTNative(n, semaphores);
		}

		public static void DeleteSemaphoresEXT(int n, ref uint semaphores)
		{
			fixed (uint* psemaphores0 = &semaphores)
			{
				DeleteSemaphoresEXTNative(n, psemaphores0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTexturesEXTNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[102])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[102])(n, (nint)textures);
			#endif
		}

		public static void DeleteTexturesEXT(int n, uint* textures)
		{
			DeleteTexturesEXTNative(n, textures);
		}

		public static void DeleteTexturesEXT(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				DeleteTexturesEXTNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteVertexShaderEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[103])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[103])(id);
			#endif
		}

		public static void DeleteVertexShaderEXT(uint id)
		{
			DeleteVertexShaderEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthBoundsEXTNative(double zmin, double zmax)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[104])(zmin, zmax);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[104])(zmin, zmax);
			#endif
		}

		public static void DepthBoundsEXT(double zmin, double zmax)
		{
			DepthBoundsEXTNative(zmin, zmax);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateIndexedEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[105])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[105])(array, index);
			#endif
		}

		public static void DisableClientStateIndexedEXT(GLEnableCap array, uint index)
		{
			DisableClientStateIndexedEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateiEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[106])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[106])(array, index);
			#endif
		}

		public static void DisableClientStateiEXT(GLEnableCap array, uint index)
		{
			DisableClientStateiEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[107])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[107])(target, index);
			#endif
		}

		public static void DisableIndexedEXT(GLEnableCap target, uint index)
		{
			DisableIndexedEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVariantClientStateEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[108])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[108])(id);
			#endif
		}

		public static void DisableVariantClientStateEXT(uint id)
		{
			DisableVariantClientStateEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayAttribEXTNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[109])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[109])(vaobj, index);
			#endif
		}

		public static void DisableVertexArrayAttribEXT(uint vaobj, uint index)
		{
			DisableVertexArrayAttribEXTNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayEXTNative(uint vaobj, GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[110])(vaobj, array);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[110])(vaobj, array);
			#endif
		}

		public static void DisableVertexArrayEXT(uint vaobj, GLEnableCap array)
		{
			DisableVertexArrayEXTNative(vaobj, array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysEXTNative(GLPrimitiveType mode, int first, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[111])(mode, first, count);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[111])(mode, first, count);
			#endif
		}

		public static void DrawArraysEXT(GLPrimitiveType mode, int first, int count)
		{
			DrawArraysEXTNative(mode, first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedEXTNative(GLPrimitiveType mode, int start, int count, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[112])(mode, start, count, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[112])(mode, start, count, primcount);
			#endif
		}

		public static void DrawArraysInstancedEXT(GLPrimitiveType mode, int start, int count, int primcount)
		{
			DrawArraysInstancedEXTNative(mode, start, count, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedEXTNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[113])(mode, count, type, indices, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[113])(mode, count, type, (nint)indices, primcount);
			#endif
		}

		public static void DrawElementsInstancedEXT(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			DrawElementsInstancedEXTNative(mode, count, type, indices, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsEXTNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, void>)funcTable[114])(mode, start, end, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, void>)funcTable[114])(mode, start, end, count, type, (nint)indices);
			#endif
		}

		public static void DrawRangeElementsEXT(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			DrawRangeElementsEXTNative(mode, start, end, count, type, indices);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EGLImageTargetTexStorageEXTNative(GLEnum target, GLeglImageOES image, int* attribList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, GLeglImageOES, int*, void>)funcTable[115])(target, image, attribList);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, GLeglImageOES, nint, void>)funcTable[115])(target, image, (nint)attribList);
			#endif
		}

		public static void EGLImageTargetTexStorageEXT(GLEnum target, GLeglImageOES image, int* attribList)
		{
			EGLImageTargetTexStorageEXTNative(target, image, attribList);
		}

		public static void EGLImageTargetTexStorageEXT(GLEnum target, GLeglImageOES image, ref int attribList)
		{
			fixed (int* pattribList0 = &attribList)
			{
				EGLImageTargetTexStorageEXTNative(target, image, pattribList0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EGLImageTargetTextureStorageEXTNative(uint texture, GLeglImageOES image, int* attribList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLeglImageOES, int*, void>)funcTable[116])(texture, image, attribList);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLeglImageOES, nint, void>)funcTable[116])(texture, image, (nint)attribList);
			#endif
		}

		public static void EGLImageTargetTextureStorageEXT(uint texture, GLeglImageOES image, int* attribList)
		{
			EGLImageTargetTextureStorageEXTNative(texture, image, attribList);
		}

		public static void EGLImageTargetTextureStorageEXT(uint texture, GLeglImageOES image, ref int attribList)
		{
			fixed (int* pattribList0 = &attribList)
			{
				EGLImageTargetTextureStorageEXTNative(texture, image, pattribList0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagPointerEXTNative(int stride, int count, byte* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, byte*, void>)funcTable[117])(stride, count, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[117])(stride, count, (nint)pointer);
			#endif
		}

		public static void EdgeFlagPointerEXT(int stride, int count, byte* pointer)
		{
			EdgeFlagPointerEXTNative(stride, count, pointer);
		}

		public static void EdgeFlagPointerEXT(int stride, int count, string pointer)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pointer != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pointer);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pointer, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			EdgeFlagPointerEXTNative(stride, count, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void EdgeFlagPointerEXT(int stride, int count, ReadOnlySpan<byte> pointer)
		{
			fixed (byte* ppointer0 = pointer)
			{
				EdgeFlagPointerEXTNative(stride, count, ppointer0);
			}
		}

		public static void EdgeFlagPointerEXT(int stride, int count, ref byte pointer)
		{
			fixed (byte* ppointer0 = &pointer)
			{
				EdgeFlagPointerEXTNative(stride, count, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateIndexedEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[118])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[118])(array, index);
			#endif
		}

		public static void EnableClientStateIndexedEXT(GLEnableCap array, uint index)
		{
			EnableClientStateIndexedEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateiEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[119])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[119])(array, index);
			#endif
		}

		public static void EnableClientStateiEXT(GLEnableCap array, uint index)
		{
			EnableClientStateiEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[120])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[120])(target, index);
			#endif
		}

		public static void EnableIndexedEXT(GLEnableCap target, uint index)
		{
			EnableIndexedEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVariantClientStateEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[121])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[121])(id);
			#endif
		}

		public static void EnableVariantClientStateEXT(uint id)
		{
			EnableVariantClientStateEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayAttribEXTNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[122])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[122])(vaobj, index);
			#endif
		}

		public static void EnableVertexArrayAttribEXT(uint vaobj, uint index)
		{
			EnableVertexArrayAttribEXTNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayEXTNative(uint vaobj, GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[123])(vaobj, array);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[123])(vaobj, array);
			#endif
		}

		public static void EnableVertexArrayEXT(uint vaobj, GLEnableCap array)
		{
			EnableVertexArrayEXTNative(vaobj, array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndTransformFeedbackEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[124])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[124])();
			#endif
		}

		public static void EndTransformFeedbackEXT()
		{
			EndTransformFeedbackEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndVertexShaderEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[125])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[125])();
			#endif
		}

		public static void EndVertexShaderEXT()
		{
			EndVertexShaderEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ExtractComponentEXTNative(uint res, uint src, uint num)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[126])(res, src, num);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[126])(res, src, num);
			#endif
		}

		public static void ExtractComponentEXT(uint res, uint src, uint num)
		{
			ExtractComponentEXTNative(res, src, num);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedNamedBufferRangeEXTNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[127])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[127])(buffer, offset, length);
			#endif
		}

		public static void FlushMappedNamedBufferRangeEXT(uint buffer, nint offset, nint length)
		{
			FlushMappedNamedBufferRangeEXTNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordPointerEXTNative(GLFogPointerTypeEXT type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogPointerTypeEXT, int, void*, void>)funcTable[128])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLFogPointerTypeEXT, int, nint, void>)funcTable[128])(type, stride, (nint)pointer);
			#endif
		}

		public static void FogCoordPointerEXT(GLFogPointerTypeEXT type, int stride, void* pointer)
		{
			FogCoordPointerEXTNative(type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoorddEXTNative(double coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[129])(coord);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[129])(coord);
			#endif
		}

		public static void FogCoorddEXT(double coord)
		{
			FogCoorddEXTNative(coord);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoorddvEXTNative(double* coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[130])(coord);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[130])((nint)coord);
			#endif
		}

		public static void FogCoorddvEXT(double* coord)
		{
			FogCoorddvEXTNative(coord);
		}

		public static void FogCoorddvEXT(ref double coord)
		{
			fixed (double* pcoord0 = &coord)
			{
				FogCoorddvEXTNative(pcoord0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordfEXTNative(float coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[131])(coord);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[131])(coord);
			#endif
		}

		public static void FogCoordfEXT(float coord)
		{
			FogCoordfEXTNative(coord);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordfvEXTNative(float* coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[132])(coord);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[132])((nint)coord);
			#endif
		}

		public static void FogCoordfvEXT(float* coord)
		{
			FogCoordfvEXTNative(coord);
		}

		public static void FogCoordfvEXT(ref float coord)
		{
			fixed (float* pcoord0 = &coord)
			{
				FogCoordfvEXTNative(pcoord0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferDrawBufferEXTNative(uint framebuffer, GLDrawBufferMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLDrawBufferMode, void>)funcTable[133])(framebuffer, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLDrawBufferMode, void>)funcTable[133])(framebuffer, mode);
			#endif
		}

		public static void FramebufferDrawBufferEXT(uint framebuffer, GLDrawBufferMode mode)
		{
			FramebufferDrawBufferEXTNative(framebuffer, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferDrawBuffersEXTNative(uint framebuffer, int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLDrawBufferMode, void>)funcTable[134])(framebuffer, n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLDrawBufferMode, void>)funcTable[134])(framebuffer, n, bufs);
			#endif
		}

		public static void FramebufferDrawBuffersEXT(uint framebuffer, int n, GLDrawBufferMode bufs)
		{
			FramebufferDrawBuffersEXTNative(framebuffer, n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferFetchBarrierEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[135])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[135])();
			#endif
		}

		public static void FramebufferFetchBarrierEXT()
		{
			FramebufferFetchBarrierEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferReadBufferEXTNative(uint framebuffer, GLReadBufferMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLReadBufferMode, void>)funcTable[136])(framebuffer, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLReadBufferMode, void>)funcTable[136])(framebuffer, mode);
			#endif
		}

		public static void FramebufferReadBufferEXT(uint framebuffer, GLReadBufferMode mode)
		{
			FramebufferReadBufferEXTNative(framebuffer, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferRenderbufferEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[137])(target, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[137])(target, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		public static void FramebufferRenderbufferEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			FramebufferRenderbufferEXTNative(target, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture1DEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[138])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[138])(target, attachment, textarget, texture, level);
			#endif
		}

		public static void FramebufferTexture1DEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture1DEXTNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture2DEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[139])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[139])(target, attachment, textarget, texture, level);
			#endif
		}

		public static void FramebufferTexture2DEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture2DEXTNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture3DEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[140])(target, attachment, textarget, texture, level, zoffset);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[140])(target, attachment, textarget, texture, level, zoffset);
			#endif
		}

		public static void FramebufferTexture3DEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			FramebufferTexture3DEXTNative(target, attachment, textarget, texture, level, zoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureLayerEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[141])(target, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[141])(target, attachment, texture, level, layer);
			#endif
		}

		public static void FramebufferTextureLayerEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			FramebufferTextureLayerEXTNative(target, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenFramebuffersEXTNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[142])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[142])(n, (nint)framebuffers);
			#endif
		}

		public static void GenFramebuffersEXT(int n, uint* framebuffers)
		{
			GenFramebuffersEXTNative(n, framebuffers);
		}

		public static void GenFramebuffersEXT(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				GenFramebuffersEXTNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramPipelinesEXTNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[143])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[143])(n, (nint)pipelines);
			#endif
		}

		public static void GenProgramPipelinesEXT(int n, uint* pipelines)
		{
			GenProgramPipelinesEXTNative(n, pipelines);
		}

		public static void GenProgramPipelinesEXT(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				GenProgramPipelinesEXTNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenRenderbuffersEXTNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[144])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[144])(n, (nint)renderbuffers);
			#endif
		}

		public static void GenRenderbuffersEXT(int n, uint* renderbuffers)
		{
			GenRenderbuffersEXTNative(n, renderbuffers);
		}

		public static void GenRenderbuffersEXT(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				GenRenderbuffersEXTNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenSemaphoresEXTNative(int n, uint* semaphores)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[145])(n, semaphores);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[145])(n, (nint)semaphores);
			#endif
		}

		public static void GenSemaphoresEXT(int n, uint* semaphores)
		{
			GenSemaphoresEXTNative(n, semaphores);
		}

		public static void GenSemaphoresEXT(int n, ref uint semaphores)
		{
			fixed (uint* psemaphores0 = &semaphores)
			{
				GenSemaphoresEXTNative(n, psemaphores0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenSymbolsEXTNative(GLDataTypeEXT datatype, GLVertexShaderStorageTypeEXT storagetype, GLParameterRangeEXT range, uint components)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLDataTypeEXT, GLVertexShaderStorageTypeEXT, GLParameterRangeEXT, uint, uint>)funcTable[146])(datatype, storagetype, range, components);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLDataTypeEXT, GLVertexShaderStorageTypeEXT, GLParameterRangeEXT, uint, uint>)funcTable[146])(datatype, storagetype, range, components);
			#endif
		}

		public static uint GenSymbolsEXT(GLDataTypeEXT datatype, GLVertexShaderStorageTypeEXT storagetype, GLParameterRangeEXT range, uint components)
		{
			uint ret = GenSymbolsEXTNative(datatype, storagetype, range, components);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTexturesEXTNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[147])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[147])(n, (nint)textures);
			#endif
		}

		public static void GenTexturesEXT(int n, uint* textures)
		{
			GenTexturesEXTNative(n, textures);
		}

		public static void GenTexturesEXT(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				GenTexturesEXTNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenVertexShadersEXTNative(uint range)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[148])(range);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[148])(range);
			#endif
		}

		public static uint GenVertexShadersEXT(uint range)
		{
			uint ret = GenVertexShadersEXTNative(range);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapEXTNative(GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[149])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[149])(target);
			#endif
		}

		public static void GenerateMipmapEXT(GLTextureTarget target)
		{
			GenerateMipmapEXTNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMultiTexMipmapEXTNative(GLTextureUnit texunit, GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, void>)funcTable[150])(texunit, target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, void>)funcTable[150])(texunit, target);
			#endif
		}

		public static void GenerateMultiTexMipmapEXT(GLTextureUnit texunit, GLTextureTarget target)
		{
			GenerateMultiTexMipmapEXTNative(texunit, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapEXTNative(uint texture, GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, void>)funcTable[151])(texture, target);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, void>)funcTable[151])(texture, target);
			#endif
		}

		public static void GenerateTextureMipmapEXT(uint texture, GLTextureTarget target)
		{
			GenerateTextureMipmapEXTNative(texture, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanIndexedvEXTNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[152])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[152])(target, index, (nint)data);
			#endif
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleanIndexedvEXTNative(target, index, data);
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanIndexedvEXTNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanIndexedvEXTNative(target, index, pdata0);
			}
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleanIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableEXTNative(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, void*, void>)funcTable[153])(target, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, nint, void>)funcTable[153])(target, format, type, (nint)data);
			#endif
		}

		public static void GetColorTableEXT(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* data)
		{
			GetColorTableEXTNative(target, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterfvEXTNative(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, float*, void>)funcTable[154])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[154])(target, pname, (nint)@params);
			#endif
		}

		public static void GetColorTableParameterfvEXT(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			GetColorTableParameterfvEXTNative(target, pname, @params);
		}

		public static void GetColorTableParameterfvEXT(GLColorTableTarget target, GLColorTableParameterPName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetColorTableParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterivEXTNative(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, int*, void>)funcTable[155])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[155])(target, pname, (nint)@params);
			#endif
		}

		public static void GetColorTableParameterivEXT(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			GetColorTableParameterivEXTNative(target, pname, @params);
		}

		public static void GetColorTableParameterivEXT(GLColorTableTarget target, GLColorTableParameterPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetColorTableParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedMultiTexImageEXTNative(GLTextureUnit texunit, GLTextureTarget target, int lod, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, void*, void>)funcTable[156])(texunit, target, lod, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, nint, void>)funcTable[156])(texunit, target, lod, (nint)img);
			#endif
		}

		public static void GetCompressedMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int lod, void* img)
		{
			GetCompressedMultiTexImageEXTNative(texunit, target, lod, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureImageEXTNative(uint texture, GLTextureTarget target, int lod, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, void*, void>)funcTable[157])(texture, target, lod, img);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, nint, void>)funcTable[157])(texture, target, lod, (nint)img);
			#endif
		}

		public static void GetCompressedTextureImageEXT(uint texture, GLTextureTarget target, int lod, void* img)
		{
			GetCompressedTextureImageEXTNative(texture, target, lod, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionFilterEXTNative(GLConvolutionTargetEXT target, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLPixelFormat, GLPixelType, void*, void>)funcTable[158])(target, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLPixelFormat, GLPixelType, nint, void>)funcTable[158])(target, format, type, (nint)image);
			#endif
		}

		public static void GetConvolutionFilterEXT(GLConvolutionTargetEXT target, GLPixelFormat format, GLPixelType type, void* image)
		{
			GetConvolutionFilterEXTNative(target, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterfvEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float*, void>)funcTable[159])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[159])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			GetConvolutionParameterfvEXTNative(target, pname, @params);
		}

		public static void GetConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetConvolutionParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterivEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int*, void>)funcTable[160])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[160])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			GetConvolutionParameterivEXTNative(target, pname, @params);
		}

		public static void GetConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetConvolutionParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoubleIndexedvEXTNative(GLGetPName target, uint index, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[161])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[161])(target, index, (nint)data);
			#endif
		}

		public static void GetDoubleIndexedvEXT(GLGetPName target, uint index, double* data)
		{
			GetDoubleIndexedvEXTNative(target, index, data);
		}

		public static void GetDoubleIndexedvEXT(GLGetPName target, uint index, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoubleIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublei_vEXTNative(GLGetPName pname, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[162])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[162])(pname, index, (nint)@params);
			#endif
		}

		public static void GetDoublei_vEXT(GLGetPName pname, uint index, double* @params)
		{
			GetDoublei_vEXTNative(pname, index, @params);
		}

		public static void GetDoublei_vEXT(GLGetPName pname, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetDoublei_vEXTNative(pname, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloatIndexedvEXTNative(GLGetPName target, uint index, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[163])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[163])(target, index, (nint)data);
			#endif
		}

		public static void GetFloatIndexedvEXT(GLGetPName target, uint index, float* data)
		{
			GetFloatIndexedvEXTNative(target, index, data);
		}

		public static void GetFloatIndexedvEXT(GLGetPName target, uint index, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloatIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloati_vEXTNative(GLGetPName pname, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[164])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[164])(pname, index, (nint)@params);
			#endif
		}

		public static void GetFloati_vEXT(GLGetPName pname, uint index, float* @params)
		{
			GetFloati_vEXTNative(pname, index, @params);
		}

		public static void GetFloati_vEXT(GLGetPName pname, uint index, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetFloati_vEXTNative(pname, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataLocationEXTNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[165])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[165])(program, (nint)name);
			#endif
		}

		public static int GetFragDataLocationEXT(uint program, byte* name)
		{
			int ret = GetFragDataLocationEXTNative(program, name);
			return ret;
		}

		public static int GetFragDataLocationEXT(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataLocationEXTNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetFragDataLocationEXT(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataLocationEXTNative(program, pname0);
				return ret;
			}
		}

		public static int GetFragDataLocationEXT(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataLocationEXTNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferAttachmentParameterivEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[166])(target, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[166])(target, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferAttachmentParameterivEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferAttachmentParameterivEXTNative(target, attachment, pname, @params);
		}

		public static void GetFramebufferAttachmentParameterivEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFramebufferAttachmentParameterivEXTNative(target, attachment, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferParameterivEXTNative(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[167])(framebuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[167])(framebuffer, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			GetFramebufferParameterivEXTNative(framebuffer, pname, @params);
		}

		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFramebufferParameterivEXTNative(framebuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramEXTNative(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[168])(target, reset, format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[168])(target, reset, format, type, (nint)values);
			#endif
		}

		public static void GetHistogramEXT(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetHistogramEXTNative(target, reset, format, type, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterfvEXTNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, float*, void>)funcTable[169])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[169])(target, pname, (nint)@params);
			#endif
		}

		public static void GetHistogramParameterfvEXT(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			GetHistogramParameterfvEXTNative(target, pname, @params);
		}

		public static void GetHistogramParameterfvEXT(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetHistogramParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterivEXTNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, int*, void>)funcTable[170])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[170])(target, pname, (nint)@params);
			#endif
		}

		public static void GetHistogramParameterivEXT(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			GetHistogramParameterivEXTNative(target, pname, @params);
		}

		public static void GetHistogramParameterivEXT(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetHistogramParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegerIndexedvEXTNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[171])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[171])(target, index, (nint)data);
			#endif
		}

		public static void GetIntegerIndexedvEXT(GLGetPName target, uint index, int* data)
		{
			GetIntegerIndexedvEXTNative(target, index, data);
		}

		public static void GetIntegerIndexedvEXT(GLGetPName target, uint index, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegerIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInvariantBooleanvEXTNative(uint id, GLGetVariantValueEXT value, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, byte*, void>)funcTable[172])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[172])(id, value, (nint)data);
			#endif
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, byte* data)
		{
			GetInvariantBooleanvEXTNative(id, value, data);
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetInvariantBooleanvEXTNative(id, value, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetInvariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetInvariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInvariantFloatvEXTNative(uint id, GLGetVariantValueEXT value, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, float*, void>)funcTable[173])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[173])(id, value, (nint)data);
			#endif
		}

		public static void GetInvariantFloatvEXT(uint id, GLGetVariantValueEXT value, float* data)
		{
			GetInvariantFloatvEXTNative(id, value, data);
		}

		public static void GetInvariantFloatvEXT(uint id, GLGetVariantValueEXT value, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetInvariantFloatvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInvariantIntegervEXTNative(uint id, GLGetVariantValueEXT value, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, int*, void>)funcTable[174])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[174])(id, value, (nint)data);
			#endif
		}

		public static void GetInvariantIntegervEXT(uint id, GLGetVariantValueEXT value, int* data)
		{
			GetInvariantIntegervEXTNative(id, value, data);
		}

		public static void GetInvariantIntegervEXT(uint id, GLGetVariantValueEXT value, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetInvariantIntegervEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLocalConstantBooleanvEXTNative(uint id, GLGetVariantValueEXT value, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, byte*, void>)funcTable[175])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[175])(id, value, (nint)data);
			#endif
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, byte* data)
		{
			GetLocalConstantBooleanvEXTNative(id, value, data);
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetLocalConstantBooleanvEXTNative(id, value, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetLocalConstantBooleanvEXTNative(id, value, pdata0);
			}
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetLocalConstantBooleanvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLocalConstantFloatvEXTNative(uint id, GLGetVariantValueEXT value, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, float*, void>)funcTable[176])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[176])(id, value, (nint)data);
			#endif
		}

		public static void GetLocalConstantFloatvEXT(uint id, GLGetVariantValueEXT value, float* data)
		{
			GetLocalConstantFloatvEXTNative(id, value, data);
		}

		public static void GetLocalConstantFloatvEXT(uint id, GLGetVariantValueEXT value, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetLocalConstantFloatvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLocalConstantIntegervEXTNative(uint id, GLGetVariantValueEXT value, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, int*, void>)funcTable[177])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[177])(id, value, (nint)data);
			#endif
		}

		public static void GetLocalConstantIntegervEXT(uint id, GLGetVariantValueEXT value, int* data)
		{
			GetLocalConstantIntegervEXTNative(id, value, data);
		}

		public static void GetLocalConstantIntegervEXT(uint id, GLGetVariantValueEXT value, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetLocalConstantIntegervEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMemoryObjectParameterivEXTNative(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, int*, void>)funcTable[178])(memoryObject, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, nint, void>)funcTable[178])(memoryObject, pname, (nint)@params);
			#endif
		}

		public static void GetMemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			GetMemoryObjectParameterivEXTNative(memoryObject, pname, @params);
		}

		public static void GetMemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMemoryObjectParameterivEXTNative(memoryObject, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxEXTNative(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[179])(target, reset, format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[179])(target, reset, format, type, (nint)values);
			#endif
		}

		public static void GetMinmaxEXT(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetMinmaxEXTNative(target, reset, format, type, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterfvEXTNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, float*, void>)funcTable[180])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[180])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMinmaxParameterfvEXT(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			GetMinmaxParameterfvEXTNative(target, pname, @params);
		}

		public static void GetMinmaxParameterfvEXT(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMinmaxParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterivEXTNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, int*, void>)funcTable[181])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[181])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMinmaxParameterivEXT(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			GetMinmaxParameterivEXTNative(target, pname, @params);
		}

		public static void GetMinmaxParameterivEXT(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMinmaxParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexEnvfvEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[182])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[182])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			GetMultiTexEnvfvEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexEnvfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexEnvivEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[183])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[183])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetMultiTexEnvivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexEnvivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGendvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[184])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[184])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			GetMultiTexGendvEXTNative(texunit, coord, pname, @params);
		}

		public static void GetMultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetMultiTexGendvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGenfvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[185])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[185])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			GetMultiTexGenfvEXTNative(texunit, coord, pname, @params);
		}

		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexGenfvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGenivEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[186])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[186])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			GetMultiTexGenivEXTNative(texunit, coord, pname, @params);
		}

		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexGenivEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexImageEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[187])(texunit, target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[187])(texunit, target, level, format, type, (nint)pixels);
			#endif
		}

		public static void GetMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetMultiTexImageEXTNative(texunit, target, level, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexLevelParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[188])(texunit, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[188])(texunit, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, @params);
		}

		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexLevelParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[189])(texunit, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[189])(texunit, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, @params);
		}

		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterIivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[190])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[190])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexParameterIivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexParameterIivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterIuivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[191])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[191])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetMultiTexParameterIuivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetMultiTexParameterIuivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[192])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[192])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetMultiTexParameterfvEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexParameterfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[193])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[193])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexParameterivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexParameterivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameterivEXTNative(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, int*, void>)funcTable[194])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[194])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			GetNamedBufferParameterivEXTNative(buffer, pname, @params);
		}

		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedBufferParameterivEXTNative(buffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferPointervEXTNative(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, void**, void>)funcTable[195])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, nint, void>)funcTable[195])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferPointervEXT(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			GetNamedBufferPointervEXTNative(buffer, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferSubDataEXTNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[196])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[196])(buffer, offset, size, (nint)data);
			#endif
		}

		public static void GetNamedBufferSubDataEXT(uint buffer, nint offset, nint size, void* data)
		{
			GetNamedBufferSubDataEXTNative(buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferAttachmentParameterivEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[197])(framebuffer, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[197])(framebuffer, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, @params);
		}

		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferParameterivEXTNative(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[198])(framebuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[198])(framebuffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			GetNamedFramebufferParameterivEXTNative(framebuffer, pname, @params);
		}

		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedFramebufferParameterivEXTNative(framebuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterIivEXTNative(uint program, GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int*, void>)funcTable[199])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[199])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, int* @params)
		{
			GetNamedProgramLocalParameterIivEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterIivEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterIuivEXTNative(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint*, void>)funcTable[200])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[200])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			GetNamedProgramLocalParameterIuivEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterIuivEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterdvEXTNative(uint program, GLProgramTarget target, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double*, void>)funcTable[201])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[201])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterdvEXT(uint program, GLProgramTarget target, uint index, double* @params)
		{
			GetNamedProgramLocalParameterdvEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterdvEXT(uint program, GLProgramTarget target, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterdvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterfvEXTNative(uint program, GLProgramTarget target, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float*, void>)funcTable[202])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[202])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, float* @params)
		{
			GetNamedProgramLocalParameterfvEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterfvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramStringEXTNative(uint program, GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramStringProperty, void*, void>)funcTable[203])(program, target, pname, str);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramStringProperty, nint, void>)funcTable[203])(program, target, pname, (nint)str);
			#endif
		}

		public static void GetNamedProgramStringEXT(uint program, GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			GetNamedProgramStringEXTNative(program, target, pname, str);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramivEXTNative(uint program, GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramPropertyARB, int*, void>)funcTable[204])(program, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramPropertyARB, nint, void>)funcTable[204])(program, target, pname, (nint)@params);
			#endif
		}

		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			GetNamedProgramivEXTNative(program, target, pname, @params);
		}

		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedProgramivEXTNative(program, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedRenderbufferParameterivEXTNative(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, int*, void>)funcTable[205])(renderbuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, nint, void>)funcTable[205])(renderbuffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, @params);
		}

		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectLabelEXTNative(GLEnum type, uint @object, int bufSize, int* length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int, int*, byte*, void>)funcTable[206])(type, @object, bufSize, length, label);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int, nint, nint, void>)funcTable[206])(type, @object, bufSize, (nint)length, (nint)label);
			#endif
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, byte* label)
		{
			GetObjectLabelEXTNative(type, @object, bufSize, length, label);
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, ref int length, byte* label)
		{
			fixed (int* plength0 = &length)
			{
				GetObjectLabelEXTNative(type, @object, bufSize, plength0, label);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetObjectLabelEXTNative(type, @object, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				GetObjectLabelEXTNative(type, @object, bufSize, length, plabel0);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				GetObjectLabelEXTNative(type, @object, bufSize, length, plabel0);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, ref int length, ref byte label)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* plabel1 = &label)
				{
					GetObjectLabelEXTNative(type, @object, bufSize, plength0, plabel1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelTransformParameterfvEXTNative(GLEnum target, GLEnum pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, float*, void>)funcTable[207])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, nint, void>)funcTable[207])(target, pname, (nint)@params);
			#endif
		}

		public static void GetPixelTransformParameterfvEXT(GLEnum target, GLEnum pname, float* @params)
		{
			GetPixelTransformParameterfvEXTNative(target, pname, @params);
		}

		public static void GetPixelTransformParameterfvEXT(GLEnum target, GLEnum pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetPixelTransformParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelTransformParameterivEXTNative(GLEnum target, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, int*, void>)funcTable[208])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, nint, void>)funcTable[208])(target, pname, (nint)@params);
			#endif
		}

		public static void GetPixelTransformParameterivEXT(GLEnum target, GLEnum pname, int* @params)
		{
			GetPixelTransformParameterivEXTNative(target, pname, @params);
		}

		public static void GetPixelTransformParameterivEXT(GLEnum target, GLEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetPixelTransformParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointerIndexedvEXTNative(GLEnum target, uint index, void** data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void**, void>)funcTable[209])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[209])(target, index, (nint)data);
			#endif
		}

		public static void GetPointerIndexedvEXT(GLEnum target, uint index, void** data)
		{
			GetPointerIndexedvEXTNative(target, index, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointeri_vEXTNative(GLEnum pname, uint index, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void**, void>)funcTable[210])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[210])(pname, index, (nint)@params);
			#endif
		}

		public static void GetPointeri_vEXT(GLEnum pname, uint index, void** @params)
		{
			GetPointeri_vEXTNative(pname, index, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointervEXTNative(GLGetPointervPName pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, void**, void>)funcTable[211])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, nint, void>)funcTable[211])(pname, (nint)@params);
			#endif
		}

		public static void GetPointervEXT(GLGetPointervPName pname, void** @params)
		{
			GetPointervEXTNative(pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineInfoLogEXTNative(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[212])(pipeline, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[212])(pipeline, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, infoLog);
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineivEXTNative(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, int*, void>)funcTable[213])(pipeline, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, nint, void>)funcTable[213])(pipeline, pname, (nint)@params);
			#endif
		}

		public static void GetProgramPipelineivEXT(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			GetProgramPipelineivEXTNative(pipeline, pname, @params);
		}

		public static void GetProgramPipelineivEXT(uint pipeline, GLPipelineParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramPipelineivEXTNative(pipeline, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjecti64vEXTNative(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, long*, void>)funcTable[214])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[214])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjecti64vEXT(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			GetQueryObjecti64vEXTNative(id, pname, @params);
		}

		public static void GetQueryObjecti64vEXT(uint id, GLQueryObjectParameterName pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetQueryObjecti64vEXTNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectui64vEXTNative(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, ulong*, void>)funcTable[215])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[215])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectui64vEXT(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			GetQueryObjectui64vEXTNative(id, pname, @params);
		}

		public static void GetQueryObjectui64vEXT(uint id, GLQueryObjectParameterName pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetQueryObjectui64vEXTNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRenderbufferParameterivEXTNative(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, int*, void>)funcTable[216])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, nint, void>)funcTable[216])(target, pname, (nint)@params);
			#endif
		}

		public static void GetRenderbufferParameterivEXT(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			GetRenderbufferParameterivEXTNative(target, pname, @params);
		}

		public static void GetRenderbufferParameterivEXT(GLRenderbufferTarget target, GLRenderbufferParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetRenderbufferParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSemaphoreParameterui64vEXTNative(uint semaphore, GLSemaphoreParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, ulong*, void>)funcTable[217])(semaphore, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, nint, void>)funcTable[217])(semaphore, pname, (nint)@params);
			#endif
		}

		public static void GetSemaphoreParameterui64vEXT(uint semaphore, GLSemaphoreParameterName pname, ulong* @params)
		{
			GetSemaphoreParameterui64vEXTNative(semaphore, pname, @params);
		}

		public static void GetSemaphoreParameterui64vEXT(uint semaphore, GLSemaphoreParameterName pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetSemaphoreParameterui64vEXTNative(semaphore, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSeparableFilterEXTNative(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, void*, void*, void*, void>)funcTable[218])(target, format, type, row, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, nint, nint, nint, void>)funcTable[218])(target, format, type, (nint)row, (nint)column, (nint)span);
			#endif
		}

		public static void GetSeparableFilterEXT(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			GetSeparableFilterEXTNative(target, format, type, row, column, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIivEXTNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[219])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[219])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIivEXT(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterIivEXTNative(target, pname, @params);
		}

		public static void GetTexParameterIivEXT(GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexParameterIivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIuivEXTNative(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[220])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[220])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIuivEXT(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTexParameterIuivEXTNative(target, pname, @params);
		}

		public static void GetTexParameterIuivEXT(GLTextureTarget target, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetTexParameterIuivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureImageEXTNative(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[221])(texture, target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[221])(texture, target, level, format, type, (nint)pixels);
			#endif
		}

		public static void GetTextureImageEXT(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetTextureImageEXTNative(texture, target, level, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterfvEXTNative(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[222])(texture, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[222])(texture, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTextureLevelParameterfvEXTNative(texture, target, level, pname, @params);
		}

		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureLevelParameterfvEXTNative(texture, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterivEXTNative(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[223])(texture, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[223])(texture, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTextureLevelParameterivEXTNative(texture, target, level, pname, @params);
		}

		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureLevelParameterivEXTNative(texture, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[224])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[224])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterIivEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterIivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIuivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[225])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[225])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTextureParameterIuivEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetTextureParameterIuivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterfvEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[226])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[226])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTextureParameterfvEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureParameterfvEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[227])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[227])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterivEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackVaryingEXTNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[228])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[228])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetTransformFeedbackVaryingEXTNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetTransformFeedbackVaryingEXTNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetTransformFeedbackVaryingEXTNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetTransformFeedbackVaryingEXTNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetTransformFeedbackVaryingEXTNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetTransformFeedbackVaryingEXTNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetTransformFeedbackVaryingEXTNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingEXTNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingEXTNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetTransformFeedbackVaryingEXTNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUniformBufferSizeEXTNative(uint program, int location)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, int>)funcTable[229])(program, location);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, int, int>)funcTable[229])(program, location);
			#endif
		}

		public static int GetUniformBufferSizeEXT(uint program, int location)
		{
			int ret = GetUniformBufferSizeEXTNative(program, location);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static nint GetUniformOffsetEXTNative(uint program, int location)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, nint>)funcTable[230])(program, location);
			#else
			return (nint)((delegate* unmanaged[Cdecl]<uint, int, nint>)funcTable[230])(program, location);
			#endif
		}

		public static nint GetUniformOffsetEXT(uint program, int location)
		{
			nint ret = GetUniformOffsetEXTNative(program, location);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformuivEXTNative(uint program, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[231])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[231])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformuivEXT(uint program, int location, uint* @params)
		{
			GetUniformuivEXTNative(program, location, @params);
		}

		public static void GetUniformuivEXT(uint program, int location, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetUniformuivEXTNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUnsignedBytevEXTNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[232])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[232])(pname, (nint)data);
			#endif
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, byte* data)
		{
			GetUnsignedBytevEXTNative(pname, data);
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetUnsignedBytevEXTNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetUnsignedBytevEXTNative(pname, pdata0);
			}
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetUnsignedBytevEXTNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUnsignedBytei_vEXTNative(GLEnum target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, byte*, void>)funcTable[233])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[233])(target, index, (nint)data);
			#endif
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, byte* data)
		{
			GetUnsignedBytei_vEXTNative(target, index, data);
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetUnsignedBytei_vEXTNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetUnsignedBytei_vEXTNative(target, index, pdata0);
			}
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetUnsignedBytei_vEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantBooleanvEXTNative(uint id, GLGetVariantValueEXT value, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, byte*, void>)funcTable[234])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[234])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, byte* data)
		{
			GetVariantBooleanvEXTNative(id, value, data);
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetVariantBooleanvEXTNative(id, value, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetVariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetVariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantFloatvEXTNative(uint id, GLGetVariantValueEXT value, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, float*, void>)funcTable[235])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[235])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantFloatvEXT(uint id, GLGetVariantValueEXT value, float* data)
		{
			GetVariantFloatvEXTNative(id, value, data);
		}

		public static void GetVariantFloatvEXT(uint id, GLGetVariantValueEXT value, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetVariantFloatvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantIntegervEXTNative(uint id, GLGetVariantValueEXT value, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, int*, void>)funcTable[236])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[236])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantIntegervEXT(uint id, GLGetVariantValueEXT value, int* data)
		{
			GetVariantIntegervEXTNative(id, value, data);
		}

		public static void GetVariantIntegervEXT(uint id, GLGetVariantValueEXT value, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetVariantIntegervEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantPointervEXTNative(uint id, GLGetVariantValueEXT value, void** data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, void**, void>)funcTable[237])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[237])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantPointervEXT(uint id, GLGetVariantValueEXT value, void** data)
		{
			GetVariantPointervEXTNative(id, value, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIntegeri_vEXTNative(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, int*, void>)funcTable[238])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[238])(vaobj, index, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIntegeri_vEXTNative(vaobj, index, pname, param);
		}

		public static void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetVertexArrayIntegeri_vEXTNative(vaobj, index, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIntegervEXTNative(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, int*, void>)funcTable[239])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[239])(vaobj, pname, (nint)param);
			#endif
		}
	}
}
