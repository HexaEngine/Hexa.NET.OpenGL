// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public static unsafe partial class GLExt
	{

		public static void Uniform1uivEXT(int location, int count, uint* value)
		{
			Uniform1uivEXTNative(location, count, value);
		}

		public static void Uniform1uivEXT(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform1uivEXTNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2uiEXTNative(int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[509])(location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, void>)funcTable[509])(location, v0, v1);
			#endif
		}

		public static void Uniform2uiEXT(int location, uint v0, uint v1)
		{
			Uniform2uiEXTNative(location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform2uivEXTNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[510])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[510])(location, count, (nint)value);
			#endif
		}

		public static void Uniform2uivEXT(int location, int count, uint* value)
		{
			Uniform2uivEXTNative(location, count, value);
		}

		public static void Uniform2uivEXT(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform2uivEXTNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3uiEXTNative(int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[511])(location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, void>)funcTable[511])(location, v0, v1, v2);
			#endif
		}

		public static void Uniform3uiEXT(int location, uint v0, uint v1, uint v2)
		{
			Uniform3uiEXTNative(location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform3uivEXTNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[512])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[512])(location, count, (nint)value);
			#endif
		}

		public static void Uniform3uivEXT(int location, int count, uint* value)
		{
			Uniform3uivEXTNative(location, count, value);
		}

		public static void Uniform3uivEXT(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform3uivEXTNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4uiEXTNative(int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[513])(location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<int, uint, uint, uint, uint, void>)funcTable[513])(location, v0, v1, v2, v3);
			#endif
		}

		public static void Uniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3)
		{
			Uniform4uiEXTNative(location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void Uniform4uivEXTNative(int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[514])(location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[514])(location, count, (nint)value);
			#endif
		}

		public static void Uniform4uivEXT(int location, int count, uint* value)
		{
			Uniform4uivEXTNative(location, count, value);
		}

		public static void Uniform4uivEXT(int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				Uniform4uivEXTNative(location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UniformBufferEXTNative(uint program, int location, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[515])(program, location, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[515])(program, location, buffer);
			#endif
		}

		public static void UniformBufferEXT(uint program, int location, uint buffer)
		{
			UniformBufferEXTNative(program, location, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UnlockArraysEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[516])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[516])();
			#endif
		}

		public static void UnlockArraysEXT()
		{
			UnlockArraysEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnmapNamedBufferEXTNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[517])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[517])(buffer);
			#endif
		}

		public static bool UnmapNamedBufferEXT(uint buffer)
		{
			byte ret = UnmapNamedBufferEXTNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseProgramStagesEXTNative(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[518])(pipeline, stages, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[518])(pipeline, stages, program);
			#endif
		}

		public static void UseProgramStagesEXT(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			UseProgramStagesEXTNative(pipeline, stages, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseShaderProgramEXTNative(GLEnum type, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void>)funcTable[519])(type, program);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void>)funcTable[519])(type, program);
			#endif
		}

		public static void UseShaderProgramEXT(GLEnum type, uint program)
		{
			UseShaderProgramEXTNative(type, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ValidateProgramPipelineEXTNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[520])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[520])(pipeline);
			#endif
		}

		public static void ValidateProgramPipelineEXT(uint pipeline)
		{
			ValidateProgramPipelineEXTNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantPointerEXTNative(uint id, GLScalarType type, uint stride, void* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, uint, void*, void>)funcTable[521])(id, type, stride, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, uint, nint, void>)funcTable[521])(id, type, stride, (nint)addr);
			#endif
		}

		public static void VariantPointerEXT(uint id, GLScalarType type, uint stride, void* addr)
		{
			VariantPointerEXTNative(id, type, stride, addr);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantbvEXTNative(uint id, sbyte* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[522])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[522])(id, (nint)addr);
			#endif
		}

		public static void VariantbvEXT(uint id, sbyte* addr)
		{
			VariantbvEXTNative(id, addr);
		}

		public static void VariantbvEXT(uint id, ref sbyte addr)
		{
			fixed (sbyte* paddr0 = &addr)
			{
				VariantbvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantdvEXTNative(uint id, double* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[523])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[523])(id, (nint)addr);
			#endif
		}

		public static void VariantdvEXT(uint id, double* addr)
		{
			VariantdvEXTNative(id, addr);
		}

		public static void VariantdvEXT(uint id, ref double addr)
		{
			fixed (double* paddr0 = &addr)
			{
				VariantdvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantfvEXTNative(uint id, float* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[524])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[524])(id, (nint)addr);
			#endif
		}

		public static void VariantfvEXT(uint id, float* addr)
		{
			VariantfvEXTNative(id, addr);
		}

		public static void VariantfvEXT(uint id, ref float addr)
		{
			fixed (float* paddr0 = &addr)
			{
				VariantfvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantivEXTNative(uint id, int* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[525])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[525])(id, (nint)addr);
			#endif
		}

		public static void VariantivEXT(uint id, int* addr)
		{
			VariantivEXTNative(id, addr);
		}

		public static void VariantivEXT(uint id, ref int addr)
		{
			fixed (int* paddr0 = &addr)
			{
				VariantivEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantsvEXTNative(uint id, short* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[526])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[526])(id, (nint)addr);
			#endif
		}

		public static void VariantsvEXT(uint id, short* addr)
		{
			VariantsvEXTNative(id, addr);
		}

		public static void VariantsvEXT(uint id, ref short addr)
		{
			fixed (short* paddr0 = &addr)
			{
				VariantsvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantubvEXTNative(uint id, byte* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[527])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[527])(id, (nint)addr);
			#endif
		}

		public static void VariantubvEXT(uint id, byte* addr)
		{
			VariantubvEXTNative(id, addr);
		}

		public static void VariantubvEXT(uint id, string addr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (addr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(addr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(addr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VariantubvEXTNative(id, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void VariantubvEXT(uint id, ReadOnlySpan<byte> addr)
		{
			fixed (byte* paddr0 = addr)
			{
				VariantubvEXTNative(id, paddr0);
			}
		}

		public static void VariantubvEXT(uint id, ref byte addr)
		{
			fixed (byte* paddr0 = &addr)
			{
				VariantubvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantuivEXTNative(uint id, uint* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[528])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[528])(id, (nint)addr);
			#endif
		}

		public static void VariantuivEXT(uint id, uint* addr)
		{
			VariantuivEXTNative(id, addr);
		}

		public static void VariantuivEXT(uint id, ref uint addr)
		{
			fixed (uint* paddr0 = &addr)
			{
				VariantuivEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantusvEXTNative(uint id, ushort* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[529])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[529])(id, (nint)addr);
			#endif
		}

		public static void VariantusvEXT(uint id, ushort* addr)
		{
			VariantusvEXTNative(id, addr);
		}

		public static void VariantusvEXT(uint id, ref ushort addr)
		{
			fixed (ushort* paddr0 = &addr)
			{
				VariantusvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayBindVertexBufferEXTNative(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[530])(vaobj, bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[530])(vaobj, bindingindex, buffer, offset, stride);
			#endif
		}

		public static void VertexArrayBindVertexBufferEXT(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			VertexArrayBindVertexBufferEXTNative(vaobj, bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[531])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[531])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArrayColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayEdgeFlagOffsetEXTNative(uint vaobj, uint buffer, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[532])(vaobj, buffer, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[532])(vaobj, buffer, stride, offset);
			#endif
		}

		public static void VertexArrayEdgeFlagOffsetEXT(uint vaobj, uint buffer, int stride, nint offset)
		{
			VertexArrayEdgeFlagOffsetEXTNative(vaobj, buffer, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayFogCoordOffsetEXTNative(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[533])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[533])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayFogCoordOffsetEXT(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			VertexArrayFogCoordOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayIndexOffsetEXTNative(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[534])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[534])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayIndexOffsetEXT(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			VertexArrayIndexOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayMultiTexCoordOffsetEXTNative(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[535])(vaobj, buffer, texunit, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[535])(vaobj, buffer, texunit, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayMultiTexCoordOffsetEXT(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayMultiTexCoordOffsetEXTNative(vaobj, buffer, texunit, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayNormalOffsetEXTNative(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[536])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[536])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayNormalOffsetEXT(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			VertexArrayNormalOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArraySecondaryColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[537])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[537])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArraySecondaryColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArraySecondaryColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayTexCoordOffsetEXTNative(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[538])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[538])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayTexCoordOffsetEXT(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayTexCoordOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribBindingEXTNative(uint vaobj, uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[539])(vaobj, attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[539])(vaobj, attribindex, bindingindex);
			#endif
		}

		public static void VertexArrayVertexAttribBindingEXT(uint vaobj, uint attribindex, uint bindingindex)
		{
			VertexArrayVertexAttribBindingEXTNative(vaobj, attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribDivisorEXTNative(uint vaobj, uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[540])(vaobj, index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[540])(vaobj, index, divisor);
			#endif
		}

		public static void VertexArrayVertexAttribDivisorEXT(uint vaobj, uint index, uint divisor)
		{
			VertexArrayVertexAttribDivisorEXTNative(vaobj, index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribType type, byte normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[541])(vaobj, attribindex, size, type, normalized, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[541])(vaobj, attribindex, size, type, normalized, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribType type, byte normalized, uint relativeoffset)
		{
			VertexArrayVertexAttribFormatEXTNative(vaobj, attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribIFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[542])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[542])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribIFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexArrayVertexAttribIFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribIOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[543])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[543])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribIOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			VertexArrayVertexAttribIOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribLFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[544])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[544])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribLFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexArrayVertexAttribLFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribLOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[545])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[545])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribLOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			VertexArrayVertexAttribLOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, byte normalized, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[546])(vaobj, buffer, index, size, type, normalized, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[546])(vaobj, buffer, index, size, type, normalized, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, byte normalized, int stride, nint offset)
		{
			VertexArrayVertexAttribOffsetEXTNative(vaobj, buffer, index, size, type, normalized, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexBindingDivisorEXTNative(uint vaobj, uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[547])(vaobj, bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[547])(vaobj, bindingindex, divisor);
			#endif
		}

		public static void VertexArrayVertexBindingDivisorEXT(uint vaobj, uint bindingindex, uint divisor)
		{
			VertexArrayVertexBindingDivisorEXTNative(vaobj, bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexOffsetEXTNative(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[548])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[548])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexOffsetEXT(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			VertexArrayVertexOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1iEXTNative(uint index, int x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[549])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[549])(index, x);
			#endif
		}

		public static void VertexAttribI1iEXT(uint index, int x)
		{
			VertexAttribI1iEXTNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1ivEXTNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[550])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[550])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI1ivEXT(uint index, int* v)
		{
			VertexAttribI1ivEXTNative(index, v);
		}

		public static void VertexAttribI1ivEXT(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI1ivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1uiEXTNative(uint index, uint x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[551])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[551])(index, x);
			#endif
		}

		public static void VertexAttribI1uiEXT(uint index, uint x)
		{
			VertexAttribI1uiEXTNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI1uivEXTNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[552])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[552])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI1uivEXT(uint index, uint* v)
		{
			VertexAttribI1uivEXTNative(index, v);
		}

		public static void VertexAttribI1uivEXT(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI1uivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2iEXTNative(uint index, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[553])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[553])(index, x, y);
			#endif
		}

		public static void VertexAttribI2iEXT(uint index, int x, int y)
		{
			VertexAttribI2iEXTNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2ivEXTNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[554])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[554])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI2ivEXT(uint index, int* v)
		{
			VertexAttribI2ivEXTNative(index, v);
		}

		public static void VertexAttribI2ivEXT(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI2ivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2uiEXTNative(uint index, uint x, uint y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[555])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[555])(index, x, y);
			#endif
		}

		public static void VertexAttribI2uiEXT(uint index, uint x, uint y)
		{
			VertexAttribI2uiEXTNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI2uivEXTNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[556])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[556])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI2uivEXT(uint index, uint* v)
		{
			VertexAttribI2uivEXTNative(index, v);
		}

		public static void VertexAttribI2uivEXT(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI2uivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3iEXTNative(uint index, int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[557])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[557])(index, x, y, z);
			#endif
		}

		public static void VertexAttribI3iEXT(uint index, int x, int y, int z)
		{
			VertexAttribI3iEXTNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3ivEXTNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[558])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[558])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI3ivEXT(uint index, int* v)
		{
			VertexAttribI3ivEXTNative(index, v);
		}

		public static void VertexAttribI3ivEXT(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI3ivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3uiEXTNative(uint index, uint x, uint y, uint z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[559])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[559])(index, x, y, z);
			#endif
		}

		public static void VertexAttribI3uiEXT(uint index, uint x, uint y, uint z)
		{
			VertexAttribI3uiEXTNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI3uivEXTNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[560])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[560])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI3uivEXT(uint index, uint* v)
		{
			VertexAttribI3uivEXTNative(index, v);
		}

		public static void VertexAttribI3uivEXT(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI3uivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4bvEXTNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[561])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[561])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4bvEXT(uint index, sbyte* v)
		{
			VertexAttribI4bvEXTNative(index, v);
		}

		public static void VertexAttribI4bvEXT(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttribI4bvEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4iEXTNative(uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[562])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[562])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttribI4iEXT(uint index, int x, int y, int z, int w)
		{
			VertexAttribI4iEXTNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4ivEXTNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[563])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[563])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4ivEXT(uint index, int* v)
		{
			VertexAttribI4ivEXTNative(index, v);
		}

		public static void VertexAttribI4ivEXT(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI4ivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4svEXTNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[564])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[564])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4svEXT(uint index, short* v)
		{
			VertexAttribI4svEXTNative(index, v);
		}

		public static void VertexAttribI4svEXT(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttribI4svEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4ubvEXTNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[565])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[565])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4ubvEXT(uint index, byte* v)
		{
			VertexAttribI4ubvEXTNative(index, v);
		}

		public static void VertexAttribI4ubvEXT(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttribI4ubvEXTNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void VertexAttribI4ubvEXT(uint index, ReadOnlySpan<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttribI4ubvEXTNative(index, pv0);
			}
		}

		public static void VertexAttribI4ubvEXT(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttribI4ubvEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4uiEXTNative(uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[566])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[566])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w)
		{
			VertexAttribI4uiEXTNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4uivEXTNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[567])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[567])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4uivEXT(uint index, uint* v)
		{
			VertexAttribI4uivEXTNative(index, v);
		}

		public static void VertexAttribI4uivEXT(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI4uivEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribI4usvEXTNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[568])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[568])(index, (nint)v);
			#endif
		}

		public static void VertexAttribI4usvEXT(uint index, ushort* v)
		{
			VertexAttribI4usvEXTNative(index, v);
		}

		public static void VertexAttribI4usvEXT(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttribI4usvEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribIPointerEXTNative(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, void*, void>)funcTable[569])(index, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, nint, void>)funcTable[569])(index, size, type, stride, (nint)pointer);
			#endif
		}

		public static void VertexAttribIPointerEXT(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			VertexAttribIPointerEXTNative(index, size, type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL1dEXTNative(uint index, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[570])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[570])(index, x);
			#endif
		}

		public static void VertexAttribL1dEXT(uint index, double x)
		{
			VertexAttribL1dEXTNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL1dvEXTNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[571])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[571])(index, (nint)v);
			#endif
		}

		public static void VertexAttribL1dvEXT(uint index, double* v)
		{
			VertexAttribL1dvEXTNative(index, v);
		}

		public static void VertexAttribL1dvEXT(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL1dvEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL2dEXTNative(uint index, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[572])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[572])(index, x, y);
			#endif
		}

		public static void VertexAttribL2dEXT(uint index, double x, double y)
		{
			VertexAttribL2dEXTNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL2dvEXTNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[573])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[573])(index, (nint)v);
			#endif
		}

		public static void VertexAttribL2dvEXT(uint index, double* v)
		{
			VertexAttribL2dvEXTNative(index, v);
		}

		public static void VertexAttribL2dvEXT(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL2dvEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL3dEXTNative(uint index, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[574])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[574])(index, x, y, z);
			#endif
		}

		public static void VertexAttribL3dEXT(uint index, double x, double y, double z)
		{
			VertexAttribL3dEXTNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL3dvEXTNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[575])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[575])(index, (nint)v);
			#endif
		}

		public static void VertexAttribL3dvEXT(uint index, double* v)
		{
			VertexAttribL3dvEXTNative(index, v);
		}

		public static void VertexAttribL3dvEXT(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL3dvEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL4dEXTNative(uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[576])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[576])(index, x, y, z, w);
			#endif
		}

		public static void VertexAttribL4dEXT(uint index, double x, double y, double z, double w)
		{
			VertexAttribL4dEXTNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribL4dvEXTNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[577])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[577])(index, (nint)v);
			#endif
		}

		public static void VertexAttribL4dvEXT(uint index, double* v)
		{
			VertexAttribL4dvEXTNative(index, v);
		}

		public static void VertexAttribL4dvEXT(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL4dvEXTNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribLPointerEXTNative(uint index, int size, GLVertexAttribLType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, int, void*, void>)funcTable[578])(index, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, int, nint, void>)funcTable[578])(index, size, type, stride, (nint)pointer);
			#endif
		}

		public static void VertexAttribLPointerEXT(uint index, int size, GLVertexAttribLType type, int stride, void* pointer)
		{
			VertexAttribLPointerEXTNative(index, size, type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexPointerEXTNative(int size, GLVertexPointerType type, int stride, int count, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLVertexPointerType, int, int, void*, void>)funcTable[579])(size, type, stride, count, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLVertexPointerType, int, int, nint, void>)funcTable[579])(size, type, stride, count, (nint)pointer);
			#endif
		}

		public static void VertexPointerEXT(int size, GLVertexPointerType type, int stride, int count, void* pointer)
		{
			VertexPointerEXTNative(size, type, stride, count, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexWeightPointerEXTNative(int size, GLVertexWeightPointerTypeEXT type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLVertexWeightPointerTypeEXT, int, void*, void>)funcTable[580])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLVertexWeightPointerTypeEXT, int, nint, void>)funcTable[580])(size, type, stride, (nint)pointer);
			#endif
		}

		public static void VertexWeightPointerEXT(int size, GLVertexWeightPointerTypeEXT type, int stride, void* pointer)
		{
			VertexWeightPointerEXTNative(size, type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexWeightfEXTNative(float weight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[581])(weight);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[581])(weight);
			#endif
		}

		public static void VertexWeightfEXT(float weight)
		{
			VertexWeightfEXTNative(weight);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexWeightfvEXTNative(float* weight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[582])(weight);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[582])((nint)weight);
			#endif
		}

		public static void VertexWeightfvEXT(float* weight)
		{
			VertexWeightfvEXTNative(weight);
		}

		public static void VertexWeightfvEXT(ref float weight)
		{
			fixed (float* pweight0 = &weight)
			{
				VertexWeightfvEXTNative(pweight0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitSemaphoreEXTNative(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, GLTextureLayout srcLayouts)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint*, uint, uint*, GLTextureLayout, void>)funcTable[583])(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, uint, nint, GLTextureLayout, void>)funcTable[583])(semaphore, numBufferBarriers, (nint)buffers, numTextureBarriers, (nint)textures, srcLayouts);
			#endif
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, GLTextureLayout srcLayouts)
		{
			WaitSemaphoreEXTNative(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, uint* textures, GLTextureLayout srcLayouts)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				WaitSemaphoreEXTNative(semaphore, numBufferBarriers, pbuffers0, numTextureBarriers, textures, srcLayouts);
			}
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, ref uint textures, GLTextureLayout srcLayouts)
		{
			fixed (uint* ptextures0 = &textures)
			{
				WaitSemaphoreEXTNative(semaphore, numBufferBarriers, buffers, numTextureBarriers, ptextures0, srcLayouts);
			}
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, ref uint textures, GLTextureLayout srcLayouts)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (uint* ptextures1 = &textures)
				{
					WaitSemaphoreEXTNative(semaphore, numBufferBarriers, pbuffers0, numTextureBarriers, ptextures1, srcLayouts);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowRectanglesEXTNative(GLEnum mode, int count, int* box)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, int*, void>)funcTable[584])(mode, count, box);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, nint, void>)funcTable[584])(mode, count, (nint)box);
			#endif
		}

		public static void WindowRectanglesEXT(GLEnum mode, int count, int* box)
		{
			WindowRectanglesEXTNative(mode, count, box);
		}

		public static void WindowRectanglesEXT(GLEnum mode, int count, ref int box)
		{
			fixed (int* pbox0 = &box)
			{
				WindowRectanglesEXTNative(mode, count, pbox0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteMaskEXTNative(uint res, uint input, GLVertexShaderWriteMaskEXT outX, GLVertexShaderWriteMaskEXT outY, GLVertexShaderWriteMaskEXT outZ, GLVertexShaderWriteMaskEXT outW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, void>)funcTable[585])(res, input, outX, outY, outZ, outW);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, void>)funcTable[585])(res, input, outX, outY, outZ, outW);
			#endif
		}

		public static void WriteMaskEXT(uint res, uint input, GLVertexShaderWriteMaskEXT outX, GLVertexShaderWriteMaskEXT outY, GLVertexShaderWriteMaskEXT outZ, GLVertexShaderWriteMaskEXT outW)
		{
			WriteMaskEXTNative(res, input, outX, outY, outZ, outW);
		}

	}
}
