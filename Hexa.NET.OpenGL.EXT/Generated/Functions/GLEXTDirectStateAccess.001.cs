// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public unsafe partial class GLEXTDirectStateAccess
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramLocalParameters4fvEXT(uint program, GLProgramTarget target, uint index, int count, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				NamedProgramLocalParameters4fvEXTNative(program, target, index, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedProgramLocalParametersI4ivEXTNative(uint program, GLProgramTarget target, uint index, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, int*, void>)funcTable[157])(program, target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, nint, void>)funcTable[157])(program, target, index, count, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramLocalParametersI4ivEXT(uint program, GLProgramTarget target, uint index, int count, int* @params)
		{
			NamedProgramLocalParametersI4ivEXTNative(program, target, index, count, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramLocalParametersI4ivEXT(uint program, GLProgramTarget target, uint index, int count, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				NamedProgramLocalParametersI4ivEXTNative(program, target, index, count, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramLocalParametersI4ivEXT(uint program, GLProgramTarget target, uint index, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				NamedProgramLocalParametersI4ivEXTNative(program, target, index, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedProgramLocalParametersI4uivEXTNative(uint program, GLProgramTarget target, uint index, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, uint*, void>)funcTable[158])(program, target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, nint, void>)funcTable[158])(program, target, index, count, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramLocalParametersI4uivEXT(uint program, GLProgramTarget target, uint index, int count, uint* @params)
		{
			NamedProgramLocalParametersI4uivEXTNative(program, target, index, count, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramLocalParametersI4uivEXT(uint program, GLProgramTarget target, uint index, int count, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				NamedProgramLocalParametersI4uivEXTNative(program, target, index, count, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramLocalParametersI4uivEXT(uint program, GLProgramTarget target, uint index, int count, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				NamedProgramLocalParametersI4uivEXTNative(program, target, index, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedProgramStringEXTNative(uint program, GLProgramTarget target, GLProgramFormat format, int len, void* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramFormat, int, void*, void>)funcTable[159])(program, target, format, len, str);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramFormat, int, nint, void>)funcTable[159])(program, target, format, len, (nint)str);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramStringEXT(uint program, GLProgramTarget target, GLProgramFormat format, int len, void* str)
		{
			NamedProgramStringEXTNative(program, target, format, len, str);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramStringEXT(uint program, GLProgramTarget target, GLProgramFormat format, int len, nint str)
		{
			NamedProgramStringEXTNative(program, target, format, len, (void*)str);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedProgramStringEXT<TStr>(uint program, GLProgramTarget target, GLProgramFormat format, int len, Span<TStr> str) where TStr : unmanaged
		{
			fixed (TStr* pstr0 = str)
			{
				NamedProgramStringEXTNative(program, target, format, len, pstr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedRenderbufferStorageEXTNative(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[160])(renderbuffer, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[160])(renderbuffer, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedRenderbufferStorageEXT(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageEXTNative(renderbuffer, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedRenderbufferStorageMultisampleCoverageEXTNative(uint renderbuffer, int coverageSamples, int colorSamples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, GLInternalFormat, int, int, void>)funcTable[161])(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, GLInternalFormat, int, int, void>)funcTable[161])(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedRenderbufferStorageMultisampleCoverageEXT(uint renderbuffer, int coverageSamples, int colorSamples, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageMultisampleCoverageEXTNative(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedRenderbufferStorageMultisampleEXTNative(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[162])(renderbuffer, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[162])(renderbuffer, samples, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void NamedRenderbufferStorageMultisampleEXT(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageMultisampleEXTNative(renderbuffer, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1dEXTNative(uint program, int location, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, void>)funcTable[163])(program, location, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, void>)funcTable[163])(program, location, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform1dEXT(uint program, int location, double x)
		{
			ProgramUniform1dEXTNative(program, location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[164])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[164])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform1dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform1dvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform1dvEXT(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform1dvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform1dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform1dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1fEXTNative(uint program, int location, float v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[165])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[165])(program, location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1fEXT(uint program, int location, float v0)
		{
			ProgramUniform1fEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[166])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[166])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform1fvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1fvEXT(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform1fvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform1fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1iEXTNative(uint program, int location, int v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[167])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[167])(program, location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1iEXT(uint program, int location, int v0)
		{
			ProgramUniform1iEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[168])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[168])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform1ivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1ivEXT(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform1ivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform1ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1uiEXTNative(uint program, int location, uint v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[169])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[169])(program, location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1uiEXT(uint program, int location, uint v0)
		{
			ProgramUniform1uiEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[170])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[170])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform1uivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1uivEXT(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform1uivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform1uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform1uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2dEXTNative(uint program, int location, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, void>)funcTable[171])(program, location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, void>)funcTable[171])(program, location, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform2dEXT(uint program, int location, double x, double y)
		{
			ProgramUniform2dEXTNative(program, location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[172])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[172])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform2dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform2dvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform2dvEXT(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform2dvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform2dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform2dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2fEXTNative(uint program, int location, float v0, float v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[173])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[173])(program, location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2fEXT(uint program, int location, float v0, float v1)
		{
			ProgramUniform2fEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[174])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[174])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform2fvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2fvEXT(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform2fvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform2fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2iEXTNative(uint program, int location, int v0, int v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[175])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[175])(program, location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2iEXT(uint program, int location, int v0, int v1)
		{
			ProgramUniform2iEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[176])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[176])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform2ivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2ivEXT(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform2ivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform2ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2uiEXTNative(uint program, int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[177])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[177])(program, location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2uiEXT(uint program, int location, uint v0, uint v1)
		{
			ProgramUniform2uiEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[178])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[178])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform2uivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2uivEXT(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform2uivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform2uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform2uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3dEXTNative(uint program, int location, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, void>)funcTable[179])(program, location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, void>)funcTable[179])(program, location, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform3dEXT(uint program, int location, double x, double y, double z)
		{
			ProgramUniform3dEXTNative(program, location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[180])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[180])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform3dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform3dvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform3dvEXT(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform3dvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform3dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform3dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3fEXTNative(uint program, int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[181])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[181])(program, location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3fEXT(uint program, int location, float v0, float v1, float v2)
		{
			ProgramUniform3fEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[182])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[182])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform3fvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3fvEXT(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform3fvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform3fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3iEXTNative(uint program, int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[183])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[183])(program, location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3iEXT(uint program, int location, int v0, int v1, int v2)
		{
			ProgramUniform3iEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[184])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[184])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform3ivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3ivEXT(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform3ivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform3ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3uiEXTNative(uint program, int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[185])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[185])(program, location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3uiEXT(uint program, int location, uint v0, uint v1, uint v2)
		{
			ProgramUniform3uiEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[186])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[186])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform3uivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3uivEXT(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform3uivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform3uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform3uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4dEXTNative(uint program, int location, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, double, void>)funcTable[187])(program, location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, double, void>)funcTable[187])(program, location, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform4dEXT(uint program, int location, double x, double y, double z, double w)
		{
			ProgramUniform4dEXTNative(program, location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[188])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[188])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform4dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform4dvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform4dvEXT(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform4dvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniform4dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform4dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4fEXTNative(uint program, int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[189])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[189])(program, location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4fEXT(uint program, int location, float v0, float v1, float v2, float v3)
		{
			ProgramUniform4fEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[190])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[190])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform4fvEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4fvEXT(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform4fvEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform4fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4iEXTNative(uint program, int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[191])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[191])(program, location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4iEXT(uint program, int location, int v0, int v1, int v2, int v3)
		{
			ProgramUniform4iEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[192])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[192])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform4ivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4ivEXT(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform4ivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform4ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4uiEXTNative(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[193])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[193])(program, location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4uiEXT(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			ProgramUniform4uiEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[194])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[194])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform4uivEXTNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4uivEXT(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform4uivEXTNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniform4uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform4uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[195])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[195])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix2dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[196])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[196])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix2fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x3dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[197])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[197])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix2x3dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix2x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x3fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[198])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[198])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix2x3fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix2x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x4dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[199])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[199])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix2x4dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix2x4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2x4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x4fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[200])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[200])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix2x4fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix2x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[201])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[201])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix3dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[202])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[202])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix3fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x2dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[203])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[203])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix3x2dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix3x2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3x2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x2fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[204])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[204])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix3x2fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix3x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x4dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[205])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[205])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix3x4dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix3x4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3x4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x4fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[206])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[206])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix3x4fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix3x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[207])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[207])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix4dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[208])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[208])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix4fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x2dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[209])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[209])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix4x2dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix4x2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4x2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x2fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[210])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[210])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix4x2fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix4x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x3dvEXTNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[211])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[211])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x3fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[212])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[212])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PushClientAttribDefaultEXTNative(GLClientAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[213])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[213])(mask);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void PushClientAttribDefaultEXT(GLClientAttribMask mask)
		{
			PushClientAttribDefaultEXTNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureBufferEXTNative(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[214])(texture, target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[214])(texture, target, internalformat, buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureBufferEXT(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			TextureBufferEXTNative(texture, target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureBufferRangeEXTNative(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[215])(texture, target, internalformat, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[215])(texture, target, internalformat, buffer, offset, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureBufferRangeEXT(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			TextureBufferRangeEXTNative(texture, target, internalformat, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[216])(texture, target, level, internalformat, width, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[216])(texture, target, level, internalformat, width, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage1DEXTNative(texture, target, level, internalformat, width, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureImage1DEXTNative(texture, target, level, internalformat, width, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage1DEXT<TPixels>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureImage1DEXTNative(texture, target, level, internalformat, width, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[217])(texture, target, level, internalformat, width, height, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[217])(texture, target, level, internalformat, width, height, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage2DEXT<TPixels>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureImage3DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[218])(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[218])(texture, target, level, internalformat, width, height, depth, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureImage3DEXT<TPixels>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexturePageCommitmentEXTNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, byte, void>)funcTable[219])(texture, level, xoffset, yoffset, zoffset, width, height, depth, *((byte*)(&commit)));
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, byte, void>)funcTable[219])(texture, level, xoffset, yoffset, zoffset, width, height, depth, *((byte*)(&commit)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TexturePageCommitmentEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit)
		{
			TexturePageCommitmentEXTNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterIivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[220])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[220])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TextureParameterIivEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TextureParameterIivEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TextureParameterIivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterIuivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[221])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[221])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			TextureParameterIuivEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				TextureParameterIuivEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				TextureParameterIuivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterfEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[222])(texture, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[222])(texture, target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterfEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			TextureParameterfEXTNative(texture, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterfvEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float*, void>)funcTable[223])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[223])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			TextureParameterfvEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				TextureParameterfvEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				TextureParameterfvEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameteriEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[224])(texture, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[224])(texture, target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameteriEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			TextureParameteriEXTNative(texture, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureParameterivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[225])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[225])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TextureParameterivEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				TextureParameterivEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TextureParameterivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureRenderbufferEXTNative(uint texture, GLTextureTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, void>)funcTable[226])(texture, target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, void>)funcTable[226])(texture, target, renderbuffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureRenderbufferEXT(uint texture, GLTextureTarget target, uint renderbuffer)
		{
			TextureRenderbufferEXTNative(texture, target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage1DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[227])(texture, target, levels, internalformat, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[227])(texture, target, levels, internalformat, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_texture_storage</remarks>
		public void TextureStorage1DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			TextureStorage1DEXTNative(texture, target, levels, internalformat, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage2DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[228])(texture, target, levels, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[228])(texture, target, levels, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_texture_storage</remarks>
		public void TextureStorage2DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			TextureStorage2DEXTNative(texture, target, levels, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage2DMultisampleEXTNative(uint texture, GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[229])(texture, target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[229])(texture, target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureStorage2DMultisampleEXT(uint texture, GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			TextureStorage2DMultisampleEXTNative(texture, target, samples, internalformat, width, height, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage3DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[230])(texture, target, levels, internalformat, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[230])(texture, target, levels, internalformat, width, height, depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_texture_storage</remarks>
		public void TextureStorage3DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			TextureStorage3DEXTNative(texture, target, levels, internalformat, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorage3DMultisampleEXTNative(uint texture, GLEnum target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[231])(texture, target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[231])(texture, target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureStorage3DMultisampleEXT(uint texture, GLEnum target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			TextureStorage3DMultisampleEXTNative(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[232])(texture, target, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[232])(texture, target, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage1DEXT<TPixels>(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[233])(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[233])(texture, target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage2DEXT<TPixels>(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[234])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[234])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void TextureSubImage3DEXT<TPixels>(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte UnmapNamedBufferEXTNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[235])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[235])(buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public bool UnmapNamedBufferEXT(uint buffer)
		{
			byte ret = UnmapNamedBufferEXTNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayBindVertexBufferEXTNative(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[236])(vaobj, bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[236])(vaobj, bindingindex, buffer, offset, stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayBindVertexBufferEXT(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			VertexArrayBindVertexBufferEXTNative(vaobj, bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[237])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[237])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArrayColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayEdgeFlagOffsetEXTNative(uint vaobj, uint buffer, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[238])(vaobj, buffer, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[238])(vaobj, buffer, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayEdgeFlagOffsetEXT(uint vaobj, uint buffer, int stride, nint offset)
		{
			VertexArrayEdgeFlagOffsetEXTNative(vaobj, buffer, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayFogCoordOffsetEXTNative(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[239])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[239])(vaobj, buffer, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayFogCoordOffsetEXT(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			VertexArrayFogCoordOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayIndexOffsetEXTNative(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[240])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[240])(vaobj, buffer, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayIndexOffsetEXT(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			VertexArrayIndexOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayMultiTexCoordOffsetEXTNative(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[241])(vaobj, buffer, texunit, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[241])(vaobj, buffer, texunit, size, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayMultiTexCoordOffsetEXT(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayMultiTexCoordOffsetEXTNative(vaobj, buffer, texunit, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayNormalOffsetEXTNative(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[242])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[242])(vaobj, buffer, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayNormalOffsetEXT(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			VertexArrayNormalOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArraySecondaryColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[243])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[243])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArraySecondaryColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArraySecondaryColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayTexCoordOffsetEXTNative(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[244])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[244])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayTexCoordOffsetEXT(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayTexCoordOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribBindingEXTNative(uint vaobj, uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[245])(vaobj, attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[245])(vaobj, attribindex, bindingindex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribBindingEXT(uint vaobj, uint attribindex, uint bindingindex)
		{
			VertexArrayVertexAttribBindingEXTNative(vaobj, attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribDivisorEXTNative(uint vaobj, uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[246])(vaobj, index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[246])(vaobj, index, divisor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribDivisorEXT(uint vaobj, uint index, uint divisor)
		{
			VertexArrayVertexAttribDivisorEXTNative(vaobj, index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[247])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[247])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			VertexArrayVertexAttribFormatEXTNative(vaobj, attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribIFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[248])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[248])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribIFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexArrayVertexAttribIFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribIOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[249])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[249])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribIOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			VertexArrayVertexAttribIOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribLFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[250])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[250])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribLFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexArrayVertexAttribLFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribLOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[251])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[251])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribLOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			VertexArrayVertexAttribLOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexAttribOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[252])(vaobj, buffer, index, size, type, *((byte*)(&normalized)), stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[252])(vaobj, buffer, index, size, type, *((byte*)(&normalized)), stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexAttribOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint offset)
		{
			VertexArrayVertexAttribOffsetEXTNative(vaobj, buffer, index, size, type, normalized, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexBindingDivisorEXTNative(uint vaobj, uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[253])(vaobj, bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[253])(vaobj, bindingindex, divisor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexBindingDivisorEXT(uint vaobj, uint bindingindex, uint divisor)
		{
			VertexArrayVertexBindingDivisorEXTNative(vaobj, bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexArrayVertexOffsetEXTNative(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[254])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[254])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public void VertexArrayVertexOffsetEXT(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			VertexArrayVertexOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

	}
}
