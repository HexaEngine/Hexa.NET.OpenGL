// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public static unsafe partial class GLEXTDirectStateAccess
	{

		public static void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		public static void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4x3fvEXTNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[212])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[212])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		public static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushClientAttribDefaultEXTNative(GLClientAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[213])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[213])(mask);
			#endif
		}

		public static void PushClientAttribDefaultEXT(GLClientAttribMask mask)
		{
			PushClientAttribDefaultEXTNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureBufferEXTNative(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[214])(texture, target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[214])(texture, target, internalformat, buffer);
			#endif
		}

		public static void TextureBufferEXT(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			TextureBufferEXTNative(texture, target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureBufferRangeEXTNative(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[215])(texture, target, internalformat, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[215])(texture, target, internalformat, buffer, offset, size);
			#endif
		}

		public static void TextureBufferRangeEXT(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			TextureBufferRangeEXTNative(texture, target, internalformat, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[216])(texture, target, level, internalformat, width, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[216])(texture, target, level, internalformat, width, border, format, type, (nint)pixels);
			#endif
		}

		public static void TextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage1DEXTNative(texture, target, level, internalformat, width, border, format, type, pixels);
		}

		public static void TextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureImage1DEXTNative(texture, target, level, internalformat, width, border, format, type, (void*)pixels);
		}

		public static void TextureImage1DEXT<TPixels>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureImage1DEXTNative(texture, target, level, internalformat, width, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[217])(texture, target, level, internalformat, width, height, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[217])(texture, target, level, internalformat, width, height, border, format, type, (nint)pixels);
			#endif
		}

		public static void TextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, format, type, pixels);
		}

		public static void TextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, format, type, (void*)pixels);
		}

		public static void TextureImage2DEXT<TPixels>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage3DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[218])(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[218])(texture, target, level, internalformat, width, height, depth, border, format, type, (nint)pixels);
			#endif
		}

		public static void TextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
		}

		public static void TextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, format, type, (void*)pixels);
		}

		public static void TextureImage3DEXT<TPixels>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexturePageCommitmentEXTNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, byte, void>)funcTable[219])(texture, level, xoffset, yoffset, zoffset, width, height, depth, *((byte*)(&commit)));
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, byte, void>)funcTable[219])(texture, level, xoffset, yoffset, zoffset, width, height, depth, *((byte*)(&commit)));
			#endif
		}

		public static void TexturePageCommitmentEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit)
		{
			TexturePageCommitmentEXTNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterIivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[220])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[220])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TextureParameterIivEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			TextureParameterIivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TextureParameterIivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterIuivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[221])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[221])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			TextureParameterIuivEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out uint @params)
		{
			uint pparams;
			TextureParameterIuivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				TextureParameterIuivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterfEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[222])(texture, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[222])(texture, target, pname, param);
			#endif
		}

		public static void TextureParameterfEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			TextureParameterfEXTNative(texture, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterfvEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float*, void>)funcTable[223])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[223])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			TextureParameterfvEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out float @params)
		{
			float pparams;
			TextureParameterfvEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				TextureParameterfvEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameteriEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[224])(texture, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[224])(texture, target, pname, param);
			#endif
		}

		public static void TextureParameteriEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			TextureParameteriEXTNative(texture, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[225])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[225])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TextureParameterivEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			TextureParameterivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TextureParameterivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureRenderbufferEXTNative(uint texture, GLTextureTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, void>)funcTable[226])(texture, target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, void>)funcTable[226])(texture, target, renderbuffer);
			#endif
		}

		public static void TextureRenderbufferEXT(uint texture, GLTextureTarget target, uint renderbuffer)
		{
			TextureRenderbufferEXTNative(texture, target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage1DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[227])(texture, target, levels, internalformat, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[227])(texture, target, levels, internalformat, width);
			#endif
		}

		public static void TextureStorage1DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			TextureStorage1DEXTNative(texture, target, levels, internalformat, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage2DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[228])(texture, target, levels, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[228])(texture, target, levels, internalformat, width, height);
			#endif
		}

		public static void TextureStorage2DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			TextureStorage2DEXTNative(texture, target, levels, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage2DMultisampleEXTNative(uint texture, GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[229])(texture, target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[229])(texture, target, samples, internalformat, width, height, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		public static void TextureStorage2DMultisampleEXT(uint texture, GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, bool fixedsamplelocations)
		{
			TextureStorage2DMultisampleEXTNative(texture, target, samples, internalformat, width, height, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage3DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[230])(texture, target, levels, internalformat, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[230])(texture, target, levels, internalformat, width, height, depth);
			#endif
		}

		public static void TextureStorage3DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			TextureStorage3DEXTNative(texture, target, levels, internalformat, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage3DMultisampleEXTNative(uint texture, GLEnum target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[231])(texture, target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[231])(texture, target, samples, internalformat, width, height, depth, *((byte*)(&fixedsamplelocations)));
			#endif
		}

		public static void TextureStorage3DMultisampleEXT(uint texture, GLEnum target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, bool fixedsamplelocations)
		{
			TextureStorage3DMultisampleEXTNative(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[232])(texture, target, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[232])(texture, target, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		public static void TextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, type, pixels);
		}

		public static void TextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, type, (void*)pixels);
		}

		public static void TextureSubImage1DEXT<TPixels>(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[233])(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[233])(texture, target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		public static void TextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		public static void TextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
		}

		public static void TextureSubImage2DEXT<TPixels>(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[234])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[234])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		public static void TextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		public static void TextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			TextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
		}

		public static void TextureSubImage3DEXT<TPixels>(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				TextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnmapNamedBufferEXTNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[235])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[235])(buffer);
			#endif
		}

		public static bool UnmapNamedBufferEXT(uint buffer)
		{
			byte ret = UnmapNamedBufferEXTNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayBindVertexBufferEXTNative(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[236])(vaobj, bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[236])(vaobj, bindingindex, buffer, offset, stride);
			#endif
		}

		public static void VertexArrayBindVertexBufferEXT(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			VertexArrayBindVertexBufferEXTNative(vaobj, bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[237])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[237])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArrayColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayEdgeFlagOffsetEXTNative(uint vaobj, uint buffer, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[238])(vaobj, buffer, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[238])(vaobj, buffer, stride, offset);
			#endif
		}

		public static void VertexArrayEdgeFlagOffsetEXT(uint vaobj, uint buffer, int stride, nint offset)
		{
			VertexArrayEdgeFlagOffsetEXTNative(vaobj, buffer, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayFogCoordOffsetEXTNative(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[239])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[239])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayFogCoordOffsetEXT(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			VertexArrayFogCoordOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayIndexOffsetEXTNative(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[240])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[240])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayIndexOffsetEXT(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			VertexArrayIndexOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayMultiTexCoordOffsetEXTNative(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[241])(vaobj, buffer, texunit, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[241])(vaobj, buffer, texunit, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayMultiTexCoordOffsetEXT(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayMultiTexCoordOffsetEXTNative(vaobj, buffer, texunit, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayNormalOffsetEXTNative(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[242])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[242])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayNormalOffsetEXT(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			VertexArrayNormalOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArraySecondaryColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[243])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[243])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArraySecondaryColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArraySecondaryColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayTexCoordOffsetEXTNative(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[244])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[244])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayTexCoordOffsetEXT(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayTexCoordOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribBindingEXTNative(uint vaobj, uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[245])(vaobj, attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[245])(vaobj, attribindex, bindingindex);
			#endif
		}

		public static void VertexArrayVertexAttribBindingEXT(uint vaobj, uint attribindex, uint bindingindex)
		{
			VertexArrayVertexAttribBindingEXTNative(vaobj, attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribDivisorEXTNative(uint vaobj, uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[246])(vaobj, index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[246])(vaobj, index, divisor);
			#endif
		}

		public static void VertexArrayVertexAttribDivisorEXT(uint vaobj, uint index, uint divisor)
		{
			VertexArrayVertexAttribDivisorEXTNative(vaobj, index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[247])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[247])(vaobj, attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			VertexArrayVertexAttribFormatEXTNative(vaobj, attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribIFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[248])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[248])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribIFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexArrayVertexAttribIFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribIOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[249])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[249])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribIOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			VertexArrayVertexAttribIOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribLFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[250])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[250])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribLFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexArrayVertexAttribLFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribLOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[251])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[251])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribLOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			VertexArrayVertexAttribLOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[252])(vaobj, buffer, index, size, type, *((byte*)(&normalized)), stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[252])(vaobj, buffer, index, size, type, *((byte*)(&normalized)), stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint offset)
		{
			VertexArrayVertexAttribOffsetEXTNative(vaobj, buffer, index, size, type, normalized, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexBindingDivisorEXTNative(uint vaobj, uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[253])(vaobj, bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[253])(vaobj, bindingindex, divisor);
			#endif
		}

		public static void VertexArrayVertexBindingDivisorEXT(uint vaobj, uint bindingindex, uint divisor)
		{
			VertexArrayVertexBindingDivisorEXTNative(vaobj, bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexOffsetEXTNative(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[254])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[254])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexOffsetEXT(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			VertexArrayVertexOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

	}
}
