// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public static unsafe partial class GLEXTDirectStateAccess
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindMultiTextureEXTNative(GLTextureUnit texunit, GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[0])(texunit, target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[0])(texunit, target, texture);
			#endif
		}

		public static void BindMultiTextureEXT(GLTextureUnit texunit, GLTextureTarget target, uint texture)
		{
			BindMultiTextureEXTNative(texunit, target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckNamedFramebufferStatusEXTNative(uint framebuffer, GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[1])(framebuffer, target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[1])(framebuffer, target);
			#endif
		}

		public static GLEnum CheckNamedFramebufferStatusEXT(uint framebuffer, GLFramebufferTarget target)
		{
			GLEnum ret = CheckNamedFramebufferStatusEXTNative(framebuffer, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferDataEXTNative(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[2])(buffer, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[2])(buffer, internalformat, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferDataEXT(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferDataEXTNative(buffer, internalformat, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferSubDataEXTNative(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[3])(buffer, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[3])(buffer, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferSubDataEXT(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferSubDataEXTNative(buffer, internalformat, offset, size, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientAttribDefaultEXTNative(GLClientAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[4])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[4])(mask);
			#endif
		}

		public static void ClientAttribDefaultEXT(GLClientAttribMask mask)
		{
			ClientAttribDefaultEXTNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[5])(texunit, target, level, internalformat, width, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[5])(texunit, target, level, internalformat, width, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[6])(texunit, target, level, internalformat, width, height, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[6])(texunit, target, level, internalformat, width, height, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[7])(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[7])(texunit, target, level, internalformat, width, height, depth, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[8])(texunit, target, level, xoffset, width, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[8])(texunit, target, level, xoffset, width, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[9])(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[9])(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[10])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[10])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedMultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[11])(texture, target, level, internalformat, width, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[11])(texture, target, level, internalformat, width, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			CompressedTextureImage1DEXTNative(texture, target, level, internalformat, width, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[12])(texture, target, level, internalformat, width, height, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[12])(texture, target, level, internalformat, width, height, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			CompressedTextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage3DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[13])(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[13])(texture, target, level, internalformat, width, height, depth, border, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			CompressedTextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[14])(texture, target, level, xoffset, width, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[14])(texture, target, level, xoffset, width, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[15])(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[15])(texture, target, level, xoffset, yoffset, width, height, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[16])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[16])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)bits);
			#endif
		}

		public static void CompressedTextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[17])(texunit, target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[17])(texunit, target, level, internalformat, x, y, width, border);
			#endif
		}

		public static void CopyMultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyMultiTexImage1DEXTNative(texunit, target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[18])(texunit, target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[18])(texunit, target, level, internalformat, x, y, width, height, border);
			#endif
		}

		public static void CopyMultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyMultiTexImage2DEXTNative(texunit, target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, void>)funcTable[19])(texunit, target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, void>)funcTable[19])(texunit, target, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyMultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[20])(texunit, target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[20])(texunit, target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyMultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[21])(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[21])(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyMultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[22])(texture, target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[22])(texture, target, level, internalformat, x, y, width, border);
			#endif
		}

		public static void CopyTextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTextureImage1DEXTNative(texture, target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[23])(texture, target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[23])(texture, target, level, internalformat, x, y, width, height, border);
			#endif
		}

		public static void CopyTextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTextureImage2DEXTNative(texture, target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, void>)funcTable[24])(texture, target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, void>)funcTable[24])(texture, target, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyTextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTextureSubImage1DEXTNative(texture, target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[25])(texture, target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[25])(texture, target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[26])(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[26])(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateIndexedEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[27])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[27])(array, index);
			#endif
		}

		public static void DisableClientStateIndexedEXT(GLEnableCap array, uint index)
		{
			DisableClientStateIndexedEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateiEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[28])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[28])(array, index);
			#endif
		}

		public static void DisableClientStateiEXT(GLEnableCap array, uint index)
		{
			DisableClientStateiEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[29])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[29])(target, index);
			#endif
		}

		public static void DisableIndexedEXT(GLEnableCap target, uint index)
		{
			DisableIndexedEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayAttribEXTNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[30])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[30])(vaobj, index);
			#endif
		}

		public static void DisableVertexArrayAttribEXT(uint vaobj, uint index)
		{
			DisableVertexArrayAttribEXTNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayEXTNative(uint vaobj, GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[31])(vaobj, array);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[31])(vaobj, array);
			#endif
		}

		public static void DisableVertexArrayEXT(uint vaobj, GLEnableCap array)
		{
			DisableVertexArrayEXTNative(vaobj, array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateIndexedEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[32])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[32])(array, index);
			#endif
		}

		public static void EnableClientStateIndexedEXT(GLEnableCap array, uint index)
		{
			EnableClientStateIndexedEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateiEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[33])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[33])(array, index);
			#endif
		}

		public static void EnableClientStateiEXT(GLEnableCap array, uint index)
		{
			EnableClientStateiEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[34])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[34])(target, index);
			#endif
		}

		public static void EnableIndexedEXT(GLEnableCap target, uint index)
		{
			EnableIndexedEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayAttribEXTNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[35])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[35])(vaobj, index);
			#endif
		}

		public static void EnableVertexArrayAttribEXT(uint vaobj, uint index)
		{
			EnableVertexArrayAttribEXTNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayEXTNative(uint vaobj, GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[36])(vaobj, array);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[36])(vaobj, array);
			#endif
		}

		public static void EnableVertexArrayEXT(uint vaobj, GLEnableCap array)
		{
			EnableVertexArrayEXTNative(vaobj, array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedNamedBufferRangeEXTNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[37])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[37])(buffer, offset, length);
			#endif
		}

		public static void FlushMappedNamedBufferRangeEXT(uint buffer, nint offset, nint length)
		{
			FlushMappedNamedBufferRangeEXTNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferDrawBufferEXTNative(uint framebuffer, GLDrawBufferMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLDrawBufferMode, void>)funcTable[38])(framebuffer, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLDrawBufferMode, void>)funcTable[38])(framebuffer, mode);
			#endif
		}

		public static void FramebufferDrawBufferEXT(uint framebuffer, GLDrawBufferMode mode)
		{
			FramebufferDrawBufferEXTNative(framebuffer, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferDrawBuffersEXTNative(uint framebuffer, int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLDrawBufferMode, void>)funcTable[39])(framebuffer, n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLDrawBufferMode, void>)funcTable[39])(framebuffer, n, bufs);
			#endif
		}

		public static void FramebufferDrawBuffersEXT(uint framebuffer, int n, GLDrawBufferMode bufs)
		{
			FramebufferDrawBuffersEXTNative(framebuffer, n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferReadBufferEXTNative(uint framebuffer, GLReadBufferMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLReadBufferMode, void>)funcTable[40])(framebuffer, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLReadBufferMode, void>)funcTable[40])(framebuffer, mode);
			#endif
		}

		public static void FramebufferReadBufferEXT(uint framebuffer, GLReadBufferMode mode)
		{
			FramebufferReadBufferEXTNative(framebuffer, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMultiTexMipmapEXTNative(GLTextureUnit texunit, GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, void>)funcTable[41])(texunit, target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, void>)funcTable[41])(texunit, target);
			#endif
		}

		public static void GenerateMultiTexMipmapEXT(GLTextureUnit texunit, GLTextureTarget target)
		{
			GenerateMultiTexMipmapEXTNative(texunit, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapEXTNative(uint texture, GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, void>)funcTable[42])(texture, target);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, void>)funcTable[42])(texture, target);
			#endif
		}

		public static void GenerateTextureMipmapEXT(uint texture, GLTextureTarget target)
		{
			GenerateTextureMipmapEXTNative(texture, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanIndexedvEXTNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[43])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[43])(target, index, (nint)data);
			#endif
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleanIndexedvEXTNative(target, index, data);
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanIndexedvEXTNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanIndexedvEXTNative(target, index, pdata0);
			}
		}

		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleanIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedMultiTexImageEXTNative(GLTextureUnit texunit, GLTextureTarget target, int lod, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, void*, void>)funcTable[44])(texunit, target, lod, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, nint, void>)funcTable[44])(texunit, target, lod, (nint)img);
			#endif
		}

		public static void GetCompressedMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int lod, void* img)
		{
			GetCompressedMultiTexImageEXTNative(texunit, target, lod, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureImageEXTNative(uint texture, GLTextureTarget target, int lod, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, void*, void>)funcTable[45])(texture, target, lod, img);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, nint, void>)funcTable[45])(texture, target, lod, (nint)img);
			#endif
		}

		public static void GetCompressedTextureImageEXT(uint texture, GLTextureTarget target, int lod, void* img)
		{
			GetCompressedTextureImageEXTNative(texture, target, lod, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoubleIndexedvEXTNative(GLGetPName target, uint index, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[46])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[46])(target, index, (nint)data);
			#endif
		}

		public static void GetDoubleIndexedvEXT(GLGetPName target, uint index, double* data)
		{
			GetDoubleIndexedvEXTNative(target, index, data);
		}

		public static void GetDoubleIndexedvEXT(GLGetPName target, uint index, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoubleIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublei_vEXTNative(GLGetPName pname, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[47])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[47])(pname, index, (nint)@params);
			#endif
		}

		public static void GetDoublei_vEXT(GLGetPName pname, uint index, double* @params)
		{
			GetDoublei_vEXTNative(pname, index, @params);
		}

		public static void GetDoublei_vEXT(GLGetPName pname, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetDoublei_vEXTNative(pname, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloatIndexedvEXTNative(GLGetPName target, uint index, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[48])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[48])(target, index, (nint)data);
			#endif
		}

		public static void GetFloatIndexedvEXT(GLGetPName target, uint index, float* data)
		{
			GetFloatIndexedvEXTNative(target, index, data);
		}

		public static void GetFloatIndexedvEXT(GLGetPName target, uint index, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloatIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloati_vEXTNative(GLGetPName pname, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[49])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[49])(pname, index, (nint)@params);
			#endif
		}

		public static void GetFloati_vEXT(GLGetPName pname, uint index, float* @params)
		{
			GetFloati_vEXTNative(pname, index, @params);
		}

		public static void GetFloati_vEXT(GLGetPName pname, uint index, out float @params)
		{
			float pparams;
			GetFloati_vEXTNative(pname, index, &pparams);
			@params = pparams;
		}

		public static void GetFloati_vEXT(GLGetPName pname, uint index, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetFloati_vEXTNative(pname, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferParameterivEXTNative(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[50])(framebuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[50])(framebuffer, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			GetFramebufferParameterivEXTNative(framebuffer, pname, @params);
		}

		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, out int @params)
		{
			int pparams;
			GetFramebufferParameterivEXTNative(framebuffer, pname, &pparams);
			@params = pparams;
		}

		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetFramebufferParameterivEXTNative(framebuffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegerIndexedvEXTNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[51])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[51])(target, index, (nint)data);
			#endif
		}

		public static void GetIntegerIndexedvEXT(GLGetPName target, uint index, int* data)
		{
			GetIntegerIndexedvEXTNative(target, index, data);
		}

		public static void GetIntegerIndexedvEXT(GLGetPName target, uint index, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegerIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexEnvfvEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[52])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[52])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			GetMultiTexEnvfvEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, out float @params)
		{
			float pparams;
			GetMultiTexEnvfvEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetMultiTexEnvfvEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexEnvivEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[53])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[53])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetMultiTexEnvivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, out int @params)
		{
			int pparams;
			GetMultiTexEnvivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMultiTexEnvivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGendvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[54])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[54])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			GetMultiTexGendvEXTNative(texunit, coord, pname, @params);
		}

		public static void GetMultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetMultiTexGendvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGenfvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[55])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[55])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			GetMultiTexGenfvEXTNative(texunit, coord, pname, @params);
		}

		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, out float @params)
		{
			float pparams;
			GetMultiTexGenfvEXTNative(texunit, coord, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetMultiTexGenfvEXTNative(texunit, coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGenivEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[56])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[56])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			GetMultiTexGenivEXTNative(texunit, coord, pname, @params);
		}

		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, out int @params)
		{
			int pparams;
			GetMultiTexGenivEXTNative(texunit, coord, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMultiTexGenivEXTNative(texunit, coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexImageEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[57])(texunit, target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[57])(texunit, target, level, format, type, (nint)pixels);
			#endif
		}

		public static void GetMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetMultiTexImageEXTNative(texunit, target, level, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexLevelParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[58])(texunit, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[58])(texunit, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, @params);
		}

		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexLevelParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[59])(texunit, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[59])(texunit, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, @params);
		}

		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterIivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[60])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[60])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexParameterIivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetMultiTexParameterIivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMultiTexParameterIivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterIuivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[61])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[61])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetMultiTexParameterIuivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, out uint @params)
		{
			uint pparams;
			GetMultiTexParameterIuivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetMultiTexParameterIuivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[62])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[62])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetMultiTexParameterfvEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetMultiTexParameterfvEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetMultiTexParameterfvEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[63])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[63])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexParameterivEXTNative(texunit, target, pname, @params);
		}

		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetMultiTexParameterivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMultiTexParameterivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameterivEXTNative(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, int*, void>)funcTable[64])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[64])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			GetNamedBufferParameterivEXTNative(buffer, pname, @params);
		}

		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, out int @params)
		{
			int pparams;
			GetNamedBufferParameterivEXTNative(buffer, pname, &pparams);
			@params = pparams;
		}

		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedBufferParameterivEXTNative(buffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferPointervEXTNative(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, void**, void>)funcTable[65])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, nint, void>)funcTable[65])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferPointervEXT(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			GetNamedBufferPointervEXTNative(buffer, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferSubDataEXTNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[66])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[66])(buffer, offset, size, (nint)data);
			#endif
		}

		public static void GetNamedBufferSubDataEXT(uint buffer, nint offset, nint size, void* data)
		{
			GetNamedBufferSubDataEXTNative(buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferAttachmentParameterivEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[67])(framebuffer, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[67])(framebuffer, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, @params);
		}

		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, out int @params)
		{
			int pparams;
			GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, &pparams);
			@params = pparams;
		}

		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferParameterivEXTNative(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[68])(framebuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[68])(framebuffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			GetNamedFramebufferParameterivEXTNative(framebuffer, pname, @params);
		}

		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, out int @params)
		{
			int pparams;
			GetNamedFramebufferParameterivEXTNative(framebuffer, pname, &pparams);
			@params = pparams;
		}

		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedFramebufferParameterivEXTNative(framebuffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterIivEXTNative(uint program, GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int*, void>)funcTable[69])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[69])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, int* @params)
		{
			GetNamedProgramLocalParameterIivEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, out int @params)
		{
			int pparams;
			GetNamedProgramLocalParameterIivEXTNative(program, target, index, &pparams);
			@params = pparams;
		}

		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedProgramLocalParameterIivEXTNative(program, target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterIuivEXTNative(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint*, void>)funcTable[70])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[70])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			GetNamedProgramLocalParameterIuivEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, out uint @params)
		{
			uint pparams;
			GetNamedProgramLocalParameterIuivEXTNative(program, target, index, &pparams);
			@params = pparams;
		}

		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetNamedProgramLocalParameterIuivEXTNative(program, target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterdvEXTNative(uint program, GLProgramTarget target, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double*, void>)funcTable[71])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[71])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterdvEXT(uint program, GLProgramTarget target, uint index, double* @params)
		{
			GetNamedProgramLocalParameterdvEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterdvEXT(uint program, GLProgramTarget target, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterdvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterfvEXTNative(uint program, GLProgramTarget target, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float*, void>)funcTable[72])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[72])(program, target, index, (nint)@params);
			#endif
		}

		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, float* @params)
		{
			GetNamedProgramLocalParameterfvEXTNative(program, target, index, @params);
		}

		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, out float @params)
		{
			float pparams;
			GetNamedProgramLocalParameterfvEXTNative(program, target, index, &pparams);
			@params = pparams;
		}

		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetNamedProgramLocalParameterfvEXTNative(program, target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramStringEXTNative(uint program, GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramStringProperty, void*, void>)funcTable[73])(program, target, pname, str);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramStringProperty, nint, void>)funcTable[73])(program, target, pname, (nint)str);
			#endif
		}

		public static void GetNamedProgramStringEXT(uint program, GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			GetNamedProgramStringEXTNative(program, target, pname, str);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramivEXTNative(uint program, GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramPropertyARB, int*, void>)funcTable[74])(program, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramPropertyARB, nint, void>)funcTable[74])(program, target, pname, (nint)@params);
			#endif
		}

		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			GetNamedProgramivEXTNative(program, target, pname, @params);
		}

		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, out int @params)
		{
			int pparams;
			GetNamedProgramivEXTNative(program, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedProgramivEXTNative(program, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedRenderbufferParameterivEXTNative(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, int*, void>)funcTable[75])(renderbuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, nint, void>)funcTable[75])(renderbuffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, @params);
		}

		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, out int @params)
		{
			int pparams;
			GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, &pparams);
			@params = pparams;
		}

		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointerIndexedvEXTNative(GLEnum target, uint index, void** data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void**, void>)funcTable[76])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[76])(target, index, (nint)data);
			#endif
		}

		public static void GetPointerIndexedvEXT(GLEnum target, uint index, void** data)
		{
			GetPointerIndexedvEXTNative(target, index, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointeri_vEXTNative(GLEnum pname, uint index, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void**, void>)funcTable[77])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[77])(pname, index, (nint)@params);
			#endif
		}

		public static void GetPointeri_vEXT(GLEnum pname, uint index, void** @params)
		{
			GetPointeri_vEXTNative(pname, index, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureImageEXTNative(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[78])(texture, target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[78])(texture, target, level, format, type, (nint)pixels);
			#endif
		}

		public static void GetTextureImageEXT(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetTextureImageEXTNative(texture, target, level, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterfvEXTNative(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[79])(texture, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[79])(texture, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTextureLevelParameterfvEXTNative(texture, target, level, pname, @params);
		}

		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTextureLevelParameterfvEXTNative(texture, target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTextureLevelParameterfvEXTNative(texture, target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterivEXTNative(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[80])(texture, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[80])(texture, target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTextureLevelParameterivEXTNative(texture, target, level, pname, @params);
		}

		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTextureLevelParameterivEXTNative(texture, target, level, pname, &pparams);
			@params = pparams;
		}

		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTextureLevelParameterivEXTNative(texture, target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[81])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[81])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterIivEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTextureParameterIivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTextureParameterIivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIuivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[82])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[82])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTextureParameterIuivEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, out uint @params)
		{
			uint pparams;
			GetTextureParameterIuivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetTextureParameterIuivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterfvEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[83])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[83])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTextureParameterfvEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTextureParameterfvEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTextureParameterfvEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[84])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[84])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterivEXTNative(texture, target, pname, @params);
		}

		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTextureParameterivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTextureParameterivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIntegeri_vEXTNative(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, int*, void>)funcTable[85])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[85])(vaobj, index, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIntegeri_vEXTNative(vaobj, index, pname, param);
		}

		public static void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, out int param)
		{
			int pparam;
			GetVertexArrayIntegeri_vEXTNative(vaobj, index, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIntegervEXTNative(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, int*, void>)funcTable[86])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[86])(vaobj, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayIntegervEXT(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIntegervEXTNative(vaobj, pname, param);
		}

		public static void GetVertexArrayIntegervEXT(uint vaobj, GLVertexArrayPName pname, out int param)
		{
			int pparam;
			GetVertexArrayIntegervEXTNative(vaobj, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayPointeri_vEXTNative(uint vaobj, uint index, GLVertexArrayPName pname, void** param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, void**, void>)funcTable[87])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[87])(vaobj, index, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayPointeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, void** param)
		{
			GetVertexArrayPointeri_vEXTNative(vaobj, index, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayPointervEXTNative(uint vaobj, GLVertexArrayPName pname, void** param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, void**, void>)funcTable[88])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[88])(vaobj, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayPointervEXT(uint vaobj, GLVertexArrayPName pname, void** param)
		{
			GetVertexArrayPointervEXTNative(vaobj, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnabledIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[89])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[89])(target, index);
			#endif
		}

		public static bool IsEnabledIndexedEXT(GLEnableCap target, uint index)
		{
			byte ret = IsEnabledIndexedEXTNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapNamedBufferEXTNative(uint buffer, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, void*>)funcTable[90])(buffer, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, nint>)funcTable[90])(buffer, access);
			#endif
		}

		public static void* MapNamedBufferEXT(uint buffer, GLBufferAccessARB access)
		{
			void* ret = MapNamedBufferEXTNative(buffer, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapNamedBufferRangeEXTNative(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, void*>)funcTable[91])(buffer, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, nint>)funcTable[91])(buffer, offset, length, access);
			#endif
		}

		public static void* MapNamedBufferRangeEXT(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapNamedBufferRangeEXTNative(buffer, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixFrustumEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[92])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[92])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixFrustumEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixFrustumEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadIdentityEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[93])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[93])(mode);
			#endif
		}

		public static void MatrixLoadIdentityEXT(GLMatrixMode mode)
		{
			MatrixLoadIdentityEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[94])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[94])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoadTransposedEXTNative(mode, m);
		}

		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoadTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[95])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[95])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadTransposefEXTNative(mode, m);
		}

		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoaddEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[96])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[96])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoaddEXTNative(mode, m);
		}

		public static void MatrixLoaddEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoaddEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[97])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[97])(mode, (nint)m);
			#endif
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadfEXTNative(mode, m);
		}

		public static void MatrixLoadfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[98])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[98])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultTransposedEXTNative(mode, m);
		}

		public static void MatrixMultTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[99])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[99])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultTransposefEXTNative(mode, m);
		}

		public static void MatrixMultTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultdEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[100])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[100])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultdEXTNative(mode, m);
		}

		public static void MatrixMultdEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultdEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[101])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[101])(mode, (nint)m);
			#endif
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultfEXTNative(mode, m);
		}

		public static void MatrixMultfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixOrthoEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[102])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[102])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		public static void MatrixOrthoEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixOrthoEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPopEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[103])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[103])(mode);
			#endif
		}

		public static void MatrixPopEXT(GLMatrixMode mode)
		{
			MatrixPopEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPushEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[104])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[104])(mode);
			#endif
		}

		public static void MatrixPushEXT(GLMatrixMode mode)
		{
			MatrixPushEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatedEXTNative(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[105])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[105])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatedEXT(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			MatrixRotatedEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatefEXTNative(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[106])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[106])(mode, angle, x, y, z);
			#endif
		}

		public static void MatrixRotatefEXT(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			MatrixRotatefEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScaledEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[107])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[107])(mode, x, y, z);
			#endif
		}

		public static void MatrixScaledEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixScaledEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScalefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[108])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[108])(mode, x, y, z);
			#endif
		}

		public static void MatrixScalefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixScalefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatedEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[109])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[109])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatedEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixTranslatedEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[110])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[110])(mode, x, y, z);
			#endif
		}

		public static void MatrixTranslatefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixTranslatefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexBufferEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLInternalFormat, uint, void>)funcTable[111])(texunit, target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLInternalFormat, uint, void>)funcTable[111])(texunit, target, internalformat, buffer);
			#endif
		}

		public static void MultiTexBufferEXT(GLTextureUnit texunit, GLTextureTarget target, GLInternalFormat internalformat, uint buffer)
		{
			MultiTexBufferEXTNative(texunit, target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordPointerEXTNative(GLTextureUnit texunit, int size, GLTexCoordPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, GLTexCoordPointerType, int, void*, void>)funcTable[112])(texunit, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, GLTexCoordPointerType, int, nint, void>)funcTable[112])(texunit, size, type, stride, (nint)pointer);
			#endif
		}

		public static void MultiTexCoordPointerEXT(GLTextureUnit texunit, int size, GLTexCoordPointerType type, int stride, void* pointer)
		{
			MultiTexCoordPointerEXTNative(texunit, size, type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnvfEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float, void>)funcTable[113])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float, void>)funcTable[113])(texunit, target, pname, param);
			#endif
		}

		public static void MultiTexEnvfEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float param)
		{
			MultiTexEnvfEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnvfvEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[114])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[114])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void MultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			MultiTexEnvfvEXTNative(texunit, target, pname, @params);
		}

		public static void MultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, out float @params)
		{
			float pparams;
			MultiTexEnvfvEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				MultiTexEnvfvEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnviEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[115])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[115])(texunit, target, pname, param);
			#endif
		}

		public static void MultiTexEnviEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			MultiTexEnviEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnvivEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[116])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[116])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void MultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			MultiTexEnvivEXTNative(texunit, target, pname, @params);
		}

		public static void MultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, out int @params)
		{
			int pparams;
			MultiTexEnvivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				MultiTexEnvivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGendEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double, void>)funcTable[117])(texunit, coord, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double, void>)funcTable[117])(texunit, coord, pname, param);
			#endif
		}

		public static void MultiTexGendEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double param)
		{
			MultiTexGendEXTNative(texunit, coord, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGendvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[118])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[118])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void MultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			MultiTexGendvEXTNative(texunit, coord, pname, @params);
		}

		public static void MultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				MultiTexGendvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGenfEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float, void>)funcTable[119])(texunit, coord, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float, void>)funcTable[119])(texunit, coord, pname, param);
			#endif
		}

		public static void MultiTexGenfEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float param)
		{
			MultiTexGenfEXTNative(texunit, coord, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGenfvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[120])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[120])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void MultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			MultiTexGenfvEXTNative(texunit, coord, pname, @params);
		}

		public static void MultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, out float @params)
		{
			float pparams;
			MultiTexGenfvEXTNative(texunit, coord, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				MultiTexGenfvEXTNative(texunit, coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGeniEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int, void>)funcTable[121])(texunit, coord, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int, void>)funcTable[121])(texunit, coord, pname, param);
			#endif
		}

		public static void MultiTexGeniEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int param)
		{
			MultiTexGeniEXTNative(texunit, coord, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGenivEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[122])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[122])(texunit, coord, pname, (nint)@params);
			#endif
		}

		public static void MultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			MultiTexGenivEXTNative(texunit, coord, pname, @params);
		}

		public static void MultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, out int @params)
		{
			int pparams;
			MultiTexGenivEXTNative(texunit, coord, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				MultiTexGenivEXTNative(texunit, coord, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[123])(texunit, target, level, internalformat, width, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[123])(texunit, target, level, internalformat, width, border, format, type, (nint)pixels);
			#endif
		}

		public static void MultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[124])(texunit, target, level, internalformat, width, height, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[124])(texunit, target, level, internalformat, width, height, border, format, type, (nint)pixels);
			#endif
		}

		public static void MultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[125])(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[125])(texunit, target, level, internalformat, width, height, depth, border, format, type, (nint)pixels);
			#endif
		}

		public static void MultiTexImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterIivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[126])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[126])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void MultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			MultiTexParameterIivEXTNative(texunit, target, pname, @params);
		}

		public static void MultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			MultiTexParameterIivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				MultiTexParameterIivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterIuivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[127])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[127])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void MultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			MultiTexParameterIuivEXTNative(texunit, target, pname, @params);
		}

		public static void MultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, out uint @params)
		{
			uint pparams;
			MultiTexParameterIuivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				MultiTexParameterIuivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterfEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[128])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[128])(texunit, target, pname, param);
			#endif
		}

		public static void MultiTexParameterfEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			MultiTexParameterfEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, float*, void>)funcTable[129])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[129])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void MultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			MultiTexParameterfvEXTNative(texunit, target, pname, @params);
		}

		public static void MultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, out float @params)
		{
			float pparams;
			MultiTexParameterfvEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				MultiTexParameterfvEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameteriEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[130])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[130])(texunit, target, pname, param);
			#endif
		}

		public static void MultiTexParameteriEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			MultiTexParameteriEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[131])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[131])(texunit, target, pname, (nint)@params);
			#endif
		}

		public static void MultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			MultiTexParameterivEXTNative(texunit, target, pname, @params);
		}

		public static void MultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			MultiTexParameterivEXTNative(texunit, target, pname, &pparams);
			@params = pparams;
		}

		public static void MultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				MultiTexParameterivEXTNative(texunit, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexRenderbufferEXTNative(GLTextureUnit texunit, GLTextureTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[132])(texunit, target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[132])(texunit, target, renderbuffer);
			#endif
		}

		public static void MultiTexRenderbufferEXT(GLTextureUnit texunit, GLTextureTarget target, uint renderbuffer)
		{
			MultiTexRenderbufferEXTNative(texunit, target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[133])(texunit, target, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[133])(texunit, target, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		public static void MultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[134])(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[134])(texunit, target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		public static void MultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[135])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[135])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		public static void MultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferDataEXTNative(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLVertexBufferObjectUsage, void>)funcTable[136])(buffer, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLVertexBufferObjectUsage, void>)funcTable[136])(buffer, size, (nint)data, usage);
			#endif
		}

		public static void NamedBufferDataEXT(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			NamedBufferDataEXTNative(buffer, size, data, usage);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferStorageEXTNative(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLBufferStorageMask, void>)funcTable[137])(buffer, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLBufferStorageMask, void>)funcTable[137])(buffer, size, (nint)data, flags);
			#endif
		}

		public static void NamedBufferStorageEXT(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			NamedBufferStorageEXTNative(buffer, size, data, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferSubDataEXTNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[138])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[138])(buffer, offset, size, (nint)data);
			#endif
		}

		public static void NamedBufferSubDataEXT(uint buffer, nint offset, nint size, void* data)
		{
			NamedBufferSubDataEXTNative(buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedCopyBufferSubDataEXTNative(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[139])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[139])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#endif
		}

		public static void NamedCopyBufferSubDataEXT(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			NamedCopyBufferSubDataEXTNative(readBuffer, writeBuffer, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferParameteriEXTNative(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[140])(framebuffer, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[140])(framebuffer, pname, param);
			#endif
		}

		public static void NamedFramebufferParameteriEXT(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			NamedFramebufferParameteriEXTNative(framebuffer, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferRenderbufferEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[141])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[141])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		public static void NamedFramebufferRenderbufferEXT(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			NamedFramebufferRenderbufferEXTNative(framebuffer, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTexture1DEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[142])(framebuffer, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[142])(framebuffer, attachment, textarget, texture, level);
			#endif
		}

		public static void NamedFramebufferTexture1DEXT(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			NamedFramebufferTexture1DEXTNative(framebuffer, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTexture2DEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[143])(framebuffer, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[143])(framebuffer, attachment, textarget, texture, level);
			#endif
		}

		public static void NamedFramebufferTexture2DEXT(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			NamedFramebufferTexture2DEXTNative(framebuffer, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTexture3DEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[144])(framebuffer, attachment, textarget, texture, level, zoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[144])(framebuffer, attachment, textarget, texture, level, zoffset);
			#endif
		}

		public static void NamedFramebufferTexture3DEXT(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			NamedFramebufferTexture3DEXTNative(framebuffer, attachment, textarget, texture, level, zoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureEXTNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[145])(framebuffer, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[145])(framebuffer, attachment, texture, level);
			#endif
		}

		public static void NamedFramebufferTextureEXT(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			NamedFramebufferTextureEXTNative(framebuffer, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureFaceEXTNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[146])(framebuffer, attachment, texture, level, face);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[146])(framebuffer, attachment, texture, level, face);
			#endif
		}

		public static void NamedFramebufferTextureFaceEXT(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			NamedFramebufferTextureFaceEXTNative(framebuffer, attachment, texture, level, face);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureLayerEXTNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[147])(framebuffer, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[147])(framebuffer, attachment, texture, level, layer);
			#endif
		}

		public static void NamedFramebufferTextureLayerEXT(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			NamedFramebufferTextureLayerEXTNative(framebuffer, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4dEXTNative(uint program, GLProgramTarget target, uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double, double, double, double, void>)funcTable[148])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double, double, double, double, void>)funcTable[148])(program, target, index, x, y, z, w);
			#endif
		}

		public static void NamedProgramLocalParameter4dEXT(uint program, GLProgramTarget target, uint index, double x, double y, double z, double w)
		{
			NamedProgramLocalParameter4dEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4dvEXTNative(uint program, GLProgramTarget target, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double*, void>)funcTable[149])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[149])(program, target, index, (nint)@params);
			#endif
		}

		public static void NamedProgramLocalParameter4dvEXT(uint program, GLProgramTarget target, uint index, double* @params)
		{
			NamedProgramLocalParameter4dvEXTNative(program, target, index, @params);
		}

		public static void NamedProgramLocalParameter4dvEXT(uint program, GLProgramTarget target, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				NamedProgramLocalParameter4dvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4fEXTNative(uint program, GLProgramTarget target, uint index, float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float, float, float, float, void>)funcTable[150])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float, float, float, float, void>)funcTable[150])(program, target, index, x, y, z, w);
			#endif
		}

		public static void NamedProgramLocalParameter4fEXT(uint program, GLProgramTarget target, uint index, float x, float y, float z, float w)
		{
			NamedProgramLocalParameter4fEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4fvEXTNative(uint program, GLProgramTarget target, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float*, void>)funcTable[151])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[151])(program, target, index, (nint)@params);
			#endif
		}

		public static void NamedProgramLocalParameter4fvEXT(uint program, GLProgramTarget target, uint index, float* @params)
		{
			NamedProgramLocalParameter4fvEXTNative(program, target, index, @params);
		}

		public static void NamedProgramLocalParameter4fvEXT(uint program, GLProgramTarget target, uint index, out float @params)
		{
			float pparams;
			NamedProgramLocalParameter4fvEXTNative(program, target, index, &pparams);
			@params = pparams;
		}

		public static void NamedProgramLocalParameter4fvEXT(uint program, GLProgramTarget target, uint index, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				NamedProgramLocalParameter4fvEXTNative(program, target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4iEXTNative(uint program, GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, int, int, int, void>)funcTable[152])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, int, int, int, void>)funcTable[152])(program, target, index, x, y, z, w);
			#endif
		}

		public static void NamedProgramLocalParameterI4iEXT(uint program, GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			NamedProgramLocalParameterI4iEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4ivEXTNative(uint program, GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int*, void>)funcTable[153])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[153])(program, target, index, (nint)@params);
			#endif
		}

		public static void NamedProgramLocalParameterI4ivEXT(uint program, GLProgramTarget target, uint index, int* @params)
		{
			NamedProgramLocalParameterI4ivEXTNative(program, target, index, @params);
		}

		public static void NamedProgramLocalParameterI4ivEXT(uint program, GLProgramTarget target, uint index, out int @params)
		{
			int pparams;
			NamedProgramLocalParameterI4ivEXTNative(program, target, index, &pparams);
			@params = pparams;
		}

		public static void NamedProgramLocalParameterI4ivEXT(uint program, GLProgramTarget target, uint index, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				NamedProgramLocalParameterI4ivEXTNative(program, target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4uiEXTNative(uint program, GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[154])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[154])(program, target, index, x, y, z, w);
			#endif
		}

		public static void NamedProgramLocalParameterI4uiEXT(uint program, GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			NamedProgramLocalParameterI4uiEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4uivEXTNative(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint*, void>)funcTable[155])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[155])(program, target, index, (nint)@params);
			#endif
		}

		public static void NamedProgramLocalParameterI4uivEXT(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			NamedProgramLocalParameterI4uivEXTNative(program, target, index, @params);
		}

		public static void NamedProgramLocalParameterI4uivEXT(uint program, GLProgramTarget target, uint index, out uint @params)
		{
			uint pparams;
			NamedProgramLocalParameterI4uivEXTNative(program, target, index, &pparams);
			@params = pparams;
		}

		public static void NamedProgramLocalParameterI4uivEXT(uint program, GLProgramTarget target, uint index, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				NamedProgramLocalParameterI4uivEXTNative(program, target, index, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameters4fvEXTNative(uint program, GLProgramTarget target, uint index, int count, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, float*, void>)funcTable[156])(program, target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, nint, void>)funcTable[156])(program, target, index, count, (nint)@params);
			#endif
		}

		public static void NamedProgramLocalParameters4fvEXT(uint program, GLProgramTarget target, uint index, int count, float* @params)
		{
			NamedProgramLocalParameters4fvEXTNative(program, target, index, count, @params);
		}

		public static void NamedProgramLocalParameters4fvEXT(uint program, GLProgramTarget target, uint index, int count, out float @params)
		{
			float pparams;
			NamedProgramLocalParameters4fvEXTNative(program, target, index, count, &pparams);
			@params = pparams;
		}

		public static void NamedProgramLocalParameters4fvEXT(uint program, GLProgramTarget target, uint index, int count, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				NamedProgramLocalParameters4fvEXTNative(program, target, index, count, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParametersI4ivEXTNative(uint program, GLProgramTarget target, uint index, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, int*, void>)funcTable[157])(program, target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, nint, void>)funcTable[157])(program, target, index, count, (nint)@params);
			#endif
		}

		public static void NamedProgramLocalParametersI4ivEXT(uint program, GLProgramTarget target, uint index, int count, int* @params)
		{
			NamedProgramLocalParametersI4ivEXTNative(program, target, index, count, @params);
		}

		public static void NamedProgramLocalParametersI4ivEXT(uint program, GLProgramTarget target, uint index, int count, out int @params)
		{
			int pparams;
			NamedProgramLocalParametersI4ivEXTNative(program, target, index, count, &pparams);
			@params = pparams;
		}

		public static void NamedProgramLocalParametersI4ivEXT(uint program, GLProgramTarget target, uint index, int count, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				NamedProgramLocalParametersI4ivEXTNative(program, target, index, count, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParametersI4uivEXTNative(uint program, GLProgramTarget target, uint index, int count, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, uint*, void>)funcTable[158])(program, target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, nint, void>)funcTable[158])(program, target, index, count, (nint)@params);
			#endif
		}

		public static void NamedProgramLocalParametersI4uivEXT(uint program, GLProgramTarget target, uint index, int count, uint* @params)
		{
			NamedProgramLocalParametersI4uivEXTNative(program, target, index, count, @params);
		}

		public static void NamedProgramLocalParametersI4uivEXT(uint program, GLProgramTarget target, uint index, int count, out uint @params)
		{
			uint pparams;
			NamedProgramLocalParametersI4uivEXTNative(program, target, index, count, &pparams);
			@params = pparams;
		}

		public static void NamedProgramLocalParametersI4uivEXT(uint program, GLProgramTarget target, uint index, int count, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				NamedProgramLocalParametersI4uivEXTNative(program, target, index, count, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramStringEXTNative(uint program, GLProgramTarget target, GLProgramFormat format, int len, void* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramFormat, int, void*, void>)funcTable[159])(program, target, format, len, str);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramFormat, int, nint, void>)funcTable[159])(program, target, format, len, (nint)str);
			#endif
		}

		public static void NamedProgramStringEXT(uint program, GLProgramTarget target, GLProgramFormat format, int len, void* str)
		{
			NamedProgramStringEXTNative(program, target, format, len, str);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedRenderbufferStorageEXTNative(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[160])(renderbuffer, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[160])(renderbuffer, internalformat, width, height);
			#endif
		}

		public static void NamedRenderbufferStorageEXT(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageEXTNative(renderbuffer, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedRenderbufferStorageMultisampleCoverageEXTNative(uint renderbuffer, int coverageSamples, int colorSamples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, GLInternalFormat, int, int, void>)funcTable[161])(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, GLInternalFormat, int, int, void>)funcTable[161])(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
			#endif
		}

		public static void NamedRenderbufferStorageMultisampleCoverageEXT(uint renderbuffer, int coverageSamples, int colorSamples, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageMultisampleCoverageEXTNative(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedRenderbufferStorageMultisampleEXTNative(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[162])(renderbuffer, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[162])(renderbuffer, samples, internalformat, width, height);
			#endif
		}

		public static void NamedRenderbufferStorageMultisampleEXT(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageMultisampleEXTNative(renderbuffer, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1dEXTNative(uint program, int location, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, void>)funcTable[163])(program, location, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, void>)funcTable[163])(program, location, x);
			#endif
		}

		public static void ProgramUniform1dEXT(uint program, int location, double x)
		{
			ProgramUniform1dEXTNative(program, location, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[164])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[164])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform1dvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform1dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform1dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1fEXTNative(uint program, int location, float v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[165])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[165])(program, location, v0);
			#endif
		}

		public static void ProgramUniform1fEXT(uint program, int location, float v0)
		{
			ProgramUniform1fEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[166])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[166])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform1fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform1fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform1fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1iEXTNative(uint program, int location, int v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[167])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[167])(program, location, v0);
			#endif
		}

		public static void ProgramUniform1iEXT(uint program, int location, int v0)
		{
			ProgramUniform1iEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[168])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[168])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform1ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform1ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform1ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1uiEXTNative(uint program, int location, uint v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[169])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[169])(program, location, v0);
			#endif
		}

		public static void ProgramUniform1uiEXT(uint program, int location, uint v0)
		{
			ProgramUniform1uiEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[170])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[170])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform1uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform1uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform1uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2dEXTNative(uint program, int location, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, void>)funcTable[171])(program, location, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, void>)funcTable[171])(program, location, x, y);
			#endif
		}

		public static void ProgramUniform2dEXT(uint program, int location, double x, double y)
		{
			ProgramUniform2dEXTNative(program, location, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[172])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[172])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform2dvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform2dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform2dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2fEXTNative(uint program, int location, float v0, float v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[173])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[173])(program, location, v0, v1);
			#endif
		}

		public static void ProgramUniform2fEXT(uint program, int location, float v0, float v1)
		{
			ProgramUniform2fEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[174])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[174])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform2fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform2fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform2fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2iEXTNative(uint program, int location, int v0, int v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[175])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[175])(program, location, v0, v1);
			#endif
		}

		public static void ProgramUniform2iEXT(uint program, int location, int v0, int v1)
		{
			ProgramUniform2iEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[176])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[176])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform2ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform2ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform2ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2uiEXTNative(uint program, int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[177])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[177])(program, location, v0, v1);
			#endif
		}

		public static void ProgramUniform2uiEXT(uint program, int location, uint v0, uint v1)
		{
			ProgramUniform2uiEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[178])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[178])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform2uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform2uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform2uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3dEXTNative(uint program, int location, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, void>)funcTable[179])(program, location, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, void>)funcTable[179])(program, location, x, y, z);
			#endif
		}

		public static void ProgramUniform3dEXT(uint program, int location, double x, double y, double z)
		{
			ProgramUniform3dEXTNative(program, location, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[180])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[180])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform3dvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform3dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform3dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3fEXTNative(uint program, int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[181])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[181])(program, location, v0, v1, v2);
			#endif
		}

		public static void ProgramUniform3fEXT(uint program, int location, float v0, float v1, float v2)
		{
			ProgramUniform3fEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[182])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[182])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform3fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform3fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform3fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3iEXTNative(uint program, int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[183])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[183])(program, location, v0, v1, v2);
			#endif
		}

		public static void ProgramUniform3iEXT(uint program, int location, int v0, int v1, int v2)
		{
			ProgramUniform3iEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[184])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[184])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform3ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform3ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform3ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3uiEXTNative(uint program, int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[185])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[185])(program, location, v0, v1, v2);
			#endif
		}

		public static void ProgramUniform3uiEXT(uint program, int location, uint v0, uint v1, uint v2)
		{
			ProgramUniform3uiEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[186])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[186])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform3uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform3uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform3uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4dEXTNative(uint program, int location, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, double, void>)funcTable[187])(program, location, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, double, void>)funcTable[187])(program, location, x, y, z, w);
			#endif
		}

		public static void ProgramUniform4dEXT(uint program, int location, double x, double y, double z, double w)
		{
			ProgramUniform4dEXTNative(program, location, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4dvEXTNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[188])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[188])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4dvEXT(uint program, int location, int count, double* value)
		{
			ProgramUniform4dvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform4dvEXT(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform4dvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4fEXTNative(uint program, int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[189])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[189])(program, location, v0, v1, v2, v3);
			#endif
		}

		public static void ProgramUniform4fEXT(uint program, int location, float v0, float v1, float v2, float v3)
		{
			ProgramUniform4fEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[190])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[190])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform4fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform4fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform4fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4iEXTNative(uint program, int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[191])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[191])(program, location, v0, v1, v2, v3);
			#endif
		}

		public static void ProgramUniform4iEXT(uint program, int location, int v0, int v1, int v2, int v3)
		{
			ProgramUniform4iEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[192])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[192])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform4ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform4ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform4ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4uiEXTNative(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[193])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[193])(program, location, v0, v1, v2, v3);
			#endif
		}

		public static void ProgramUniform4uiEXT(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			ProgramUniform4uiEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[194])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[194])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform4uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform4uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform4uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[195])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[195])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix2dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[196])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[196])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix2fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2x3dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[197])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[197])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix2x3dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2x3dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2x3fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[198])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[198])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix2x3fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2x4dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[199])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[199])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix2x4dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2x4dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2x4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2x4fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[200])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[200])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix2x4fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[201])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[201])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix3dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[202])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[202])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix3fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3x2dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[203])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[203])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix3x2dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3x2dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3x2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3x2fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[204])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[204])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix3x2fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3x4dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[205])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[205])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix3x4dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3x4dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3x4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3x4fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[206])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[206])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix3x4fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[207])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[207])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix4dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[208])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[208])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix4fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4x2dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[209])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[209])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix4x2dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x2dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4x2dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4x2fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[210])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[210])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix4x2fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4x3dvEXTNative(uint program, int location, int count, byte transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[211])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[211])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, byte transpose, double* value)
		{
			ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x3dvEXT(uint program, int location, int count, byte transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3dvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4x3fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[212])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[212])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushClientAttribDefaultEXTNative(GLClientAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[213])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[213])(mask);
			#endif
		}

		public static void PushClientAttribDefaultEXT(GLClientAttribMask mask)
		{
			PushClientAttribDefaultEXTNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureBufferEXTNative(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[214])(texture, target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[214])(texture, target, internalformat, buffer);
			#endif
		}

		public static void TextureBufferEXT(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			TextureBufferEXTNative(texture, target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureBufferRangeEXTNative(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[215])(texture, target, internalformat, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[215])(texture, target, internalformat, buffer, offset, size);
			#endif
		}

		public static void TextureBufferRangeEXT(uint texture, GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			TextureBufferRangeEXTNative(texture, target, internalformat, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[216])(texture, target, level, internalformat, width, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[216])(texture, target, level, internalformat, width, border, format, type, (nint)pixels);
			#endif
		}

		public static void TextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage1DEXTNative(texture, target, level, internalformat, width, border, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[217])(texture, target, level, internalformat, width, height, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[217])(texture, target, level, internalformat, width, height, border, format, type, (nint)pixels);
			#endif
		}

		public static void TextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureImage3DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[218])(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[218])(texture, target, level, internalformat, width, height, depth, border, format, type, (nint)pixels);
			#endif
		}

		public static void TextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexturePageCommitmentEXTNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, byte, void>)funcTable[219])(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, byte, void>)funcTable[219])(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
			#endif
		}

		public static void TexturePageCommitmentEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit)
		{
			TexturePageCommitmentEXTNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterIivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[220])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[220])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TextureParameterIivEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			TextureParameterIivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterIivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TextureParameterIivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterIuivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[221])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[221])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			TextureParameterIuivEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out uint @params)
		{
			uint pparams;
			TextureParameterIuivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterIuivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				TextureParameterIuivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterfEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[222])(texture, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[222])(texture, target, pname, param);
			#endif
		}

		public static void TextureParameterfEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			TextureParameterfEXTNative(texture, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterfvEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, float*, void>)funcTable[223])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[223])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			TextureParameterfvEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out float @params)
		{
			float pparams;
			TextureParameterfvEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterfvEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				TextureParameterfvEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameteriEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[224])(texture, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[224])(texture, target, pname, param);
			#endif
		}

		public static void TextureParameteriEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			TextureParameteriEXTNative(texture, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureParameterivEXTNative(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[225])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[225])(texture, target, pname, (nint)@params);
			#endif
		}

		public static void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TextureParameterivEXTNative(texture, target, pname, @params);
		}

		public static void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, out int @params)
		{
			int pparams;
			TextureParameterivEXTNative(texture, target, pname, &pparams);
			@params = pparams;
		}

		public static void TextureParameterivEXT(uint texture, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				TextureParameterivEXTNative(texture, target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureRenderbufferEXTNative(uint texture, GLTextureTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, void>)funcTable[226])(texture, target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, void>)funcTable[226])(texture, target, renderbuffer);
			#endif
		}

		public static void TextureRenderbufferEXT(uint texture, GLTextureTarget target, uint renderbuffer)
		{
			TextureRenderbufferEXTNative(texture, target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage1DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[227])(texture, target, levels, internalformat, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[227])(texture, target, levels, internalformat, width);
			#endif
		}

		public static void TextureStorage1DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			TextureStorage1DEXTNative(texture, target, levels, internalformat, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage2DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[228])(texture, target, levels, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[228])(texture, target, levels, internalformat, width, height);
			#endif
		}

		public static void TextureStorage2DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			TextureStorage2DEXTNative(texture, target, levels, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage2DMultisampleEXTNative(uint texture, GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[229])(texture, target, samples, internalformat, width, height, fixedsamplelocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, void>)funcTable[229])(texture, target, samples, internalformat, width, height, fixedsamplelocations);
			#endif
		}

		public static void TextureStorage2DMultisampleEXT(uint texture, GLTextureTarget target, int samples, GLSizedInternalFormat internalformat, int width, int height, byte fixedsamplelocations)
		{
			TextureStorage2DMultisampleEXTNative(texture, target, samples, internalformat, width, height, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage3DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[230])(texture, target, levels, internalformat, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[230])(texture, target, levels, internalformat, width, height, depth);
			#endif
		}

		public static void TextureStorage3DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			TextureStorage3DEXTNative(texture, target, levels, internalformat, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage3DMultisampleEXTNative(uint texture, GLEnum target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[231])(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, byte, void>)funcTable[231])(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
			#endif
		}

		public static void TextureStorage3DMultisampleEXT(uint texture, GLEnum target, int samples, GLSizedInternalFormat internalformat, int width, int height, int depth, byte fixedsamplelocations)
		{
			TextureStorage3DMultisampleEXTNative(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[232])(texture, target, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[232])(texture, target, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		public static void TextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[233])(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[233])(texture, target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		public static void TextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[234])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[234])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		public static void TextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			TextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte UnmapNamedBufferEXTNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[235])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[235])(buffer);
			#endif
		}

		public static bool UnmapNamedBufferEXT(uint buffer)
		{
			byte ret = UnmapNamedBufferEXTNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayBindVertexBufferEXTNative(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[236])(vaobj, bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, int, void>)funcTable[236])(vaobj, bindingindex, buffer, offset, stride);
			#endif
		}

		public static void VertexArrayBindVertexBufferEXT(uint vaobj, uint bindingindex, uint buffer, nint offset, int stride)
		{
			VertexArrayBindVertexBufferEXTNative(vaobj, bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[237])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[237])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArrayColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayEdgeFlagOffsetEXTNative(uint vaobj, uint buffer, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[238])(vaobj, buffer, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[238])(vaobj, buffer, stride, offset);
			#endif
		}

		public static void VertexArrayEdgeFlagOffsetEXT(uint vaobj, uint buffer, int stride, nint offset)
		{
			VertexArrayEdgeFlagOffsetEXTNative(vaobj, buffer, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayFogCoordOffsetEXTNative(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[239])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLFogCoordinatePointerType, int, nint, void>)funcTable[239])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayFogCoordOffsetEXT(uint vaobj, uint buffer, GLFogCoordinatePointerType type, int stride, nint offset)
		{
			VertexArrayFogCoordOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayIndexOffsetEXTNative(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[240])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLIndexPointerType, int, nint, void>)funcTable[240])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayIndexOffsetEXT(uint vaobj, uint buffer, GLIndexPointerType type, int stride, nint offset)
		{
			VertexArrayIndexOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayMultiTexCoordOffsetEXTNative(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[241])(vaobj, buffer, texunit, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLEnum, int, GLTexCoordPointerType, int, nint, void>)funcTable[241])(vaobj, buffer, texunit, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayMultiTexCoordOffsetEXT(uint vaobj, uint buffer, GLEnum texunit, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayMultiTexCoordOffsetEXTNative(vaobj, buffer, texunit, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayNormalOffsetEXTNative(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[242])(vaobj, buffer, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLNormalPointerType, int, nint, void>)funcTable[242])(vaobj, buffer, type, stride, offset);
			#endif
		}

		public static void VertexArrayNormalOffsetEXT(uint vaobj, uint buffer, GLNormalPointerType type, int stride, nint offset)
		{
			VertexArrayNormalOffsetEXTNative(vaobj, buffer, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArraySecondaryColorOffsetEXTNative(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[243])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLColorPointerType, int, nint, void>)funcTable[243])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArraySecondaryColorOffsetEXT(uint vaobj, uint buffer, int size, GLColorPointerType type, int stride, nint offset)
		{
			VertexArraySecondaryColorOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayTexCoordOffsetEXTNative(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[244])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLTexCoordPointerType, int, nint, void>)funcTable[244])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayTexCoordOffsetEXT(uint vaobj, uint buffer, int size, GLTexCoordPointerType type, int stride, nint offset)
		{
			VertexArrayTexCoordOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribBindingEXTNative(uint vaobj, uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[245])(vaobj, attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[245])(vaobj, attribindex, bindingindex);
			#endif
		}

		public static void VertexArrayVertexAttribBindingEXT(uint vaobj, uint attribindex, uint bindingindex)
		{
			VertexArrayVertexAttribBindingEXTNative(vaobj, attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribDivisorEXTNative(uint vaobj, uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[246])(vaobj, index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[246])(vaobj, index, divisor);
			#endif
		}

		public static void VertexArrayVertexAttribDivisorEXT(uint vaobj, uint index, uint divisor)
		{
			VertexArrayVertexAttribDivisorEXTNative(vaobj, index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribType type, byte normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[247])(vaobj, attribindex, size, type, normalized, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribType, byte, uint, void>)funcTable[247])(vaobj, attribindex, size, type, normalized, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribType type, byte normalized, uint relativeoffset)
		{
			VertexArrayVertexAttribFormatEXTNative(vaobj, attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribIFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[248])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribIType, uint, void>)funcTable[248])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribIFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexArrayVertexAttribIFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribIOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[249])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribType, int, nint, void>)funcTable[249])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribIOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribType type, int stride, nint offset)
		{
			VertexArrayVertexAttribIOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribLFormatEXTNative(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[250])(vaobj, attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexAttribLType, uint, void>)funcTable[250])(vaobj, attribindex, size, type, relativeoffset);
			#endif
		}

		public static void VertexArrayVertexAttribLFormatEXT(uint vaobj, uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexArrayVertexAttribLFormatEXTNative(vaobj, attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribLOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[251])(vaobj, buffer, index, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribLType, int, nint, void>)funcTable[251])(vaobj, buffer, index, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribLOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribLType type, int stride, nint offset)
		{
			VertexArrayVertexAttribLOffsetEXTNative(vaobj, buffer, index, size, type, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexAttribOffsetEXTNative(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, byte normalized, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[252])(vaobj, buffer, index, size, type, normalized, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[252])(vaobj, buffer, index, size, type, normalized, stride, offset);
			#endif
		}

		public static void VertexArrayVertexAttribOffsetEXT(uint vaobj, uint buffer, uint index, int size, GLVertexAttribPointerType type, byte normalized, int stride, nint offset)
		{
			VertexArrayVertexAttribOffsetEXTNative(vaobj, buffer, index, size, type, normalized, stride, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexBindingDivisorEXTNative(uint vaobj, uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[253])(vaobj, bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[253])(vaobj, bindingindex, divisor);
			#endif
		}

		public static void VertexArrayVertexBindingDivisorEXT(uint vaobj, uint bindingindex, uint divisor)
		{
			VertexArrayVertexBindingDivisorEXTNative(vaobj, bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexArrayVertexOffsetEXTNative(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[254])(vaobj, buffer, size, type, stride, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, GLVertexPointerType, int, nint, void>)funcTable[254])(vaobj, buffer, size, type, stride, offset);
			#endif
		}

		public static void VertexArrayVertexOffsetEXT(uint vaobj, uint buffer, int size, GLVertexPointerType type, int stride, nint offset)
		{
			VertexArrayVertexOffsetEXTNative(vaobj, buffer, size, type, stride, offset);
		}

	}
}
