// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public static unsafe partial class GLEXTDirectStateAccess
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindMultiTextureEXTNative(GLTextureUnit texunit, GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[0])(texunit, target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[0])(texunit, target, texture);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void BindMultiTextureEXT(GLTextureUnit texunit, GLTextureTarget target, uint texture)
		{
			BindMultiTextureEXTNative(texunit, target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckNamedFramebufferStatusEXTNative(uint framebuffer, GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[1])(framebuffer, target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[1])(framebuffer, target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static GLEnum CheckNamedFramebufferStatusEXT(uint framebuffer, GLFramebufferTarget target)
		{
			GLEnum ret = CheckNamedFramebufferStatusEXTNative(framebuffer, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferDataEXTNative(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[2])(buffer, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[2])(buffer, internalformat, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void ClearNamedBufferDataEXT(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferDataEXTNative(buffer, internalformat, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void ClearNamedBufferDataEXT(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearNamedBufferDataEXTNative(buffer, internalformat, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void ClearNamedBufferDataEXT<TData>(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearNamedBufferDataEXTNative(buffer, internalformat, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferSubDataEXTNative(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[3])(buffer, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[3])(buffer, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void ClearNamedBufferSubDataEXT(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferSubDataEXTNative(buffer, internalformat, offset, size, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void ClearNamedBufferSubDataEXT(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearNamedBufferSubDataEXTNative(buffer, internalformat, offset, size, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void ClearNamedBufferSubDataEXT<TData>(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearNamedBufferSubDataEXTNative(buffer, internalformat, offset, size, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientAttribDefaultEXTNative(GLClientAttribMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[4])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClientAttribMask, void>)funcTable[4])(mask);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void ClientAttribDefaultEXT(GLClientAttribMask mask)
		{
			ClientAttribDefaultEXTNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[5])(texunit, target, level, internalformat, width, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[5])(texunit, target, level, internalformat, width, border, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, nint bits)
		{
			CompressedMultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage1DEXT<TBits>(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedMultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[6])(texunit, target, level, internalformat, width, height, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[6])(texunit, target, level, internalformat, width, height, border, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, nint bits)
		{
			CompressedMultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage2DEXT<TBits>(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedMultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[7])(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[7])(texunit, target, level, internalformat, width, height, depth, border, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			CompressedMultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, nint bits)
		{
			CompressedMultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexImage3DEXT<TBits>(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedMultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[8])(texunit, target, level, xoffset, width, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[8])(texunit, target, level, xoffset, width, format, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, nint bits)
		{
			CompressedMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage1DEXT<TBits>(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[9])(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[9])(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, nint bits)
		{
			CompressedMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage2DEXT<TBits>(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedMultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[10])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[10])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, nint bits)
		{
			CompressedMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedMultiTexSubImage3DEXT<TBits>(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[11])(texture, target, level, internalformat, width, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[11])(texture, target, level, internalformat, width, border, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* bits)
		{
			CompressedTextureImage1DEXTNative(texture, target, level, internalformat, width, border, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, nint bits)
		{
			CompressedTextureImage1DEXTNative(texture, target, level, internalformat, width, border, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage1DEXT<TBits>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedTextureImage1DEXTNative(texture, target, level, internalformat, width, border, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[12])(texture, target, level, internalformat, width, height, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[12])(texture, target, level, internalformat, width, height, border, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* bits)
		{
			CompressedTextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, nint bits)
		{
			CompressedTextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage2DEXT<TBits>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedTextureImage2DEXTNative(texture, target, level, internalformat, width, height, border, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureImage3DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[13])(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[13])(texture, target, level, internalformat, width, height, depth, border, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* bits)
		{
			CompressedTextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage3DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, nint bits)
		{
			CompressedTextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureImage3DEXT<TBits>(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedTextureImage3DEXTNative(texture, target, level, internalformat, width, height, depth, border, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[14])(texture, target, level, xoffset, width, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[14])(texture, target, level, xoffset, width, format, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, nint bits)
		{
			CompressedTextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage1DEXT<TBits>(uint texture, GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedTextureSubImage1DEXTNative(texture, target, level, xoffset, width, format, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[15])(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[15])(texture, target, level, xoffset, yoffset, width, height, format, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, nint bits)
		{
			CompressedTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage2DEXT<TBits>(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, width, height, format, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[16])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[16])(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)bits);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* bits)
		{
			CompressedTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, nint bits)
		{
			CompressedTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)bits);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CompressedTextureSubImage3DEXT<TBits>(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, Span<TBits> bits) where TBits : unmanaged
		{
			fixed (TBits* pbits0 = bits)
			{
				CompressedTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pbits0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[17])(texunit, target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[17])(texunit, target, level, internalformat, x, y, width, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyMultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyMultiTexImage1DEXTNative(texunit, target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[18])(texunit, target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[18])(texunit, target, level, internalformat, x, y, width, height, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyMultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyMultiTexImage2DEXTNative(texunit, target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, void>)funcTable[19])(texunit, target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, void>)funcTable[19])(texunit, target, level, xoffset, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyMultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyMultiTexSubImage1DEXTNative(texunit, target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[20])(texunit, target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[20])(texunit, target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyMultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyMultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyMultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[21])(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[21])(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyMultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyMultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureImage1DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[22])(texture, target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[22])(texture, target, level, internalformat, x, y, width, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyTextureImage1DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTextureImage1DEXTNative(texture, target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureImage2DEXTNative(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[23])(texture, target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[23])(texture, target, level, internalformat, x, y, width, height, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyTextureImage2DEXT(uint texture, GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTextureImage2DEXTNative(texture, target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage1DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, void>)funcTable[24])(texture, target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, void>)funcTable[24])(texture, target, level, xoffset, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyTextureSubImage1DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTextureSubImage1DEXTNative(texture, target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage2DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[25])(texture, target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[25])(texture, target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyTextureSubImage2DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage2DEXTNative(texture, target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage3DEXTNative(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[26])(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[26])(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void CopyTextureSubImage3DEXT(uint texture, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage3DEXTNative(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateIndexedEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[27])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[27])(array, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void DisableClientStateIndexedEXT(GLEnableCap array, uint index)
		{
			DisableClientStateIndexedEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateiEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[28])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[28])(array, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void DisableClientStateiEXT(GLEnableCap array, uint index)
		{
			DisableClientStateiEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[29])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[29])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void DisableIndexedEXT(GLEnableCap target, uint index)
		{
			DisableIndexedEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayAttribEXTNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[30])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[30])(vaobj, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void DisableVertexArrayAttribEXT(uint vaobj, uint index)
		{
			DisableVertexArrayAttribEXTNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayEXTNative(uint vaobj, GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[31])(vaobj, array);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[31])(vaobj, array);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void DisableVertexArrayEXT(uint vaobj, GLEnableCap array)
		{
			DisableVertexArrayEXTNative(vaobj, array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateIndexedEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[32])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[32])(array, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void EnableClientStateIndexedEXT(GLEnableCap array, uint index)
		{
			EnableClientStateIndexedEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateiEXTNative(GLEnableCap array, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[33])(array, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[33])(array, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void EnableClientStateiEXT(GLEnableCap array, uint index)
		{
			EnableClientStateiEXTNative(array, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[34])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[34])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void EnableIndexedEXT(GLEnableCap target, uint index)
		{
			EnableIndexedEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayAttribEXTNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[35])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[35])(vaobj, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void EnableVertexArrayAttribEXT(uint vaobj, uint index)
		{
			EnableVertexArrayAttribEXTNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayEXTNative(uint vaobj, GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[36])(vaobj, array);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnableCap, void>)funcTable[36])(vaobj, array);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void EnableVertexArrayEXT(uint vaobj, GLEnableCap array)
		{
			EnableVertexArrayEXTNative(vaobj, array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedNamedBufferRangeEXTNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[37])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[37])(buffer, offset, length);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void FlushMappedNamedBufferRangeEXT(uint buffer, nint offset, nint length)
		{
			FlushMappedNamedBufferRangeEXTNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferDrawBufferEXTNative(uint framebuffer, GLDrawBufferMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLDrawBufferMode, void>)funcTable[38])(framebuffer, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLDrawBufferMode, void>)funcTable[38])(framebuffer, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void FramebufferDrawBufferEXT(uint framebuffer, GLDrawBufferMode mode)
		{
			FramebufferDrawBufferEXTNative(framebuffer, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferDrawBuffersEXTNative(uint framebuffer, int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLDrawBufferMode, void>)funcTable[39])(framebuffer, n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLDrawBufferMode, void>)funcTable[39])(framebuffer, n, bufs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void FramebufferDrawBuffersEXT(uint framebuffer, int n, GLDrawBufferMode bufs)
		{
			FramebufferDrawBuffersEXTNative(framebuffer, n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferReadBufferEXTNative(uint framebuffer, GLReadBufferMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLReadBufferMode, void>)funcTable[40])(framebuffer, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLReadBufferMode, void>)funcTable[40])(framebuffer, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void FramebufferReadBufferEXT(uint framebuffer, GLReadBufferMode mode)
		{
			FramebufferReadBufferEXTNative(framebuffer, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMultiTexMipmapEXTNative(GLTextureUnit texunit, GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, void>)funcTable[41])(texunit, target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, void>)funcTable[41])(texunit, target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GenerateMultiTexMipmapEXT(GLTextureUnit texunit, GLTextureTarget target)
		{
			GenerateMultiTexMipmapEXTNative(texunit, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapEXTNative(uint texture, GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, void>)funcTable[42])(texture, target);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, void>)funcTable[42])(texture, target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GenerateTextureMipmapEXT(uint texture, GLTextureTarget target)
		{
			GenerateTextureMipmapEXTNative(texture, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanIndexedvEXTNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[43])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[43])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleanIndexedvEXTNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanIndexedvEXTNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, Span<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanIndexedvEXTNative(target, index, pdata0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void GetBooleanIndexedvEXT(GLBufferTargetARB target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleanIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedMultiTexImageEXTNative(GLTextureUnit texunit, GLTextureTarget target, int lod, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, void*, void>)funcTable[44])(texunit, target, lod, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, nint, void>)funcTable[44])(texunit, target, lod, (nint)img);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetCompressedMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int lod, void* img)
		{
			GetCompressedMultiTexImageEXTNative(texunit, target, lod, img);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetCompressedMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int lod, nint img)
		{
			GetCompressedMultiTexImageEXTNative(texunit, target, lod, (void*)img);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetCompressedMultiTexImageEXT<TImg>(GLTextureUnit texunit, GLTextureTarget target, int lod, Span<TImg> img) where TImg : unmanaged
		{
			fixed (TImg* pimg0 = img)
			{
				GetCompressedMultiTexImageEXTNative(texunit, target, lod, pimg0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureImageEXTNative(uint texture, GLTextureTarget target, int lod, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, void*, void>)funcTable[45])(texture, target, lod, img);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, nint, void>)funcTable[45])(texture, target, lod, (nint)img);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetCompressedTextureImageEXT(uint texture, GLTextureTarget target, int lod, void* img)
		{
			GetCompressedTextureImageEXTNative(texture, target, lod, img);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetCompressedTextureImageEXT(uint texture, GLTextureTarget target, int lod, nint img)
		{
			GetCompressedTextureImageEXTNative(texture, target, lod, (void*)img);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetCompressedTextureImageEXT<TImg>(uint texture, GLTextureTarget target, int lod, Span<TImg> img) where TImg : unmanaged
		{
			fixed (TImg* pimg0 = img)
			{
				GetCompressedTextureImageEXTNative(texture, target, lod, pimg0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoubleIndexedvEXTNative(GLGetPName target, uint index, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[46])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[46])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetDoubleIndexedvEXT(GLGetPName target, uint index, double* data)
		{
			GetDoubleIndexedvEXTNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetDoubleIndexedvEXT(GLGetPName target, uint index, Span<double> data)
		{
			fixed (double* pdata0 = data)
			{
				GetDoubleIndexedvEXTNative(target, index, pdata0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetDoubleIndexedvEXT(GLGetPName target, uint index, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoubleIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublei_vEXTNative(GLGetPName pname, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[47])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[47])(pname, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetDoublei_vEXT(GLGetPName pname, uint index, double* @params)
		{
			GetDoublei_vEXTNative(pname, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetDoublei_vEXT(GLGetPName pname, uint index, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetDoublei_vEXTNative(pname, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetDoublei_vEXT(GLGetPName pname, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetDoublei_vEXTNative(pname, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloatIndexedvEXTNative(GLGetPName target, uint index, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[48])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[48])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFloatIndexedvEXT(GLGetPName target, uint index, float* data)
		{
			GetFloatIndexedvEXTNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFloatIndexedvEXT(GLGetPName target, uint index, Span<float> data)
		{
			fixed (float* pdata0 = data)
			{
				GetFloatIndexedvEXTNative(target, index, pdata0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFloatIndexedvEXT(GLGetPName target, uint index, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloatIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloati_vEXTNative(GLGetPName pname, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[49])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[49])(pname, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFloati_vEXT(GLGetPName pname, uint index, float* @params)
		{
			GetFloati_vEXTNative(pname, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFloati_vEXT(GLGetPName pname, uint index, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetFloati_vEXTNative(pname, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFloati_vEXT(GLGetPName pname, uint index, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetFloati_vEXTNative(pname, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferParameterivEXTNative(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[50])(framebuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[50])(framebuffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			GetFramebufferParameterivEXTNative(framebuffer, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetFramebufferParameterivEXTNative(framebuffer, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFramebufferParameterivEXTNative(framebuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegerIndexedvEXTNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[51])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[51])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void GetIntegerIndexedvEXT(GLGetPName target, uint index, int* data)
		{
			GetIntegerIndexedvEXTNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void GetIntegerIndexedvEXT(GLGetPName target, uint index, Span<int> data)
		{
			fixed (int* pdata0 = data)
			{
				GetIntegerIndexedvEXTNative(target, index, pdata0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static void GetIntegerIndexedvEXT(GLGetPName target, uint index, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegerIndexedvEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexEnvfvEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[52])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[52])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			GetMultiTexEnvfvEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetMultiTexEnvfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexEnvfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexEnvivEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[53])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[53])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetMultiTexEnvivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetMultiTexEnvivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexEnvivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGendvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[54])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[54])(texunit, coord, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			GetMultiTexGendvEXTNative(texunit, coord, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetMultiTexGendvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetMultiTexGendvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGenfvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[55])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[55])(texunit, coord, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			GetMultiTexGenfvEXTNative(texunit, coord, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetMultiTexGenfvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexGenfvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexGenivEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[56])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[56])(texunit, coord, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			GetMultiTexGenivEXTNative(texunit, coord, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetMultiTexGenivEXTNative(texunit, coord, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexGenivEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexImageEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[57])(texunit, target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[57])(texunit, target, level, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetMultiTexImageEXTNative(texunit, target, level, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexImageEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			GetMultiTexImageEXTNative(texunit, target, level, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexImageEXT<TPixels>(GLTextureUnit texunit, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetMultiTexImageEXTNative(texunit, target, level, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexLevelParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[58])(texunit, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[58])(texunit, target, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexLevelParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexLevelParameterfvEXTNative(texunit, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexLevelParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[59])(texunit, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[59])(texunit, target, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexLevelParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexLevelParameterivEXTNative(texunit, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterIivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[60])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[60])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexParameterIivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetMultiTexParameterIivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexParameterIivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterIuivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[61])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[61])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetMultiTexParameterIuivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				GetMultiTexParameterIuivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetMultiTexParameterIuivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[62])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[62])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetMultiTexParameterfvEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetMultiTexParameterfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMultiTexParameterfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultiTexParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[63])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[63])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetMultiTexParameterivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetMultiTexParameterivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetMultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMultiTexParameterivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameterivEXTNative(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, int*, void>)funcTable[64])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[64])(buffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			GetNamedBufferParameterivEXTNative(buffer, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetNamedBufferParameterivEXTNative(buffer, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedBufferParameterivEXT(uint buffer, GLBufferPNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedBufferParameterivEXTNative(buffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferPointervEXTNative(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, void**, void>)funcTable[65])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, nint, void>)funcTable[65])(buffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedBufferPointervEXT(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			GetNamedBufferPointervEXTNative(buffer, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferSubDataEXTNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[66])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[66])(buffer, offset, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedBufferSubDataEXT(uint buffer, nint offset, nint size, void* data)
		{
			GetNamedBufferSubDataEXTNative(buffer, offset, size, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedBufferSubDataEXT(uint buffer, nint offset, nint size, nint data)
		{
			GetNamedBufferSubDataEXTNative(buffer, offset, size, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedBufferSubDataEXT<TData>(uint buffer, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				GetNamedBufferSubDataEXTNative(buffer, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferAttachmentParameterivEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[67])(framebuffer, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[67])(framebuffer, attachment, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedFramebufferAttachmentParameterivEXTNative(framebuffer, attachment, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferParameterivEXTNative(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[68])(framebuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[68])(framebuffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, int* @params)
		{
			GetNamedFramebufferParameterivEXTNative(framebuffer, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetNamedFramebufferParameterivEXTNative(framebuffer, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedFramebufferParameterivEXT(uint framebuffer, GLGetFramebufferParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedFramebufferParameterivEXTNative(framebuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterIivEXTNative(uint program, GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int*, void>)funcTable[69])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[69])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, int* @params)
		{
			GetNamedProgramLocalParameterIivEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetNamedProgramLocalParameterIivEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterIivEXT(uint program, GLProgramTarget target, uint index, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterIivEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterIuivEXTNative(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint*, void>)funcTable[70])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[70])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			GetNamedProgramLocalParameterIuivEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				GetNamedProgramLocalParameterIuivEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterIuivEXT(uint program, GLProgramTarget target, uint index, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterIuivEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterdvEXTNative(uint program, GLProgramTarget target, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double*, void>)funcTable[71])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[71])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterdvEXT(uint program, GLProgramTarget target, uint index, double* @params)
		{
			GetNamedProgramLocalParameterdvEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterdvEXT(uint program, GLProgramTarget target, uint index, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetNamedProgramLocalParameterdvEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterdvEXT(uint program, GLProgramTarget target, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterdvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramLocalParameterfvEXTNative(uint program, GLProgramTarget target, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float*, void>)funcTable[72])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[72])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, float* @params)
		{
			GetNamedProgramLocalParameterfvEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetNamedProgramLocalParameterfvEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramLocalParameterfvEXT(uint program, GLProgramTarget target, uint index, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetNamedProgramLocalParameterfvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramStringEXTNative(uint program, GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramStringProperty, void*, void>)funcTable[73])(program, target, pname, str);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramStringProperty, nint, void>)funcTable[73])(program, target, pname, (nint)str);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramStringEXT(uint program, GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			GetNamedProgramStringEXTNative(program, target, pname, str);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramStringEXT(uint program, GLProgramTarget target, GLProgramStringProperty pname, nint str)
		{
			GetNamedProgramStringEXTNative(program, target, pname, (void*)str);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramStringEXT<TStr>(uint program, GLProgramTarget target, GLProgramStringProperty pname, Span<TStr> str) where TStr : unmanaged
		{
			fixed (TStr* pstr0 = str)
			{
				GetNamedProgramStringEXTNative(program, target, pname, pstr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedProgramivEXTNative(uint program, GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramPropertyARB, int*, void>)funcTable[74])(program, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, GLProgramPropertyARB, nint, void>)funcTable[74])(program, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			GetNamedProgramivEXTNative(program, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetNamedProgramivEXTNative(program, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedProgramivEXT(uint program, GLProgramTarget target, GLProgramPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedProgramivEXTNative(program, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedRenderbufferParameterivEXTNative(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, int*, void>)funcTable[75])(renderbuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, nint, void>)funcTable[75])(renderbuffer, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetNamedRenderbufferParameterivEXT(uint renderbuffer, GLRenderbufferParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedRenderbufferParameterivEXTNative(renderbuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointerIndexedvEXTNative(GLEnum target, uint index, void** data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void**, void>)funcTable[76])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[76])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetPointerIndexedvEXT(GLEnum target, uint index, void** data)
		{
			GetPointerIndexedvEXTNative(target, index, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointeri_vEXTNative(GLEnum pname, uint index, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void**, void>)funcTable[77])(pname, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[77])(pname, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetPointeri_vEXT(GLEnum pname, uint index, void** @params)
		{
			GetPointeri_vEXTNative(pname, index, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureImageEXTNative(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[78])(texture, target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[78])(texture, target, level, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureImageEXT(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetTextureImageEXTNative(texture, target, level, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureImageEXT(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			GetTextureImageEXTNative(texture, target, level, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureImageEXT<TPixels>(uint texture, GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetTextureImageEXTNative(texture, target, level, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterfvEXTNative(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[79])(texture, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[79])(texture, target, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTextureLevelParameterfvEXTNative(texture, target, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetTextureLevelParameterfvEXTNative(texture, target, level, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureLevelParameterfvEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureLevelParameterfvEXTNative(texture, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterivEXTNative(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[80])(texture, target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[80])(texture, target, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTextureLevelParameterivEXTNative(texture, target, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetTextureLevelParameterivEXTNative(texture, target, level, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureLevelParameterivEXT(uint texture, GLTextureTarget target, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureLevelParameterivEXTNative(texture, target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[81])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[81])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterIivEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetTextureParameterIivEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterIivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterIivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIuivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[82])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[82])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTextureParameterIuivEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				GetTextureParameterIuivEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterIuivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetTextureParameterIuivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterfvEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[83])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[83])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTextureParameterfvEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				GetTextureParameterfvEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterfvEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureParameterfvEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterivEXTNative(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[84])(texture, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[84])(texture, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterivEXTNative(texture, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetTextureParameterivEXTNative(texture, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetTextureParameterivEXT(uint texture, GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterivEXTNative(texture, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIntegeri_vEXTNative(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, int*, void>)funcTable[85])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[85])(vaobj, index, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIntegeri_vEXTNative(vaobj, index, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, Span<int> param)
		{
			fixed (int* pparam0 = param)
			{
				GetVertexArrayIntegeri_vEXTNative(vaobj, index, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayIntegeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetVertexArrayIntegeri_vEXTNative(vaobj, index, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIntegervEXTNative(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, int*, void>)funcTable[86])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[86])(vaobj, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayIntegervEXT(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIntegervEXTNative(vaobj, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayIntegervEXT(uint vaobj, GLVertexArrayPName pname, Span<int> param)
		{
			fixed (int* pparam0 = param)
			{
				GetVertexArrayIntegervEXTNative(vaobj, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayIntegervEXT(uint vaobj, GLVertexArrayPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetVertexArrayIntegervEXTNative(vaobj, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayPointeri_vEXTNative(uint vaobj, uint index, GLVertexArrayPName pname, void** param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, void**, void>)funcTable[87])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[87])(vaobj, index, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayPointeri_vEXT(uint vaobj, uint index, GLVertexArrayPName pname, void** param)
		{
			GetVertexArrayPointeri_vEXTNative(vaobj, index, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayPointervEXTNative(uint vaobj, GLVertexArrayPName pname, void** param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, void**, void>)funcTable[88])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[88])(vaobj, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void GetVertexArrayPointervEXT(uint vaobj, GLVertexArrayPName pname, void** param)
		{
			GetVertexArrayPointervEXTNative(vaobj, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnabledIndexedEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[89])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[89])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_EXT_draw_buffers2</remarks>
		public static bool IsEnabledIndexedEXT(GLEnableCap target, uint index)
		{
			byte ret = IsEnabledIndexedEXTNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapNamedBufferEXTNative(uint buffer, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, void*>)funcTable[90])(buffer, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, nint>)funcTable[90])(buffer, access);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void* MapNamedBufferEXT(uint buffer, GLBufferAccessARB access)
		{
			void* ret = MapNamedBufferEXTNative(buffer, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapNamedBufferRangeEXTNative(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, void*>)funcTable[91])(buffer, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, nint>)funcTable[91])(buffer, offset, length, access);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void* MapNamedBufferRangeEXT(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapNamedBufferRangeEXTNative(buffer, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixFrustumEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[92])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[92])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixFrustumEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixFrustumEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadIdentityEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[93])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[93])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadIdentityEXT(GLMatrixMode mode)
		{
			MatrixLoadIdentityEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[94])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[94])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoadTransposedEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixLoadTransposedEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoadTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[95])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[95])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadTransposefEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixLoadTransposefEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoaddEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[96])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[96])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoaddEXT(GLMatrixMode mode, double* m)
		{
			MatrixLoaddEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoaddEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixLoaddEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoaddEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixLoaddEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixLoadfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[97])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[97])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadfEXT(GLMatrixMode mode, float* m)
		{
			MatrixLoadfEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadfEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixLoadfEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixLoadfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixLoadfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposedEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[98])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[98])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultTransposedEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultTransposedEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultTransposedEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixMultTransposedEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultTransposedEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultTransposedEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultTransposefEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[99])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[99])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultTransposefEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultTransposefEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultTransposefEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixMultTransposefEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultTransposefEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultTransposefEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultdEXTNative(GLMatrixMode mode, double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double*, void>)funcTable[100])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[100])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultdEXT(GLMatrixMode mode, double* m)
		{
			MatrixMultdEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultdEXT(GLMatrixMode mode, Span<double> m)
		{
			fixed (double* pm0 = m)
			{
				MatrixMultdEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultdEXT(GLMatrixMode mode, ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MatrixMultdEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixMultfEXTNative(GLMatrixMode mode, float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float*, void>)funcTable[101])(mode, m);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, nint, void>)funcTable[101])(mode, (nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultfEXT(GLMatrixMode mode, float* m)
		{
			MatrixMultfEXTNative(mode, m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultfEXT(GLMatrixMode mode, Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MatrixMultfEXTNative(mode, pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixMultfEXT(GLMatrixMode mode, ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MatrixMultfEXTNative(mode, pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixOrthoEXTNative(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[102])(mode, left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, double, double, void>)funcTable[102])(mode, left, right, bottom, top, zNear, zFar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixOrthoEXT(GLMatrixMode mode, double left, double right, double bottom, double top, double zNear, double zFar)
		{
			MatrixOrthoEXTNative(mode, left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPopEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[103])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[103])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixPopEXT(GLMatrixMode mode)
		{
			MatrixPopEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixPushEXTNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[104])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[104])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixPushEXT(GLMatrixMode mode)
		{
			MatrixPushEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatedEXTNative(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[105])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, double, void>)funcTable[105])(mode, angle, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixRotatedEXT(GLMatrixMode mode, double angle, double x, double y, double z)
		{
			MatrixRotatedEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixRotatefEXTNative(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[106])(mode, angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, float, void>)funcTable[106])(mode, angle, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixRotatefEXT(GLMatrixMode mode, float angle, float x, float y, float z)
		{
			MatrixRotatefEXTNative(mode, angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScaledEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[107])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[107])(mode, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixScaledEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixScaledEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixScalefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[108])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[108])(mode, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixScalefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixScalefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatedEXTNative(GLMatrixMode mode, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[109])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, double, double, double, void>)funcTable[109])(mode, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixTranslatedEXT(GLMatrixMode mode, double x, double y, double z)
		{
			MatrixTranslatedEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixTranslatefEXTNative(GLMatrixMode mode, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[110])(mode, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, float, float, float, void>)funcTable[110])(mode, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access<br/>GL_NV_path_rendering</remarks>
		public static void MatrixTranslatefEXT(GLMatrixMode mode, float x, float y, float z)
		{
			MatrixTranslatefEXTNative(mode, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexBufferEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLInternalFormat, uint, void>)funcTable[111])(texunit, target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLInternalFormat, uint, void>)funcTable[111])(texunit, target, internalformat, buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexBufferEXT(GLTextureUnit texunit, GLTextureTarget target, GLInternalFormat internalformat, uint buffer)
		{
			MultiTexBufferEXTNative(texunit, target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordPointerEXTNative(GLTextureUnit texunit, int size, GLTexCoordPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, GLTexCoordPointerType, int, void*, void>)funcTable[112])(texunit, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, GLTexCoordPointerType, int, nint, void>)funcTable[112])(texunit, size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexCoordPointerEXT(GLTextureUnit texunit, int size, GLTexCoordPointerType type, int stride, void* pointer)
		{
			MultiTexCoordPointerEXTNative(texunit, size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexCoordPointerEXT(GLTextureUnit texunit, int size, GLTexCoordPointerType type, int stride, nint pointer)
		{
			MultiTexCoordPointerEXTNative(texunit, size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexCoordPointerEXT<TPointer>(GLTextureUnit texunit, int size, GLTexCoordPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				MultiTexCoordPointerEXTNative(texunit, size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnvfEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float, void>)funcTable[113])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float, void>)funcTable[113])(texunit, target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnvfEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float param)
		{
			MultiTexEnvfEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnvfvEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[114])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[114])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			MultiTexEnvfvEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				MultiTexEnvfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnvfvEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				MultiTexEnvfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnviEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[115])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int, void>)funcTable[115])(texunit, target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnviEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int param)
		{
			MultiTexEnviEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexEnvivEXTNative(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[116])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[116])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			MultiTexEnvivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				MultiTexEnvivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexEnvivEXT(GLTextureUnit texunit, GLTextureEnvTarget target, GLTextureEnvParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MultiTexEnvivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGendEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double, void>)funcTable[117])(texunit, coord, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double, void>)funcTable[117])(texunit, coord, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGendEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double param)
		{
			MultiTexGendEXTNative(texunit, coord, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGendvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[118])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[118])(texunit, coord, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			MultiTexGendvEXTNative(texunit, coord, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				MultiTexGendvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGendvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				MultiTexGendvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGenfEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float, void>)funcTable[119])(texunit, coord, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float, void>)funcTable[119])(texunit, coord, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGenfEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float param)
		{
			MultiTexGenfEXTNative(texunit, coord, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGenfvEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[120])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[120])(texunit, coord, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			MultiTexGenfvEXTNative(texunit, coord, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				MultiTexGenfvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGenfvEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				MultiTexGenfvEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGeniEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int, void>)funcTable[121])(texunit, coord, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int, void>)funcTable[121])(texunit, coord, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGeniEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int param)
		{
			MultiTexGeniEXTNative(texunit, coord, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexGenivEXTNative(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[122])(texunit, coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[122])(texunit, coord, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			MultiTexGenivEXTNative(texunit, coord, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				MultiTexGenivEXTNative(texunit, coord, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexGenivEXT(GLTextureUnit texunit, GLTextureCoordName coord, GLTextureGenParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MultiTexGenivEXTNative(texunit, coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[123])(texunit, target, level, internalformat, width, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[123])(texunit, target, level, internalformat, width, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			MultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage1DEXT<TPixels>(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				MultiTexImage1DEXTNative(texunit, target, level, internalformat, width, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[124])(texunit, target, level, internalformat, width, height, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[124])(texunit, target, level, internalformat, width, height, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			MultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage2DEXT<TPixels>(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				MultiTexImage2DEXTNative(texunit, target, level, internalformat, width, height, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[125])(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, GLInternalFormat, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[125])(texunit, target, level, internalformat, width, height, depth, border, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			MultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexImage3DEXT<TPixels>(GLTextureUnit texunit, GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				MultiTexImage3DEXTNative(texunit, target, level, internalformat, width, height, depth, border, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterIivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[126])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[126])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			MultiTexParameterIivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				MultiTexParameterIivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterIivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MultiTexParameterIivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterIuivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[127])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[127])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			MultiTexParameterIuivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				MultiTexParameterIuivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterIuivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				MultiTexParameterIuivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterfEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[128])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, float, void>)funcTable[128])(texunit, target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterfEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float param)
		{
			MultiTexParameterfEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterfvEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, float*, void>)funcTable[129])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[129])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, float* @params)
		{
			MultiTexParameterfvEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				MultiTexParameterfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterfvEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				MultiTexParameterfvEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameteriEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[130])(texunit, target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int, void>)funcTable[130])(texunit, target, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameteriEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int param)
		{
			MultiTexParameteriEXTNative(texunit, target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexParameterivEXTNative(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[131])(texunit, target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[131])(texunit, target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			MultiTexParameterivEXTNative(texunit, target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				MultiTexParameterivEXTNative(texunit, target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexParameterivEXT(GLTextureUnit texunit, GLTextureTarget target, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MultiTexParameterivEXTNative(texunit, target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexRenderbufferEXTNative(GLTextureUnit texunit, GLTextureTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[132])(texunit, target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, uint, void>)funcTable[132])(texunit, target, renderbuffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexRenderbufferEXT(GLTextureUnit texunit, GLTextureTarget target, uint renderbuffer)
		{
			MultiTexRenderbufferEXTNative(texunit, target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexSubImage1DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[133])(texunit, target, level, xoffset, width, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[133])(texunit, target, level, xoffset, width, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage1DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			MultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage1DEXT<TPixels>(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int width, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				MultiTexSubImage1DEXTNative(texunit, target, level, xoffset, width, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexSubImage2DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[134])(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[134])(texunit, target, level, xoffset, yoffset, width, height, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage2DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			MultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage2DEXT<TPixels>(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				MultiTexSubImage2DEXTNative(texunit, target, level, xoffset, yoffset, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexSubImage3DEXTNative(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[135])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureTarget, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[135])(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			MultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage3DEXT(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			MultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void MultiTexSubImage3DEXT<TPixels>(GLTextureUnit texunit, GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				MultiTexSubImage3DEXTNative(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferDataEXTNative(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLVertexBufferObjectUsage, void>)funcTable[136])(buffer, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLVertexBufferObjectUsage, void>)funcTable[136])(buffer, size, (nint)data, usage);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferDataEXT(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			NamedBufferDataEXTNative(buffer, size, data, usage);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferDataEXT(uint buffer, nint size, nint data, GLVertexBufferObjectUsage usage)
		{
			NamedBufferDataEXTNative(buffer, size, (void*)data, usage);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferDataEXT<TData>(uint buffer, nint size, Span<TData> data, GLVertexBufferObjectUsage usage) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				NamedBufferDataEXTNative(buffer, size, pdata0, usage);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferStorageEXTNative(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLBufferStorageMask, void>)funcTable[137])(buffer, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLBufferStorageMask, void>)funcTable[137])(buffer, size, (nint)data, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferStorageEXT(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			NamedBufferStorageEXTNative(buffer, size, data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferStorageEXT(uint buffer, nint size, nint data, GLBufferStorageMask flags)
		{
			NamedBufferStorageEXTNative(buffer, size, (void*)data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferStorageEXT<TData>(uint buffer, nint size, Span<TData> data, GLBufferStorageMask flags) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				NamedBufferStorageEXTNative(buffer, size, pdata0, flags);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferSubDataEXTNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[138])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[138])(buffer, offset, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferSubDataEXT(uint buffer, nint offset, nint size, void* data)
		{
			NamedBufferSubDataEXTNative(buffer, offset, size, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferSubDataEXT(uint buffer, nint offset, nint size, nint data)
		{
			NamedBufferSubDataEXTNative(buffer, offset, size, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedBufferSubDataEXT<TData>(uint buffer, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				NamedBufferSubDataEXTNative(buffer, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedCopyBufferSubDataEXTNative(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[139])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[139])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedCopyBufferSubDataEXT(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			NamedCopyBufferSubDataEXTNative(readBuffer, writeBuffer, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferParameteriEXTNative(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[140])(framebuffer, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[140])(framebuffer, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferParameteriEXT(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			NamedFramebufferParameteriEXTNative(framebuffer, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferRenderbufferEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[141])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[141])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferRenderbufferEXT(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			NamedFramebufferRenderbufferEXTNative(framebuffer, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTexture1DEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[142])(framebuffer, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[142])(framebuffer, attachment, textarget, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferTexture1DEXT(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			NamedFramebufferTexture1DEXTNative(framebuffer, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTexture2DEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[143])(framebuffer, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[143])(framebuffer, attachment, textarget, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferTexture2DEXT(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			NamedFramebufferTexture2DEXTNative(framebuffer, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTexture3DEXTNative(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[144])(framebuffer, attachment, textarget, texture, level, zoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[144])(framebuffer, attachment, textarget, texture, level, zoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferTexture3DEXT(uint framebuffer, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			NamedFramebufferTexture3DEXTNative(framebuffer, attachment, textarget, texture, level, zoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureEXTNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[145])(framebuffer, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[145])(framebuffer, attachment, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferTextureEXT(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			NamedFramebufferTextureEXTNative(framebuffer, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureFaceEXTNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[146])(framebuffer, attachment, texture, level, face);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[146])(framebuffer, attachment, texture, level, face);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferTextureFaceEXT(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			NamedFramebufferTextureFaceEXTNative(framebuffer, attachment, texture, level, face);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureLayerEXTNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[147])(framebuffer, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[147])(framebuffer, attachment, texture, level, layer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedFramebufferTextureLayerEXT(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			NamedFramebufferTextureLayerEXTNative(framebuffer, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4dEXTNative(uint program, GLProgramTarget target, uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double, double, double, double, void>)funcTable[148])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double, double, double, double, void>)funcTable[148])(program, target, index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4dEXT(uint program, GLProgramTarget target, uint index, double x, double y, double z, double w)
		{
			NamedProgramLocalParameter4dEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4dvEXTNative(uint program, GLProgramTarget target, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, double*, void>)funcTable[149])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[149])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4dvEXT(uint program, GLProgramTarget target, uint index, double* @params)
		{
			NamedProgramLocalParameter4dvEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4dvEXT(uint program, GLProgramTarget target, uint index, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				NamedProgramLocalParameter4dvEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4dvEXT(uint program, GLProgramTarget target, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				NamedProgramLocalParameter4dvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4fEXTNative(uint program, GLProgramTarget target, uint index, float x, float y, float z, float w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float, float, float, float, void>)funcTable[150])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float, float, float, float, void>)funcTable[150])(program, target, index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4fEXT(uint program, GLProgramTarget target, uint index, float x, float y, float z, float w)
		{
			NamedProgramLocalParameter4fEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameter4fvEXTNative(uint program, GLProgramTarget target, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, float*, void>)funcTable[151])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[151])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4fvEXT(uint program, GLProgramTarget target, uint index, float* @params)
		{
			NamedProgramLocalParameter4fvEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4fvEXT(uint program, GLProgramTarget target, uint index, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				NamedProgramLocalParameter4fvEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameter4fvEXT(uint program, GLProgramTarget target, uint index, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				NamedProgramLocalParameter4fvEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4iEXTNative(uint program, GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, int, int, int, void>)funcTable[152])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, int, int, int, void>)funcTable[152])(program, target, index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4iEXT(uint program, GLProgramTarget target, uint index, int x, int y, int z, int w)
		{
			NamedProgramLocalParameterI4iEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4ivEXTNative(uint program, GLProgramTarget target, uint index, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int*, void>)funcTable[153])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[153])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4ivEXT(uint program, GLProgramTarget target, uint index, int* @params)
		{
			NamedProgramLocalParameterI4ivEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4ivEXT(uint program, GLProgramTarget target, uint index, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				NamedProgramLocalParameterI4ivEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4ivEXT(uint program, GLProgramTarget target, uint index, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				NamedProgramLocalParameterI4ivEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4uiEXTNative(uint program, GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[154])(program, target, index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint, uint, uint, uint, void>)funcTable[154])(program, target, index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4uiEXT(uint program, GLProgramTarget target, uint index, uint x, uint y, uint z, uint w)
		{
			NamedProgramLocalParameterI4uiEXTNative(program, target, index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameterI4uivEXTNative(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, uint*, void>)funcTable[155])(program, target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, nint, void>)funcTable[155])(program, target, index, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4uivEXT(uint program, GLProgramTarget target, uint index, uint* @params)
		{
			NamedProgramLocalParameterI4uivEXTNative(program, target, index, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4uivEXT(uint program, GLProgramTarget target, uint index, Span<uint> @params)
		{
			fixed (uint* pparams0 = @params)
			{
				NamedProgramLocalParameterI4uivEXTNative(program, target, index, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameterI4uivEXT(uint program, GLProgramTarget target, uint index, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				NamedProgramLocalParameterI4uivEXTNative(program, target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedProgramLocalParameters4fvEXTNative(uint program, GLProgramTarget target, uint index, int count, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, float*, void>)funcTable[156])(program, target, index, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramTarget, uint, int, nint, void>)funcTable[156])(program, target, index, count, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameters4fvEXT(uint program, GLProgramTarget target, uint index, int count, float* @params)
		{
			NamedProgramLocalParameters4fvEXTNative(program, target, index, count, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_direct_state_access</remarks>
		public static void NamedProgramLocalParameters4fvEXT(uint program, GLProgramTarget target, uint index, int count, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				NamedProgramLocalParameters4fvEXTNative(program, target, index, count, pparams0);
			}
		}
	}
}
