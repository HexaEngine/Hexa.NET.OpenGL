// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public static unsafe partial class GLEXTConvolution
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter1DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[0])(target, internalformat, width, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[0])(target, internalformat, width, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter1DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter1DEXTNative(target, internalformat, width, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter2DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[1])(target, internalformat, width, height, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[1])(target, internalformat, width, height, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter2DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter2DEXTNative(target, internalformat, width, height, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float, void>)funcTable[2])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float, void>)funcTable[2])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameterfEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float @params)
		{
			ConvolutionParameterfEXTNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfvEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float*, void>)funcTable[3])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[3])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			ConvolutionParameterfvEXTNative(target, pname, @params);
		}

		public static void ConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ConvolutionParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameteriEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int, void>)funcTable[4])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int, void>)funcTable[4])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameteriEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int @params)
		{
			ConvolutionParameteriEXTNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterivEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int*, void>)funcTable[5])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[5])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			ConvolutionParameterivEXTNative(target, pname, @params);
		}

		public static void ConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ConvolutionParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter1DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, void>)funcTable[6])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, void>)funcTable[6])(target, internalformat, x, y, width);
			#endif
		}

		public static void CopyConvolutionFilter1DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyConvolutionFilter1DEXTNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter2DEXTNative(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, int, void>)funcTable[7])(target, internalformat, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLInternalFormat, int, int, int, int, void>)funcTable[7])(target, internalformat, x, y, width, height);
			#endif
		}

		public static void CopyConvolutionFilter2DEXT(GLConvolutionTargetEXT target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			CopyConvolutionFilter2DEXTNative(target, internalformat, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionFilterEXTNative(GLConvolutionTargetEXT target, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLPixelFormat, GLPixelType, void*, void>)funcTable[8])(target, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLPixelFormat, GLPixelType, nint, void>)funcTable[8])(target, format, type, (nint)image);
			#endif
		}

		public static void GetConvolutionFilterEXT(GLConvolutionTargetEXT target, GLPixelFormat format, GLPixelType type, void* image)
		{
			GetConvolutionFilterEXTNative(target, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterfvEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, float*, void>)funcTable[9])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[9])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, float* @params)
		{
			GetConvolutionParameterfvEXTNative(target, pname, @params);
		}

		public static void GetConvolutionParameterfvEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetConvolutionParameterfvEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterivEXTNative(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, int*, void>)funcTable[10])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTargetEXT, GLConvolutionParameter, nint, void>)funcTable[10])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, int* @params)
		{
			GetConvolutionParameterivEXTNative(target, pname, @params);
		}

		public static void GetConvolutionParameterivEXT(GLConvolutionTargetEXT target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetConvolutionParameterivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSeparableFilterEXTNative(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, void*, void*, void*, void>)funcTable[11])(target, format, type, row, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, nint, nint, nint, void>)funcTable[11])(target, format, type, (nint)row, (nint)column, (nint)span);
			#endif
		}

		public static void GetSeparableFilterEXT(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			GetSeparableFilterEXTNative(target, format, type, row, column, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SeparableFilter2DEXTNative(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, void* column)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void*, void>)funcTable[12])(target, internalformat, width, height, format, type, row, column);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, nint, void>)funcTable[12])(target, internalformat, width, height, format, type, (nint)row, (nint)column);
			#endif
		}

		public static void SeparableFilter2DEXT(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, void* column)
		{
			SeparableFilter2DEXTNative(target, internalformat, width, height, format, type, row, column);
		}

	}
}
