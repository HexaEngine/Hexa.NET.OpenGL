// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.EXT
{
	public static unsafe partial class GLEXTVertexShader
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginVertexShaderEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[0])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[0])();
			#endif
		}

		public static void BeginVertexShaderEXT()
		{
			BeginVertexShaderEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindLightParameterEXTNative(GLLightName light, GLLightParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, uint>)funcTable[1])(light, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, uint>)funcTable[1])(light, value);
			#endif
		}

		public static uint BindLightParameterEXT(GLLightName light, GLLightParameter value)
		{
			uint ret = BindLightParameterEXTNative(light, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindMaterialParameterEXTNative(GLTriangleFace face, GLMaterialParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, uint>)funcTable[2])(face, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, uint>)funcTable[2])(face, value);
			#endif
		}

		public static uint BindMaterialParameterEXT(GLTriangleFace face, GLMaterialParameter value)
		{
			uint ret = BindMaterialParameterEXTNative(face, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindParameterEXTNative(GLVertexShaderParameterEXT value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLVertexShaderParameterEXT, uint>)funcTable[3])(value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLVertexShaderParameterEXT, uint>)funcTable[3])(value);
			#endif
		}

		public static uint BindParameterEXT(GLVertexShaderParameterEXT value)
		{
			uint ret = BindParameterEXTNative(value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindTexGenParameterEXTNative(GLTextureUnit unit, GLTextureCoordName coord, GLTextureGenParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, uint>)funcTable[4])(unit, coord, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTextureCoordName, GLTextureGenParameter, uint>)funcTable[4])(unit, coord, value);
			#endif
		}

		public static uint BindTexGenParameterEXT(GLTextureUnit unit, GLTextureCoordName coord, GLTextureGenParameter value)
		{
			uint ret = BindTexGenParameterEXTNative(unit, coord, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint BindTextureUnitParameterEXTNative(GLTextureUnit unit, GLVertexShaderTextureUnitParameter value)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLTextureUnit, GLVertexShaderTextureUnitParameter, uint>)funcTable[5])(unit, value);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLTextureUnit, GLVertexShaderTextureUnitParameter, uint>)funcTable[5])(unit, value);
			#endif
		}

		public static uint BindTextureUnitParameterEXT(GLTextureUnit unit, GLVertexShaderTextureUnitParameter value)
		{
			uint ret = BindTextureUnitParameterEXTNative(unit, value);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexShaderEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[6])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[6])(id);
			#endif
		}

		public static void BindVertexShaderEXT(uint id)
		{
			BindVertexShaderEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteVertexShaderEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[7])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[7])(id);
			#endif
		}

		public static void DeleteVertexShaderEXT(uint id)
		{
			DeleteVertexShaderEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVariantClientStateEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[8])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[8])(id);
			#endif
		}

		public static void DisableVariantClientStateEXT(uint id)
		{
			DisableVariantClientStateEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVariantClientStateEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[9])(id);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[9])(id);
			#endif
		}

		public static void EnableVariantClientStateEXT(uint id)
		{
			EnableVariantClientStateEXTNative(id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndVertexShaderEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[10])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[10])();
			#endif
		}

		public static void EndVertexShaderEXT()
		{
			EndVertexShaderEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ExtractComponentEXTNative(uint res, uint src, uint num)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[11])(res, src, num);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[11])(res, src, num);
			#endif
		}

		public static void ExtractComponentEXT(uint res, uint src, uint num)
		{
			ExtractComponentEXTNative(res, src, num);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenSymbolsEXTNative(GLDataTypeEXT datatype, GLVertexShaderStorageTypeEXT storagetype, GLParameterRangeEXT range, uint components)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLDataTypeEXT, GLVertexShaderStorageTypeEXT, GLParameterRangeEXT, uint, uint>)funcTable[12])(datatype, storagetype, range, components);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLDataTypeEXT, GLVertexShaderStorageTypeEXT, GLParameterRangeEXT, uint, uint>)funcTable[12])(datatype, storagetype, range, components);
			#endif
		}

		public static uint GenSymbolsEXT(GLDataTypeEXT datatype, GLVertexShaderStorageTypeEXT storagetype, GLParameterRangeEXT range, uint components)
		{
			uint ret = GenSymbolsEXTNative(datatype, storagetype, range, components);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenVertexShadersEXTNative(uint range)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[13])(range);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, uint>)funcTable[13])(range);
			#endif
		}

		public static uint GenVertexShadersEXT(uint range)
		{
			uint ret = GenVertexShadersEXTNative(range);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInvariantBooleanvEXTNative(uint id, GLGetVariantValueEXT value, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, byte*, void>)funcTable[14])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[14])(id, value, (nint)data);
			#endif
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, byte* data)
		{
			GetInvariantBooleanvEXTNative(id, value, data);
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetInvariantBooleanvEXTNative(id, value, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetInvariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		public static void GetInvariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetInvariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInvariantFloatvEXTNative(uint id, GLGetVariantValueEXT value, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, float*, void>)funcTable[15])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[15])(id, value, (nint)data);
			#endif
		}

		public static void GetInvariantFloatvEXT(uint id, GLGetVariantValueEXT value, float* data)
		{
			GetInvariantFloatvEXTNative(id, value, data);
		}

		public static void GetInvariantFloatvEXT(uint id, GLGetVariantValueEXT value, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetInvariantFloatvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInvariantIntegervEXTNative(uint id, GLGetVariantValueEXT value, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, int*, void>)funcTable[16])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[16])(id, value, (nint)data);
			#endif
		}

		public static void GetInvariantIntegervEXT(uint id, GLGetVariantValueEXT value, int* data)
		{
			GetInvariantIntegervEXTNative(id, value, data);
		}

		public static void GetInvariantIntegervEXT(uint id, GLGetVariantValueEXT value, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetInvariantIntegervEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLocalConstantBooleanvEXTNative(uint id, GLGetVariantValueEXT value, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, byte*, void>)funcTable[17])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[17])(id, value, (nint)data);
			#endif
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, byte* data)
		{
			GetLocalConstantBooleanvEXTNative(id, value, data);
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetLocalConstantBooleanvEXTNative(id, value, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetLocalConstantBooleanvEXTNative(id, value, pdata0);
			}
		}

		public static void GetLocalConstantBooleanvEXT(uint id, GLGetVariantValueEXT value, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetLocalConstantBooleanvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLocalConstantFloatvEXTNative(uint id, GLGetVariantValueEXT value, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, float*, void>)funcTable[18])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[18])(id, value, (nint)data);
			#endif
		}

		public static void GetLocalConstantFloatvEXT(uint id, GLGetVariantValueEXT value, float* data)
		{
			GetLocalConstantFloatvEXTNative(id, value, data);
		}

		public static void GetLocalConstantFloatvEXT(uint id, GLGetVariantValueEXT value, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetLocalConstantFloatvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLocalConstantIntegervEXTNative(uint id, GLGetVariantValueEXT value, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, int*, void>)funcTable[19])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[19])(id, value, (nint)data);
			#endif
		}

		public static void GetLocalConstantIntegervEXT(uint id, GLGetVariantValueEXT value, int* data)
		{
			GetLocalConstantIntegervEXTNative(id, value, data);
		}

		public static void GetLocalConstantIntegervEXT(uint id, GLGetVariantValueEXT value, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetLocalConstantIntegervEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantBooleanvEXTNative(uint id, GLGetVariantValueEXT value, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, byte*, void>)funcTable[20])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[20])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, byte* data)
		{
			GetVariantBooleanvEXTNative(id, value, data);
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetVariantBooleanvEXTNative(id, value, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetVariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		public static void GetVariantBooleanvEXT(uint id, GLGetVariantValueEXT value, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetVariantBooleanvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantFloatvEXTNative(uint id, GLGetVariantValueEXT value, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, float*, void>)funcTable[21])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[21])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantFloatvEXT(uint id, GLGetVariantValueEXT value, float* data)
		{
			GetVariantFloatvEXTNative(id, value, data);
		}

		public static void GetVariantFloatvEXT(uint id, GLGetVariantValueEXT value, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetVariantFloatvEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantIntegervEXTNative(uint id, GLGetVariantValueEXT value, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, int*, void>)funcTable[22])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[22])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantIntegervEXT(uint id, GLGetVariantValueEXT value, int* data)
		{
			GetVariantIntegervEXTNative(id, value, data);
		}

		public static void GetVariantIntegervEXT(uint id, GLGetVariantValueEXT value, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetVariantIntegervEXTNative(id, value, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVariantPointervEXTNative(uint id, GLGetVariantValueEXT value, void** data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, void**, void>)funcTable[23])(id, value, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetVariantValueEXT, nint, void>)funcTable[23])(id, value, (nint)data);
			#endif
		}

		public static void GetVariantPointervEXT(uint id, GLGetVariantValueEXT value, void** data)
		{
			GetVariantPointervEXTNative(id, value, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InsertComponentEXTNative(uint res, uint src, uint num)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[24])(res, src, num);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[24])(res, src, num);
			#endif
		}

		public static void InsertComponentEXT(uint res, uint src, uint num)
		{
			InsertComponentEXTNative(res, src, num);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsVariantEnabledEXTNative(uint id, GLVariantCapEXT cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLVariantCapEXT, byte>)funcTable[25])(id, cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, GLVariantCapEXT, byte>)funcTable[25])(id, cap);
			#endif
		}

		public static bool IsVariantEnabledEXT(uint id, GLVariantCapEXT cap)
		{
			byte ret = IsVariantEnabledEXTNative(id, cap);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetInvariantEXTNative(uint id, GLScalarType type, void* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, void*, void>)funcTable[26])(id, type, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, nint, void>)funcTable[26])(id, type, (nint)addr);
			#endif
		}

		public static void SetInvariantEXT(uint id, GLScalarType type, void* addr)
		{
			SetInvariantEXTNative(id, type, addr);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SetLocalConstantEXTNative(uint id, GLScalarType type, void* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, void*, void>)funcTable[27])(id, type, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, nint, void>)funcTable[27])(id, type, (nint)addr);
			#endif
		}

		public static void SetLocalConstantEXT(uint id, GLScalarType type, void* addr)
		{
			SetLocalConstantEXTNative(id, type, addr);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShaderOp1EXTNative(GLVertexShaderOpEXT op, uint res, uint arg1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexShaderOpEXT, uint, uint, void>)funcTable[28])(op, res, arg1);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexShaderOpEXT, uint, uint, void>)funcTable[28])(op, res, arg1);
			#endif
		}

		public static void ShaderOp1EXT(GLVertexShaderOpEXT op, uint res, uint arg1)
		{
			ShaderOp1EXTNative(op, res, arg1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShaderOp2EXTNative(GLVertexShaderOpEXT op, uint res, uint arg1, uint arg2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexShaderOpEXT, uint, uint, uint, void>)funcTable[29])(op, res, arg1, arg2);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexShaderOpEXT, uint, uint, uint, void>)funcTable[29])(op, res, arg1, arg2);
			#endif
		}

		public static void ShaderOp2EXT(GLVertexShaderOpEXT op, uint res, uint arg1, uint arg2)
		{
			ShaderOp2EXTNative(op, res, arg1, arg2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShaderOp3EXTNative(GLVertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexShaderOpEXT, uint, uint, uint, uint, void>)funcTable[30])(op, res, arg1, arg2, arg3);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexShaderOpEXT, uint, uint, uint, uint, void>)funcTable[30])(op, res, arg1, arg2, arg3);
			#endif
		}

		public static void ShaderOp3EXT(GLVertexShaderOpEXT op, uint res, uint arg1, uint arg2, uint arg3)
		{
			ShaderOp3EXTNative(op, res, arg1, arg2, arg3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SwizzleEXTNative(uint res, uint input, GLVertexShaderCoordOutEXT outX, GLVertexShaderCoordOutEXT outY, GLVertexShaderCoordOutEXT outZ, GLVertexShaderCoordOutEXT outW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexShaderCoordOutEXT, GLVertexShaderCoordOutEXT, GLVertexShaderCoordOutEXT, GLVertexShaderCoordOutEXT, void>)funcTable[31])(res, input, outX, outY, outZ, outW);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexShaderCoordOutEXT, GLVertexShaderCoordOutEXT, GLVertexShaderCoordOutEXT, GLVertexShaderCoordOutEXT, void>)funcTable[31])(res, input, outX, outY, outZ, outW);
			#endif
		}

		public static void SwizzleEXT(uint res, uint input, GLVertexShaderCoordOutEXT outX, GLVertexShaderCoordOutEXT outY, GLVertexShaderCoordOutEXT outZ, GLVertexShaderCoordOutEXT outW)
		{
			SwizzleEXTNative(res, input, outX, outY, outZ, outW);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantPointerEXTNative(uint id, GLScalarType type, uint stride, void* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, uint, void*, void>)funcTable[32])(id, type, stride, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLScalarType, uint, nint, void>)funcTable[32])(id, type, stride, (nint)addr);
			#endif
		}

		public static void VariantPointerEXT(uint id, GLScalarType type, uint stride, void* addr)
		{
			VariantPointerEXTNative(id, type, stride, addr);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantbvEXTNative(uint id, sbyte* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[33])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[33])(id, (nint)addr);
			#endif
		}

		public static void VariantbvEXT(uint id, sbyte* addr)
		{
			VariantbvEXTNative(id, addr);
		}

		public static void VariantbvEXT(uint id, ref sbyte addr)
		{
			fixed (sbyte* paddr0 = &addr)
			{
				VariantbvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantdvEXTNative(uint id, double* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[34])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[34])(id, (nint)addr);
			#endif
		}

		public static void VariantdvEXT(uint id, double* addr)
		{
			VariantdvEXTNative(id, addr);
		}

		public static void VariantdvEXT(uint id, ref double addr)
		{
			fixed (double* paddr0 = &addr)
			{
				VariantdvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantfvEXTNative(uint id, float* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[35])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[35])(id, (nint)addr);
			#endif
		}

		public static void VariantfvEXT(uint id, float* addr)
		{
			VariantfvEXTNative(id, addr);
		}

		public static void VariantfvEXT(uint id, ref float addr)
		{
			fixed (float* paddr0 = &addr)
			{
				VariantfvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantivEXTNative(uint id, int* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[36])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[36])(id, (nint)addr);
			#endif
		}

		public static void VariantivEXT(uint id, int* addr)
		{
			VariantivEXTNative(id, addr);
		}

		public static void VariantivEXT(uint id, ref int addr)
		{
			fixed (int* paddr0 = &addr)
			{
				VariantivEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantsvEXTNative(uint id, short* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[37])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[37])(id, (nint)addr);
			#endif
		}

		public static void VariantsvEXT(uint id, short* addr)
		{
			VariantsvEXTNative(id, addr);
		}

		public static void VariantsvEXT(uint id, ref short addr)
		{
			fixed (short* paddr0 = &addr)
			{
				VariantsvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantubvEXTNative(uint id, byte* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[38])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[38])(id, (nint)addr);
			#endif
		}

		public static void VariantubvEXT(uint id, byte* addr)
		{
			VariantubvEXTNative(id, addr);
		}

		public static void VariantubvEXT(uint id, string addr)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (addr != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(addr);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(addr, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VariantubvEXTNative(id, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void VariantubvEXT(uint id, ReadOnlySpan<byte> addr)
		{
			fixed (byte* paddr0 = addr)
			{
				VariantubvEXTNative(id, paddr0);
			}
		}

		public static void VariantubvEXT(uint id, ref byte addr)
		{
			fixed (byte* paddr0 = &addr)
			{
				VariantubvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantuivEXTNative(uint id, uint* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[39])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[39])(id, (nint)addr);
			#endif
		}

		public static void VariantuivEXT(uint id, uint* addr)
		{
			VariantuivEXTNative(id, addr);
		}

		public static void VariantuivEXT(uint id, ref uint addr)
		{
			fixed (uint* paddr0 = &addr)
			{
				VariantuivEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VariantusvEXTNative(uint id, ushort* addr)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[40])(id, addr);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[40])(id, (nint)addr);
			#endif
		}

		public static void VariantusvEXT(uint id, ushort* addr)
		{
			VariantusvEXTNative(id, addr);
		}

		public static void VariantusvEXT(uint id, ref ushort addr)
		{
			fixed (ushort* paddr0 = &addr)
			{
				VariantusvEXTNative(id, paddr0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WriteMaskEXTNative(uint res, uint input, GLVertexShaderWriteMaskEXT outX, GLVertexShaderWriteMaskEXT outY, GLVertexShaderWriteMaskEXT outZ, GLVertexShaderWriteMaskEXT outW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, void>)funcTable[41])(res, input, outX, outY, outZ, outW);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, GLVertexShaderWriteMaskEXT, void>)funcTable[41])(res, input, outX, outY, outZ, outW);
			#endif
		}

		public static void WriteMaskEXT(uint res, uint input, GLVertexShaderWriteMaskEXT outX, GLVertexShaderWriteMaskEXT outY, GLVertexShaderWriteMaskEXT outZ, GLVertexShaderWriteMaskEXT outW)
		{
			WriteMaskEXTNative(res, input, outX, outY, outZ, outW);
		}

	}
}
