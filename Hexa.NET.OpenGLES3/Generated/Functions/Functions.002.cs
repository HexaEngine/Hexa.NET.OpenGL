// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES
{
	public static unsafe partial class GL
	{

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, int* length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (GLEnum* pbinaryFormat0 = &binaryFormat)
			{
				GetProgramBinaryNative(program, bufSize, length, pbinaryFormat0, binary);
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, Span<int> length, Span<GLEnum> binaryFormat, void* binary)
		{
			fixed (int* plength0 = length)
			{
				fixed (GLEnum* pbinaryFormat1 = binaryFormat)
				{
					GetProgramBinaryNative(program, bufSize, plength0, pbinaryFormat1, binary);
				}
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, ref int length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (int* plength0 = &length)
			{
				fixed (GLEnum* pbinaryFormat1 = &binaryFormat)
				{
					GetProgramBinaryNative(program, bufSize, plength0, pbinaryFormat1, binary);
				}
			}
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary(uint program, int bufSize, int* length, GLEnum* binaryFormat, nint binary)
		{
			GetProgramBinaryNative(program, bufSize, length, binaryFormat, (void*)binary);
		}

		/// <summary>
		/// Return a binary representation of a program object's compiled and linked executable source
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public static void GetProgramBinary<TBinary>(uint program, int bufSize, int* length, GLEnum* binaryFormat, Span<TBinary> binary) where TBinary : unmanaged
		{
			fixed (TBinary* pbinary0 = binary)
			{
				GetProgramBinaryNative(program, bufSize, length, binaryFormat, pbinary0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInfoLogNative(uint program, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[260])(program, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[260])(program, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, byte* infoLog)
		{
			GetProgramInfoLogNative(program, bufSize, length, infoLog);
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static string GetProgramInfoLog(uint program)
		{
			int pStrSize0;
			GetProgramiv(program, GLProgramPropertyARB.InfoLogLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetProgramInfoLogNative(program, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, Span<int> length, byte* infoLog)
		{
			fixed (int* plength0 = length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramInfoLogNative(program, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, Span<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, Span<int> length, Span<byte> infoLog)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pinfoLog1 = infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		/// <summary>
		/// Returns the information log for a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInterfaceivNative(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, int*, void>)funcTable[261])(program, programInterface, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, nint, void>)funcTable[261])(program, programInterface, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			GetProgramInterfaceivNative(program, programInterface, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, out int @params)
		{
			int pparams;
			GetProgramInterfaceivNative(program, programInterface, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetProgramInterfaceivNative(program, programInterface, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineInfoLogNative(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[262])(pipeline, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[262])(pipeline, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, infoLog);
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static string GetProgramPipelineInfoLog(uint pipeline)
		{
			int pStrSize0;
			GetProgramPipelineiv(pipeline, GLPipelineParameterName.InfoLogLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetProgramPipelineInfoLogNative(pipeline, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, Span<int> length, byte* infoLog)
		{
			fixed (int* plength0 = length)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, Span<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, Span<int> length, Span<byte> infoLog)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pinfoLog1 = infoLog)
				{
					GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		/// <summary>
		/// Retrieve the info log string from a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineivNative(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, int*, void>)funcTable[263])(pipeline, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, nint, void>)funcTable[263])(pipeline, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			GetProgramPipelineivNative(pipeline, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, out int @params)
		{
			int pparams;
			GetProgramPipelineivNative(pipeline, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetProgramPipelineivNative(pipeline, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetProgramResourceIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, uint>)funcTable[264])(program, programInterface, name);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, uint>)funcTable[264])(program, programInterface, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			uint ret = GetProgramResourceIndexNative(program, programInterface, name);
			return ret;
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetProgramResourceIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Query the index of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[265])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[265])(program, programInterface, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationNative(program, programInterface, name);
			return ret;
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Query the location of a named resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[266])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[266])(program, programInterface, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourceNameNative(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, int*, byte*, void>)funcTable[267])(program, programInterface, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, nint, nint, void>)funcTable[267])(program, programInterface, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, name);
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, Span<int> length, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, Span<int> length, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, pname1);
				}
			}
		}

		/// <summary>
		/// Query the name of an indexed resource within a program
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourceivNative(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLProgramResourceProperty, int, int*, int*, void>)funcTable[268])(program, programInterface, index, propCount, props, count, length, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLProgramResourceProperty, int, nint, nint, void>)funcTable[268])(program, programInterface, index, propCount, props, count, (nint)length, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, int* @params)
		{
			GetProgramResourceivNative(program, programInterface, index, propCount, props, count, length, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, out int @params)
		{
			int pparams;
			GetProgramResourceivNative(program, programInterface, index, propCount, props, count, length, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetProgramResourceivNative(program, programInterface, index, propCount, props, count, length, pparams);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, Span<int> length, int* @params)
		{
			fixed (int* plength0 = length)
			{
				GetProgramResourceivNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_program_interface_query</remarks>
		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, ref int length, int* @params)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourceivNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramStageivNative(uint program, GLShaderType shadertype, GLProgramStagePName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, GLProgramStagePName, int*, void>)funcTable[269])(program, shadertype, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, GLProgramStagePName, nint, void>)funcTable[269])(program, shadertype, pname, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetProgramStageiv(uint program, GLShaderType shadertype, GLProgramStagePName pname, int* values)
		{
			GetProgramStageivNative(program, shadertype, pname, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetProgramStageiv(uint program, GLShaderType shadertype, GLProgramStagePName pname, Span<int> values)
		{
			fixed (int* pvalues0 = values)
			{
				GetProgramStageivNative(program, shadertype, pname, pvalues0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetProgramStageiv(uint program, GLShaderType shadertype, GLProgramStagePName pname, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetProgramStageivNative(program, shadertype, pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramivNative(uint program, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, int*, void>)funcTable[270])(program, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, nint, void>)funcTable[270])(program, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Returns a parameter from a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, int* @params)
		{
			GetProgramivNative(program, pname, @params);
		}

		/// <summary>
		/// Returns a parameter from a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, out int @params)
		{
			int pparams;
			GetProgramivNative(program, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// Returns a parameter from a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetProgramivNative(program, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjecti64vNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[271])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[271])(id, buffer, pname, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetQueryBufferObjecti64v(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjecti64vNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectivNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[272])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[272])(id, buffer, pname, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetQueryBufferObjectiv(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectivNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectui64vNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[273])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[273])(id, buffer, pname, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetQueryBufferObjectui64v(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectui64vNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectuivNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[274])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[274])(id, buffer, pname, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetQueryBufferObjectuiv(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectuivNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryIndexedivNative(GLQueryTarget target, uint index, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, GLQueryParameterName, int*, void>)funcTable[275])(target, index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, GLQueryParameterName, nint, void>)funcTable[275])(target, index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public static void GetQueryIndexediv(GLQueryTarget target, uint index, GLQueryParameterName pname, int* @params)
		{
			GetQueryIndexedivNative(target, index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public static void GetQueryIndexediv(GLQueryTarget target, uint index, GLQueryParameterName pname, out int @params)
		{
			int pparams;
			GetQueryIndexedivNative(target, index, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public static void GetQueryIndexediv(GLQueryTarget target, uint index, GLQueryParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetQueryIndexedivNative(target, index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjecti64vNative(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, long*, void>)funcTable[276])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[276])(id, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_timer_query</remarks>
		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			GetQueryObjecti64vNative(id, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_timer_query</remarks>
		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, out long @params)
		{
			long pparams;
			GetQueryObjecti64vNative(id, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_timer_query</remarks>
		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, Span<long> @params)
		{
			fixed (long* pparams = @params)
			{
				GetQueryObjecti64vNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectivNative(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, int*, void>)funcTable[277])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[277])(id, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			GetQueryObjectivNative(id, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, out int @params)
		{
			int pparams;
			GetQueryObjectivNative(id, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetQueryObjectivNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectui64vNative(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, ulong*, void>)funcTable[278])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[278])(id, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_timer_query</remarks>
		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			GetQueryObjectui64vNative(id, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_timer_query</remarks>
		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, out ulong @params)
		{
			ulong pparams;
			GetQueryObjectui64vNative(id, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_timer_query</remarks>
		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, Span<ulong> @params)
		{
			fixed (ulong* pparams = @params)
			{
				GetQueryObjectui64vNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectuivNative(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, uint*, void>)funcTable[279])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[279])(id, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			GetQueryObjectuivNative(id, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, out uint @params)
		{
			uint pparams;
			GetQueryObjectuivNative(id, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetQueryObjectuivNative(id, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryivNative(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, int*, void>)funcTable[280])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, nint, void>)funcTable[280])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Return parameters of a query object target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			GetQueryivNative(target, pname, @params);
		}

		/// <summary>
		/// Return parameters of a query object target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, out int @params)
		{
			int pparams;
			GetQueryivNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// Return parameters of a query object target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetQueryivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRenderbufferParameterivNative(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, int*, void>)funcTable[281])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, nint, void>)funcTable[281])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Query a named parameter of a renderbuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			GetRenderbufferParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// Query a named parameter of a renderbuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, out int @params)
		{
			int pparams;
			GetRenderbufferParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// Query a named parameter of a renderbuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetRenderbufferParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[282])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[282])(sampler, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterIivNative(sampler, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, out int @params)
		{
			int pparams;
			GetSamplerParameterIivNative(sampler, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetSamplerParameterIivNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIuivNative(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[283])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[283])(sampler, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			GetSamplerParameterIuivNative(sampler, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, out uint @params)
		{
			uint pparams;
			GetSamplerParameterIuivNative(sampler, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetSamplerParameterIuivNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterfvNative(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float*, void>)funcTable[284])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, nint, void>)funcTable[284])(sampler, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			GetSamplerParameterfvNative(sampler, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, out float @params)
		{
			float pparams;
			GetSamplerParameterfvNative(sampler, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetSamplerParameterfvNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[285])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[285])(sampler, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterivNative(sampler, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, out int @params)
		{
			int pparams;
			GetSamplerParameterivNative(sampler, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetSamplerParameterivNative(sampler, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderInfoLogNative(uint shader, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[286])(shader, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[286])(shader, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, byte* infoLog)
		{
			GetShaderInfoLogNative(shader, bufSize, length, infoLog);
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static string GetShaderInfoLog(uint shader)
		{
			int pStrSize0;
			GetShaderiv(shader, GLShaderParameterName.InfoLogLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetShaderInfoLogNative(shader, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, Span<int> length, byte* infoLog)
		{
			fixed (int* plength0 = length)
			{
				GetShaderInfoLogNative(shader, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderInfoLogNative(shader, bufSize, plength0, infoLog);
			}
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderInfoLogNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, Span<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, Span<int> length, Span<byte> infoLog)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pinfoLog1 = infoLog)
				{
					GetShaderInfoLogNative(shader, bufSize, plength0, pinfoLog1);
				}
			}
		}

		/// <summary>
		/// Returns the information log for a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetShaderInfoLogNative(shader, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderPrecisionFormatNative(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, int*, int*, void>)funcTable[287])(shadertype, precisiontype, range, precision);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, nint, nint, void>)funcTable[287])(shadertype, precisiontype, (nint)range, (nint)precision);
			#endif
		}

		/// <summary>
		/// Retrieve the range and precision for numeric formats supported by the shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			GetShaderPrecisionFormatNative(shadertype, precisiontype, range, precision);
		}

		/// <summary>
		/// Retrieve the range and precision for numeric formats supported by the shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, Span<int> range, int* precision)
		{
			fixed (int* prange0 = range)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, precision);
			}
		}

		/// <summary>
		/// Retrieve the range and precision for numeric formats supported by the shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, int* precision)
		{
			fixed (int* prange0 = &range)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, precision);
			}
		}

		/// <summary>
		/// Retrieve the range and precision for numeric formats supported by the shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, Span<int> precision)
		{
			fixed (int* pprecision0 = precision)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, range, pprecision0);
			}
		}

		/// <summary>
		/// Retrieve the range and precision for numeric formats supported by the shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, ref int precision)
		{
			fixed (int* pprecision0 = &precision)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, range, pprecision0);
			}
		}

		/// <summary>
		/// Retrieve the range and precision for numeric formats supported by the shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, Span<int> range, Span<int> precision)
		{
			fixed (int* prange0 = range)
			{
				fixed (int* pprecision1 = precision)
				{
					GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, pprecision1);
				}
			}
		}

		/// <summary>
		/// Retrieve the range and precision for numeric formats supported by the shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, ref int precision)
		{
			fixed (int* prange0 = &range)
			{
				fixed (int* pprecision1 = &precision)
				{
					GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, pprecision1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderSourceNative(uint shader, int bufSize, int* length, byte* source)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[288])(shader, bufSize, length, source);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[288])(shader, bufSize, (nint)length, (nint)source);
			#endif
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, int* length, byte* source)
		{
			GetShaderSourceNative(shader, bufSize, length, source);
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static string GetShaderSource(uint shader)
		{
			int pStrSize0;
			GetShaderiv(shader, GLShaderParameterName.SourceLength, &pStrSize0);

			byte* pStr0 = null;
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
			}
			else
			{
				byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
				pStr0 = pStrStack0;
			}
			GetShaderSourceNative(shader, pStrSize0, null, pStr0);
			string ret = Utils.DecodeStringUTF8(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, Span<int> length, byte* source)
		{
			fixed (int* plength0 = length)
			{
				GetShaderSourceNative(shader, bufSize, plength0, source);
			}
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, ref int length, byte* source)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderSourceNative(shader, bufSize, plength0, source);
			}
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, int* length, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderSourceNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, int* length, Span<byte> source)
		{
			fixed (byte* psource0 = source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, int* length, ref byte source)
		{
			fixed (byte* psource0 = &source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, Span<int> length, Span<byte> source)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* psource1 = source)
				{
					GetShaderSourceNative(shader, bufSize, plength0, psource1);
				}
			}
		}

		/// <summary>
		/// Returns the source code string from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderSource(uint shader, int bufSize, ref int length, ref byte source)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* psource1 = &source)
				{
					GetShaderSourceNative(shader, bufSize, plength0, psource1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderivNative(uint shader, GLShaderParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, int*, void>)funcTable[289])(shader, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, nint, void>)funcTable[289])(shader, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Returns a parameter from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderiv(uint shader, GLShaderParameterName pname, int* @params)
		{
			GetShaderivNative(shader, pname, @params);
		}

		/// <summary>
		/// Returns a parameter from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderiv(uint shader, GLShaderParameterName pname, out int @params)
		{
			int pparams;
			GetShaderivNative(shader, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// Returns a parameter from a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetShaderiv(uint shader, GLShaderParameterName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetShaderivNative(shader, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringNative(GLStringName name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLStringName, byte*>)funcTable[290])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GLStringName, nint>)funcTable[290])(name);
			#endif
		}

		/// <summary>
		/// Return a string describing the current GL connection
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static byte* GetString(GLStringName name)
		{
			byte* ret = GetStringNative(name);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringiNative(GLStringName name, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLStringName, uint, byte*>)funcTable[291])(name, index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GLStringName, uint, nint>)funcTable[291])(name, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static byte* GetStringi(GLStringName name, uint index)
		{
			byte* ret = GetStringiNative(name, index);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSubroutineIndexNative(uint program, GLShaderType shadertype, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLShaderType, byte*, uint>)funcTable[292])(program, shadertype, name);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, GLShaderType, nint, uint>)funcTable[292])(program, shadertype, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, byte* name)
		{
			uint ret = GetSubroutineIndexNative(program, shadertype, name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetSubroutineIndexNative(program, shadertype, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				uint ret = GetSubroutineIndexNative(program, shadertype, pname0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				uint ret = GetSubroutineIndexNative(program, shadertype, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSubroutineUniformLocationNative(uint program, GLShaderType shadertype, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLShaderType, byte*, int>)funcTable[293])(program, shadertype, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLShaderType, nint, int>)funcTable[293])(program, shadertype, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, byte* name)
		{
			int ret = GetSubroutineUniformLocationNative(program, shadertype, name);
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetSubroutineUniformLocationNative(program, shadertype, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetSubroutineUniformLocationNative(program, shadertype, pname0);
				return ret;
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetSubroutineUniformLocationNative(program, shadertype, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSyncivNative(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, int*, int*, void>)funcTable[294])(sync, pname, count, length, values);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, nint, nint, void>)funcTable[294])(sync, pname, count, (nint)length, (nint)values);
			#endif
		}

		/// <summary>
		/// Query the properties of a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			GetSyncivNative(sync, pname, count, length, values);
		}

		/// <summary>
		/// Query the properties of a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, Span<int> length, int* values)
		{
			fixed (int* plength0 = length)
			{
				GetSyncivNative(sync, pname, count, plength0, values);
			}
		}

		/// <summary>
		/// Query the properties of a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, int* values)
		{
			fixed (int* plength0 = &length)
			{
				GetSyncivNative(sync, pname, count, plength0, values);
			}
		}

		/// <summary>
		/// Query the properties of a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, Span<int> values)
		{
			fixed (int* pvalues0 = values)
			{
				GetSyncivNative(sync, pname, count, length, pvalues0);
			}
		}

		/// <summary>
		/// Query the properties of a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetSyncivNative(sync, pname, count, length, pvalues0);
			}
		}

		/// <summary>
		/// Query the properties of a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, Span<int> length, Span<int> values)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* pvalues1 = values)
				{
					GetSyncivNative(sync, pname, count, plength0, pvalues1);
				}
			}
		}

		/// <summary>
		/// Query the properties of a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, ref int values)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* pvalues1 = &values)
				{
					GetSyncivNative(sync, pname, count, plength0, pvalues1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvfvNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[295])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[295])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			GetTexEnvfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, out float @params)
		{
			float pparams;
			GetTexEnvfvNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexEnvfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvivNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[296])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[296])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetTexEnvivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, out int @params)
		{
			int pparams;
			GetTexEnvivNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexEnvivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvxvNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[297])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[297])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnvxv(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetTexEnvxvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnvxv(GLTextureEnvTarget target, GLTextureEnvParameter pname, out int @params)
		{
			int pparams;
			GetTexEnvxvNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexEnvxv(GLTextureEnvTarget target, GLTextureEnvParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexEnvxvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexImageNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[298])(target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[298])(target, level, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetTexImageNative(target, level, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			GetTexImageNative(target, level, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexImage<TPixels>(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetTexImageNative(target, level, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterfvNative(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[299])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[299])(target, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTexLevelParameterfvNative(target, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTexLevelParameterfvNative(target, level, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexLevelParameterfvNative(target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterivNative(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[300])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[300])(target, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTexLevelParameterivNative(target, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexLevelParameterivNative(target, level, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexLevelParameterivNative(target, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[301])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[301])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterIivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexParameterIivNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexParameterIivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIuivNative(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[302])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[302])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTexParameterIuivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, out uint @params)
		{
			uint pparams;
			GetTexParameterIuivNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetTexParameterIuivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterfvNative(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[303])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[303])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTexParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTexParameterfvNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTexParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[304])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[304])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexParameterivNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterxvNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[305])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[305])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterxv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterxvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterxv(GLTextureTarget target, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTexParameterxvNative(target, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTexParameterxv(GLTextureTarget target, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTexParameterxvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureImageNative(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[306])(texture, level, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[306])(texture, level, format, type, bufSize, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureImage(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetTextureImageNative(texture, level, format, type, bufSize, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureImage(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, nint pixels)
		{
			GetTextureImageNative(texture, level, format, type, bufSize, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureImage<TPixels>(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetTextureImageNative(texture, level, format, type, bufSize, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterfvNative(uint texture, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, float*, void>)funcTable[307])(texture, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, nint, void>)funcTable[307])(texture, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureLevelParameterfv(uint texture, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTextureLevelParameterfvNative(texture, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureLevelParameterfv(uint texture, int level, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTextureLevelParameterfvNative(texture, level, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureLevelParameterfv(uint texture, int level, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTextureLevelParameterfvNative(texture, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterivNative(uint texture, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, int*, void>)funcTable[308])(texture, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, nint, void>)funcTable[308])(texture, level, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureLevelParameteriv(uint texture, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTextureLevelParameterivNative(texture, level, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureLevelParameteriv(uint texture, int level, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTextureLevelParameterivNative(texture, level, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureLevelParameteriv(uint texture, int level, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTextureLevelParameterivNative(texture, level, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIivNative(uint texture, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, int*, void>)funcTable[309])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[309])(texture, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterIiv(uint texture, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterIivNative(texture, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterIiv(uint texture, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTextureParameterIivNative(texture, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterIiv(uint texture, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTextureParameterIivNative(texture, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIuivNative(uint texture, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, uint*, void>)funcTable[310])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[310])(texture, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterIuiv(uint texture, GLGetTextureParameter pname, uint* @params)
		{
			GetTextureParameterIuivNative(texture, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterIuiv(uint texture, GLGetTextureParameter pname, out uint @params)
		{
			uint pparams;
			GetTextureParameterIuivNative(texture, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterIuiv(uint texture, GLGetTextureParameter pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetTextureParameterIuivNative(texture, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterfvNative(uint texture, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, float*, void>)funcTable[311])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[311])(texture, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterfv(uint texture, GLGetTextureParameter pname, float* @params)
		{
			GetTextureParameterfvNative(texture, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterfv(uint texture, GLGetTextureParameter pname, out float @params)
		{
			float pparams;
			GetTextureParameterfvNative(texture, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameterfv(uint texture, GLGetTextureParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetTextureParameterfvNative(texture, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterivNative(uint texture, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, int*, void>)funcTable[312])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[312])(texture, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameteriv(uint texture, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterivNative(texture, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameteriv(uint texture, GLGetTextureParameter pname, out int @params)
		{
			int pparams;
			GetTextureParameterivNative(texture, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTextureParameteriv(uint texture, GLGetTextureParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetTextureParameterivNative(texture, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[313])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[313])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_texture_sub_image</remarks>
		public static void GetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_texture_sub_image</remarks>
		public static void GetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, nint pixels)
		{
			GetTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_texture_sub_image</remarks>
		public static void GetTextureSubImage<TPixels>(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackVaryingNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[314])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[314])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, name);
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = size)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* psize0 = size)
			{
				fixed (byte* pname1 = name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					fixed (byte* pname2 = name)
					{
						GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		/// <summary>
		/// Retrieve information about varying variables selected for transform feedback
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbacki64_vNative(uint xfb, GLTransformFeedbackPName pname, uint index, long* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, long*, void>)funcTable[315])(xfb, pname, index, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, nint, void>)funcTable[315])(xfb, pname, index, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTransformFeedbacki64_v(uint xfb, GLTransformFeedbackPName pname, uint index, long* param)
		{
			GetTransformFeedbacki64_vNative(xfb, pname, index, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTransformFeedbacki64_v(uint xfb, GLTransformFeedbackPName pname, uint index, out long param)
		{
			long pparam;
			GetTransformFeedbacki64_vNative(xfb, pname, index, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbacki_vNative(uint xfb, GLTransformFeedbackPName pname, uint index, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, int*, void>)funcTable[316])(xfb, pname, index, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, nint, void>)funcTable[316])(xfb, pname, index, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTransformFeedbacki_v(uint xfb, GLTransformFeedbackPName pname, uint index, int* param)
		{
			GetTransformFeedbacki_vNative(xfb, pname, index, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTransformFeedbacki_v(uint xfb, GLTransformFeedbackPName pname, uint index, out int param)
		{
			int pparam;
			GetTransformFeedbacki_vNative(xfb, pname, index, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackivNative(uint xfb, GLTransformFeedbackPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, int*, void>)funcTable[317])(xfb, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, nint, void>)funcTable[317])(xfb, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTransformFeedbackiv(uint xfb, GLTransformFeedbackPName pname, int* param)
		{
			GetTransformFeedbackivNative(xfb, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetTransformFeedbackiv(uint xfb, GLTransformFeedbackPName pname, out int param)
		{
			int pparam;
			GetTransformFeedbackivNative(xfb, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUniformBlockIndexNative(uint program, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, uint>)funcTable[318])(program, uniformBlockName);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint>)funcTable[318])(program, (nint)uniformBlockName);
			#endif
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static uint GetUniformBlockIndex(uint program, byte* uniformBlockName)
		{
			uint ret = GetUniformBlockIndexNative(program, uniformBlockName);
			return ret;
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static uint GetUniformBlockIndex(uint program, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetUniformBlockIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static uint GetUniformBlockIndex(uint program, Span<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static uint GetUniformBlockIndex(uint program, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformIndicesNative(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, uint*, void>)funcTable[319])(program, uniformCount, uniformNames, uniformIndices);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[319])(program, uniformCount, (nint)uniformNames, (nint)uniformIndices);
			#endif
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			GetUniformIndicesNative(program, uniformCount, uniformNames, uniformIndices);
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, Span<uint> uniformIndices)
		{
			fixed (uint* puniformIndices0 = uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		/// <summary>
		/// Retrieve the index of a named uniform block
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUniformLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[320])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[320])(program, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static int GetUniformLocation(uint program, byte* name)
		{
			int ret = GetUniformLocationNative(program, name);
			return ret;
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static int GetUniformLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetUniformLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static int GetUniformLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Returns the location of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static int GetUniformLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformSubroutineuivNative(GLShaderType shadertype, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, int, uint*, void>)funcTable[321])(shadertype, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, void>)funcTable[321])(shadertype, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetUniformSubroutineuiv(GLShaderType shadertype, int location, uint* @params)
		{
			GetUniformSubroutineuivNative(shadertype, location, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetUniformSubroutineuiv(GLShaderType shadertype, int location, out uint @params)
		{
			uint pparams;
			GetUniformSubroutineuivNative(shadertype, location, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetUniformSubroutineuiv(GLShaderType shadertype, int location, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetUniformSubroutineuivNative(shadertype, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformdvNative(uint program, int location, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[322])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[322])(program, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void GetUniformdv(uint program, int location, double* @params)
		{
			GetUniformdvNative(program, location, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void GetUniformdv(uint program, int location, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetUniformdvNative(program, location, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_gpu_shader_fp64</remarks>
		public static void GetUniformdv(uint program, int location, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetUniformdvNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformfvNative(uint program, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[323])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[323])(program, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// Returns the value of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformfv(uint program, int location, float* @params)
		{
			GetUniformfvNative(program, location, @params);
		}

		/// <summary>
		/// Returns the value of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformfv(uint program, int location, out float @params)
		{
			float pparams;
			GetUniformfvNative(program, location, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// Returns the value of a uniform variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformfv(uint program, int location, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetUniformfvNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformivNative(uint program, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[324])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[324])(program, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformiv(uint program, int location, int* @params)
		{
			GetUniformivNative(program, location, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformiv(uint program, int location, out int @params)
		{
			int pparams;
			GetUniformivNative(program, location, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformiv(uint program, int location, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetUniformivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformuivNative(uint program, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[325])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[325])(program, location, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformuiv(uint program, int location, uint* @params)
		{
			GetUniformuivNative(program, location, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformuiv(uint program, int location, out uint @params)
		{
			uint pparams;
			GetUniformuivNative(program, location, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetUniformuiv(uint program, int location, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetUniformuivNative(program, location, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIndexed64ivNative(uint vaobj, uint index, GLVertexArrayPName pname, long* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, long*, void>)funcTable[326])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[326])(vaobj, index, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetVertexArrayIndexed64iv(uint vaobj, uint index, GLVertexArrayPName pname, long* param)
		{
			GetVertexArrayIndexed64ivNative(vaobj, index, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetVertexArrayIndexed64iv(uint vaobj, uint index, GLVertexArrayPName pname, out long param)
		{
			long pparam;
			GetVertexArrayIndexed64ivNative(vaobj, index, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIndexedivNative(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, int*, void>)funcTable[327])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[327])(vaobj, index, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetVertexArrayIndexediv(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIndexedivNative(vaobj, index, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetVertexArrayIndexediv(uint vaobj, uint index, GLVertexArrayPName pname, out int param)
		{
			int pparam;
			GetVertexArrayIndexedivNative(vaobj, index, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayivNative(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, int*, void>)funcTable[328])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[328])(vaobj, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetVertexArrayiv(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayivNative(vaobj, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GetVertexArrayiv(uint vaobj, GLVertexArrayPName pname, out int param)
		{
			int pparam;
			GetVertexArrayivNative(vaobj, pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIivNative(uint index, GLVertexAttribEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, int*, void>)funcTable[329])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[329])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, int* @params)
		{
			GetVertexAttribIivNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, out int @params)
		{
			int pparams;
			GetVertexAttribIivNative(index, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribIivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIuivNative(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, uint*, void>)funcTable[330])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[330])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			GetVertexAttribIuivNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, out uint @params)
		{
			uint pparams;
			GetVertexAttribIuivNative(index, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetVertexAttribIuivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribLdvNative(uint index, GLVertexAttribEnum pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, double*, void>)funcTable[331])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[331])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void GetVertexAttribLdv(uint index, GLVertexAttribEnum pname, double* @params)
		{
			GetVertexAttribLdvNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void GetVertexAttribLdv(uint index, GLVertexAttribEnum pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetVertexAttribLdvNative(index, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public static void GetVertexAttribLdv(uint index, GLVertexAttribEnum pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribLdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[332])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[332])(index, pname, (nint)pointer);
			#endif
		}

		/// <summary>
		/// Return the address of the specified generic vertex attribute pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribPointerv(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[333])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[333])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[334])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[334])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, out float @params)
		{
			float pparams;
			GetVertexAttribfvNative(index, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetVertexAttribfvNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[335])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[335])(index, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivNative(index, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, out int @params)
		{
			int pparams;
			GetVertexAttribivNative(index, pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetVertexAttribivNative(index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnCompressedTexImageNative(GLTextureTarget target, int lod, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, void*, void>)funcTable[336])(target, lod, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, nint, void>)funcTable[336])(target, lod, bufSize, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnCompressedTexImage(GLTextureTarget target, int lod, int bufSize, void* pixels)
		{
			GetnCompressedTexImageNative(target, lod, bufSize, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnCompressedTexImage(GLTextureTarget target, int lod, int bufSize, nint pixels)
		{
			GetnCompressedTexImageNative(target, lod, bufSize, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnCompressedTexImage<TPixels>(GLTextureTarget target, int lod, int bufSize, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetnCompressedTexImageNative(target, lod, bufSize, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnTexImageNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[337])(target, level, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[337])(target, level, format, type, bufSize, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetnTexImageNative(target, level, format, type, bufSize, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, nint pixels)
		{
			GetnTexImageNative(target, level, format, type, bufSize, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnTexImage<TPixels>(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				GetnTexImageNative(target, level, format, type, bufSize, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformdvNative(uint program, int location, int bufSize, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[338])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[338])(program, location, bufSize, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnUniformdv(uint program, int location, int bufSize, double* @params)
		{
			GetnUniformdvNative(program, location, bufSize, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnUniformdv(uint program, int location, int bufSize, Span<double> @params)
		{
			fixed (double* pparams0 = @params)
			{
				GetnUniformdvNative(program, location, bufSize, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void GetnUniformdv(uint program, int location, int bufSize, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetnUniformdvNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformfvNative(uint program, int location, int bufSize, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[339])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[339])(program, location, bufSize, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformfv(uint program, int location, int bufSize, float* @params)
		{
			GetnUniformfvNative(program, location, bufSize, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformfv(uint program, int location, int bufSize, out float @params)
		{
			float pparams;
			GetnUniformfvNative(program, location, bufSize, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformfv(uint program, int location, int bufSize, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetnUniformfvNative(program, location, bufSize, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformivNative(uint program, int location, int bufSize, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[340])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[340])(program, location, bufSize, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformiv(uint program, int location, int bufSize, int* @params)
		{
			GetnUniformivNative(program, location, bufSize, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformiv(uint program, int location, int bufSize, out int @params)
		{
			int pparams;
			GetnUniformivNative(program, location, bufSize, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformiv(uint program, int location, int bufSize, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetnUniformivNative(program, location, bufSize, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformuivNative(uint program, int location, int bufSize, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[341])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[341])(program, location, bufSize, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformuiv(uint program, int location, int bufSize, uint* @params)
		{
			GetnUniformuivNative(program, location, bufSize, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformuiv(uint program, int location, int bufSize, out uint @params)
		{
			uint pparams;
			GetnUniformuivNative(program, location, bufSize, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public static void GetnUniformuiv(uint program, int location, int bufSize, Span<uint> @params)
		{
			fixed (uint* pparams = @params)
			{
				GetnUniformuivNative(program, location, bufSize, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HintNative(GLHintTarget target, GLHintMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[342])(target, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLHintTarget, GLHintMode, void>)funcTable[342])(target, mode);
			#endif
		}

		/// <summary>
		/// Specify implementation-specific hints
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Hint(GLHintTarget target, GLHintMode mode)
		{
			HintNative(target, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateBufferDataNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[343])(buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[343])(buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_invalidate_subdata</remarks>
		public static void InvalidateBufferData(uint buffer)
		{
			InvalidateBufferDataNative(buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateBufferSubDataNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[344])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[344])(buffer, offset, length);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_invalidate_subdata</remarks>
		public static void InvalidateBufferSubData(uint buffer, nint offset, nint length)
		{
			InvalidateBufferSubDataNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateFramebufferNative(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, void>)funcTable[345])(target, numAttachments, attachments);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, void>)funcTable[345])(target, numAttachments, attachments);
			#endif
		}

		/// <summary>
		/// Invalidate the content of some or all of a framebuffer's attachments
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_invalidate_subdata</remarks>
		public static void InvalidateFramebuffer(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments)
		{
			InvalidateFramebufferNative(target, numAttachments, attachments);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateNamedFramebufferDataNative(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, void>)funcTable[346])(framebuffer, numAttachments, attachments);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, void>)funcTable[346])(framebuffer, numAttachments, attachments);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void InvalidateNamedFramebufferData(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments)
		{
			InvalidateNamedFramebufferDataNative(framebuffer, numAttachments, attachments);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateNamedFramebufferSubDataNative(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, int, int, int, int, void>)funcTable[347])(framebuffer, numAttachments, attachments, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, int, int, int, int, void>)funcTable[347])(framebuffer, numAttachments, attachments, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void InvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			InvalidateNamedFramebufferSubDataNative(framebuffer, numAttachments, attachments, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateSubFramebufferNative(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, int, int, int, int, void>)funcTable[348])(target, numAttachments, attachments, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, int, int, int, int, void>)funcTable[348])(target, numAttachments, attachments, x, y, width, height);
			#endif
		}

		/// <summary>
		/// Invalidate the content of a region of some or all of a framebuffer's attachments
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_invalidate_subdata</remarks>
		public static void InvalidateSubFramebuffer(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			InvalidateSubFramebufferNative(target, numAttachments, attachments, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateTexImageNative(uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[349])(texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[349])(texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_invalidate_subdata</remarks>
		public static void InvalidateTexImage(uint texture, int level)
		{
			InvalidateTexImageNative(texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateTexSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[350])(texture, level, xoffset, yoffset, zoffset, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[350])(texture, level, xoffset, yoffset, zoffset, width, height, depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_invalidate_subdata</remarks>
		public static void InvalidateTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)
		{
			InvalidateTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBufferNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[351])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[351])(buffer);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a buffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static bool IsBuffer(uint buffer)
		{
			byte ret = IsBufferNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnabledNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[352])(cap);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, byte>)funcTable[352])(cap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static bool IsEnabled(GLEnableCap cap)
		{
			byte ret = IsEnabledNative(cap);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnablediNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[353])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[353])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static bool IsEnabledi(GLEnableCap target, uint index)
		{
			byte ret = IsEnablediNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFramebufferNative(uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[354])(framebuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[354])(framebuffer);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static bool IsFramebuffer(uint framebuffer)
		{
			byte ret = IsFramebufferNative(framebuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[355])(program);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[355])(program);
			#endif
		}

		/// <summary>
		/// Determines if a name corresponds to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static bool IsProgram(uint program)
		{
			byte ret = IsProgramNative(program);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[356])(pipeline);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[356])(pipeline);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static bool IsProgramPipeline(uint pipeline)
		{
			byte ret = IsProgramPipelineNative(pipeline);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQueryNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[357])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[357])(id);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a query object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static bool IsQuery(uint id)
		{
			byte ret = IsQueryNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsRenderbufferNative(uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[358])(renderbuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[358])(renderbuffer);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a renderbuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static bool IsRenderbuffer(uint renderbuffer)
		{
			byte ret = IsRenderbufferNative(renderbuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSamplerNative(uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[359])(sampler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[359])(sampler);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a sampler object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public static bool IsSampler(uint sampler)
		{
			byte ret = IsSamplerNative(sampler);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[360])(shader);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[360])(shader);
			#endif
		}

		/// <summary>
		/// Determines if a name corresponds to a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static bool IsShader(uint shader)
		{
			byte ret = IsShaderNative(shader);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[361])(sync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[361])(sync);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static bool IsSync(GLSync sync)
		{
			byte ret = IsSyncNative(sync);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[362])(texture);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[362])(texture);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a texture
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static bool IsTexture(uint texture)
		{
			byte ret = IsTextureNative(texture);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTransformFeedbackNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[363])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[363])(id);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a transform feedback object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static bool IsTransformFeedback(uint id)
		{
			byte ret = IsTransformFeedbackNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[364])(array);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[364])(array);
			#endif
		}

		/// <summary>
		/// Determine if a name corresponds to a vertex array object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static bool IsVertexArray(uint array)
		{
			byte ret = IsVertexArrayNative(array);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfNative(GLLightModelParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[365])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float, void>)funcTable[365])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void LightModelf(GLLightModelParameter pname, float param)
		{
			LightModelfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelfvNative(GLLightModelParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, float*, void>)funcTable[366])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[366])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void LightModelfv(GLLightModelParameter pname, float* @params)
		{
			LightModelfvNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void LightModelfv(GLLightModelParameter pname, out float @params)
		{
			float pparams;
			LightModelfvNative(pname, &pparams);
			@params = pparams;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void LightModelfv(GLLightModelParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				LightModelfvNative(pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelxNative(GLLightModelParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[367])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int, void>)funcTable[367])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void LightModelx(GLLightModelParameter pname, int param)
		{
			LightModelxNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightModelxvNative(GLLightModelParameter pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, int*, void>)funcTable[368])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightModelParameter, nint, void>)funcTable[368])(pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void LightModelxv(GLLightModelParameter pname, int* param)
		{
			LightModelxvNative(pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void LightModelxv(GLLightModelParameter pname, out int param)
		{
			int pparam;
			LightModelxvNative(pname, &pparam);
			param = pparam;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfNative(GLLightName light, GLLightParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[369])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[369])(light, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Lightf(GLLightName light, GLLightParameter pname, float param)
		{
			LightfNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[370])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[370])(light, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Lightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			LightfvNative(light, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public static void Lightfv(GLLightName light, GLLightParameter pname, out float @params)
		{
			float pparams;
			LightfvNative(light, pname, &pparams);
			@params = pparams;
		}
	}
}
