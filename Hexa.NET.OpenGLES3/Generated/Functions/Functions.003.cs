// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES
{
	public unsafe partial class GL
	{

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LightModelxv(GLLightModelParameter pname, int* param)
		{
			LightModelxvNative(pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LightModelxv(GLLightModelParameter pname, Span<int> param)
		{
			fixed (int* pparam0 = param)
			{
				LightModelxvNative(pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LightModelxv(GLLightModelParameter pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				LightModelxvNative(pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightfNative(GLLightName light, GLLightParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[369])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float, void>)funcTable[369])(light, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightf(GLLightName light, GLLightParameter pname, float param)
		{
			LightfNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[370])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[370])(light, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			LightfvNative(light, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightfv(GLLightName light, GLLightParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				LightfvNative(light, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightfv(GLLightName light, GLLightParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				LightfvNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightxNative(GLLightName light, GLLightParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[371])(light, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int, void>)funcTable[371])(light, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightx(GLLightName light, GLLightParameter pname, int param)
		{
			LightxNative(light, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LightxvNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[372])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[372])(light, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightxv(GLLightName light, GLLightParameter pname, int* @params)
		{
			LightxvNative(light, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightxv(GLLightName light, GLLightParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				LightxvNative(light, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Lightxv(GLLightName light, GLLightParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				LightxvNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LineWidthNative(float width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[373])(width);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[373])(width);
			#endif
		}

		/// <summary>
		/// Specify the width of rasterized lines
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LineWidth(float width)
		{
			LineWidthNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LineWidthxNative(int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[374])(width);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[374])(width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LineWidthx(int width)
		{
			LineWidthxNative(width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LinkProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[375])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[375])(program);
			#endif
		}

		/// <summary>
		/// Links a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LinkProgram(uint program)
		{
			LinkProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadIdentityNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[376])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[376])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LoadIdentity()
		{
			LoadIdentityNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[377])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[377])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LoadMatrixf(float* m)
		{
			LoadMatrixfNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LoadMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LoadMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LoadMatrixxNative(int* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[378])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[378])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LoadMatrixx(int* m)
		{
			LoadMatrixxNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LoadMatrixx(Span<int> m)
		{
			fixed (int* pm0 = m)
			{
				LoadMatrixxNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LoadMatrixx(ref int m)
		{
			fixed (int* pm0 = &m)
			{
				LoadMatrixxNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void LogicOpNative(GLLogicOp opcode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[379])(opcode);
			#else
			((delegate* unmanaged[Cdecl]<GLLogicOp, void>)funcTable[379])(opcode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void LogicOp(GLLogicOp opcode)
		{
			LogicOpNative(opcode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void* MapBufferNative(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, void*>)funcTable[380])(target, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, nint>)funcTable[380])(target, access);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void* MapBuffer(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			void* ret = MapBufferNative(target, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void* MapBufferRangeNative(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, void*>)funcTable[381])(target, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, nint>)funcTable[381])(target, offset, length, access);
			#endif
		}

		/// <summary>
		/// Map all or part of a buffer object's data store into the client's address space
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_map_buffer_range</remarks>
		public void* MapBufferRange(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapBufferRangeNative(target, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void* MapNamedBufferNative(uint buffer, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, void*>)funcTable[382])(buffer, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, nint>)funcTable[382])(buffer, access);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void* MapNamedBuffer(uint buffer, GLBufferAccessARB access)
		{
			void* ret = MapNamedBufferNative(buffer, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void* MapNamedBufferRangeNative(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, void*>)funcTable[383])(buffer, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, nint>)funcTable[383])(buffer, offset, length, access);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void* MapNamedBufferRange(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapNamedBufferRangeNative(buffer, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialfNative(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[384])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float, void>)funcTable[384])(face, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialf(GLTriangleFace face, GLMaterialParameter pname, float param)
		{
			MaterialfNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialfvNative(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float*, void>)funcTable[385])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[385])(face, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialfv(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			MaterialfvNative(face, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialfv(GLTriangleFace face, GLMaterialParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				MaterialfvNative(face, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialfv(GLTriangleFace face, GLMaterialParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				MaterialfvNative(face, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialxNative(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[386])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int, void>)funcTable[386])(face, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialx(GLTriangleFace face, GLMaterialParameter pname, int param)
		{
			MaterialxNative(face, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MaterialxvNative(GLTriangleFace face, GLMaterialParameter pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[387])(face, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[387])(face, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialxv(GLTriangleFace face, GLMaterialParameter pname, int* param)
		{
			MaterialxvNative(face, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialxv(GLTriangleFace face, GLMaterialParameter pname, Span<int> param)
		{
			fixed (int* pparam0 = param)
			{
				MaterialxvNative(face, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Materialxv(GLTriangleFace face, GLMaterialParameter pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				MaterialxvNative(face, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MatrixModeNative(GLMatrixMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[388])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLMatrixMode, void>)funcTable[388])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MatrixMode(GLMatrixMode mode)
		{
			MatrixModeNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MemoryBarrierNative(GLMemoryBarrierMask barriers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[389])(barriers);
			#else
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[389])(barriers);
			#endif
		}

		/// <summary>
		/// Defines a barrier ordering memory transactions
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_image_load_store</remarks>
		public void MemoryBarrier(GLMemoryBarrierMask barriers)
		{
			MemoryBarrierNative(barriers);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MemoryBarrierByRegionNative(GLMemoryBarrierMask barriers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[390])(barriers);
			#else
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[390])(barriers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES3_1_compatibility</remarks>
		public void MemoryBarrierByRegion(GLMemoryBarrierMask barriers)
		{
			MemoryBarrierByRegionNative(barriers);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MinSampleShadingNative(float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[391])(value);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[391])(value);
			#endif
		}

		/// <summary>
		/// Specifies minimum rate at which sample shading takes place
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MinSampleShading(float value)
		{
			MinSampleShadingNative(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultMatrixfNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[392])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[392])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultMatrixf(float* m)
		{
			MultMatrixfNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultMatrixf(Span<float> m)
		{
			fixed (float* pm0 = m)
			{
				MultMatrixfNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultMatrixf(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultMatrixfNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultMatrixxNative(int* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[393])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[393])((nint)m);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultMatrixx(int* m)
		{
			MultMatrixxNative(m);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultMatrixx(Span<int> m)
		{
			fixed (int* pm0 = m)
			{
				MultMatrixxNative(pm0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultMatrixx(ref int m)
		{
			fixed (int* pm0 = &m)
			{
				MultMatrixxNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawArraysNative(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, int*, int, void>)funcTable[394])(mode, first, count, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, void>)funcTable[394])(mode, (nint)first, (nint)count, drawcount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, int* first, int* count, int drawcount)
		{
			MultiDrawArraysNative(mode, first, count, drawcount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, ref int first, int* count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				MultiDrawArraysNative(mode, pfirst0, count, drawcount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, int* first, Span<int> count, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, int* first, ref int count, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawArraysNative(mode, first, pcount0, drawcount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, Span<int> first, Span<int> count, int drawcount)
		{
			fixed (int* pfirst0 = first)
			{
				fixed (int* pcount1 = count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArrays(GLPrimitiveType mode, ref int first, ref int count, int drawcount)
		{
			fixed (int* pfirst0 = &first)
			{
				fixed (int* pcount1 = &count)
				{
					MultiDrawArraysNative(mode, pfirst0, pcount1, drawcount);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawArraysIndirectNative(GLPrimitiveType mode, void* indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, int, int, void>)funcTable[395])(mode, indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, int, int, void>)funcTable[395])(mode, (nint)indirect, drawcount, stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_draw_indirect</remarks>
		public void MultiDrawArraysIndirect(GLPrimitiveType mode, void* indirect, int drawcount, int stride)
		{
			MultiDrawArraysIndirectNative(mode, indirect, drawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_draw_indirect</remarks>
		public void MultiDrawArraysIndirect(GLPrimitiveType mode, nint indirect, int drawcount, int stride)
		{
			MultiDrawArraysIndirectNative(mode, (void*)indirect, drawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_draw_indirect</remarks>
		public void MultiDrawArraysIndirect<TIndirect>(GLPrimitiveType mode, Span<TIndirect> indirect, int drawcount, int stride) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				MultiDrawArraysIndirectNative(mode, pindirect0, drawcount, stride);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawArraysIndirectCountNative(GLPrimitiveType mode, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, nint, int, int, void>)funcTable[396])(mode, indirect, drawcount, maxdrawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, int, void>)funcTable[396])(mode, (nint)indirect, drawcount, maxdrawcount, stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArraysIndirectCount(GLPrimitiveType mode, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawArraysIndirectCountNative(mode, indirect, drawcount, maxdrawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArraysIndirectCount(GLPrimitiveType mode, nint indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawArraysIndirectCountNative(mode, (void*)indirect, drawcount, maxdrawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawArraysIndirectCount<TIndirect>(GLPrimitiveType mode, Span<TIndirect> indirect, nint drawcount, int maxdrawcount, int stride) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				MultiDrawArraysIndirectCountNative(mode, pindirect0, drawcount, maxdrawcount, stride);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawElementsNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, void>)funcTable[397])(mode, count, type, indices, drawcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, void>)funcTable[397])(mode, (nint)count, type, (nint)indices, drawcount);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawElements(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount)
		{
			MultiDrawElementsNative(mode, count, type, indices, drawcount);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawElements(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawElements(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsNative(mode, pcount0, type, indices, drawcount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawElementsBaseVertexNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, int*, void>)funcTable[398])(mode, count, type, indices, drawcount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, nint, void>)funcTable[398])(mode, (nint)count, type, (nint)indices, drawcount, (nint)basevertex);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, basevertex);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pbasevertex0 = basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pbasevertex0 = &basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, Span<int> count, GLDrawElementsType type, void** indices, int drawcount, Span<int> basevertex)
		{
			fixed (int* pcount0 = count)
			{
				fixed (int* pbasevertex1 = basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (int* pbasevertex1 = &basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawElementsIndirectNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, int, int, void>)funcTable[399])(mode, type, indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, int, int, void>)funcTable[399])(mode, type, (nint)indirect, drawcount, stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_draw_indirect</remarks>
		public void MultiDrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawcount, int stride)
		{
			MultiDrawElementsIndirectNative(mode, type, indirect, drawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_draw_indirect</remarks>
		public void MultiDrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, nint indirect, int drawcount, int stride)
		{
			MultiDrawElementsIndirectNative(mode, type, (void*)indirect, drawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_draw_indirect</remarks>
		public void MultiDrawElementsIndirect<TIndirect>(GLPrimitiveType mode, GLDrawElementsType type, Span<TIndirect> indirect, int drawcount, int stride) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				MultiDrawElementsIndirectNative(mode, type, pindirect0, drawcount, stride);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiDrawElementsIndirectCountNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, nint, int, int, void>)funcTable[400])(mode, type, indirect, drawcount, maxdrawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, nint, int, int, void>)funcTable[400])(mode, type, (nint)indirect, drawcount, maxdrawcount, stride);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawElementsIndirectCount(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawElementsIndirectCountNative(mode, type, indirect, drawcount, maxdrawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawElementsIndirectCount(GLPrimitiveType mode, GLDrawElementsType type, nint indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawElementsIndirectCountNative(mode, type, (void*)indirect, drawcount, maxdrawcount, stride);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiDrawElementsIndirectCount<TIndirect>(GLPrimitiveType mode, GLDrawElementsType type, Span<TIndirect> indirect, nint drawcount, int maxdrawcount, int stride) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				MultiDrawElementsIndirectCountNative(mode, type, pindirect0, drawcount, maxdrawcount, stride);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4fNative(GLTextureUnit target, float s, float t, float r, float q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[401])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[401])(target, s, t, r, q);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiTexCoord4f(GLTextureUnit target, float s, float t, float r, float q)
		{
			MultiTexCoord4fNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MultiTexCoord4xNative(GLTextureUnit texture, int s, int t, int r, int q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[402])(texture, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[402])(texture, s, t, r, q);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void MultiTexCoord4x(GLTextureUnit texture, int s, int t, int r, int q)
		{
			MultiTexCoord4xNative(texture, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedBufferDataNative(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLVertexBufferObjectUsage, void>)funcTable[403])(buffer, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLVertexBufferObjectUsage, void>)funcTable[403])(buffer, size, (nint)data, usage);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferData(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			NamedBufferDataNative(buffer, size, data, usage);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferData(uint buffer, nint size, nint data, GLVertexBufferObjectUsage usage)
		{
			NamedBufferDataNative(buffer, size, (void*)data, usage);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferData<TData>(uint buffer, nint size, Span<TData> data, GLVertexBufferObjectUsage usage) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				NamedBufferDataNative(buffer, size, pdata0, usage);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedBufferStorageNative(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLBufferStorageMask, void>)funcTable[404])(buffer, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLBufferStorageMask, void>)funcTable[404])(buffer, size, (nint)data, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferStorage(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			NamedBufferStorageNative(buffer, size, data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferStorage(uint buffer, nint size, nint data, GLBufferStorageMask flags)
		{
			NamedBufferStorageNative(buffer, size, (void*)data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferStorage<TData>(uint buffer, nint size, Span<TData> data, GLBufferStorageMask flags) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				NamedBufferStorageNative(buffer, size, pdata0, flags);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedBufferSubDataNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[405])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[405])(buffer, offset, size, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferSubData(uint buffer, nint offset, nint size, void* data)
		{
			NamedBufferSubDataNative(buffer, offset, size, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferSubData(uint buffer, nint offset, nint size, nint data)
		{
			NamedBufferSubDataNative(buffer, offset, size, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedBufferSubData<TData>(uint buffer, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				NamedBufferSubDataNative(buffer, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedFramebufferDrawBufferNative(uint framebuffer, GLColorBuffer buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[406])(framebuffer, buf);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[406])(framebuffer, buf);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedFramebufferDrawBuffer(uint framebuffer, GLColorBuffer buf)
		{
			NamedFramebufferDrawBufferNative(framebuffer, buf);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedFramebufferDrawBuffersNative(uint framebuffer, int n, GLColorBuffer bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLColorBuffer, void>)funcTable[407])(framebuffer, n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLColorBuffer, void>)funcTable[407])(framebuffer, n, bufs);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedFramebufferDrawBuffers(uint framebuffer, int n, GLColorBuffer bufs)
		{
			NamedFramebufferDrawBuffersNative(framebuffer, n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedFramebufferParameteriNative(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[408])(framebuffer, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[408])(framebuffer, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedFramebufferParameteri(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			NamedFramebufferParameteriNative(framebuffer, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedFramebufferReadBufferNative(uint framebuffer, GLColorBuffer src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[409])(framebuffer, src);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[409])(framebuffer, src);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedFramebufferReadBuffer(uint framebuffer, GLColorBuffer src)
		{
			NamedFramebufferReadBufferNative(framebuffer, src);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedFramebufferRenderbufferNative(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[410])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[410])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedFramebufferRenderbuffer(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			NamedFramebufferRenderbufferNative(framebuffer, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedFramebufferTextureNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[411])(framebuffer, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[411])(framebuffer, attachment, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedFramebufferTexture(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			NamedFramebufferTextureNative(framebuffer, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedFramebufferTextureLayerNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[412])(framebuffer, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[412])(framebuffer, attachment, texture, level, layer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedFramebufferTextureLayer(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			NamedFramebufferTextureLayerNative(framebuffer, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedRenderbufferStorageNative(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[413])(renderbuffer, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[413])(renderbuffer, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedRenderbufferStorage(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageNative(renderbuffer, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedRenderbufferStorageMultisampleNative(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[414])(renderbuffer, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[414])(renderbuffer, samples, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void NamedRenderbufferStorageMultisample(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageMultisampleNative(renderbuffer, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3fNative(float nx, float ny, float nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[415])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[415])(nx, ny, nz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Normal3f(float nx, float ny, float nz)
		{
			Normal3fNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Normal3xNative(int nx, int ny, int nz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[416])(nx, ny, nz);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[416])(nx, ny, nz);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Normal3x(int nx, int ny, int nz)
		{
			Normal3xNative(nx, ny, nz);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NormalPointerNative(GLNormalPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, int, void*, void>)funcTable[417])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, int, nint, void>)funcTable[417])(type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void NormalPointer(GLNormalPointerType type, int stride, void* pointer)
		{
			NormalPointerNative(type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void NormalPointer(GLNormalPointerType type, int stride, nint pointer)
		{
			NormalPointerNative(type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void NormalPointer<TPointer>(GLNormalPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				NormalPointerNative(type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ObjectLabelNative(GLObjectIdentifier identifier, uint name, int length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLObjectIdentifier, uint, int, byte*, void>)funcTable[418])(identifier, name, length, label);
			#else
			((delegate* unmanaged[Cdecl]<GLObjectIdentifier, uint, int, nint, void>)funcTable[418])(identifier, name, length, (nint)label);
			#endif
		}

		/// <summary>
		/// Label a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectLabel(GLObjectIdentifier identifier, uint name, int length, byte* label)
		{
			ObjectLabelNative(identifier, name, length, label);
		}

		/// <summary>
		/// Label a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectLabel(GLObjectIdentifier identifier, uint name, int length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ObjectLabelNative(identifier, name, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Label a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectLabel(GLObjectIdentifier identifier, uint name, int length, Span<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				ObjectLabelNative(identifier, name, length, plabel0);
			}
		}

		/// <summary>
		/// Label a named object identified within a namespace
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectLabel(GLObjectIdentifier identifier, uint name, int length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				ObjectLabelNative(identifier, name, length, plabel0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ObjectPtrLabelNative(void* ptr, int length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, int, byte*, void>)funcTable[419])(ptr, length, label);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, void>)funcTable[419])((nint)ptr, length, (nint)label);
			#endif
		}

		/// <summary>
		/// Label a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectPtrLabel(void* ptr, int length, byte* label)
		{
			ObjectPtrLabelNative(ptr, length, label);
		}

		/// <summary>
		/// Label a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectPtrLabel(nint ptr, int length, byte* label)
		{
			ObjectPtrLabelNative((void*)ptr, length, label);
		}

		/// <summary>
		/// Label a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectPtrLabel<TPtr>(Span<TPtr> ptr, int length, byte* label) where TPtr : unmanaged
		{
			fixed (TPtr* pptr0 = ptr)
			{
				ObjectPtrLabelNative(pptr0, length, label);
			}
		}

		/// <summary>
		/// Label a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectPtrLabel(void* ptr, int length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ObjectPtrLabelNative(ptr, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Label a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectPtrLabel(void* ptr, int length, Span<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				ObjectPtrLabelNative(ptr, length, plabel0);
			}
		}

		/// <summary>
		/// Label a sync object identified by a pointer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void ObjectPtrLabel(void* ptr, int length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				ObjectPtrLabelNative(ptr, length, plabel0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void OrthofNative(float l, float r, float b, float t, float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>)funcTable[420])(l, r, b, t, n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, void>)funcTable[420])(l, r, b, t, n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Orthof(float l, float r, float b, float t, float n, float f)
		{
			OrthofNative(l, r, b, t, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void OrthoxNative(int l, int r, int b, int t, int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[421])(l, r, b, t, n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, void>)funcTable[421])(l, r, b, t, n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Orthox(int l, int r, int b, int t, int n, int f)
		{
			OrthoxNative(l, r, b, t, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PatchParameterfvNative(GLPatchParameterName pname, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, float*, void>)funcTable[422])(pname, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, nint, void>)funcTable[422])(pname, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_tessellation_shader</remarks>
		public void PatchParameterfv(GLPatchParameterName pname, float* values)
		{
			PatchParameterfvNative(pname, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_tessellation_shader</remarks>
		public void PatchParameterfv(GLPatchParameterName pname, Span<float> values)
		{
			fixed (float* pvalues0 = values)
			{
				PatchParameterfvNative(pname, pvalues0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_tessellation_shader</remarks>
		public void PatchParameterfv(GLPatchParameterName pname, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				PatchParameterfvNative(pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PatchParameteriNative(GLPatchParameterName pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, int, void>)funcTable[423])(pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, int, void>)funcTable[423])(pname, value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_tessellation_shader</remarks>
		public void PatchParameteri(GLPatchParameterName pname, int value)
		{
			PatchParameteriNative(pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PauseTransformFeedbackNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[424])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[424])();
			#endif
		}

		/// <summary>
		/// Pause transform feedback operations
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public void PauseTransformFeedback()
		{
			PauseTransformFeedbackNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelStorefNative(GLPixelStoreParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[425])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, float, void>)funcTable[425])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PixelStoref(GLPixelStoreParameter pname, float param)
		{
			PixelStorefNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PixelStoreiNative(GLPixelStoreParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[426])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelStoreParameter, int, void>)funcTable[426])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PixelStorei(GLPixelStoreParameter pname, int param)
		{
			PixelStoreiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterfNative(GLPointParameterNameARB pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[427])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float, void>)funcTable[427])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterf(GLPointParameterNameARB pname, float param)
		{
			PointParameterfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterfvNative(GLPointParameterNameARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, float*, void>)funcTable[428])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[428])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterfv(GLPointParameterNameARB pname, float* @params)
		{
			PointParameterfvNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterfv(GLPointParameterNameARB pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				PointParameterfvNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterfv(GLPointParameterNameARB pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				PointParameterfvNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameteriNative(GLPointParameterNameARB pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[429])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[429])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameteri(GLPointParameterNameARB pname, int param)
		{
			PointParameteriNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterivNative(GLPointParameterNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int*, void>)funcTable[430])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[430])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameteriv(GLPointParameterNameARB pname, int* @params)
		{
			PointParameterivNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameteriv(GLPointParameterNameARB pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				PointParameterivNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameteriv(GLPointParameterNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				PointParameterivNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterxNative(GLPointParameterNameARB pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[431])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int, void>)funcTable[431])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterx(GLPointParameterNameARB pname, int param)
		{
			PointParameterxNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointParameterxvNative(GLPointParameterNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, int*, void>)funcTable[432])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLPointParameterNameARB, nint, void>)funcTable[432])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterxv(GLPointParameterNameARB pname, int* @params)
		{
			PointParameterxvNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterxv(GLPointParameterNameARB pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				PointParameterxvNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointParameterxv(GLPointParameterNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				PointParameterxvNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointSizeNative(float size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[433])(size);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[433])(size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointSize(float size)
		{
			PointSizeNative(size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PointSizexNative(int size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[434])(size);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[434])(size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PointSizex(int size)
		{
			PointSizexNative(size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PolygonModeNative(GLTriangleFace face, GLPolygonMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[435])(face, mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLPolygonMode, void>)funcTable[435])(face, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PolygonMode(GLTriangleFace face, GLPolygonMode mode)
		{
			PolygonModeNative(face, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PolygonOffsetNative(float factor, float units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[436])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[436])(factor, units);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PolygonOffset(float factor, float units)
		{
			PolygonOffsetNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PolygonOffsetClampNative(float factor, float units, float clamp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[437])(factor, units, clamp);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[437])(factor, units, clamp);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_polygon_offset_clamp</remarks>
		public void PolygonOffsetClamp(float factor, float units, float clamp)
		{
			PolygonOffsetClampNative(factor, units, clamp);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PolygonOffsetxNative(int factor, int units)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[438])(factor, units);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[438])(factor, units);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PolygonOffsetx(int factor, int units)
		{
			PolygonOffsetxNative(factor, units);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PopDebugGroupNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[439])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[439])();
			#endif
		}

		/// <summary>
		/// Pop the active debug group
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void PopDebugGroup()
		{
			PopDebugGroupNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PopMatrixNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[440])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[440])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PopMatrix()
		{
			PopMatrixNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PrimitiveBoundingBoxNative(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, void>)funcTable[441])(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, void>)funcTable[441])(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL ES 3.2</remarks>
		public void PrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)
		{
			PrimitiveBoundingBoxNative(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PrimitiveRestartIndexNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[442])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[442])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PrimitiveRestartIndex(uint index)
		{
			PrimitiveRestartIndexNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramBinaryNative(uint program, GLEnum binaryFormat, void* binary, int length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, void*, int, void>)funcTable[443])(program, binaryFormat, binary, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, int, void>)funcTable[443])(program, binaryFormat, (nint)binary, length);
			#endif
		}

		/// <summary>
		/// Load a program object with a program binary
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public void ProgramBinary(uint program, GLEnum binaryFormat, void* binary, int length)
		{
			ProgramBinaryNative(program, binaryFormat, binary, length);
		}

		/// <summary>
		/// Load a program object with a program binary
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public void ProgramBinary(uint program, GLEnum binaryFormat, nint binary, int length)
		{
			ProgramBinaryNative(program, binaryFormat, (void*)binary, length);
		}

		/// <summary>
		/// Load a program object with a program binary
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary</remarks>
		public void ProgramBinary<TBinary>(uint program, GLEnum binaryFormat, Span<TBinary> binary, int length) where TBinary : unmanaged
		{
			fixed (TBinary* pbinary0 = binary)
			{
				ProgramBinaryNative(program, binaryFormat, pbinary0, length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramParameteriNative(uint program, GLProgramParameterPName pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramParameterPName, int, void>)funcTable[444])(program, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramParameterPName, int, void>)funcTable[444])(program, pname, value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_get_program_binary<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramParameteri(uint program, GLProgramParameterPName pname, int value)
		{
			ProgramParameteriNative(program, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1dNative(uint program, int location, double v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, void>)funcTable[445])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, void>)funcTable[445])(program, location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1d(uint program, int location, double v0)
		{
			ProgramUniform1dNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1dvNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[446])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[446])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1dv(uint program, int location, int count, double* value)
		{
			ProgramUniform1dvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1dv(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform1dvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1dv(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform1dvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1fNative(uint program, int location, float v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[447])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[447])(program, location, v0);
			#endif
		}

		/// <summary>
		/// Specify the value of a uniform variable for a specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1f(uint program, int location, float v0)
		{
			ProgramUniform1fNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1fvNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[448])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[448])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1fv(uint program, int location, int count, float* value)
		{
			ProgramUniform1fvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1fv(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform1fvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1fv(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform1fvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1iNative(uint program, int location, int v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[449])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[449])(program, location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1i(uint program, int location, int v0)
		{
			ProgramUniform1iNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1ivNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[450])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[450])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1iv(uint program, int location, int count, int* value)
		{
			ProgramUniform1ivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1iv(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform1ivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1iv(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform1ivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1uiNative(uint program, int location, uint v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[451])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[451])(program, location, v0);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1ui(uint program, int location, uint v0)
		{
			ProgramUniform1uiNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform1uivNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[452])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[452])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1uiv(uint program, int location, int count, uint* value)
		{
			ProgramUniform1uivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1uiv(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform1uivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform1uiv(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform1uivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2dNative(uint program, int location, double v0, double v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, void>)funcTable[453])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, void>)funcTable[453])(program, location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2d(uint program, int location, double v0, double v1)
		{
			ProgramUniform2dNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2dvNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[454])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[454])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2dv(uint program, int location, int count, double* value)
		{
			ProgramUniform2dvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2dv(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform2dvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2dv(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform2dvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2fNative(uint program, int location, float v0, float v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[455])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[455])(program, location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2f(uint program, int location, float v0, float v1)
		{
			ProgramUniform2fNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2fvNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[456])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[456])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2fv(uint program, int location, int count, float* value)
		{
			ProgramUniform2fvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2fv(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform2fvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2fv(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform2fvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2iNative(uint program, int location, int v0, int v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[457])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[457])(program, location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2i(uint program, int location, int v0, int v1)
		{
			ProgramUniform2iNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2ivNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[458])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[458])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2iv(uint program, int location, int count, int* value)
		{
			ProgramUniform2ivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2iv(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform2ivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2iv(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform2ivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2uiNative(uint program, int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[459])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[459])(program, location, v0, v1);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2ui(uint program, int location, uint v0, uint v1)
		{
			ProgramUniform2uiNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform2uivNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[460])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[460])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2uiv(uint program, int location, int count, uint* value)
		{
			ProgramUniform2uivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2uiv(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform2uivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform2uiv(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform2uivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3dNative(uint program, int location, double v0, double v1, double v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, void>)funcTable[461])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, void>)funcTable[461])(program, location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3d(uint program, int location, double v0, double v1, double v2)
		{
			ProgramUniform3dNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3dvNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[462])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[462])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3dv(uint program, int location, int count, double* value)
		{
			ProgramUniform3dvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3dv(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform3dvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3dv(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform3dvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3fNative(uint program, int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[463])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[463])(program, location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3f(uint program, int location, float v0, float v1, float v2)
		{
			ProgramUniform3fNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3fvNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[464])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[464])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3fv(uint program, int location, int count, float* value)
		{
			ProgramUniform3fvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3fv(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform3fvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3fv(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform3fvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3iNative(uint program, int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[465])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[465])(program, location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3i(uint program, int location, int v0, int v1, int v2)
		{
			ProgramUniform3iNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3ivNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[466])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[466])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3iv(uint program, int location, int count, int* value)
		{
			ProgramUniform3ivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3iv(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform3ivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3iv(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform3ivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3uiNative(uint program, int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[467])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[467])(program, location, v0, v1, v2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3ui(uint program, int location, uint v0, uint v1, uint v2)
		{
			ProgramUniform3uiNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform3uivNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[468])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[468])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3uiv(uint program, int location, int count, uint* value)
		{
			ProgramUniform3uivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3uiv(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform3uivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform3uiv(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform3uivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4dNative(uint program, int location, double v0, double v1, double v2, double v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, double, void>)funcTable[469])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, double, double, double, double, void>)funcTable[469])(program, location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4d(uint program, int location, double v0, double v1, double v2, double v3)
		{
			ProgramUniform4dNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4dvNative(uint program, int location, int count, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[470])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[470])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4dv(uint program, int location, int count, double* value)
		{
			ProgramUniform4dvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4dv(uint program, int location, int count, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniform4dvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4dv(uint program, int location, int count, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniform4dvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4fNative(uint program, int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[471])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[471])(program, location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4f(uint program, int location, float v0, float v1, float v2, float v3)
		{
			ProgramUniform4fNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4fvNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[472])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[472])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4fv(uint program, int location, int count, float* value)
		{
			ProgramUniform4fvNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4fv(uint program, int location, int count, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniform4fvNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4fv(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform4fvNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4iNative(uint program, int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[473])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[473])(program, location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4i(uint program, int location, int v0, int v1, int v2, int v3)
		{
			ProgramUniform4iNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4ivNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[474])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[474])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4iv(uint program, int location, int count, int* value)
		{
			ProgramUniform4ivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4iv(uint program, int location, int count, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ProgramUniform4ivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4iv(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform4ivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4uiNative(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[475])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[475])(program, location, v0, v1, v2, v3);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4ui(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			ProgramUniform4uiNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniform4uivNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[476])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[476])(program, location, count, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4uiv(uint program, int location, int count, uint* value)
		{
			ProgramUniform4uivNative(program, location, count, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4uiv(uint program, int location, int count, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ProgramUniform4uivNative(program, location, count, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniform4uiv(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform4uivNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[477])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[477])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix2dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix2dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[478])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[478])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix2fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix2fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x3dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[479])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[479])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix2x3dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix2x3dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2x3dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x3fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[480])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[480])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix2x3fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix2x3fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x3fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x4dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[481])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[481])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix2x4dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix2x4dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix2x4dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix2x4fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[482])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[482])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix2x4fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix2x4fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x4fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[483])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[483])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix3dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix3dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[484])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[484])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix3fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix3fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x2dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[485])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[485])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix3x2dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix3x2dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3x2dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x2fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[486])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[486])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix3x2fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix3x2fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x2fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x4dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[487])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[487])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix3x4dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix3x4dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix3x4dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix3x4fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[488])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[488])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix3x4fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix3x4fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x4fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[489])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[489])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix4dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix4dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[490])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[490])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix4fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix4fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x2dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[491])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[491])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix4x2dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix4x2dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4x2dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x2fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[492])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[492])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix4x2fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix4x2fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x2fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x3dvNative(uint program, int location, int count, bool transpose, double* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, double*, void>)funcTable[493])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[493])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, double* value)
		{
			ProgramUniformMatrix4x3dvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, Span<double> value)
		{
			fixed (double* pvalue0 = value)
			{
				ProgramUniformMatrix4x3dvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, ref double value)
		{
			fixed (double* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3dvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProgramUniformMatrix4x3fvNative(uint program, int location, int count, bool transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[494])(program, location, count, *((byte*)(&transpose)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[494])(program, location, count, *((byte*)(&transpose)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, float* value)
		{
			ProgramUniformMatrix4x3fvNative(program, location, count, transpose, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ProgramUniformMatrix4x3fvNative(program, location, count, transpose, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3fvNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ProvokingVertexNative(GLVertexProvokingMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexProvokingMode, void>)funcTable[495])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexProvokingMode, void>)funcTable[495])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_provoking_vertex</remarks>
		public void ProvokingVertex(GLVertexProvokingMode mode)
		{
			ProvokingVertexNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PushDebugGroupNative(GLDebugSource source, uint id, int length, byte* message)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, uint, int, byte*, void>)funcTable[496])(source, id, length, message);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, uint, int, nint, void>)funcTable[496])(source, id, length, (nint)message);
			#endif
		}

		/// <summary>
		/// Push a named debug group into the command stream
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void PushDebugGroup(GLDebugSource source, uint id, int length, byte* message)
		{
			PushDebugGroupNative(source, id, length, message);
		}

		/// <summary>
		/// Push a named debug group into the command stream
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void PushDebugGroup(GLDebugSource source, uint id, int length, string message)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (message != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(message);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(message, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushDebugGroupNative(source, id, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Push a named debug group into the command stream
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void PushDebugGroup(GLDebugSource source, uint id, int length, Span<byte> message)
		{
			fixed (byte* pmessage0 = message)
			{
				PushDebugGroupNative(source, id, length, pmessage0);
			}
		}

		/// <summary>
		/// Push a named debug group into the command stream
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void PushDebugGroup(GLDebugSource source, uint id, int length, ref byte message)
		{
			fixed (byte* pmessage0 = &message)
			{
				PushDebugGroupNative(source, id, length, pmessage0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void PushMatrixNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[497])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[497])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void PushMatrix()
		{
			PushMatrixNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void QueryCounterNative(uint id, GLQueryCounterTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryCounterTarget, void>)funcTable[498])(id, target);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryCounterTarget, void>)funcTable[498])(id, target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_timer_query</remarks>
		public void QueryCounter(uint id, GLQueryCounterTarget target)
		{
			QueryCounterNative(id, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadBufferNative(GLReadBufferMode src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, void>)funcTable[499])(src);
			#else
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, void>)funcTable[499])(src);
			#endif
		}

		/// <summary>
		/// Select a color buffer source for pixels
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ReadBuffer(GLReadBufferMode src)
		{
			ReadBufferNative(src);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadPixelsNative(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[500])(x, y, width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[500])(x, y, width, height, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ReadPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			ReadPixelsNative(x, y, width, height, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ReadPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			ReadPixelsNative(x, y, width, height, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ReadPixels<TPixels>(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				ReadPixelsNative(x, y, width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadnPixelsNative(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[501])(x, y, width, height, format, type, bufSize, data);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[501])(x, y, width, height, format, type, bufSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public void ReadnPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, void* data)
		{
			ReadnPixelsNative(x, y, width, height, format, type, bufSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public void ReadnPixels(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, nint data)
		{
			ReadnPixelsNative(x, y, width, height, format, type, bufSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_robustness</remarks>
		public void ReadnPixels<TData>(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ReadnPixelsNative(x, y, width, height, format, type, bufSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReleaseShaderCompilerNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[502])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[502])();
			#endif
		}

		/// <summary>
		/// Release resources consumed by the implementation's shader compiler
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void ReleaseShaderCompiler()
		{
			ReleaseShaderCompilerNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RenderbufferStorageNative(GLRenderbufferTarget target, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLInternalFormat, int, int, void>)funcTable[503])(target, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLInternalFormat, int, int, void>)funcTable[503])(target, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// Establish data storage, format and dimensions of a
		///     renderbuffer object's image
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void RenderbufferStorage(GLRenderbufferTarget target, GLInternalFormat internalformat, int width, int height)
		{
			RenderbufferStorageNative(target, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RenderbufferStorageMultisampleNative(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[504])(target, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[504])(target, samples, internalformat, width, height);
			#endif
		}

		/// <summary>
		/// Establish data storage, format, dimensions and sample count of
		///     a renderbuffer object's image
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void RenderbufferStorageMultisample(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			RenderbufferStorageMultisampleNative(target, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ResumeTransformFeedbackNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[505])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[505])();
			#endif
		}

		/// <summary>
		/// Resume transform feedback operations
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public void ResumeTransformFeedback()
		{
			ResumeTransformFeedbackNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RotatefNative(float angle, float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[506])(angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[506])(angle, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Rotatef(float angle, float x, float y, float z)
		{
			RotatefNative(angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void RotatexNative(int angle, int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[507])(angle, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[507])(angle, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Rotatex(int angle, int x, int y, int z)
		{
			RotatexNative(angle, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SampleCoverageNative(float value, bool invert)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, byte, void>)funcTable[508])(value, *((byte*)(&invert)));
			#else
			((delegate* unmanaged[Cdecl]<float, byte, void>)funcTable[508])(value, *((byte*)(&invert)));
			#endif
		}

		/// <summary>
		/// Specify multisample coverage parameters
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SampleCoverage(float value, bool invert)
		{
			SampleCoverageNative(value, invert);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SampleCoveragexNative(int value, bool invert)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte, void>)funcTable[509])(value, *((byte*)(&invert)));
			#else
			((delegate* unmanaged[Cdecl]<int, byte, void>)funcTable[509])(value, *((byte*)(&invert)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void SampleCoveragex(int value, bool invert)
		{
			SampleCoveragexNative(value, invert);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SampleMaskiNative(uint maskNumber, uint mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[510])(maskNumber, mask);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[510])(maskNumber, mask);
			#endif
		}

		/// <summary>
		/// Set the value of a sub-word of the sample mask
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_texture_multisample</remarks>
		public void SampleMaski(uint maskNumber, uint mask)
		{
			SampleMaskiNative(maskNumber, mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SamplerParameterIivNative(uint sampler, GLSamplerParameterI pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[511])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[511])(sampler, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public void SamplerParameterIiv(uint sampler, GLSamplerParameterI pname, int* param)
		{
			SamplerParameterIivNative(sampler, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public void SamplerParameterIiv(uint sampler, GLSamplerParameterI pname, Span<int> param)
		{
			fixed (int* pparam0 = param)
			{
				SamplerParameterIivNative(sampler, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public void SamplerParameterIiv(uint sampler, GLSamplerParameterI pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				SamplerParameterIivNative(sampler, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SamplerParameterIuivNative(uint sampler, GLSamplerParameterI pname, uint* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[512])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[512])(sampler, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public void SamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, uint* param)
		{
			SamplerParameterIuivNative(sampler, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public void SamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, Span<uint> param)
		{
			fixed (uint* pparam0 = param)
			{
				SamplerParameterIuivNative(sampler, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public void SamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, ref uint param)
		{
			fixed (uint* pparam0 = &param)
			{
				SamplerParameterIuivNative(sampler, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SamplerParameterfNative(uint sampler, GLSamplerParameterF pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float, void>)funcTable[513])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float, void>)funcTable[513])(sampler, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameterf(uint sampler, GLSamplerParameterF pname, float param)
		{
			SamplerParameterfNative(sampler, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SamplerParameterfvNative(uint sampler, GLSamplerParameterF pname, float* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float*, void>)funcTable[514])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, nint, void>)funcTable[514])(sampler, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameterfv(uint sampler, GLSamplerParameterF pname, float* param)
		{
			SamplerParameterfvNative(sampler, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameterfv(uint sampler, GLSamplerParameterF pname, Span<float> param)
		{
			fixed (float* pparam0 = param)
			{
				SamplerParameterfvNative(sampler, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameterfv(uint sampler, GLSamplerParameterF pname, ref float param)
		{
			fixed (float* pparam0 = &param)
			{
				SamplerParameterfvNative(sampler, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SamplerParameteriNative(uint sampler, GLSamplerParameterI pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int, void>)funcTable[515])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int, void>)funcTable[515])(sampler, pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameteri(uint sampler, GLSamplerParameterI pname, int param)
		{
			SamplerParameteriNative(sampler, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SamplerParameterivNative(uint sampler, GLSamplerParameterI pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[516])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[516])(sampler, pname, (nint)param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameteriv(uint sampler, GLSamplerParameterI pname, int* param)
		{
			SamplerParameterivNative(sampler, pname, param);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameteriv(uint sampler, GLSamplerParameterI pname, Span<int> param)
		{
			fixed (int* pparam0 = param)
			{
				SamplerParameterivNative(sampler, pname, pparam0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void SamplerParameteriv(uint sampler, GLSamplerParameterI pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				SamplerParameterivNative(sampler, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ScalefNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[517])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[517])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Scalef(float x, float y, float z)
		{
			ScalefNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ScalexNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[518])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[518])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Scalex(int x, int y, int z)
		{
			ScalexNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ScissorNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[519])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[519])(x, y, width, height);
			#endif
		}

		/// <summary>
		/// Define the scissor box
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Scissor(int x, int y, int width, int height)
		{
			ScissorNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ScissorArrayvNative(uint first, int count, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[520])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[520])(first, count, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ScissorArrayv(uint first, int count, int* v)
		{
			ScissorArrayvNative(first, count, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ScissorArrayv(uint first, int count, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				ScissorArrayvNative(first, count, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ScissorArrayv(uint first, int count, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				ScissorArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ScissorIndexedNative(uint index, int left, int bottom, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[521])(index, left, bottom, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[521])(index, left, bottom, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ScissorIndexed(uint index, int left, int bottom, int width, int height)
		{
			ScissorIndexedNative(index, left, bottom, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ScissorIndexedvNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[522])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[522])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ScissorIndexedv(uint index, int* v)
		{
			ScissorIndexedvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ScissorIndexedv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				ScissorIndexedvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ScissorIndexedv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				ScissorIndexedvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ShadeModelNative(GLShadingModel mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShadingModel, void>)funcTable[523])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLShadingModel, void>)funcTable[523])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ShadeModel(GLShadingModel mode)
		{
			ShadeModelNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ShaderBinaryNative(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, GLShaderBinaryFormat, void*, int, void>)funcTable[524])(count, shaders, binaryFormat, binary, length);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, GLShaderBinaryFormat, nint, int, void>)funcTable[524])(count, (nint)shaders, binaryFormat, (nint)binary, length);
			#endif
		}

		/// <summary>
		/// Load pre-compiled shader binaries
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void ShaderBinary(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			ShaderBinaryNative(count, shaders, binaryFormat, binary, length);
		}

		/// <summary>
		/// Load pre-compiled shader binaries
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void ShaderBinary(int count, Span<uint> shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			fixed (uint* pshaders0 = shaders)
			{
				ShaderBinaryNative(count, pshaders0, binaryFormat, binary, length);
			}
		}

		/// <summary>
		/// Load pre-compiled shader binaries
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void ShaderBinary(int count, ref uint shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			fixed (uint* pshaders0 = &shaders)
			{
				ShaderBinaryNative(count, pshaders0, binaryFormat, binary, length);
			}
		}

		/// <summary>
		/// Load pre-compiled shader binaries
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void ShaderBinary(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, nint binary, int length)
		{
			ShaderBinaryNative(count, shaders, binaryFormat, (void*)binary, length);
		}

		/// <summary>
		/// Load pre-compiled shader binaries
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void ShaderBinary<TBinary>(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, Span<TBinary> binary, int length) where TBinary : unmanaged
		{
			fixed (TBinary* pbinary0 = binary)
			{
				ShaderBinaryNative(count, shaders, binaryFormat, pbinary0, length);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ShaderSourceNative(uint shader, int count, byte** str, int* length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, int*, void>)funcTable[525])(shader, count, str, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[525])(shader, count, (nint)str, (nint)length);
			#endif
		}

		/// <summary>
		/// Replaces the source code in a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ShaderSource(uint shader, int count, byte** str, int* length)
		{
			ShaderSourceNative(shader, count, str, length);
		}

		/// <summary>
		/// Replaces the source code in a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ShaderSource(uint shader, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			ShaderSourceNative(shader, 1, &pStr0, &pStrSize0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Replaces the source code in a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ShaderSource(uint shader, string[] sources)
		{
			byte** pStrArray0 = null;
			int* pStrArraySizes0 = null;
			int pStrArraySize0 = Utils.GetByteCountArray(sources) + sources.Length * sizeof(int);
			if (sources != null)
			{
				if (pStrArraySize0 > Utils.MaxStackallocSize)
				{
					pStrArraySizes0 = (int*)Utils.Alloc<int>(sources.Length);
					pStrArray0 = (byte**)Utils.Alloc<byte>(pStrArraySize0);
				}
				else
				{
					byte* pStrArraySizesStack0 = stackalloc byte[sources.Length * sizeof(int)];
					pStrArraySizes0 = (int*)pStrArraySizesStack0;
					byte* pStrArrayStack0 = stackalloc byte[pStrArraySize0];
					pStrArray0 = (byte**)pStrArrayStack0;
				}
			}
			for (int i = 0; i < sources.Length; i++)
			{
				pStrArraySizes0[i] = Utils.GetByteCountUTF8(sources[i]);
				pStrArray0[i] = (byte*)Utils.StringToUTF8Ptr(sources[i]);
			}
			ShaderSourceNative(shader, sources.Length, pStrArray0, pStrArraySizes0);
			for (int i = 0; i < sources.Length; i++)
			{
				Utils.Free(pStrArray0[i]);
			}
			if (pStrArraySize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStrArray0);
				Utils.Free(pStrArraySizes0);
			}
		}

		/// <summary>
		/// Replaces the source code in a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ShaderSource(uint shader, int count, byte** str, Span<int> length)
		{
			fixed (int* plength0 = length)
			{
				ShaderSourceNative(shader, count, str, plength0);
			}
		}

		/// <summary>
		/// Replaces the source code in a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ShaderSource(uint shader, int count, byte** str, ref int length)
		{
			fixed (int* plength0 = &length)
			{
				ShaderSourceNative(shader, count, str, plength0);
			}
		}
	}
}
