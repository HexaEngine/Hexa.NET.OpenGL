// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES
{
	public unsafe partial class GL
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ActiveShaderProgramNative(uint pipeline, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#endif
		}

		/// <summary>
		/// Set the active program object for a program pipeline object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void ActiveShaderProgram(uint pipeline, uint program)
		{
			ActiveShaderProgramNative(pipeline, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#endif
		}

		/// <summary>
		/// Select active texture unit
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ActiveTexture(GLTextureUnit texture)
		{
			ActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void AlphaFuncNative(GLAlphaFunction func, float reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, float, void>)funcTable[2])(func, reference);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void AlphaFunc(GLAlphaFunction func, float reference)
		{
			AlphaFuncNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void AlphaFuncxNative(GLAlphaFunction func, int reference)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[3])(func, reference);
			#else
			((delegate* unmanaged[Cdecl]<GLAlphaFunction, int, void>)funcTable[3])(func, reference);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void AlphaFuncx(GLAlphaFunction func, int reference)
		{
			AlphaFuncxNative(func, reference);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void AttachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[4])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[4])(program, shader);
			#endif
		}

		/// <summary>
		/// Attaches a shader object to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void AttachShader(uint program, uint shader)
		{
			AttachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BeginConditionalRenderNative(uint id, GLConditionalRenderMode mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLConditionalRenderMode, void>)funcTable[5])(id, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BeginConditionalRender(uint id, GLConditionalRenderMode mode)
		{
			BeginConditionalRenderNative(id, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BeginQueryNative(GLQueryTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[6])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[6])(target, id);
			#endif
		}

		/// <summary>
		/// Delimit the boundaries of a query object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BeginQuery(GLQueryTarget target, uint id)
		{
			BeginQueryNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BeginQueryIndexedNative(GLQueryTarget target, uint index, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[7])(target, index, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[7])(target, index, id);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public void BeginQueryIndexed(GLQueryTarget target, uint index, uint id)
		{
			BeginQueryIndexedNative(target, index, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BeginTransformFeedbackNative(GLPrimitiveType primitiveMode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void>)funcTable[8])(primitiveMode);
			#endif
		}

		/// <summary>
		/// Start transform feedback operation
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BeginTransformFeedback(GLPrimitiveType primitiveMode)
		{
			BeginTransformFeedbackNative(primitiveMode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindAttribLocationNative(uint program, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[9])(program, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[9])(program, index, (nint)name);
			#endif
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindAttribLocation(uint program, uint index, byte* name)
		{
			BindAttribLocationNative(program, index, name);
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindAttribLocation(uint program, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindAttribLocationNative(program, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindAttribLocation(uint program, uint index, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		/// <summary>
		/// Associates a generic vertex attribute index with a named attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindAttribLocation(uint program, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindAttribLocationNative(program, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindBufferNative(GLBufferTargetARB target, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[10])(target, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[10])(target, buffer);
			#endif
		}

		/// <summary>
		/// Bind a named buffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindBuffer(GLBufferTargetARB target, uint buffer)
		{
			BindBufferNative(target, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindBufferBaseNative(GLBufferTargetARB target, uint index, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[11])(target, index, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[11])(target, index, buffer);
			#endif
		}

		/// <summary>
		/// Bind a buffer object to an indexed buffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public void BindBufferBase(GLBufferTargetARB target, uint index, uint buffer)
		{
			BindBufferBaseNative(target, index, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindBufferRangeNative(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[12])(target, index, buffer, offset, size);
			#endif
		}

		/// <summary>
		/// Bind a range within a buffer object to an indexed buffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public void BindBufferRange(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			BindBufferRangeNative(target, index, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindBuffersBaseNative(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, void>)funcTable[13])(target, first, count, buffers);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, void>)funcTable[13])(target, first, count, (nint)buffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersBase(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			BindBuffersBaseNative(target, first, count, buffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersBase(GLBufferTargetARB target, uint first, int count, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				BindBuffersBaseNative(target, first, count, pbuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersBase(GLBufferTargetARB target, uint first, int count, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersBaseNative(target, first, count, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindBuffersRangeNative(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, nint*, nint*, void>)funcTable[14])(target, first, count, buffers, offsets, sizes);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, nint, nint, void>)funcTable[14])(target, first, count, (nint)buffers, (nint)offsets, (nint)sizes);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			BindBuffersRangeNative(target, first, count, buffers, offsets, sizes);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, nint* offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				BindBuffersRangeNative(target, first, count, pbuffers0, offsets, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersRangeNative(target, first, count, pbuffers0, offsets, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, Span<nint> offsets, nint* sizes)
		{
			fixed (nint* poffsets0 = offsets)
			{
				BindBuffersRangeNative(target, first, count, buffers, poffsets0, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, nint* sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindBuffersRangeNative(target, first, count, buffers, poffsets0, sizes);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, Span<nint> offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, sizes);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, sizes);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, Span<nint> sizes)
		{
			fixed (nint* psizes0 = sizes)
			{
				BindBuffersRangeNative(target, first, count, buffers, offsets, psizes0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, ref nint sizes)
		{
			fixed (nint* psizes0 = &sizes)
			{
				BindBuffersRangeNative(target, first, count, buffers, offsets, psizes0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, nint* offsets, Span<nint> sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* psizes1 = sizes)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, offsets, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, offsets, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, Span<nint> offsets, Span<nint> sizes)
		{
			fixed (nint* poffsets0 = offsets)
			{
				fixed (nint* psizes1 = sizes)
				{
					BindBuffersRangeNative(target, first, count, buffers, poffsets0, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, ref nint sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, buffers, poffsets0, psizes1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, Span<uint> buffers, Span<nint> offsets, Span<nint> sizes)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					fixed (nint* psizes2 = sizes)
					{
						BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, psizes2);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (nint* psizes2 = &sizes)
					{
						BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, psizes2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindFragDataLocationNative(uint program, uint color, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[15])(program, color, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[15])(program, color, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindFragDataLocation(uint program, uint color, byte* name)
		{
			BindFragDataLocationNative(program, color, name);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindFragDataLocation(uint program, uint color, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationNative(program, color, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindFragDataLocation(uint program, uint color, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationNative(program, color, pname0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindFragDataLocation(uint program, uint color, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationNative(program, color, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindFragDataLocationIndexedNative(uint program, uint colorNumber, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, byte*, void>)funcTable[16])(program, colorNumber, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, void>)funcTable[16])(program, colorNumber, index, (nint)name);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, byte* name)
		{
			BindFragDataLocationIndexedNative(program, colorNumber, index, name);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationIndexedNative(program, colorNumber, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_blend_func_extended</remarks>
		public void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindFramebufferNative(GLFramebufferTarget target, uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[17])(target, framebuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[17])(target, framebuffer);
			#endif
		}

		/// <summary>
		/// Bind a framebuffer to a framebuffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void BindFramebuffer(GLFramebufferTarget target, uint framebuffer)
		{
			BindFramebufferNative(target, framebuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindImageTextureNative(uint unit, uint texture, int level, bool layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[18])(unit, texture, level, *((byte*)(&layered)), layer, access, format);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[18])(unit, texture, level, *((byte*)(&layered)), layer, access, format);
			#endif
		}

		/// <summary>
		/// Bind a level of a texture to an image unit
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_image_load_store</remarks>
		public void BindImageTexture(uint unit, uint texture, int level, bool layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			BindImageTextureNative(unit, texture, level, layered, layer, access, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindImageTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[19])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[19])(first, count, (nint)textures);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindImageTextures(uint first, int count, uint* textures)
		{
			BindImageTexturesNative(first, count, textures);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindImageTextures(uint first, int count, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				BindImageTexturesNative(first, count, ptextures0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindImageTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindImageTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[20])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[20])(pipeline);
			#endif
		}

		/// <summary>
		/// Bind a program pipeline to the current context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void BindProgramPipeline(uint pipeline)
		{
			BindProgramPipelineNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindRenderbufferNative(GLRenderbufferTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[21])(target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[21])(target, renderbuffer);
			#endif
		}

		/// <summary>
		/// Bind a renderbuffer to a renderbuffer target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void BindRenderbuffer(GLRenderbufferTarget target, uint renderbuffer)
		{
			BindRenderbufferNative(target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindSamplerNative(uint unit, uint sampler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[22])(unit, sampler);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[22])(unit, sampler);
			#endif
		}

		/// <summary>
		/// Bind a named sampler to a texturing target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void BindSampler(uint unit, uint sampler)
		{
			BindSamplerNative(unit, sampler);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindSamplersNative(uint first, int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[23])(first, count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[23])(first, count, (nint)samplers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindSamplers(uint first, int count, uint* samplers)
		{
			BindSamplersNative(first, count, samplers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindSamplers(uint first, int count, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				BindSamplersNative(first, count, psamplers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindSamplers(uint first, int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				BindSamplersNative(first, count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindTextureNative(GLTextureTarget target, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[24])(target, texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, uint, void>)funcTable[24])(target, texture);
			#endif
		}

		/// <summary>
		/// Bind a named texture to a texturing target
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BindTexture(GLTextureTarget target, uint texture)
		{
			BindTextureNative(target, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindTextureUnitNative(uint unit, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[25])(unit, texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[25])(unit, texture);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void BindTextureUnit(uint unit, uint texture)
		{
			BindTextureUnitNative(unit, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[26])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[26])(first, count, (nint)textures);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindTextures(uint first, int count, uint* textures)
		{
			BindTexturesNative(first, count, textures);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindTextures(uint first, int count, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				BindTexturesNative(first, count, ptextures0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindTransformFeedbackNative(GLBindTransformFeedbackTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[27])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[27])(target, id);
			#endif
		}

		/// <summary>
		/// Bind a transform feedback object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public void BindTransformFeedback(GLBindTransformFeedbackTarget target, uint id)
		{
			BindTransformFeedbackNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[28])(array);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[28])(array);
			#endif
		}

		/// <summary>
		/// Bind a vertex array object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public void BindVertexArray(uint array)
		{
			BindVertexArrayNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindVertexBufferNative(uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[29])(bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[29])(bindingindex, buffer, offset, stride);
			#endif
		}

		/// <summary>
		/// Bind a buffer to a vertex buffer bind point
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public void BindVertexBuffer(uint bindingindex, uint buffer, nint offset, int stride)
		{
			BindVertexBufferNative(bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BindVertexBuffersNative(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, nint*, int*, void>)funcTable[30])(first, count, buffers, offsets, strides);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, nint, void>)funcTable[30])(first, count, (nint)buffers, (nint)offsets, (nint)strides);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			BindVertexBuffersNative(first, count, buffers, offsets, strides);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, Span<uint> buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				BindVertexBuffersNative(first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindVertexBuffersNative(first, count, pbuffers0, offsets, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, uint* buffers, Span<nint> offsets, int* strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				BindVertexBuffersNative(first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, int* strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindVertexBuffersNative(first, count, buffers, poffsets0, strides);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, Span<uint> buffers, Span<nint> offsets, int* strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					BindVertexBuffersNative(first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindVertexBuffersNative(first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, Span<int> strides)
		{
			fixed (int* pstrides0 = strides)
			{
				BindVertexBuffersNative(first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, ref int strides)
		{
			fixed (int* pstrides0 = &strides)
			{
				BindVertexBuffersNative(first, count, buffers, offsets, pstrides0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, Span<uint> buffers, nint* offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (int* pstrides1 = strides)
				{
					BindVertexBuffersNative(first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, uint* buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (nint* poffsets0 = offsets)
			{
				fixed (int* pstrides1 = strides)
				{
					BindVertexBuffersNative(first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, ref int strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, Span<uint> buffers, Span<nint> offsets, Span<int> strides)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				fixed (nint* poffsets1 = offsets)
				{
					fixed (int* pstrides2 = strides)
					{
						BindVertexBuffersNative(first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_multi_bind</remarks>
		public void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (int* pstrides2 = &strides)
					{
						BindVertexBuffersNative(first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendBarrierNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[31])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[31])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL ES 3.2</remarks>
		public void BlendBarrier()
		{
			BlendBarrierNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[32])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[32])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// Set the blend color
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public void BlendColor(float red, float green, float blue, float alpha)
		{
			BlendColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendEquationNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[33])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[33])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public void BlendEquation(GLBlendEquationModeEXT mode)
		{
			BlendEquationNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendEquationSeparateNative(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[34])(modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[34])(modeRGB, modeAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BlendEquationSeparate(GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateNative(modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendEquationSeparateiNative(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[35])(buf, modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[35])(buf, modeRGB, modeAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BlendEquationSeparatei(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateiNative(buf, modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendEquationiNative(uint buf, GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[36])(buf, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[36])(buf, mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BlendEquationi(uint buf, GLBlendEquationModeEXT mode)
		{
			BlendEquationiNative(buf, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendFuncNative(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[37])(sfactor, dfactor);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, void>)funcTable[37])(sfactor, dfactor);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BlendFunc(GLBlendingFactor sfactor, GLBlendingFactor dfactor)
		{
			BlendFuncNative(sfactor, dfactor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendFuncSeparateNative(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[38])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[38])(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BlendFuncSeparate(GLBlendingFactor sfactorRGB, GLBlendingFactor dfactorRGB, GLBlendingFactor sfactorAlpha, GLBlendingFactor dfactorAlpha)
		{
			BlendFuncSeparateNative(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendFuncSeparateiNative(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[39])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BlendFuncSeparatei(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			BlendFuncSeparateiNative(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlendFunciNative(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[40])(buf, src, dst);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[40])(buf, src, dst);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BlendFunci(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			BlendFunciNative(buf, src, dst);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlitFramebufferNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[41])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		/// <summary>
		/// Copy a block of pixels from one framebuffer object to another
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BlitNamedFramebufferNative(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[42])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[42])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void BlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitNamedFramebufferNative(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BufferDataNative(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, void*, GLBufferUsageARB, void>)funcTable[43])(target, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLBufferUsageARB, void>)funcTable[43])(target, size, (nint)data, usage);
			#endif
		}

		/// <summary>
		/// Creates and initializes a buffer object's data
		///     store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BufferData(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			BufferDataNative(target, size, data, usage);
		}

		/// <summary>
		/// Creates and initializes a buffer object's data
		///     store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BufferData(GLBufferTargetARB target, nint size, nint data, GLBufferUsageARB usage)
		{
			BufferDataNative(target, size, (void*)data, usage);
		}

		/// <summary>
		/// Creates and initializes a buffer object's data
		///     store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BufferData<TData>(GLBufferTargetARB target, nint size, Span<TData> data, GLBufferUsageARB usage) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				BufferDataNative(target, size, pdata0, usage);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BufferStorageNative(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, void*, GLBufferStorageMask, void>)funcTable[44])(target, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, GLBufferStorageMask, void>)funcTable[44])(target, size, (nint)data, flags);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_buffer_storage</remarks>
		public void BufferStorage(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			BufferStorageNative(target, size, data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_buffer_storage</remarks>
		public void BufferStorage(GLBufferStorageTarget target, nint size, nint data, GLBufferStorageMask flags)
		{
			BufferStorageNative(target, size, (void*)data, flags);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_buffer_storage</remarks>
		public void BufferStorage<TData>(GLBufferStorageTarget target, nint size, Span<TData> data, GLBufferStorageMask flags) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				BufferStorageNative(target, size, pdata0, flags);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[45])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[45])(target, offset, size, (nint)data);
			#endif
		}

		/// <summary>
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			BufferSubDataNative(target, offset, size, data);
		}

		/// <summary>
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BufferSubData(GLBufferTargetARB target, nint offset, nint size, nint data)
		{
			BufferSubDataNative(target, offset, size, (void*)data);
		}

		/// <summary>
		/// Updates a subset of a buffer object's data store
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void BufferSubData<TData>(GLBufferTargetARB target, nint offset, nint size, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				BufferSubDataNative(target, offset, size, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal GLEnum CheckFramebufferStatusNative(GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[46])(target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[46])(target);
			#endif
		}

		/// <summary>
		/// Check the completeness status of a framebuffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public GLEnum CheckFramebufferStatus(GLFramebufferTarget target)
		{
			GLEnum ret = CheckFramebufferStatusNative(target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal GLEnum CheckNamedFramebufferStatusNative(uint framebuffer, GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[47])(framebuffer, target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[47])(framebuffer, target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public GLEnum CheckNamedFramebufferStatus(uint framebuffer, GLFramebufferTarget target)
		{
			GLEnum ret = CheckNamedFramebufferStatusNative(framebuffer, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClampColorNative(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[48])(target, clamp);
			#else
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[48])(target, clamp);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClampColor(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			ClampColorNative(target, clamp);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearNative(GLClearBufferMask mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[49])(mask);
			#else
			((delegate* unmanaged[Cdecl]<GLClearBufferMask, void>)funcTable[49])(mask);
			#endif
		}

		/// <summary>
		/// Clear buffers to preset values
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Clear(GLClearBufferMask mask)
		{
			ClearNative(mask);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearBufferDataNative(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[50])(target, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[50])(target, internalformat, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public void ClearBufferData(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferDataNative(target, internalformat, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public void ClearBufferData(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearBufferDataNative(target, internalformat, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public void ClearBufferData<TData>(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearBufferDataNative(target, internalformat, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearBufferSubDataNative(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[51])(target, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[51])(target, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public void ClearBufferSubData(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferSubDataNative(target, internalformat, offset, size, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public void ClearBufferSubData(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearBufferSubDataNative(target, internalformat, offset, size, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_buffer_object</remarks>
		public void ClearBufferSubData<TData>(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearBufferSubDataNative(target, internalformat, offset, size, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearBufferfiNative(GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float, int, void>)funcTable[52])(buffer, drawbuffer, depth, stencil);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float, int, void>)funcTable[52])(buffer, drawbuffer, depth, stencil);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferfi(GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			ClearBufferfiNative(buffer, drawbuffer, depth, stencil);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearBufferfvNative(GLBuffer buffer, int drawbuffer, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, float*, void>)funcTable[53])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[53])(buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferfv(GLBuffer buffer, int drawbuffer, float* value)
		{
			ClearBufferfvNative(buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferfv(GLBuffer buffer, int drawbuffer, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ClearBufferfvNative(buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferfv(GLBuffer buffer, int drawbuffer, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ClearBufferfvNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearBufferivNative(GLBuffer buffer, int drawbuffer, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, int*, void>)funcTable[54])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[54])(buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferiv(GLBuffer buffer, int drawbuffer, int* value)
		{
			ClearBufferivNative(buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferiv(GLBuffer buffer, int drawbuffer, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ClearBufferivNative(buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferiv(GLBuffer buffer, int drawbuffer, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ClearBufferivNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearBufferuivNative(GLBuffer buffer, int drawbuffer, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBuffer, int, uint*, void>)funcTable[55])(buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<GLBuffer, int, nint, void>)funcTable[55])(buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferuiv(GLBuffer buffer, int drawbuffer, uint* value)
		{
			ClearBufferuivNative(buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferuiv(GLBuffer buffer, int drawbuffer, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ClearBufferuivNative(buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearBufferuiv(GLBuffer buffer, int drawbuffer, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ClearBufferuivNative(buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[56])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[56])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// Specify clear values for the color buffers
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearColor(float red, float green, float blue, float alpha)
		{
			ClearColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearColorxNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[57])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[57])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearColorx(int red, int green, int blue, int alpha)
		{
			ClearColorxNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearDepthNative(double depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[58])(depth);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[58])(depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearDepth(double depth)
		{
			ClearDepthNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearDepthfNative(float d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[59])(d);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[59])(d);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void ClearDepthf(float d)
		{
			ClearDepthfNative(d);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearDepthxNative(int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[60])(depth);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[60])(depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearDepthx(int depth)
		{
			ClearDepthxNative(depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearNamedBufferDataNative(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[61])(buffer, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[61])(buffer, internalformat, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedBufferData(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferDataNative(buffer, internalformat, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedBufferData(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearNamedBufferDataNative(buffer, internalformat, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedBufferData<TData>(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearNamedBufferDataNative(buffer, internalformat, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearNamedBufferSubDataNative(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[62])(buffer, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[62])(buffer, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedBufferSubData(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedBufferSubData(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedBufferSubData<TData>(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearNamedFramebufferfiNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[63])(framebuffer, buffer, drawbuffer, depth, stencil);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[63])(framebuffer, buffer, drawbuffer, depth, stencil);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferfi(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			ClearNamedFramebufferfiNative(framebuffer, buffer, drawbuffer, depth, stencil);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearNamedFramebufferfvNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float*, void>)funcTable[64])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[64])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, Span<float> value)
		{
			fixed (float* pvalue0 = value)
			{
				ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearNamedFramebufferivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, int*, void>)funcTable[65])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[65])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, Span<int> value)
		{
			fixed (int* pvalue0 = value)
			{
				ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearNamedFramebufferuivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, uint*, void>)funcTable[66])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[66])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearStencilNative(int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[67])(s);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[67])(s);
			#endif
		}

		/// <summary>
		/// Specify the clear value for the stencil buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClearStencil(int s)
		{
			ClearStencilNative(s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearTexImageNative(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[68])(texture, level, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[68])(texture, level, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public void ClearTexImage(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexImageNative(texture, level, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public void ClearTexImage(uint texture, int level, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearTexImageNative(texture, level, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public void ClearTexImage<TData>(uint texture, int level, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearTexImageNative(texture, level, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearTexSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[69])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[69])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, nint data)
		{
			ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clear_texture</remarks>
		public void ClearTexSubImage<TData>(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClientActiveTextureNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[70])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[70])(texture);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClientActiveTexture(GLTextureUnit texture)
		{
			ClientActiveTextureNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal GLEnum ClientWaitSyncNative(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[71])(sync, flags, timeout);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[71])(sync, flags, timeout);
			#endif
		}

		/// <summary>
		/// Block and wait for a sync object to become signaled
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public GLEnum ClientWaitSync(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			GLEnum ret = ClientWaitSyncNative(sync, flags, timeout);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClipControlNative(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[72])(origin, depth);
			#else
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[72])(origin, depth);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_clip_control</remarks>
		public void ClipControl(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			ClipControlNative(origin, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClipPlanefNative(GLClipPlaneName p, float* eqn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, float*, void>)funcTable[73])(p, eqn);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[73])(p, (nint)eqn);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClipPlanef(GLClipPlaneName p, float* eqn)
		{
			ClipPlanefNative(p, eqn);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClipPlanef(GLClipPlaneName p, Span<float> eqn)
		{
			fixed (float* peqn0 = eqn)
			{
				ClipPlanefNative(p, peqn0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClipPlanef(GLClipPlaneName p, ref float eqn)
		{
			fixed (float* peqn0 = &eqn)
			{
				ClipPlanefNative(p, peqn0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClipPlanexNative(GLClipPlaneName plane, int* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, int*, void>)funcTable[74])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[74])(plane, (nint)equation);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClipPlanex(GLClipPlaneName plane, int* equation)
		{
			ClipPlanexNative(plane, equation);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClipPlanex(GLClipPlaneName plane, Span<int> equation)
		{
			fixed (int* pequation0 = equation)
			{
				ClipPlanexNative(plane, pequation0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ClipPlanex(GLClipPlaneName plane, ref int equation)
		{
			fixed (int* pequation0 = &equation)
			{
				ClipPlanexNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Color4fNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[75])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[75])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Color4f(float red, float green, float blue, float alpha)
		{
			Color4fNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Color4ubNative(bool red, bool green, bool blue, bool alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[76])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[76])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Color4ub(bool red, bool green, bool blue, bool alpha)
		{
			Color4ubNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void Color4xNative(int red, int green, int blue, int alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[77])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[77])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Color4x(int red, int green, int blue, int alpha)
		{
			Color4xNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ColorMaskNative(bool red, bool green, bool blue, bool alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[78])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#else
			((delegate* unmanaged[Cdecl]<byte, byte, byte, byte, void>)funcTable[78])(*((byte*)(&red)), *((byte*)(&green)), *((byte*)(&blue)), *((byte*)(&alpha)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ColorMask(bool red, bool green, bool blue, bool alpha)
		{
			ColorMaskNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ColorMaskiNative(uint index, bool r, bool g, bool b, bool a)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[79])(index, *((byte*)(&r)), *((byte*)(&g)), *((byte*)(&b)), *((byte*)(&a)));
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[79])(index, *((byte*)(&r)), *((byte*)(&g)), *((byte*)(&b)), *((byte*)(&a)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ColorMaski(uint index, bool r, bool g, bool b, bool a)
		{
			ColorMaskiNative(index, r, g, b, a);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ColorPointerNative(int size, GLColorPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, void*, void>)funcTable[80])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLColorPointerType, int, nint, void>)funcTable[80])(size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ColorPointer(int size, GLColorPointerType type, int stride, void* pointer)
		{
			ColorPointerNative(size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ColorPointer(int size, GLColorPointerType type, int stride, nint pointer)
		{
			ColorPointerNative(size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void ColorPointer<TPointer>(int size, GLColorPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				ColorPointerNative(size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompileShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[81])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[81])(shader);
			#endif
		}

		/// <summary>
		/// Compiles a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompileShader(uint shader)
		{
			CompileShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[82])(target, level, internalformat, width, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[82])(target, level, internalformat, width, border, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, nint data)
		{
			CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage1D<TData>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexImage1DNative(target, level, internalformat, width, border, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[83])(target, level, internalformat, width, height, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[83])(target, level, internalformat, width, height, border, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, nint data)
		{
			CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage2D<TData>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexImage2DNative(target, level, internalformat, width, height, border, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTexImage3DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[84])(target, level, internalformat, width, height, depth, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[84])(target, level, internalformat, width, height, depth, border, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage3D(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, nint data)
		{
			CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexImage3D<TData>(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexImage3DNative(target, level, internalformat, width, height, depth, border, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[85])(target, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[85])(target, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage1D(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage1D<TData>(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexSubImage1DNative(target, level, xoffset, width, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[86])(target, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[86])(target, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, (void*)data);
		}

		/// <summary>
		/// Specify a two-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage2D<TData>(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexSubImage2DNative(target, level, xoffset, yoffset, width, height, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[87])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[87])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)data);
		}

		/// <summary>
		/// Specify a three-dimensional texture subimage in a compressed format
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CompressedTexSubImage3D<TData>(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTextureSubImage1DNative(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, void*, void>)funcTable[88])(texture, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, nint, void>)funcTable[88])(texture, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage1D<TData>(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[89])(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[89])(texture, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage2D<TData>(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CompressedTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[90])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[90])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, nint data)
		{
			CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CompressedTextureSubImage3D<TData>(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyBufferSubDataNative(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[91])(readTarget, writeTarget, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[91])(readTarget, writeTarget, readOffset, writeOffset, size);
			#endif
		}

		/// <summary>
		/// Copy all or part of the data store of a buffer object to the data store of another buffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_copy_buffer</remarks>
		public void CopyBufferSubData(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			CopyBufferSubDataNative(readTarget, writeTarget, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyImageSubDataNative(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[92])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[92])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#endif
		}

		/// <summary>
		/// Perform a raw data copy between two images
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_copy_image</remarks>
		public void CopyImageSubData(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			CopyImageSubDataNative(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyNamedBufferSubDataNative(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[93])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[93])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CopyNamedBufferSubData(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			CopyNamedBufferSubDataNative(readBuffer, writeBuffer, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTexImage1DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[94])(target, level, internalformat, x, y, width, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void>)funcTable[94])(target, level, internalformat, x, y, width, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CopyTexImage1D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int border)
		{
			CopyTexImage1DNative(target, level, internalformat, x, y, width, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTexImage2DNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[95])(target, level, internalformat, x, y, width, height, border);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void>)funcTable[95])(target, level, internalformat, x, y, width, height, border);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CopyTexImage2D(GLTextureTarget target, int level, GLInternalFormat internalformat, int x, int y, int width, int height, int border)
		{
			CopyTexImage2DNative(target, level, internalformat, x, y, width, height, border);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTexSubImage1DNative(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[96])(target, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, void>)funcTable[96])(target, level, xoffset, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CopyTexSubImage1D(GLTextureTarget target, int level, int xoffset, int x, int y, int width)
		{
			CopyTexSubImage1DNative(target, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTexSubImage2DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[97])(target, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, void>)funcTable[97])(target, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CopyTexSubImage2D(GLTextureTarget target, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage2DNative(target, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTexSubImage3DNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[98])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, int, void>)funcTable[98])(target, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CopyTexSubImage3D(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTexSubImage3DNative(target, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTextureSubImage1DNative(uint texture, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[99])(texture, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[99])(texture, level, xoffset, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width)
		{
			CopyTextureSubImage1DNative(texture, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[100])(texture, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[100])(texture, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage2DNative(texture, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CopyTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[101])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[101])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[102])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[102])(n, (nint)buffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateBuffers(int n, uint* buffers)
		{
			CreateBuffersNative(n, buffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateBuffers(int n, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				CreateBuffersNative(n, pbuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				CreateBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[103])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[103])(n, (nint)framebuffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateFramebuffers(int n, uint* framebuffers)
		{
			CreateFramebuffersNative(n, framebuffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateFramebuffers(int n, Span<uint> framebuffers)
		{
			fixed (uint* pframebuffers0 = framebuffers)
			{
				CreateFramebuffersNative(n, pframebuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				CreateFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint CreateProgramNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[104])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[104])();
			#endif
		}

		/// <summary>
		/// Creates a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public uint CreateProgram()
		{
			uint ret = CreateProgramNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[105])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[105])(n, (nint)pipelines);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateProgramPipelines(int n, uint* pipelines)
		{
			CreateProgramPipelinesNative(n, pipelines);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateProgramPipelines(int n, Span<uint> pipelines)
		{
			fixed (uint* ppipelines0 = pipelines)
			{
				CreateProgramPipelinesNative(n, ppipelines0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				CreateProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateQueriesNative(GLQueryTarget target, int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, uint*, void>)funcTable[106])(target, n, ids);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, nint, void>)funcTable[106])(target, n, (nint)ids);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateQueries(GLQueryTarget target, int n, uint* ids)
		{
			CreateQueriesNative(target, n, ids);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateQueries(GLQueryTarget target, int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				CreateQueriesNative(target, n, pids0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateQueries(GLQueryTarget target, int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateQueriesNative(target, n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[107])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[107])(n, (nint)renderbuffers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateRenderbuffers(int n, uint* renderbuffers)
		{
			CreateRenderbuffersNative(n, renderbuffers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateRenderbuffers(int n, Span<uint> renderbuffers)
		{
			fixed (uint* prenderbuffers0 = renderbuffers)
			{
				CreateRenderbuffersNative(n, prenderbuffers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				CreateRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateSamplersNative(int n, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[108])(n, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[108])(n, (nint)samplers);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateSamplers(int n, uint* samplers)
		{
			CreateSamplersNative(n, samplers);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateSamplers(int n, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				CreateSamplersNative(n, psamplers0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateSamplers(int n, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				CreateSamplersNative(n, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint CreateShaderNative(GLShaderType type)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[109])(type);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[109])(type);
			#endif
		}

		/// <summary>
		/// Creates a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public uint CreateShader(GLShaderType type)
		{
			uint ret = CreateShaderNative(type);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint CreateShaderProgramvNative(GLShaderType type, int count, byte** strings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, int, byte**, uint>)funcTable[110])(type, count, strings);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, uint>)funcTable[110])(type, count, (nint)strings);
			#endif
		}

		/// <summary>
		/// Create a stand-alone program from an array of null-terminated source code strings
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public uint CreateShaderProgramv(GLShaderType type, int count, byte** strings)
		{
			uint ret = CreateShaderProgramvNative(type, count, strings);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateTexturesNative(GLTextureTarget target, int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, uint*, void>)funcTable[111])(target, n, textures);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[111])(target, n, (nint)textures);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateTextures(GLTextureTarget target, int n, uint* textures)
		{
			CreateTexturesNative(target, n, textures);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateTextures(GLTextureTarget target, int n, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				CreateTexturesNative(target, n, ptextures0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateTextures(GLTextureTarget target, int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				CreateTexturesNative(target, n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[112])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[112])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateTransformFeedbacks(int n, uint* ids)
		{
			CreateTransformFeedbacksNative(n, ids);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateTransformFeedbacks(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				CreateTransformFeedbacksNative(n, pids0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[113])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[113])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateVertexArrays(int n, uint* arrays)
		{
			CreateVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void CreateVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CullFaceNative(GLTriangleFace mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[114])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[114])(mode);
			#endif
		}

		/// <summary>
		/// Specify whether front- or back-facing facets can be culled
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void CullFace(GLTriangleFace mode)
		{
			CullFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DebugMessageCallbackNative(GLDebugProc callback, void* userParam)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[115])((void*)Utils.GetFunctionPointerForDelegate(callback), userParam);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[115])(Utils.GetFunctionPointerForDelegate(callback), (nint)userParam);
			#endif
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageCallback(GLDebugProc callback, void* userParam)
		{
			DebugMessageCallbackNative(callback, userParam);
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageCallback(GLDebugProc callback, nint userParam)
		{
			DebugMessageCallbackNative(callback, (void*)userParam);
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageCallback<TUserParam>(GLDebugProc callback, Span<TUserParam> userParam) where TUserParam : unmanaged
		{
			fixed (TUserParam* puserParam0 = userParam)
			{
				DebugMessageCallbackNative(callback, puserParam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DebugMessageControlNative(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, bool enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, uint*, byte, void>)funcTable[116])(source, type, severity, count, ids, *((byte*)(&enabled)));
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, nint, byte, void>)funcTable[116])(source, type, severity, count, (nint)ids, *((byte*)(&enabled)));
			#endif
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, bool enabled)
		{
			DebugMessageControlNative(source, type, severity, count, ids, enabled);
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, Span<uint> ids, bool enabled)
		{
			fixed (uint* pids0 = ids)
			{
				DebugMessageControlNative(source, type, severity, count, pids0, enabled);
			}
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, ref uint ids, bool enabled)
		{
			fixed (uint* pids0 = &ids)
			{
				DebugMessageControlNative(source, type, severity, count, pids0, enabled);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DebugMessageInsertNative(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, byte*, void>)funcTable[117])(source, type, id, severity, length, buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, nint, void>)funcTable[117])(source, type, id, severity, length, (nint)buf);
			#endif
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			DebugMessageInsertNative(source, type, id, severity, length, buf);
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugMessageInsertNative(source, type, id, severity, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, Span<byte> buf)
		{
			fixed (byte* pbuf0 = buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, ref byte buf)
		{
			fixed (byte* pbuf0 = &buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[118])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[118])(n, (nint)buffers);
			#endif
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteBuffers(int n, uint* buffers)
		{
			DeleteBuffersNative(n, buffers);
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteBuffer(uint buffer)
		{
			DeleteBuffersNative(1, &buffer);
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteBuffers(int n, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[119])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[119])(n, (nint)framebuffers);
			#endif
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteFramebuffers(int n, uint* framebuffers)
		{
			DeleteFramebuffersNative(n, framebuffers);
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteFramebuffer(uint framebuffer)
		{
			DeleteFramebuffersNative(1, &framebuffer);
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteFramebuffers(int n, Span<uint> framebuffers)
		{
			fixed (uint* pframebuffers0 = framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[120])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[120])(program);
			#endif
		}

		/// <summary>
		/// Deletes a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteProgram(uint program)
		{
			DeleteProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[121])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[121])(n, (nint)pipelines);
			#endif
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void DeleteProgramPipelines(int n, uint* pipelines)
		{
			DeleteProgramPipelinesNative(n, pipelines);
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void DeleteProgramPipeline(uint pipeline)
		{
			DeleteProgramPipelinesNative(1, &pipeline);
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void DeleteProgramPipelines(int n, Span<uint> pipelines)
		{
			fixed (uint* ppipelines0 = pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public void DeleteProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[122])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[122])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteQueries(int n, uint* ids)
		{
			DeleteQueriesNative(n, ids);
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteQuerie(uint id)
		{
			DeleteQueriesNative(1, &id);
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteQueries(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[123])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[123])(n, (nint)renderbuffers);
			#endif
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteRenderbuffers(int n, uint* renderbuffers)
		{
			DeleteRenderbuffersNative(n, renderbuffers);
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteRenderbuffer(uint renderbuffer)
		{
			DeleteRenderbuffersNative(1, &renderbuffer);
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteRenderbuffers(int n, Span<uint> renderbuffers)
		{
			fixed (uint* prenderbuffers0 = renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public void DeleteRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[124])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[124])(count, (nint)samplers);
			#endif
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void DeleteSamplers(int count, uint* samplers)
		{
			DeleteSamplersNative(count, samplers);
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void DeleteSampler(uint sampler)
		{
			DeleteSamplersNative(1, &sampler);
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void DeleteSamplers(int count, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects<br/>GL_MESA_sampler_objects</remarks>
		public void DeleteSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[125])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[125])(shader);
			#endif
		}

		/// <summary>
		/// Deletes a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteShader(uint shader)
		{
			DeleteShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[126])(sync);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[126])(sync);
			#endif
		}

		/// <summary>
		/// Delete a sync object
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public void DeleteSync(GLSync sync)
		{
			DeleteSyncNative(sync);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[127])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[127])(n, (nint)textures);
			#endif
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteTextures(int n, uint* textures)
		{
			DeleteTexturesNative(n, textures);
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteTexture(uint texture)
		{
			DeleteTexturesNative(1, &texture);
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteTextures(int n, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DeleteTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[128])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[128])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public void DeleteTransformFeedbacks(int n, uint* ids)
		{
			DeleteTransformFeedbacksNative(n, ids);
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public void DeleteTransformFeedback(uint id)
		{
			DeleteTransformFeedbacksNative(1, &id);
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public void DeleteTransformFeedbacks(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public void DeleteTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[129])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[129])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public void DeleteVertexArrays(int n, uint* arrays)
		{
			DeleteVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public void DeleteVertexArray(uint array)
		{
			DeleteVertexArraysNative(1, &array);
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public void DeleteVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public void DeleteVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DepthFuncNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[130])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[130])(func);
			#endif
		}

		/// <summary>
		/// Specify the value used for depth buffer comparisons
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DepthFunc(GLDepthFunction func)
		{
			DepthFuncNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DepthMaskNative(bool flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[131])(*((byte*)(&flag)));
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[131])(*((byte*)(&flag)));
			#endif
		}

		/// <summary>
		/// Enable or disable writing into the depth buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DepthMask(bool flag)
		{
			DepthMaskNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DepthRangeNative(double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[132])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[132])(n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DepthRange(double n, double f)
		{
			DepthRangeNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DepthRangeArrayvNative(uint first, int count, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[133])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[133])(first, count, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void DepthRangeArrayv(uint first, int count, double* v)
		{
			DepthRangeArrayvNative(first, count, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void DepthRangeArrayv(uint first, int count, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void DepthRangeArrayv(uint first, int count, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DepthRangeIndexedNative(uint index, double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[134])(index, n, f);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[134])(index, n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void DepthRangeIndexed(uint index, double n, double f)
		{
			DepthRangeIndexedNative(index, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DepthRangefNative(float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[135])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[135])(n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public void DepthRangef(float n, float f)
		{
			DepthRangefNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DepthRangexNative(int n, int f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[136])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[136])(n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DepthRangex(int n, int f)
		{
			DepthRangexNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DetachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[137])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[137])(program, shader);
			#endif
		}

		/// <summary>
		/// Detaches a shader object from a program object to which it is attached
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DetachShader(uint program, uint shader)
		{
			DetachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DisableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[138])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[138])(cap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Disable(GLEnableCap cap)
		{
			DisableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DisableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[139])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[139])(array);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DisableClientState(GLEnableCap array)
		{
			DisableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DisableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[140])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[140])(vaobj, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public void DisableVertexArrayAttrib(uint vaobj, uint index)
		{
			DisableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DisableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[141])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[141])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DisableVertexAttribArray(uint index)
		{
			DisableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DisableiNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[142])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[142])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void Disablei(GLEnableCap target, uint index)
		{
			DisableiNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DispatchComputeNative(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[143])(numGroupsX, numGroupsY, numGroupsZ);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[143])(numGroupsX, numGroupsY, numGroupsZ);
			#endif
		}

		/// <summary>
		/// Launch one or more compute work groups
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_compute_shader</remarks>
		public void DispatchCompute(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			DispatchComputeNative(numGroupsX, numGroupsY, numGroupsZ);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DispatchComputeIndirectNative(nint indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[144])(indirect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[144])(indirect);
			#endif
		}

		/// <summary>
		/// Launch one or more compute work groups using parameters stored in a buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_compute_shader</remarks>
		public void DispatchComputeIndirect(nint indirect)
		{
			DispatchComputeIndirectNative(indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawArraysNative(GLPrimitiveType mode, int first, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[145])(mode, first, count);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[145])(mode, first, count);
			#endif
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawArrays(GLPrimitiveType mode, int first, int count)
		{
			DrawArraysNative(mode, first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawArraysIndirectNative(GLPrimitiveType mode, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, void>)funcTable[146])(mode, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, void>)funcTable[146])(mode, (nint)indirect);
			#endif
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public void DrawArraysIndirect(GLPrimitiveType mode, void* indirect)
		{
			DrawArraysIndirectNative(mode, indirect);
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public void DrawArraysIndirect(GLPrimitiveType mode, nint indirect)
		{
			DrawArraysIndirectNative(mode, (void*)indirect);
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public void DrawArraysIndirect<TIndirect>(GLPrimitiveType mode, Span<TIndirect> indirect) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				DrawArraysIndirectNative(mode, pindirect0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawArraysInstancedNative(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[147])(mode, first, count, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[147])(mode, first, count, instancecount);
			#endif
		}

		/// <summary>
		/// Draw multiple instances of a range of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawArraysInstanced(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			DrawArraysInstancedNative(mode, first, count, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawArraysInstancedBaseInstanceNative(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[148])(mode, first, count, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[148])(mode, first, count, instancecount, baseinstance);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public void DrawArraysInstancedBaseInstance(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			DrawArraysInstancedBaseInstanceNative(mode, first, count, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawBufferNative(GLDrawBufferMode buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[149])(buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[149])(buf);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawBuffer(GLDrawBufferMode buf)
		{
			DrawBufferNative(buf);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawBuffersNative(int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[150])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[150])(n, bufs);
			#endif
		}

		/// <summary>
		/// Specifies a list of color buffers to be drawn
		///     into
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawBuffers(int n, GLDrawBufferMode bufs)
		{
			DrawBuffersNative(n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawElementsNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, void>)funcTable[151])(mode, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, void>)funcTable[151])(mode, count, type, (nint)indices);
			#endif
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			DrawElementsNative(mode, count, type, indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices)
		{
			DrawElementsNative(mode, count, type, (void*)indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawElements<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsNative(mode, count, type, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawElementsBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[152])(mode, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[152])(mode, count, type, (nint)indices, basevertex);
			#endif
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, (void*)indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void DrawElementsBaseVertex<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int basevertex) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsBaseVertexNative(mode, count, type, pindices0, basevertex);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawElementsIndirectNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, void>)funcTable[153])(mode, type, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, void>)funcTable[153])(mode, type, (nint)indirect);
			#endif
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			DrawElementsIndirectNative(mode, type, indirect);
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, nint indirect)
		{
			DrawElementsIndirectNative(mode, type, (void*)indirect);
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public void DrawElementsIndirect<TIndirect>(GLPrimitiveType mode, GLDrawElementsType type, Span<TIndirect> indirect) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				DrawElementsIndirectNative(mode, type, pindirect0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawElementsInstancedNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[154])(mode, count, type, indices, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[154])(mode, count, type, (nint)indices, instancecount);
			#endif
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawElementsInstanced(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			DrawElementsInstancedNative(mode, count, type, indices, instancecount);
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawElementsInstanced(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount)
		{
			DrawElementsInstancedNative(mode, count, type, (void*)indices, instancecount);
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.</remarks>
		public void DrawElementsInstanced<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedNative(mode, count, type, pindices0, instancecount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawElementsInstancedBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, uint, void>)funcTable[155])(mode, count, type, indices, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, uint, void>)funcTable[155])(mode, count, type, (nint)indices, instancecount, baseinstance);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, indices, instancecount, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, (void*)indices, instancecount, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public void DrawElementsInstancedBaseInstance<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount, uint baseinstance) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedBaseInstanceNative(mode, count, type, pindices0, instancecount, baseinstance);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DrawElementsInstancedBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, void>)funcTable[156])(mode, count, type, indices, instancecount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, void>)funcTable[156])(mode, count, type, (nint)indices, instancecount, basevertex);
			#endif
		}

		/// <summary>
		/// Render multiple instances of a set of primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions: All GL ES versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public void DrawElementsInstancedBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexNative(mode, count, type, indices, instancecount, basevertex);
		}
	}
}
