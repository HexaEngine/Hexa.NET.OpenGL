// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES.EXT
{
	public unsafe partial class GLEXTMemoryObject
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void BufferStorageMemEXTNative(GLBufferTargetARB target, nint size, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, uint, ulong, void>)funcTable[0])(target, size, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, uint, ulong, void>)funcTable[0])(target, size, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void BufferStorageMemEXT(GLBufferTargetARB target, nint size, uint memory, ulong offset)
		{
			BufferStorageMemEXTNative(target, size, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CreateMemoryObjectsEXTNative(int n, uint* memoryObjects)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[1])(n, memoryObjects);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[1])(n, (nint)memoryObjects);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void CreateMemoryObjectsEXT(int n, uint* memoryObjects)
		{
			CreateMemoryObjectsEXTNative(n, memoryObjects);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void CreateMemoryObjectsEXT(int n, Span<uint> memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = memoryObjects)
			{
				CreateMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void CreateMemoryObjectsEXT(int n, ref uint memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = &memoryObjects)
			{
				CreateMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DeleteMemoryObjectsEXTNative(int n, uint* memoryObjects)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[2])(n, memoryObjects);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[2])(n, (nint)memoryObjects);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void DeleteMemoryObjectsEXT(int n, uint* memoryObjects)
		{
			DeleteMemoryObjectsEXTNative(n, memoryObjects);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void DeleteMemoryObjectsEX(uint memoryObject)
		{
			DeleteMemoryObjectsEXTNative(1, &memoryObject);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void DeleteMemoryObjectsEXT(int n, Span<uint> memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = memoryObjects)
			{
				DeleteMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void DeleteMemoryObjectsEXT(int n, ref uint memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = &memoryObjects)
			{
				DeleteMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetMemoryObjectParameterivEXTNative(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, int*, void>)funcTable[3])(memoryObject, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, nint, void>)funcTable[3])(memoryObject, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void GetMemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			GetMemoryObjectParameterivEXTNative(memoryObject, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void GetMemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				GetMemoryObjectParameterivEXTNative(memoryObject, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void GetMemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMemoryObjectParameterivEXTNative(memoryObject, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetUnsignedBytevEXTNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[4])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[4])(pname, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytevEXT(GLGetPName pname, byte* data)
		{
			GetUnsignedBytevEXTNative(pname, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytevEXT(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetUnsignedBytevEXTNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytevEXT(GLGetPName pname, Span<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetUnsignedBytevEXTNative(pname, pdata0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytevEXT(GLGetPName pname, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetUnsignedBytevEXTNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void GetUnsignedBytei_vEXTNative(GLEnum target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, byte*, void>)funcTable[5])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[5])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytei_vEXT(GLEnum target, uint index, byte* data)
		{
			GetUnsignedBytei_vEXTNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytei_vEXT(GLEnum target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetUnsignedBytei_vEXTNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytei_vEXT(GLEnum target, uint index, Span<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetUnsignedBytei_vEXTNative(target, index, pdata0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object<br/>GL_EXT_semaphore</remarks>
		public void GetUnsignedBytei_vEXT(GLEnum target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetUnsignedBytei_vEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal byte IsMemoryObjectEXTNative(uint memoryObject)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[6])(memoryObject);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[6])(memoryObject);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public bool IsMemoryObjectEXT(uint memoryObject)
		{
			byte ret = IsMemoryObjectEXTNative(memoryObject);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void MemoryObjectParameterivEXTNative(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, int*, void>)funcTable[7])(memoryObject, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, nint, void>)funcTable[7])(memoryObject, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void MemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			MemoryObjectParameterivEXTNative(memoryObject, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void MemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				MemoryObjectParameterivEXTNative(memoryObject, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void MemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MemoryObjectParameterivEXTNative(memoryObject, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void NamedBufferStorageMemEXTNative(uint buffer, nint size, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, uint, ulong, void>)funcTable[8])(buffer, size, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, uint, ulong, void>)funcTable[8])(buffer, size, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void NamedBufferStorageMemEXT(uint buffer, nint size, uint memory, ulong offset)
		{
			NamedBufferStorageMemEXTNative(buffer, size, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorageMem1DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[9])(target, levels, internalFormat, width, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[9])(target, levels, internalFormat, width, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TexStorageMem1DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			TexStorageMem1DEXTNative(target, levels, internalFormat, width, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorageMem2DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[10])(target, levels, internalFormat, width, height, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[10])(target, levels, internalFormat, width, height, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TexStorageMem2DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			TexStorageMem2DEXTNative(target, levels, internalFormat, width, height, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorageMem2DMultisampleEXTNative(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[11])(target, samples, internalFormat, width, height, *((byte*)(&fixedSampleLocations)), memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[11])(target, samples, internalFormat, width, height, *((byte*)(&fixedSampleLocations)), memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TexStorageMem2DMultisampleEXT(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset)
		{
			TexStorageMem2DMultisampleEXTNative(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorageMem3DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[12])(target, levels, internalFormat, width, height, depth, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[12])(target, levels, internalFormat, width, height, depth, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TexStorageMem3DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			TexStorageMem3DEXTNative(target, levels, internalFormat, width, height, depth, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TexStorageMem3DMultisampleEXTNative(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[13])(target, samples, internalFormat, width, height, depth, *((byte*)(&fixedSampleLocations)), memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[13])(target, samples, internalFormat, width, height, depth, *((byte*)(&fixedSampleLocations)), memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TexStorageMem3DMultisampleEXT(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset)
		{
			TexStorageMem3DMultisampleEXTNative(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorageMem1DEXTNative(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[14])(texture, levels, internalFormat, width, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[14])(texture, levels, internalFormat, width, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TextureStorageMem1DEXT(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			TextureStorageMem1DEXTNative(texture, levels, internalFormat, width, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorageMem2DEXTNative(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[15])(texture, levels, internalFormat, width, height, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[15])(texture, levels, internalFormat, width, height, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TextureStorageMem2DEXT(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			TextureStorageMem2DEXTNative(texture, levels, internalFormat, width, height, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorageMem2DMultisampleEXTNative(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[16])(texture, samples, internalFormat, width, height, *((byte*)(&fixedSampleLocations)), memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[16])(texture, samples, internalFormat, width, height, *((byte*)(&fixedSampleLocations)), memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TextureStorageMem2DMultisampleEXT(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset)
		{
			TextureStorageMem2DMultisampleEXTNative(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorageMem3DEXTNative(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[17])(texture, levels, internalFormat, width, height, depth, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[17])(texture, levels, internalFormat, width, height, depth, memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TextureStorageMem3DEXT(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			TextureStorageMem3DEXTNative(texture, levels, internalFormat, width, height, depth, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void TextureStorageMem3DMultisampleEXTNative(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[18])(texture, samples, internalFormat, width, height, depth, *((byte*)(&fixedSampleLocations)), memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[18])(texture, samples, internalFormat, width, height, depth, *((byte*)(&fixedSampleLocations)), memory, offset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_EXT_memory_object</remarks>
		public void TextureStorageMem3DMultisampleEXT(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset)
		{
			TextureStorageMem3DMultisampleEXTNative(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
		}

	}
}
