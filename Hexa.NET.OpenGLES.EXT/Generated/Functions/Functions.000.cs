// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGLES.EXT
{
	public static unsafe partial class GLExt
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveProgramEXTNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[0])(program);
			#endif
		}

		public static void ActiveProgramEXT(uint program)
		{
			ActiveProgramEXTNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveShaderProgramEXTNative(uint pipeline, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1])(pipeline, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1])(pipeline, program);
			#endif
		}

		public static void ActiveShaderProgramEXT(uint pipeline, uint program)
		{
			ActiveShaderProgramEXTNative(pipeline, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte AcquireKeyedMutexWin32EXTNative(uint memory, ulong key, uint timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ulong, uint, byte>)funcTable[2])(memory, key, timeout);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, ulong, uint, byte>)funcTable[2])(memory, key, timeout);
			#endif
		}

		public static bool AcquireKeyedMutexWin32EXT(uint memory, ulong key, uint timeout)
		{
			byte ret = AcquireKeyedMutexWin32EXTNative(memory, key, timeout);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryEXTNative(GLQueryTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[3])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[3])(target, id);
			#endif
		}

		public static void BeginQueryEXT(GLQueryTarget target, uint id)
		{
			BeginQueryEXTNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationEXTNative(uint program, uint color, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[4])(program, color, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[4])(program, color, (nint)name);
			#endif
		}

		public static void BindFragDataLocationEXT(uint program, uint color, byte* name)
		{
			BindFragDataLocationEXTNative(program, color, name);
		}

		public static void BindFragDataLocationEXT(uint program, uint color, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationEXTNative(program, color, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindFragDataLocationEXT(uint program, uint color, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationEXTNative(program, color, pname0);
			}
		}

		public static void BindFragDataLocationEXT(uint program, uint color, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationEXTNative(program, color, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationIndexedEXTNative(uint program, uint colorNumber, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, byte*, void>)funcTable[5])(program, colorNumber, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, void>)funcTable[5])(program, colorNumber, index, (nint)name);
			#endif
		}

		public static void BindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, byte* name)
		{
			BindFragDataLocationIndexedEXTNative(program, colorNumber, index, name);
		}

		public static void BindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationIndexedEXTNative(program, colorNumber, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationIndexedEXTNative(program, colorNumber, index, pname0);
			}
		}

		public static void BindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationIndexedEXTNative(program, colorNumber, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindProgramPipelineEXTNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[6])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[6])(pipeline);
			#endif
		}

		public static void BindProgramPipelineEXT(uint pipeline)
		{
			BindProgramPipelineEXTNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationEXTNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[7])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[7])(mode);
			#endif
		}

		public static void BlendEquationEXT(GLBlendEquationModeEXT mode)
		{
			BlendEquationEXTNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateiEXTNative(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[8])(buf, modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[8])(buf, modeRGB, modeAlpha);
			#endif
		}

		public static void BlendEquationSeparateiEXT(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateiEXTNative(buf, modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationiEXTNative(uint buf, GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[9])(buf, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[9])(buf, mode);
			#endif
		}

		public static void BlendEquationiEXT(uint buf, GLBlendEquationModeEXT mode)
		{
			BlendEquationiEXTNative(buf, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateiEXTNative(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[10])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[10])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#endif
		}

		public static void BlendFuncSeparateiEXT(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			BlendFuncSeparateiEXTNative(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFunciEXTNative(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[11])(buf, src, dst);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[11])(buf, src, dst);
			#endif
		}

		public static void BlendFunciEXT(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			BlendFunciEXTNative(buf, src, dst);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferLayerEXTNative(int srcX0, int srcY0, int srcX1, int srcY1, int srcLayer, int dstX0, int dstY0, int dstX1, int dstY1, int dstLayer, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[12])(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[12])(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
			#endif
		}

		public static void BlitFramebufferLayerEXT(int srcX0, int srcY0, int srcX1, int srcY1, int srcLayer, int dstX0, int dstY0, int dstX1, int dstY1, int dstLayer, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferLayerEXTNative(srcX0, srcY0, srcX1, srcY1, srcLayer, dstX0, dstY0, dstX1, dstY1, dstLayer, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferLayersEXTNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[13])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[13])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitFramebufferLayersEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferLayersEXTNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageEXTNative(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, void*, GLBufferStorageMask, void>)funcTable[14])(target, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, GLBufferStorageMask, void>)funcTable[14])(target, size, (nint)data, flags);
			#endif
		}

		public static void BufferStorageEXT(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			BufferStorageEXTNative(target, size, data, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageExternalEXTNative(GLEnum target, nint offset, nint size, GLeglClientBufferEXT clientBuffer, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, GLeglClientBufferEXT, GLBufferStorageMask, void>)funcTable[15])(target, offset, size, clientBuffer, flags);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, GLeglClientBufferEXT, GLBufferStorageMask, void>)funcTable[15])(target, offset, size, clientBuffer, flags);
			#endif
		}

		public static void BufferStorageExternalEXT(GLEnum target, nint offset, nint size, GLeglClientBufferEXT clientBuffer, GLBufferStorageMask flags)
		{
			BufferStorageExternalEXTNative(target, offset, size, clientBuffer, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageMemEXTNative(GLBufferTargetARB target, nint size, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, uint, ulong, void>)funcTable[16])(target, size, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, uint, ulong, void>)funcTable[16])(target, size, memory, offset);
			#endif
		}

		public static void BufferStorageMemEXT(GLBufferTargetARB target, nint size, uint memory, ulong offset)
		{
			BufferStorageMemEXTNative(target, size, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearPixelLocalStorageuiEXTNative(int offset, int n, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, uint*, void>)funcTable[17])(offset, n, values);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, void>)funcTable[17])(offset, n, (nint)values);
			#endif
		}

		public static void ClearPixelLocalStorageuiEXT(int offset, int n, uint* values)
		{
			ClearPixelLocalStorageuiEXTNative(offset, n, values);
		}

		public static void ClearPixelLocalStorageuiEXT(int offset, int n, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				ClearPixelLocalStorageuiEXTNative(offset, n, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexImageEXTNative(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[18])(texture, level, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[18])(texture, level, format, type, (nint)data);
			#endif
		}

		public static void ClearTexImageEXT(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexImageEXTNative(texture, level, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexSubImageEXTNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[19])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[19])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)data);
			#endif
		}

		public static void ClearTexSubImageEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexSubImageEXTNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipControlEXTNative(GLEnum origin, GLEnum depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, void>)funcTable[20])(origin, depth);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, GLEnum, void>)funcTable[20])(origin, depth);
			#endif
		}

		public static void ClipControlEXT(GLEnum origin, GLEnum depth)
		{
			ClipControlEXTNative(origin, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorMaskiEXTNative(uint index, byte r, byte g, byte b, byte a)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[21])(index, r, g, b, a);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, byte, byte, byte, void>)funcTable[21])(index, r, g, b, a);
			#endif
		}

		public static void ColorMaskiEXT(uint index, byte r, byte g, byte b, byte a)
		{
			ColorMaskiEXTNative(index, r, g, b, a);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyImageSubDataEXTNative(uint srcName, GLCopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLCopyBufferSubDataTarget, int, int, int, int, uint, GLCopyBufferSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[22])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLCopyBufferSubDataTarget, int, int, int, int, uint, GLCopyBufferSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[22])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#endif
		}

		public static void CopyImageSubDataEXT(uint srcName, GLCopyBufferSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyBufferSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			CopyImageSubDataEXTNative(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateMemoryObjectsEXTNative(int n, uint* memoryObjects)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[23])(n, memoryObjects);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[23])(n, (nint)memoryObjects);
			#endif
		}

		public static void CreateMemoryObjectsEXT(int n, uint* memoryObjects)
		{
			CreateMemoryObjectsEXTNative(n, memoryObjects);
		}

		public static void CreateMemoryObjectsEXT(int n, ref uint memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = &memoryObjects)
			{
				CreateMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderProgramEXTNative(GLShaderType type, byte* str)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, byte*, uint>)funcTable[24])(type, str);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, nint, uint>)funcTable[24])(type, (nint)str);
			#endif
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, byte* str)
		{
			uint ret = CreateShaderProgramEXTNative(type, str);
			return ret;
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = CreateShaderProgramEXTNative(type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr0 = str)
			{
				uint ret = CreateShaderProgramEXTNative(type, pstr0);
				return ret;
			}
		}

		public static uint CreateShaderProgramEXT(GLShaderType type, ref byte str)
		{
			fixed (byte* pstr0 = &str)
			{
				uint ret = CreateShaderProgramEXTNative(type, pstr0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderProgramvEXTNative(GLShaderType type, int count, byte** strings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, int, byte**, uint>)funcTable[25])(type, count, strings);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, uint>)funcTable[25])(type, count, (nint)strings);
			#endif
		}

		public static uint CreateShaderProgramvEXT(GLShaderType type, int count, byte** strings)
		{
			uint ret = CreateShaderProgramvEXTNative(type, count, strings);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteMemoryObjectsEXTNative(int n, uint* memoryObjects)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[26])(n, memoryObjects);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[26])(n, (nint)memoryObjects);
			#endif
		}

		public static void DeleteMemoryObjectsEXT(int n, uint* memoryObjects)
		{
			DeleteMemoryObjectsEXTNative(n, memoryObjects);
		}

		public static void DeleteMemoryObjectsEXT(int n, ref uint memoryObjects)
		{
			fixed (uint* pmemoryObjects0 = &memoryObjects)
			{
				DeleteMemoryObjectsEXTNative(n, pmemoryObjects0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramPipelinesEXTNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[27])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[27])(n, (nint)pipelines);
			#endif
		}

		public static void DeleteProgramPipelinesEXT(int n, uint* pipelines)
		{
			DeleteProgramPipelinesEXTNative(n, pipelines);
		}

		public static void DeleteProgramPipelinesEXT(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				DeleteProgramPipelinesEXTNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteQueriesEXTNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[28])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[28])(n, (nint)ids);
			#endif
		}

		public static void DeleteQueriesEXT(int n, uint* ids)
		{
			DeleteQueriesEXTNative(n, ids);
		}

		public static void DeleteQueriesEXT(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteQueriesEXTNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSemaphoresEXTNative(int n, uint* semaphores)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[29])(n, semaphores);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[29])(n, (nint)semaphores);
			#endif
		}

		public static void DeleteSemaphoresEXT(int n, uint* semaphores)
		{
			DeleteSemaphoresEXTNative(n, semaphores);
		}

		public static void DeleteSemaphoresEXT(int n, ref uint semaphores)
		{
			fixed (uint* psemaphores0 = &semaphores)
			{
				DeleteSemaphoresEXTNative(n, psemaphores0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableiEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[30])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[30])(target, index);
			#endif
		}

		public static void DisableiEXT(GLEnableCap target, uint index)
		{
			DisableiEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DiscardFramebufferEXTNative(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, void>)funcTable[31])(target, numAttachments, attachments);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, void>)funcTable[31])(target, numAttachments, attachments);
			#endif
		}

		public static void DiscardFramebufferEXT(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments)
		{
			DiscardFramebufferEXTNative(target, numAttachments, attachments);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedBaseInstanceEXTNative(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[32])(mode, first, count, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[32])(mode, first, count, instancecount, baseinstance);
			#endif
		}

		public static void DrawArraysInstancedBaseInstanceEXT(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			DrawArraysInstancedBaseInstanceEXTNative(mode, first, count, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedEXTNative(GLPrimitiveType mode, int start, int count, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[33])(mode, start, count, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[33])(mode, start, count, primcount);
			#endif
		}

		public static void DrawArraysInstancedEXT(GLPrimitiveType mode, int start, int count, int primcount)
		{
			DrawArraysInstancedEXTNative(mode, start, count, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersEXTNative(int n, GLEnum* bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLEnum*, void>)funcTable[34])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[34])(n, (nint)bufs);
			#endif
		}

		public static void DrawBuffersEXT(int n, GLEnum* bufs)
		{
			DrawBuffersEXTNative(n, bufs);
		}

		public static void DrawBuffersEXT(int n, ref GLEnum bufs)
		{
			fixed (GLEnum* pbufs0 = &bufs)
			{
				DrawBuffersEXTNative(n, pbufs0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersIndexedEXTNative(int n, GLEnum* location, int* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLEnum*, int*, void>)funcTable[35])(n, location, indices);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, nint, void>)funcTable[35])(n, (nint)location, (nint)indices);
			#endif
		}

		public static void DrawBuffersIndexedEXT(int n, GLEnum* location, int* indices)
		{
			DrawBuffersIndexedEXTNative(n, location, indices);
		}

		public static void DrawBuffersIndexedEXT(int n, ref GLEnum location, int* indices)
		{
			fixed (GLEnum* plocation0 = &location)
			{
				DrawBuffersIndexedEXTNative(n, plocation0, indices);
			}
		}

		public static void DrawBuffersIndexedEXT(int n, GLEnum* location, ref int indices)
		{
			fixed (int* pindices0 = &indices)
			{
				DrawBuffersIndexedEXTNative(n, location, pindices0);
			}
		}

		public static void DrawBuffersIndexedEXT(int n, ref GLEnum location, ref int indices)
		{
			fixed (GLEnum* plocation0 = &location)
			{
				fixed (int* pindices1 = &indices)
				{
					DrawBuffersIndexedEXTNative(n, plocation0, pindices1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsBaseVertexEXTNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[36])(mode, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[36])(mode, count, type, (nint)indices, basevertex);
			#endif
		}

		public static void DrawElementsBaseVertexEXT(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawElementsBaseVertexEXTNative(mode, count, type, indices, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseInstanceEXTNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, uint, void>)funcTable[37])(mode, count, type, indices, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, uint, void>)funcTable[37])(mode, count, type, (nint)indices, instancecount, baseinstance);
			#endif
		}

		public static void DrawElementsInstancedBaseInstanceEXT(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceEXTNative(mode, count, type, indices, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexBaseInstanceEXTNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, uint, void>)funcTable[38])(mode, count, type, indices, instancecount, basevertex, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, uint, void>)funcTable[38])(mode, count, type, (nint)indices, instancecount, basevertex, baseinstance);
			#endif
		}

		public static void DrawElementsInstancedBaseVertexBaseInstanceEXT(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			DrawElementsInstancedBaseVertexBaseInstanceEXTNative(mode, count, type, indices, instancecount, basevertex, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexEXTNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, void>)funcTable[39])(mode, count, type, indices, instancecount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, void>)funcTable[39])(mode, count, type, (nint)indices, instancecount, basevertex);
			#endif
		}

		public static void DrawElementsInstancedBaseVertexEXT(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexEXTNative(mode, count, type, indices, instancecount, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedEXTNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[40])(mode, count, type, indices, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[40])(mode, count, type, (nint)indices, primcount);
			#endif
		}

		public static void DrawElementsInstancedEXT(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			DrawElementsInstancedEXTNative(mode, count, type, indices, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsBaseVertexEXTNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, int, void>)funcTable[41])(mode, start, end, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, int, void>)funcTable[41])(mode, start, end, count, type, (nint)indices, basevertex);
			#endif
		}

		public static void DrawRangeElementsBaseVertexEXT(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawRangeElementsBaseVertexEXTNative(mode, start, end, count, type, indices, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackEXTNative(GLPrimitiveType mode, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[42])(mode, id);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[42])(mode, id);
			#endif
		}

		public static void DrawTransformFeedbackEXT(GLPrimitiveType mode, uint id)
		{
			DrawTransformFeedbackEXTNative(mode, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackInstancedEXTNative(GLPrimitiveType mode, uint id, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[43])(mode, id, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[43])(mode, id, instancecount);
			#endif
		}

		public static void DrawTransformFeedbackInstancedEXT(GLPrimitiveType mode, uint id, int instancecount)
		{
			DrawTransformFeedbackInstancedEXTNative(mode, id, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EGLImageTargetTexStorageEXTNative(GLEnum target, GLeglImageOES image, int* attribList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, GLeglImageOES, int*, void>)funcTable[44])(target, image, attribList);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, GLeglImageOES, nint, void>)funcTable[44])(target, image, (nint)attribList);
			#endif
		}

		public static void EGLImageTargetTexStorageEXT(GLEnum target, GLeglImageOES image, int* attribList)
		{
			EGLImageTargetTexStorageEXTNative(target, image, attribList);
		}

		public static void EGLImageTargetTexStorageEXT(GLEnum target, GLeglImageOES image, ref int attribList)
		{
			fixed (int* pattribList0 = &attribList)
			{
				EGLImageTargetTexStorageEXTNative(target, image, pattribList0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EGLImageTargetTextureStorageEXTNative(uint texture, GLeglImageOES image, int* attribList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLeglImageOES, int*, void>)funcTable[45])(texture, image, attribList);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLeglImageOES, nint, void>)funcTable[45])(texture, image, (nint)attribList);
			#endif
		}

		public static void EGLImageTargetTextureStorageEXT(uint texture, GLeglImageOES image, int* attribList)
		{
			EGLImageTargetTextureStorageEXTNative(texture, image, attribList);
		}

		public static void EGLImageTargetTextureStorageEXT(uint texture, GLeglImageOES image, ref int attribList)
		{
			fixed (int* pattribList0 = &attribList)
			{
				EGLImageTargetTextureStorageEXTNative(texture, image, pattribList0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableiEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[46])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[46])(target, index);
			#endif
		}

		public static void EnableiEXT(GLEnableCap target, uint index)
		{
			EnableiEXTNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryEXTNative(GLQueryTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[47])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[47])(target);
			#endif
		}

		public static void EndQueryEXT(GLQueryTarget target)
		{
			EndQueryEXTNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedBufferRangeEXTNative(GLBufferTargetARB target, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[48])(target, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[48])(target, offset, length);
			#endif
		}

		public static void FlushMappedBufferRangeEXT(GLBufferTargetARB target, nint offset, nint length)
		{
			FlushMappedBufferRangeEXTNative(target, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferFetchBarrierEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[49])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[49])();
			#endif
		}

		public static void FramebufferFetchBarrierEXT()
		{
			FramebufferFetchBarrierEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferPixelLocalStorageSizeEXTNative(uint target, int size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[50])(target, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[50])(target, size);
			#endif
		}

		public static void FramebufferPixelLocalStorageSizeEXT(uint target, int size)
		{
			FramebufferPixelLocalStorageSizeEXTNative(target, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferShadingRateEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int baseLayer, int numLayers, int texelWidth, int texelHeight)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, int, int, void>)funcTable[51])(target, attachment, texture, baseLayer, numLayers, texelWidth, texelHeight);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, int, int, void>)funcTable[51])(target, attachment, texture, baseLayer, numLayers, texelWidth, texelHeight);
			#endif
		}

		public static void FramebufferShadingRateEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int baseLayer, int numLayers, int texelWidth, int texelHeight)
		{
			FramebufferShadingRateEXTNative(target, attachment, texture, baseLayer, numLayers, texelWidth, texelHeight);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture2DMultisampleEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int samples)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[52])(target, attachment, textarget, texture, level, samples);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[52])(target, attachment, textarget, texture, level, samples);
			#endif
		}

		public static void FramebufferTexture2DMultisampleEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int samples)
		{
			FramebufferTexture2DMultisampleEXTNative(target, attachment, textarget, texture, level, samples);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureEXTNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[53])(target, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[53])(target, attachment, texture, level);
			#endif
		}

		public static void FramebufferTextureEXT(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			FramebufferTextureEXTNative(target, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramPipelinesEXTNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[54])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[54])(n, (nint)pipelines);
			#endif
		}

		public static void GenProgramPipelinesEXT(int n, uint* pipelines)
		{
			GenProgramPipelinesEXTNative(n, pipelines);
		}

		public static void GenProgramPipelinesEXT(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				GenProgramPipelinesEXTNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenQueriesEXTNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[55])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[55])(n, (nint)ids);
			#endif
		}

		public static void GenQueriesEXT(int n, uint* ids)
		{
			GenQueriesEXTNative(n, ids);
		}

		public static void GenQueriesEXT(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenQueriesEXTNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenSemaphoresEXTNative(int n, uint* semaphores)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[56])(n, semaphores);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[56])(n, (nint)semaphores);
			#endif
		}

		public static void GenSemaphoresEXT(int n, uint* semaphores)
		{
			GenSemaphoresEXTNative(n, semaphores);
		}

		public static void GenSemaphoresEXT(int n, ref uint semaphores)
		{
			fixed (uint* psemaphores0 = &semaphores)
			{
				GenSemaphoresEXTNative(n, psemaphores0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataIndexEXTNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[57])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[57])(program, (nint)name);
			#endif
		}

		public static int GetFragDataIndexEXT(uint program, byte* name)
		{
			int ret = GetFragDataIndexEXTNative(program, name);
			return ret;
		}

		public static int GetFragDataIndexEXT(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataIndexEXTNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetFragDataIndexEXT(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataIndexEXTNative(program, pname0);
				return ret;
			}
		}

		public static int GetFragDataIndexEXT(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataIndexEXTNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFragmentShadingRatesEXTNative(int samples, int maxCount, int* count, GLShadingRate shadingRates)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int*, GLShadingRate, void>)funcTable[58])(samples, maxCount, count, shadingRates);
			#else
			((delegate* unmanaged[Cdecl]<int, int, nint, GLShadingRate, void>)funcTable[58])(samples, maxCount, (nint)count, shadingRates);
			#endif
		}

		public static void GetFragmentShadingRatesEXT(int samples, int maxCount, int* count, GLShadingRate shadingRates)
		{
			GetFragmentShadingRatesEXTNative(samples, maxCount, count, shadingRates);
		}

		public static void GetFragmentShadingRatesEXT(int samples, int maxCount, ref int count, GLShadingRate shadingRates)
		{
			fixed (int* pcount0 = &count)
			{
				GetFragmentShadingRatesEXTNative(samples, maxCount, pcount0, shadingRates);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFramebufferPixelLocalStorageSizeEXTNative(GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int>)funcTable[59])(target);
			#else
			return (int)((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int>)funcTable[59])(target);
			#endif
		}

		public static int GetFramebufferPixelLocalStorageSizeEXT(GLFramebufferTarget target)
		{
			int ret = GetFramebufferPixelLocalStorageSizeEXTNative(target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetGraphicsResetStatusEXTNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[60])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[60])();
			#endif
		}

		public static GLEnum GetGraphicsResetStatusEXT()
		{
			GLEnum ret = GetGraphicsResetStatusEXTNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64vEXTNative(GLGetPName pname, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, long*, void>)funcTable[61])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[61])(pname, (nint)data);
			#endif
		}

		public static void GetInteger64vEXT(GLGetPName pname, long* data)
		{
			GetInteger64vEXTNative(pname, data);
		}

		public static void GetInteger64vEXT(GLGetPName pname, ref long data)
		{
			fixed (long* pdata0 = &data)
			{
				GetInteger64vEXTNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegeri_vEXTNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[62])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[62])(target, index, (nint)data);
			#endif
		}

		public static void GetIntegeri_vEXT(GLGetPName target, uint index, int* data)
		{
			GetIntegeri_vEXTNative(target, index, data);
		}

		public static void GetIntegeri_vEXT(GLGetPName target, uint index, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegeri_vEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMemoryObjectParameterivEXTNative(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, int*, void>)funcTable[63])(memoryObject, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, nint, void>)funcTable[63])(memoryObject, pname, (nint)@params);
			#endif
		}

		public static void GetMemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			GetMemoryObjectParameterivEXTNative(memoryObject, pname, @params);
		}

		public static void GetMemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMemoryObjectParameterivEXTNative(memoryObject, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectLabelEXTNative(GLEnum type, uint @object, int bufSize, int* length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int, int*, byte*, void>)funcTable[64])(type, @object, bufSize, length, label);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int, nint, nint, void>)funcTable[64])(type, @object, bufSize, (nint)length, (nint)label);
			#endif
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, byte* label)
		{
			GetObjectLabelEXTNative(type, @object, bufSize, length, label);
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, ref int length, byte* label)
		{
			fixed (int* plength0 = &length)
			{
				GetObjectLabelEXTNative(type, @object, bufSize, plength0, label);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetObjectLabelEXTNative(type, @object, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				GetObjectLabelEXTNative(type, @object, bufSize, length, plabel0);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, int* length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				GetObjectLabelEXTNative(type, @object, bufSize, length, plabel0);
			}
		}

		public static void GetObjectLabelEXT(GLEnum type, uint @object, int bufSize, ref int length, ref byte label)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* plabel1 = &label)
				{
					GetObjectLabelEXTNative(type, @object, bufSize, plength0, plabel1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineInfoLogEXTNative(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[65])(pipeline, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[65])(pipeline, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, infoLog);
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramPipelineInfoLogEXTNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineivEXTNative(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, int*, void>)funcTable[66])(pipeline, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, nint, void>)funcTable[66])(pipeline, pname, (nint)@params);
			#endif
		}

		public static void GetProgramPipelineivEXT(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			GetProgramPipelineivEXTNative(pipeline, pname, @params);
		}

		public static void GetProgramPipelineivEXT(uint pipeline, GLPipelineParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramPipelineivEXTNative(pipeline, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationIndexEXTNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[67])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[67])(program, programInterface, (nint)name);
			#endif
		}

		public static int GetProgramResourceLocationIndexEXT(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationIndexEXTNative(program, programInterface, name);
			return ret;
		}

		public static int GetProgramResourceLocationIndexEXT(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationIndexEXTNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetProgramResourceLocationIndexEXT(uint program, GLProgramInterface programInterface, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationIndexEXTNative(program, programInterface, pname0);
				return ret;
			}
		}

		public static int GetProgramResourceLocationIndexEXT(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationIndexEXTNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjecti64vEXTNative(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, long*, void>)funcTable[68])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[68])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjecti64vEXT(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			GetQueryObjecti64vEXTNative(id, pname, @params);
		}

		public static void GetQueryObjecti64vEXT(uint id, GLQueryObjectParameterName pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetQueryObjecti64vEXTNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectivEXTNative(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, int*, void>)funcTable[69])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[69])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectivEXT(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			GetQueryObjectivEXTNative(id, pname, @params);
		}

		public static void GetQueryObjectivEXT(uint id, GLQueryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryObjectivEXTNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectui64vEXTNative(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, ulong*, void>)funcTable[70])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[70])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectui64vEXT(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			GetQueryObjectui64vEXTNative(id, pname, @params);
		}

		public static void GetQueryObjectui64vEXT(uint id, GLQueryObjectParameterName pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetQueryObjectui64vEXTNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectuivEXTNative(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, uint*, void>)funcTable[71])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[71])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectuivEXT(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			GetQueryObjectuivEXTNative(id, pname, @params);
		}

		public static void GetQueryObjectuivEXT(uint id, GLQueryObjectParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetQueryObjectuivEXTNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryivEXTNative(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, int*, void>)funcTable[72])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, nint, void>)funcTable[72])(target, pname, (nint)@params);
			#endif
		}

		public static void GetQueryivEXT(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			GetQueryivEXTNative(target, pname, @params);
		}

		public static void GetQueryivEXT(GLQueryTarget target, GLQueryParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIivEXTNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[73])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[73])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIivEXT(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterIivEXTNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIivEXT(uint sampler, GLSamplerParameterI pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetSamplerParameterIivEXTNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIuivEXTNative(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[74])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[74])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIuivEXT(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			GetSamplerParameterIuivEXTNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIuivEXT(uint sampler, GLSamplerParameterI pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetSamplerParameterIuivEXTNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSemaphoreParameterui64vEXTNative(uint semaphore, GLSemaphoreParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, ulong*, void>)funcTable[75])(semaphore, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, nint, void>)funcTable[75])(semaphore, pname, (nint)@params);
			#endif
		}

		public static void GetSemaphoreParameterui64vEXT(uint semaphore, GLSemaphoreParameterName pname, ulong* @params)
		{
			GetSemaphoreParameterui64vEXTNative(semaphore, pname, @params);
		}

		public static void GetSemaphoreParameterui64vEXT(uint semaphore, GLSemaphoreParameterName pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetSemaphoreParameterui64vEXTNative(semaphore, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIivEXTNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[76])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[76])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIivEXT(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterIivEXTNative(target, pname, @params);
		}

		public static void GetTexParameterIivEXT(GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexParameterIivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIuivEXTNative(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[77])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[77])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIuivEXT(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTexParameterIuivEXTNative(target, pname, @params);
		}

		public static void GetTexParameterIuivEXT(GLTextureTarget target, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetTexParameterIuivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUnsignedBytevEXTNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[78])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[78])(pname, (nint)data);
			#endif
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, byte* data)
		{
			GetUnsignedBytevEXTNative(pname, data);
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetUnsignedBytevEXTNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetUnsignedBytevEXTNative(pname, pdata0);
			}
		}

		public static void GetUnsignedBytevEXT(GLGetPName pname, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetUnsignedBytevEXTNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUnsignedBytei_vEXTNative(GLEnum target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, byte*, void>)funcTable[79])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, nint, void>)funcTable[79])(target, index, (nint)data);
			#endif
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, byte* data)
		{
			GetUnsignedBytei_vEXTNative(target, index, data);
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetUnsignedBytei_vEXTNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetUnsignedBytei_vEXTNative(target, index, pdata0);
			}
		}

		public static void GetUnsignedBytei_vEXT(GLEnum target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetUnsignedBytei_vEXTNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformfvEXTNative(uint program, int location, int bufSize, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[80])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[80])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformfvEXT(uint program, int location, int bufSize, float* @params)
		{
			GetnUniformfvEXTNative(program, location, bufSize, @params);
		}

		public static void GetnUniformfvEXT(uint program, int location, int bufSize, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetnUniformfvEXTNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformivEXTNative(uint program, int location, int bufSize, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[81])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[81])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformivEXT(uint program, int location, int bufSize, int* @params)
		{
			GetnUniformivEXTNative(program, location, bufSize, @params);
		}

		public static void GetnUniformivEXT(uint program, int location, int bufSize, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetnUniformivEXTNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImportMemoryFdEXTNative(uint memory, ulong size, GLExternalHandleType handleType, int fd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ulong, GLExternalHandleType, int, void>)funcTable[82])(memory, size, handleType, fd);
			#else
			((delegate* unmanaged[Cdecl]<uint, ulong, GLExternalHandleType, int, void>)funcTable[82])(memory, size, handleType, fd);
			#endif
		}

		public static void ImportMemoryFdEXT(uint memory, ulong size, GLExternalHandleType handleType, int fd)
		{
			ImportMemoryFdEXTNative(memory, size, handleType, fd);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImportMemoryWin32HandleEXTNative(uint memory, ulong size, GLExternalHandleType handleType, void* handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ulong, GLExternalHandleType, void*, void>)funcTable[83])(memory, size, handleType, handle);
			#else
			((delegate* unmanaged[Cdecl]<uint, ulong, GLExternalHandleType, nint, void>)funcTable[83])(memory, size, handleType, (nint)handle);
			#endif
		}

		public static void ImportMemoryWin32HandleEXT(uint memory, ulong size, GLExternalHandleType handleType, void* handle)
		{
			ImportMemoryWin32HandleEXTNative(memory, size, handleType, handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImportMemoryWin32NameEXTNative(uint memory, ulong size, GLExternalHandleType handleType, void* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ulong, GLExternalHandleType, void*, void>)funcTable[84])(memory, size, handleType, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, ulong, GLExternalHandleType, nint, void>)funcTable[84])(memory, size, handleType, (nint)name);
			#endif
		}

		public static void ImportMemoryWin32NameEXT(uint memory, ulong size, GLExternalHandleType handleType, void* name)
		{
			ImportMemoryWin32NameEXTNative(memory, size, handleType, name);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImportSemaphoreFdEXTNative(uint semaphore, GLExternalHandleType handleType, int fd)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLExternalHandleType, int, void>)funcTable[85])(semaphore, handleType, fd);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLExternalHandleType, int, void>)funcTable[85])(semaphore, handleType, fd);
			#endif
		}

		public static void ImportSemaphoreFdEXT(uint semaphore, GLExternalHandleType handleType, int fd)
		{
			ImportSemaphoreFdEXTNative(semaphore, handleType, fd);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImportSemaphoreWin32HandleEXTNative(uint semaphore, GLExternalHandleType handleType, void* handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLExternalHandleType, void*, void>)funcTable[86])(semaphore, handleType, handle);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLExternalHandleType, nint, void>)funcTable[86])(semaphore, handleType, (nint)handle);
			#endif
		}

		public static void ImportSemaphoreWin32HandleEXT(uint semaphore, GLExternalHandleType handleType, void* handle)
		{
			ImportSemaphoreWin32HandleEXTNative(semaphore, handleType, handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ImportSemaphoreWin32NameEXTNative(uint semaphore, GLExternalHandleType handleType, void* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLExternalHandleType, void*, void>)funcTable[87])(semaphore, handleType, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLExternalHandleType, nint, void>)funcTable[87])(semaphore, handleType, (nint)name);
			#endif
		}

		public static void ImportSemaphoreWin32NameEXT(uint semaphore, GLExternalHandleType handleType, void* name)
		{
			ImportSemaphoreWin32NameEXTNative(semaphore, handleType, name);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InsertEventMarkerEXTNative(int length, byte* marker)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[88])(length, marker);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[88])(length, (nint)marker);
			#endif
		}

		public static void InsertEventMarkerEXT(int length, byte* marker)
		{
			InsertEventMarkerEXTNative(length, marker);
		}

		public static void InsertEventMarkerEXT(int length, string marker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (marker != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(marker);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(marker, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			InsertEventMarkerEXTNative(length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void InsertEventMarkerEXT(int length, ReadOnlySpan<byte> marker)
		{
			fixed (byte* pmarker0 = marker)
			{
				InsertEventMarkerEXTNative(length, pmarker0);
			}
		}

		public static void InsertEventMarkerEXT(int length, ref byte marker)
		{
			fixed (byte* pmarker0 = &marker)
			{
				InsertEventMarkerEXTNative(length, pmarker0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsEnablediEXTNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[89])(target, index);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLEnableCap, uint, byte>)funcTable[89])(target, index);
			#endif
		}

		public static bool IsEnablediEXT(GLEnableCap target, uint index)
		{
			byte ret = IsEnablediEXTNative(target, index);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsMemoryObjectEXTNative(uint memoryObject)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[90])(memoryObject);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[90])(memoryObject);
			#endif
		}

		public static bool IsMemoryObjectEXT(uint memoryObject)
		{
			byte ret = IsMemoryObjectEXTNative(memoryObject);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramPipelineEXTNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[91])(pipeline);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[91])(pipeline);
			#endif
		}

		public static bool IsProgramPipelineEXT(uint pipeline)
		{
			byte ret = IsProgramPipelineEXTNative(pipeline);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQueryEXTNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[92])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[92])(id);
			#endif
		}

		public static bool IsQueryEXT(uint id)
		{
			byte ret = IsQueryEXTNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSemaphoreEXTNative(uint semaphore)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[93])(semaphore);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[93])(semaphore);
			#endif
		}

		public static bool IsSemaphoreEXT(uint semaphore)
		{
			byte ret = IsSemaphoreEXTNative(semaphore);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LabelObjectEXTNative(GLEnum type, uint @object, int length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int, byte*, void>)funcTable[94])(type, @object, length, label);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, int, nint, void>)funcTable[94])(type, @object, length, (nint)label);
			#endif
		}

		public static void LabelObjectEXT(GLEnum type, uint @object, int length, byte* label)
		{
			LabelObjectEXTNative(type, @object, length, label);
		}

		public static void LabelObjectEXT(GLEnum type, uint @object, int length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			LabelObjectEXTNative(type, @object, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void LabelObjectEXT(GLEnum type, uint @object, int length, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				LabelObjectEXTNative(type, @object, length, plabel0);
			}
		}

		public static void LabelObjectEXT(GLEnum type, uint @object, int length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				LabelObjectEXTNative(type, @object, length, plabel0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferRangeEXTNative(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, void*>)funcTable[95])(target, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, nint>)funcTable[95])(target, offset, length, access);
			#endif
		}

		public static void* MapBufferRangeEXT(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapBufferRangeEXTNative(target, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryObjectParameterivEXTNative(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, int*, void>)funcTable[96])(memoryObject, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLMemoryObjectParameterName, nint, void>)funcTable[96])(memoryObject, pname, (nint)@params);
			#endif
		}

		public static void MemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, int* @params)
		{
			MemoryObjectParameterivEXTNative(memoryObject, pname, @params);
		}

		public static void MemoryObjectParameterivEXT(uint memoryObject, GLMemoryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				MemoryObjectParameterivEXTNative(memoryObject, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysEXTNative(GLPrimitiveType mode, int* first, int* count, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, int*, int, void>)funcTable[97])(mode, first, count, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, void>)funcTable[97])(mode, (nint)first, (nint)count, primcount);
			#endif
		}

		public static void MultiDrawArraysEXT(GLPrimitiveType mode, int* first, int* count, int primcount)
		{
			MultiDrawArraysEXTNative(mode, first, count, primcount);
		}

		public static void MultiDrawArraysEXT(GLPrimitiveType mode, ref int first, int* count, int primcount)
		{
			fixed (int* pfirst0 = &first)
			{
				MultiDrawArraysEXTNative(mode, pfirst0, count, primcount);
			}
		}

		public static void MultiDrawArraysEXT(GLPrimitiveType mode, int* first, ref int count, int primcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawArraysEXTNative(mode, first, pcount0, primcount);
			}
		}

		public static void MultiDrawArraysEXT(GLPrimitiveType mode, ref int first, ref int count, int primcount)
		{
			fixed (int* pfirst0 = &first)
			{
				fixed (int* pcount1 = &count)
				{
					MultiDrawArraysEXTNative(mode, pfirst0, pcount1, primcount);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysIndirectEXTNative(GLPrimitiveType mode, void* indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, int, int, void>)funcTable[98])(mode, indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, int, int, void>)funcTable[98])(mode, (nint)indirect, drawcount, stride);
			#endif
		}

		public static void MultiDrawArraysIndirectEXT(GLPrimitiveType mode, void* indirect, int drawcount, int stride)
		{
			MultiDrawArraysIndirectEXTNative(mode, indirect, drawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsBaseVertexEXTNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, int*, void>)funcTable[99])(mode, count, type, indices, drawcount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, nint, void>)funcTable[99])(mode, (nint)count, type, (nint)indices, drawcount, (nint)basevertex);
			#endif
		}

		public static void MultiDrawElementsBaseVertexEXT(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			MultiDrawElementsBaseVertexEXTNative(mode, count, type, indices, drawcount, basevertex);
		}

		public static void MultiDrawElementsBaseVertexEXT(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsBaseVertexEXTNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		public static void MultiDrawElementsBaseVertexEXT(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pbasevertex0 = &basevertex)
			{
				MultiDrawElementsBaseVertexEXTNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		public static void MultiDrawElementsBaseVertexEXT(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (int* pbasevertex1 = &basevertex)
				{
					MultiDrawElementsBaseVertexEXTNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsEXTNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, void>)funcTable[100])(mode, count, type, indices, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, void>)funcTable[100])(mode, (nint)count, type, (nint)indices, primcount);
			#endif
		}

		public static void MultiDrawElementsEXT(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int primcount)
		{
			MultiDrawElementsEXTNative(mode, count, type, indices, primcount);
		}

		public static void MultiDrawElementsEXT(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int primcount)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsEXTNative(mode, pcount0, type, indices, primcount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsIndirectEXTNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, int, int, void>)funcTable[101])(mode, type, indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, int, int, void>)funcTable[101])(mode, type, (nint)indirect, drawcount, stride);
			#endif
		}

		public static void MultiDrawElementsIndirectEXT(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawcount, int stride)
		{
			MultiDrawElementsIndirectEXTNative(mode, type, indirect, drawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferStorageExternalEXTNative(uint buffer, nint offset, nint size, GLeglClientBufferEXT clientBuffer, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLeglClientBufferEXT, GLBufferStorageMask, void>)funcTable[102])(buffer, offset, size, clientBuffer, flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLeglClientBufferEXT, GLBufferStorageMask, void>)funcTable[102])(buffer, offset, size, clientBuffer, flags);
			#endif
		}

		public static void NamedBufferStorageExternalEXT(uint buffer, nint offset, nint size, GLeglClientBufferEXT clientBuffer, GLBufferStorageMask flags)
		{
			NamedBufferStorageExternalEXTNative(buffer, offset, size, clientBuffer, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferStorageMemEXTNative(uint buffer, nint size, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, uint, ulong, void>)funcTable[103])(buffer, size, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, uint, ulong, void>)funcTable[103])(buffer, size, memory, offset);
			#endif
		}

		public static void NamedBufferStorageMemEXT(uint buffer, nint size, uint memory, ulong offset)
		{
			NamedBufferStorageMemEXTNative(buffer, size, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PatchParameteriEXTNative(GLPatchParameterName pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, int, void>)funcTable[104])(pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, int, void>)funcTable[104])(pname, value);
			#endif
		}

		public static void PatchParameteriEXT(GLPatchParameterName pname, int value)
		{
			PatchParameteriEXTNative(pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PolygonOffsetClampEXTNative(float factor, float units, float clamp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[105])(factor, units, clamp);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[105])(factor, units, clamp);
			#endif
		}

		public static void PolygonOffsetClampEXT(float factor, float units, float clamp)
		{
			PolygonOffsetClampEXTNative(factor, units, clamp);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PopGroupMarkerEXTNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[106])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[106])();
			#endif
		}

		public static void PopGroupMarkerEXT()
		{
			PopGroupMarkerEXTNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PrimitiveBoundingBoxEXTNative(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, void>)funcTable[107])(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, float, float, float, float, void>)funcTable[107])(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
			#endif
		}

		public static void PrimitiveBoundingBoxEXT(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW)
		{
			PrimitiveBoundingBoxEXTNative(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramParameteriEXTNative(uint program, GLProgramParameterPName pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramParameterPName, int, void>)funcTable[108])(program, pname, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramParameterPName, int, void>)funcTable[108])(program, pname, value);
			#endif
		}

		public static void ProgramParameteriEXT(uint program, GLProgramParameterPName pname, int value)
		{
			ProgramParameteriEXTNative(program, pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1fEXTNative(uint program, int location, float v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[109])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, void>)funcTable[109])(program, location, v0);
			#endif
		}

		public static void ProgramUniform1fEXT(uint program, int location, float v0)
		{
			ProgramUniform1fEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[110])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[110])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform1fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform1fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform1fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1iEXTNative(uint program, int location, int v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[111])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[111])(program, location, v0);
			#endif
		}

		public static void ProgramUniform1iEXT(uint program, int location, int v0)
		{
			ProgramUniform1iEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[112])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[112])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform1ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform1ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform1ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1uiEXTNative(uint program, int location, uint v0)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[113])(program, location, v0);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, void>)funcTable[113])(program, location, v0);
			#endif
		}

		public static void ProgramUniform1uiEXT(uint program, int location, uint v0)
		{
			ProgramUniform1uiEXTNative(program, location, v0);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform1uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[114])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[114])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform1uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform1uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform1uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform1uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2fEXTNative(uint program, int location, float v0, float v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[115])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, void>)funcTable[115])(program, location, v0, v1);
			#endif
		}

		public static void ProgramUniform2fEXT(uint program, int location, float v0, float v1)
		{
			ProgramUniform2fEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[116])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[116])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform2fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform2fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform2fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2iEXTNative(uint program, int location, int v0, int v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[117])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[117])(program, location, v0, v1);
			#endif
		}

		public static void ProgramUniform2iEXT(uint program, int location, int v0, int v1)
		{
			ProgramUniform2iEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[118])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[118])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform2ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform2ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform2ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2uiEXTNative(uint program, int location, uint v0, uint v1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[119])(program, location, v0, v1);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, void>)funcTable[119])(program, location, v0, v1);
			#endif
		}

		public static void ProgramUniform2uiEXT(uint program, int location, uint v0, uint v1)
		{
			ProgramUniform2uiEXTNative(program, location, v0, v1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform2uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[120])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[120])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform2uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform2uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform2uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform2uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3fEXTNative(uint program, int location, float v0, float v1, float v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[121])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, void>)funcTable[121])(program, location, v0, v1, v2);
			#endif
		}

		public static void ProgramUniform3fEXT(uint program, int location, float v0, float v1, float v2)
		{
			ProgramUniform3fEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[122])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[122])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform3fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform3fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform3fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3iEXTNative(uint program, int location, int v0, int v1, int v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[123])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[123])(program, location, v0, v1, v2);
			#endif
		}

		public static void ProgramUniform3iEXT(uint program, int location, int v0, int v1, int v2)
		{
			ProgramUniform3iEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[124])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[124])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform3ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform3ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform3ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3uiEXTNative(uint program, int location, uint v0, uint v1, uint v2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[125])(program, location, v0, v1, v2);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, void>)funcTable[125])(program, location, v0, v1, v2);
			#endif
		}

		public static void ProgramUniform3uiEXT(uint program, int location, uint v0, uint v1, uint v2)
		{
			ProgramUniform3uiEXTNative(program, location, v0, v1, v2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform3uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[126])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[126])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform3uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform3uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform3uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform3uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4fEXTNative(uint program, int location, float v0, float v1, float v2, float v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[127])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, float, float, float, float, void>)funcTable[127])(program, location, v0, v1, v2, v3);
			#endif
		}

		public static void ProgramUniform4fEXT(uint program, int location, float v0, float v1, float v2, float v3)
		{
			ProgramUniform4fEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4fvEXTNative(uint program, int location, int count, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[128])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[128])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4fvEXT(uint program, int location, int count, float* value)
		{
			ProgramUniform4fvEXTNative(program, location, count, value);
		}

		public static void ProgramUniform4fvEXT(uint program, int location, int count, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniform4fvEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4iEXTNative(uint program, int location, int v0, int v1, int v2, int v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[129])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[129])(program, location, v0, v1, v2, v3);
			#endif
		}

		public static void ProgramUniform4iEXT(uint program, int location, int v0, int v1, int v2, int v3)
		{
			ProgramUniform4iEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4ivEXTNative(uint program, int location, int count, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[130])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[130])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4ivEXT(uint program, int location, int count, int* value)
		{
			ProgramUniform4ivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform4ivEXT(uint program, int location, int count, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ProgramUniform4ivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4uiEXTNative(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[131])(program, location, v0, v1, v2, v3);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, uint, uint, uint, uint, void>)funcTable[131])(program, location, v0, v1, v2, v3);
			#endif
		}

		public static void ProgramUniform4uiEXT(uint program, int location, uint v0, uint v1, uint v2, uint v3)
		{
			ProgramUniform4uiEXTNative(program, location, v0, v1, v2, v3);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniform4uivEXTNative(uint program, int location, int count, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[132])(program, location, count, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[132])(program, location, count, (nint)value);
			#endif
		}

		public static void ProgramUniform4uivEXT(uint program, int location, int count, uint* value)
		{
			ProgramUniform4uivEXTNative(program, location, count, value);
		}

		public static void ProgramUniform4uivEXT(uint program, int location, int count, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ProgramUniform4uivEXTNative(program, location, count, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[133])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[133])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix2fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2x3fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[134])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[134])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix2x3fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2x3fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix2x4fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[135])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[135])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix2x4fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix2x4fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix2x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[136])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[136])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix3fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3x2fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[137])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[137])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix3x2fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3x2fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix3x4fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[138])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[138])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix3x4fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix3x4fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix3x4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[139])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[139])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix4fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4x2fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[140])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[140])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix4x2fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x2fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x2fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ProgramUniformMatrix4x3fvEXTNative(uint program, int location, int count, byte transpose, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, float*, void>)funcTable[141])(program, location, count, transpose, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, byte, nint, void>)funcTable[141])(program, location, count, transpose, (nint)value);
			#endif
		}

		public static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, byte transpose, float* value)
		{
			ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, value);
		}

		public static void ProgramUniformMatrix4x3fvEXT(uint program, int location, int count, byte transpose, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ProgramUniformMatrix4x3fvEXTNative(program, location, count, transpose, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PushGroupMarkerEXTNative(int length, byte* marker)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[142])(length, marker);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[142])(length, (nint)marker);
			#endif
		}

		public static void PushGroupMarkerEXT(int length, byte* marker)
		{
			PushGroupMarkerEXTNative(length, marker);
		}

		public static void PushGroupMarkerEXT(int length, string marker)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (marker != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(marker);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(marker, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			PushGroupMarkerEXTNative(length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void PushGroupMarkerEXT(int length, ReadOnlySpan<byte> marker)
		{
			fixed (byte* pmarker0 = marker)
			{
				PushGroupMarkerEXTNative(length, pmarker0);
			}
		}

		public static void PushGroupMarkerEXT(int length, ref byte marker)
		{
			fixed (byte* pmarker0 = &marker)
			{
				PushGroupMarkerEXTNative(length, pmarker0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void QueryCounterEXTNative(uint id, GLQueryCounterTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryCounterTarget, void>)funcTable[143])(id, target);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryCounterTarget, void>)funcTable[143])(id, target);
			#endif
		}

		public static void QueryCounterEXT(uint id, GLQueryCounterTarget target)
		{
			QueryCounterEXTNative(id, target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RasterSamplesEXTNative(uint samples, byte fixedsamplelocations)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[144])(samples, fixedsamplelocations);
			#else
			((delegate* unmanaged[Cdecl]<uint, byte, void>)funcTable[144])(samples, fixedsamplelocations);
			#endif
		}

		public static void RasterSamplesEXT(uint samples, byte fixedsamplelocations)
		{
			RasterSamplesEXTNative(samples, fixedsamplelocations);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadBufferIndexedEXTNative(GLReadBufferMode src, int index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, int, void>)funcTable[145])(src, index);
			#else
			((delegate* unmanaged[Cdecl]<GLReadBufferMode, int, void>)funcTable[145])(src, index);
			#endif
		}

		public static void ReadBufferIndexedEXT(GLReadBufferMode src, int index)
		{
			ReadBufferIndexedEXTNative(src, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadnPixelsEXTNative(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[146])(x, y, width, height, format, type, bufSize, data);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[146])(x, y, width, height, format, type, bufSize, (nint)data);
			#endif
		}

		public static void ReadnPixelsEXT(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, void* data)
		{
			ReadnPixelsEXTNative(x, y, width, height, format, type, bufSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ReleaseKeyedMutexWin32EXTNative(uint memory, ulong key)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ulong, byte>)funcTable[147])(memory, key);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, ulong, byte>)funcTable[147])(memory, key);
			#endif
		}

		public static bool ReleaseKeyedMutexWin32EXT(uint memory, ulong key)
		{
			byte ret = ReleaseKeyedMutexWin32EXTNative(memory, key);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void RenderbufferStorageMultisampleEXTNative(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[148])(target, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, int, GLInternalFormat, int, int, void>)funcTable[148])(target, samples, internalformat, width, height);
			#endif
		}

		public static void RenderbufferStorageMultisampleEXT(GLRenderbufferTarget target, int samples, GLInternalFormat internalformat, int width, int height)
		{
			RenderbufferStorageMultisampleEXTNative(target, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameterIivEXTNative(uint sampler, GLSamplerParameterI pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[149])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[149])(sampler, pname, (nint)param);
			#endif
		}

		public static void SamplerParameterIivEXT(uint sampler, GLSamplerParameterI pname, int* param)
		{
			SamplerParameterIivEXTNative(sampler, pname, param);
		}

		public static void SamplerParameterIivEXT(uint sampler, GLSamplerParameterI pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				SamplerParameterIivEXTNative(sampler, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SamplerParameterIuivEXTNative(uint sampler, GLSamplerParameterI pname, uint* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[150])(sampler, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[150])(sampler, pname, (nint)param);
			#endif
		}

		public static void SamplerParameterIuivEXT(uint sampler, GLSamplerParameterI pname, uint* param)
		{
			SamplerParameterIuivEXTNative(sampler, pname, param);
		}

		public static void SamplerParameterIuivEXT(uint sampler, GLSamplerParameterI pname, ref uint param)
		{
			fixed (uint* pparam0 = &param)
			{
				SamplerParameterIuivEXTNative(sampler, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SemaphoreParameterui64vEXTNative(uint semaphore, GLSemaphoreParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, ulong*, void>)funcTable[151])(semaphore, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSemaphoreParameterName, nint, void>)funcTable[151])(semaphore, pname, (nint)@params);
			#endif
		}

		public static void SemaphoreParameterui64vEXT(uint semaphore, GLSemaphoreParameterName pname, ulong* @params)
		{
			SemaphoreParameterui64vEXTNative(semaphore, pname, @params);
		}

		public static void SemaphoreParameterui64vEXT(uint semaphore, GLSemaphoreParameterName pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				SemaphoreParameterui64vEXTNative(semaphore, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateEXTNative(GLShadingRate rate)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShadingRate, void>)funcTable[152])(rate);
			#else
			((delegate* unmanaged[Cdecl]<GLShadingRate, void>)funcTable[152])(rate);
			#endif
		}

		public static void ShadingRateEXT(GLShadingRate rate)
		{
			ShadingRateEXTNative(rate);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShadingRateCombinerOpsEXTNative(GLShadingRateCombinerOp combinerOp0, GLShadingRateCombinerOp combinerOp1)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShadingRateCombinerOp, GLShadingRateCombinerOp, void>)funcTable[153])(combinerOp0, combinerOp1);
			#else
			((delegate* unmanaged[Cdecl]<GLShadingRateCombinerOp, GLShadingRateCombinerOp, void>)funcTable[153])(combinerOp0, combinerOp1);
			#endif
		}

		public static void ShadingRateCombinerOpsEXT(GLShadingRateCombinerOp combinerOp0, GLShadingRateCombinerOp combinerOp1)
		{
			ShadingRateCombinerOpsEXTNative(combinerOp0, combinerOp1);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SignalSemaphoreEXTNative(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, GLTextureLayout dstLayouts)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint*, uint, uint*, GLTextureLayout, void>)funcTable[154])(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, uint, nint, GLTextureLayout, void>)funcTable[154])(semaphore, numBufferBarriers, (nint)buffers, numTextureBarriers, (nint)textures, dstLayouts);
			#endif
		}

		public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, GLTextureLayout dstLayouts)
		{
			SignalSemaphoreEXTNative(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
		}

		public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, uint* textures, GLTextureLayout dstLayouts)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				SignalSemaphoreEXTNative(semaphore, numBufferBarriers, pbuffers0, numTextureBarriers, textures, dstLayouts);
			}
		}

		public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, ref uint textures, GLTextureLayout dstLayouts)
		{
			fixed (uint* ptextures0 = &textures)
			{
				SignalSemaphoreEXTNative(semaphore, numBufferBarriers, buffers, numTextureBarriers, ptextures0, dstLayouts);
			}
		}

		public static void SignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, ref uint textures, GLTextureLayout dstLayouts)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (uint* ptextures1 = &textures)
				{
					SignalSemaphoreEXTNative(semaphore, numBufferBarriers, pbuffers0, numTextureBarriers, ptextures1, dstLayouts);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexBufferEXTNative(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[155])(target, internalformat, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, void>)funcTable[155])(target, internalformat, buffer);
			#endif
		}

		public static void TexBufferEXT(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer)
		{
			TexBufferEXTNative(target, internalformat, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexBufferRangeEXTNative(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[156])(target, internalformat, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLSizedInternalFormat, uint, nint, nint, void>)funcTable[156])(target, internalformat, buffer, offset, size);
			#endif
		}

		public static void TexBufferRangeEXT(GLTextureTarget target, GLSizedInternalFormat internalformat, uint buffer, nint offset, nint size)
		{
			TexBufferRangeEXTNative(target, internalformat, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexPageCommitmentEXTNative(GLEnum target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, int, int, int, int, int, int, byte, void>)funcTable[157])(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, int, int, int, int, int, int, byte, void>)funcTable[157])(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
			#endif
		}

		public static void TexPageCommitmentEXT(GLEnum target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, byte commit)
		{
			TexPageCommitmentEXTNative(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterIivEXTNative(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, int*, void>)funcTable[158])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[158])(target, pname, (nint)@params);
			#endif
		}

		public static void TexParameterIivEXT(GLTextureTarget target, GLTextureParameterName pname, int* @params)
		{
			TexParameterIivEXTNative(target, pname, @params);
		}

		public static void TexParameterIivEXT(GLTextureTarget target, GLTextureParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				TexParameterIivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexParameterIuivEXTNative(GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, uint*, void>)funcTable[159])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLTextureParameterName, nint, void>)funcTable[159])(target, pname, (nint)@params);
			#endif
		}

		public static void TexParameterIuivEXT(GLTextureTarget target, GLTextureParameterName pname, uint* @params)
		{
			TexParameterIuivEXTNative(target, pname, @params);
		}

		public static void TexParameterIuivEXT(GLTextureTarget target, GLTextureParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				TexParameterIuivEXTNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorage1DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, void>)funcTable[160])(target, levels, internalformat, width);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, void>)funcTable[160])(target, levels, internalformat, width);
			#endif
		}

		public static void TexStorage1DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			TexStorage1DEXTNative(target, levels, internalformat, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorage2DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, void>)funcTable[161])(target, levels, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, void>)funcTable[161])(target, levels, internalformat, width, height);
			#endif
		}

		public static void TexStorage2DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			TexStorage2DEXTNative(target, levels, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorage3DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, void>)funcTable[162])(target, levels, internalformat, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, void>)funcTable[162])(target, levels, internalformat, width, height, depth);
			#endif
		}

		public static void TexStorage3DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			TexStorage3DEXTNative(target, levels, internalformat, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorageAttribs2DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, GLTexStorageAttribs attribList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, GLTexStorageAttribs, void>)funcTable[163])(target, levels, internalformat, width, height, attribList);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, GLTexStorageAttribs, void>)funcTable[163])(target, levels, internalformat, width, height, attribList);
			#endif
		}

		public static void TexStorageAttribs2DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, GLTexStorageAttribs attribList)
		{
			TexStorageAttribs2DEXTNative(target, levels, internalformat, width, height, attribList);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorageAttribs3DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth, GLTexStorageAttribs attribList)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, GLTexStorageAttribs, void>)funcTable[164])(target, levels, internalformat, width, height, depth, attribList);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, GLTexStorageAttribs, void>)funcTable[164])(target, levels, internalformat, width, height, depth, attribList);
			#endif
		}

		public static void TexStorageAttribs3DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth, GLTexStorageAttribs attribList)
		{
			TexStorageAttribs3DEXTNative(target, levels, internalformat, width, height, depth, attribList);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorageMem1DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[165])(target, levels, internalFormat, width, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[165])(target, levels, internalFormat, width, memory, offset);
			#endif
		}

		public static void TexStorageMem1DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			TexStorageMem1DEXTNative(target, levels, internalFormat, width, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorageMem2DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[166])(target, levels, internalFormat, width, height, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[166])(target, levels, internalFormat, width, height, memory, offset);
			#endif
		}

		public static void TexStorageMem2DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			TexStorageMem2DEXTNative(target, levels, internalFormat, width, height, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorageMem2DMultisampleEXTNative(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[167])(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[167])(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
			#endif
		}

		public static void TexStorageMem2DMultisampleEXT(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset)
		{
			TexStorageMem2DMultisampleEXTNative(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorageMem3DEXTNative(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[168])(target, levels, internalFormat, width, height, depth, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[168])(target, levels, internalFormat, width, height, depth, memory, offset);
			#endif
		}

		public static void TexStorageMem3DEXT(GLTextureTarget target, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			TexStorageMem3DEXTNative(target, levels, internalFormat, width, height, depth, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TexStorageMem3DMultisampleEXTNative(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[169])(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[169])(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
			#endif
		}

		public static void TexStorageMem3DMultisampleEXT(GLTextureTarget target, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset)
		{
			TexStorageMem3DMultisampleEXTNative(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage1DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[170])(texture, target, levels, internalformat, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, void>)funcTable[170])(texture, target, levels, internalformat, width);
			#endif
		}

		public static void TextureStorage1DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width)
		{
			TextureStorage1DEXTNative(texture, target, levels, internalformat, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage2DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[171])(texture, target, levels, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, void>)funcTable[171])(texture, target, levels, internalformat, width, height);
			#endif
		}

		public static void TextureStorage2DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height)
		{
			TextureStorage2DEXTNative(texture, target, levels, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorage3DEXTNative(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[172])(texture, target, levels, internalformat, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int, GLSizedInternalFormat, int, int, int, void>)funcTable[172])(texture, target, levels, internalformat, width, height, depth);
			#endif
		}

		public static void TextureStorage3DEXT(uint texture, GLEnum target, int levels, GLSizedInternalFormat internalformat, int width, int height, int depth)
		{
			TextureStorage3DEXTNative(texture, target, levels, internalformat, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorageMem1DEXTNative(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[173])(texture, levels, internalFormat, width, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, uint, ulong, void>)funcTable[173])(texture, levels, internalFormat, width, memory, offset);
			#endif
		}

		public static void TextureStorageMem1DEXT(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, uint memory, ulong offset)
		{
			TextureStorageMem1DEXTNative(texture, levels, internalFormat, width, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorageMem2DEXTNative(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[174])(texture, levels, internalFormat, width, height, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, uint, ulong, void>)funcTable[174])(texture, levels, internalFormat, width, height, memory, offset);
			#endif
		}

		public static void TextureStorageMem2DEXT(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, uint memory, ulong offset)
		{
			TextureStorageMem2DEXTNative(texture, levels, internalFormat, width, height, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorageMem2DMultisampleEXTNative(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[175])(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, byte, uint, ulong, void>)funcTable[175])(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
			#endif
		}

		public static void TextureStorageMem2DMultisampleEXT(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, byte fixedSampleLocations, uint memory, ulong offset)
		{
			TextureStorageMem2DMultisampleEXTNative(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorageMem3DEXTNative(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[176])(texture, levels, internalFormat, width, height, depth, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, uint, ulong, void>)funcTable[176])(texture, levels, internalFormat, width, height, depth, memory, offset);
			#endif
		}

		public static void TextureStorageMem3DEXT(uint texture, int levels, GLSizedInternalFormat internalFormat, int width, int height, int depth, uint memory, ulong offset)
		{
			TextureStorageMem3DEXTNative(texture, levels, internalFormat, width, height, depth, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureStorageMem3DMultisampleEXTNative(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[177])(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLSizedInternalFormat, int, int, int, byte, uint, ulong, void>)funcTable[177])(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
			#endif
		}

		public static void TextureStorageMem3DMultisampleEXT(uint texture, int samples, GLSizedInternalFormat internalFormat, int width, int height, int depth, byte fixedSampleLocations, uint memory, ulong offset)
		{
			TextureStorageMem3DMultisampleEXTNative(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void TextureViewEXTNative(uint texture, GLTextureTarget target, uint origtexture, GLSizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, GLSizedInternalFormat, uint, uint, uint, uint, void>)funcTable[178])(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTextureTarget, uint, GLSizedInternalFormat, uint, uint, uint, uint, void>)funcTable[178])(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
			#endif
		}

		public static void TextureViewEXT(uint texture, GLTextureTarget target, uint origtexture, GLSizedInternalFormat internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers)
		{
			TextureViewEXTNative(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseProgramStagesEXTNative(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[179])(pipeline, stages, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLUseProgramStageMask, uint, void>)funcTable[179])(pipeline, stages, program);
			#endif
		}

		public static void UseProgramStagesEXT(uint pipeline, GLUseProgramStageMask stages, uint program)
		{
			UseProgramStagesEXTNative(pipeline, stages, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void UseShaderProgramEXTNative(GLEnum type, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void>)funcTable[180])(type, program);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, uint, void>)funcTable[180])(type, program);
			#endif
		}

		public static void UseShaderProgramEXT(GLEnum type, uint program)
		{
			UseShaderProgramEXTNative(type, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ValidateProgramPipelineEXTNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[181])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[181])(pipeline);
			#endif
		}

		public static void ValidateProgramPipelineEXT(uint pipeline)
		{
			ValidateProgramPipelineEXTNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void VertexAttribDivisorEXTNative(uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[182])(index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[182])(index, divisor);
			#endif
		}

		public static void VertexAttribDivisorEXT(uint index, uint divisor)
		{
			VertexAttribDivisorEXTNative(index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WaitSemaphoreEXTNative(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, GLTextureLayout srcLayouts)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint*, uint, uint*, GLTextureLayout, void>)funcTable[183])(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, uint, nint, GLTextureLayout, void>)funcTable[183])(semaphore, numBufferBarriers, (nint)buffers, numTextureBarriers, (nint)textures, srcLayouts);
			#endif
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, GLTextureLayout srcLayouts)
		{
			WaitSemaphoreEXTNative(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, uint* textures, GLTextureLayout srcLayouts)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				WaitSemaphoreEXTNative(semaphore, numBufferBarriers, pbuffers0, numTextureBarriers, textures, srcLayouts);
			}
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, ref uint textures, GLTextureLayout srcLayouts)
		{
			fixed (uint* ptextures0 = &textures)
			{
				WaitSemaphoreEXTNative(semaphore, numBufferBarriers, buffers, numTextureBarriers, ptextures0, srcLayouts);
			}
		}

		public static void WaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, ref uint buffers, uint numTextureBarriers, ref uint textures, GLTextureLayout srcLayouts)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (uint* ptextures1 = &textures)
				{
					WaitSemaphoreEXTNative(semaphore, numBufferBarriers, pbuffers0, numTextureBarriers, ptextures1, srcLayouts);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WindowRectanglesEXTNative(GLEnum mode, int count, int* box)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, int*, void>)funcTable[184])(mode, count, box);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, nint, void>)funcTable[184])(mode, count, (nint)box);
			#endif
		}

		public static void WindowRectanglesEXT(GLEnum mode, int count, int* box)
		{
			WindowRectanglesEXTNative(mode, count, box);
		}

		public static void WindowRectanglesEXT(GLEnum mode, int count, ref int box)
		{
			fixed (int* pbox0 = &box)
			{
				WindowRectanglesEXTNative(mode, count, pbox0);
			}
		}

	}
}
