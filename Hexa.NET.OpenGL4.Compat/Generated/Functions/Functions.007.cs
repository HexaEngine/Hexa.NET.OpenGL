// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public unsafe partial class GL
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4fvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[968])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[968])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4fv(uint index, float* v)
		{
			VertexAttrib4fvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4fv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4fv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				VertexAttrib4fvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[969])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[969])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4iv(uint index, int* v)
		{
			VertexAttrib4ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttrib4ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4sNative(uint index, short x, short y, short z, short w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[970])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, short, short, short, short, void>)funcTable[970])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4s(uint index, short x, short y, short z, short w)
		{
			VertexAttrib4sNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[971])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[971])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4sv(uint index, short* v)
		{
			VertexAttrib4svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttrib4svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4ubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[972])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[972])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4ubv(uint index, byte* v)
		{
			VertexAttrib4ubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4ubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttrib4ubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4ubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4ubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttrib4ubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[973])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[973])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4uiv(uint index, uint* v)
		{
			VertexAttrib4uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttrib4uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttrib4usvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[974])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[974])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4usv(uint index, ushort* v)
		{
			VertexAttrib4usvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4usv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttrib4usv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttrib4usvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribBindingNative(uint attribindex, uint bindingindex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[975])(attribindex, bindingindex);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[975])(attribindex, bindingindex);
			#endif
		}

		/// <summary>
		/// Associate a vertex attribute and a vertex buffer binding for a vertex array object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public void VertexAttribBinding(uint attribindex, uint bindingindex)
		{
			VertexAttribBindingNative(attribindex, bindingindex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribDivisorNative(uint index, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[976])(index, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[976])(index, divisor);
			#endif
		}

		/// <summary>
		/// Modify the rate at which generic vertex attributes advance during instanced rendering
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X</remarks>
		public void VertexAttribDivisor(uint index, uint divisor)
		{
			VertexAttribDivisorNative(index, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribFormatNative(uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribType, byte, uint, void>)funcTable[977])(attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribType, byte, uint, void>)funcTable[977])(attribindex, size, type, *((byte*)(&normalized)), relativeoffset);
			#endif
		}

		/// <summary>
		/// Specify the organization of vertex arrays
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public void VertexAttribFormat(uint attribindex, int size, GLVertexAttribType type, bool normalized, uint relativeoffset)
		{
			VertexAttribFormatNative(attribindex, size, type, normalized, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI1iNative(uint index, int x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[978])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[978])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1i(uint index, int x)
		{
			VertexAttribI1iNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI1ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[979])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[979])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1iv(uint index, int* v)
		{
			VertexAttribI1ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI1ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI1ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI1uiNative(uint index, uint x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[980])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[980])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1ui(uint index, uint x)
		{
			VertexAttribI1uiNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI1uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[981])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[981])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1uiv(uint index, uint* v)
		{
			VertexAttribI1uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI1uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI1uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI1uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI2iNative(uint index, int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[982])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, void>)funcTable[982])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2i(uint index, int x, int y)
		{
			VertexAttribI2iNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI2ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[983])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[983])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2iv(uint index, int* v)
		{
			VertexAttribI2ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI2ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI2ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI2uiNative(uint index, uint x, uint y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[984])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[984])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2ui(uint index, uint x, uint y)
		{
			VertexAttribI2uiNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI2uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[985])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[985])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2uiv(uint index, uint* v)
		{
			VertexAttribI2uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI2uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI2uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI2uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI3iNative(uint index, int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[986])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, void>)funcTable[986])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3i(uint index, int x, int y, int z)
		{
			VertexAttribI3iNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI3ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[987])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[987])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3iv(uint index, int* v)
		{
			VertexAttribI3ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI3ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI3ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI3uiNative(uint index, uint x, uint y, uint z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[988])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, void>)funcTable[988])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3ui(uint index, uint x, uint y, uint z)
		{
			VertexAttribI3uiNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI3uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[989])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[989])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3uiv(uint index, uint* v)
		{
			VertexAttribI3uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI3uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI3uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI3uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4bvNative(uint index, sbyte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, sbyte*, void>)funcTable[990])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[990])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4bv(uint index, sbyte* v)
		{
			VertexAttribI4bvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4bv(uint index, Span<sbyte> v)
		{
			fixed (sbyte* pv0 = v)
			{
				VertexAttribI4bvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4bv(uint index, ref sbyte v)
		{
			fixed (sbyte* pv0 = &v)
			{
				VertexAttribI4bvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4iNative(uint index, int x, int y, int z, int w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[991])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, void>)funcTable[991])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4i(uint index, int x, int y, int z, int w)
		{
			VertexAttribI4iNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4ivNative(uint index, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int*, void>)funcTable[992])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[992])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4iv(uint index, int* v)
		{
			VertexAttribI4ivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4iv(uint index, Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				VertexAttribI4ivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4iv(uint index, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				VertexAttribI4ivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4svNative(uint index, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, short*, void>)funcTable[993])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[993])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4sv(uint index, short* v)
		{
			VertexAttribI4svNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4sv(uint index, Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				VertexAttribI4svNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4sv(uint index, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				VertexAttribI4svNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4ubvNative(uint index, byte* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, byte*, void>)funcTable[994])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[994])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4ubv(uint index, byte* v)
		{
			VertexAttribI4ubvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4ubv(uint index, string v)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (v != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(v);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(v, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			VertexAttribI4ubvNative(index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4ubv(uint index, Span<byte> v)
		{
			fixed (byte* pv0 = v)
			{
				VertexAttribI4ubvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4ubv(uint index, ref byte v)
		{
			fixed (byte* pv0 = &v)
			{
				VertexAttribI4ubvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4uiNative(uint index, uint x, uint y, uint z, uint w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[995])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, void>)funcTable[995])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4ui(uint index, uint x, uint y, uint z, uint w)
		{
			VertexAttribI4uiNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4uivNative(uint index, uint* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint*, void>)funcTable[996])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[996])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4uiv(uint index, uint* v)
		{
			VertexAttribI4uivNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4uiv(uint index, Span<uint> v)
		{
			fixed (uint* pv0 = v)
			{
				VertexAttribI4uivNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4uiv(uint index, ref uint v)
		{
			fixed (uint* pv0 = &v)
			{
				VertexAttribI4uivNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribI4usvNative(uint index, ushort* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, ushort*, void>)funcTable[997])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[997])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4usv(uint index, ushort* v)
		{
			VertexAttribI4usvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4usv(uint index, Span<ushort> v)
		{
			fixed (ushort* pv0 = v)
			{
				VertexAttribI4usvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribI4usv(uint index, ref ushort v)
		{
			fixed (ushort* pv0 = &v)
			{
				VertexAttribI4usvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribIFormatNative(uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, uint, void>)funcTable[998])(attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, uint, void>)funcTable[998])(attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public void VertexAttribIFormat(uint attribindex, int size, GLVertexAttribIType type, uint relativeoffset)
		{
			VertexAttribIFormatNative(attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribIPointerNative(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, void*, void>)funcTable[999])(index, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribIType, int, nint, void>)funcTable[999])(index, size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribIPointer(uint index, int size, GLVertexAttribIType type, int stride, void* pointer)
		{
			VertexAttribIPointerNative(index, size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribIPointer(uint index, int size, GLVertexAttribIType type, int stride, nint pointer)
		{
			VertexAttribIPointerNative(index, size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribIPointer<TPointer>(uint index, int size, GLVertexAttribIType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribIPointerNative(index, size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL1dNative(uint index, double x)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[1000])(index, x);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, void>)funcTable[1000])(index, x);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL1d(uint index, double x)
		{
			VertexAttribL1dNative(index, x);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL1dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[1001])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[1001])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL1dv(uint index, double* v)
		{
			VertexAttribL1dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL1dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL1dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL1dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL1dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL2dNative(uint index, double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[1002])(index, x, y);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[1002])(index, x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL2d(uint index, double x, double y)
		{
			VertexAttribL2dNative(index, x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL2dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[1003])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[1003])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL2dv(uint index, double* v)
		{
			VertexAttribL2dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL2dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL2dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL2dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL2dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL3dNative(uint index, double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[1004])(index, x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, void>)funcTable[1004])(index, x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL3d(uint index, double x, double y, double z)
		{
			VertexAttribL3dNative(index, x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL3dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[1005])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[1005])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL3dv(uint index, double* v)
		{
			VertexAttribL3dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL3dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL3dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL3dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL3dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL4dNative(uint index, double x, double y, double z, double w)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[1006])(index, x, y, z, w);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, double, double, void>)funcTable[1006])(index, x, y, z, w);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL4d(uint index, double x, double y, double z, double w)
		{
			VertexAttribL4dNative(index, x, y, z, w);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribL4dvNative(uint index, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double*, void>)funcTable[1007])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[1007])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL4dv(uint index, double* v)
		{
			VertexAttribL4dvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL4dv(uint index, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				VertexAttribL4dvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribL4dv(uint index, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				VertexAttribL4dvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribLFormatNative(uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, uint, void>)funcTable[1008])(attribindex, size, type, relativeoffset);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, uint, void>)funcTable[1008])(attribindex, size, type, relativeoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public void VertexAttribLFormat(uint attribindex, int size, GLVertexAttribLType type, uint relativeoffset)
		{
			VertexAttribLFormatNative(attribindex, size, type, relativeoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribLPointerNative(uint index, int size, GLVertexAttribLType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, int, void*, void>)funcTable[1009])(index, size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribLType, int, nint, void>)funcTable[1009])(index, size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribLPointer(uint index, int size, GLVertexAttribLType type, int stride, void* pointer)
		{
			VertexAttribLPointerNative(index, size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribLPointer(uint index, int size, GLVertexAttribLType type, int stride, nint pointer)
		{
			VertexAttribLPointerNative(index, size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_64bit</remarks>
		public void VertexAttribLPointer<TPointer>(uint index, int size, GLVertexAttribLType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribLPointerNative(index, size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP1uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1010])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1010])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP1ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP1uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP1uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[1011])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[1011])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP1uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP1uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP1uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP1uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP2uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1012])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1012])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP2ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP2uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP2uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[1013])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[1013])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP2uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP2uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP2uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP2uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP3uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1014])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1014])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP3ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP3uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP3uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[1015])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[1015])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP3uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP3uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP3uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP3uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP4uiNative(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1016])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint, void>)funcTable[1016])(index, type, *((byte*)(&normalized)), value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP4ui(uint index, GLVertexAttribPointerType type, bool normalized, uint value)
		{
			VertexAttribP4uiNative(index, type, normalized, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribP4uivNative(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, uint*, void>)funcTable[1017])(index, type, *((byte*)(&normalized)), value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerType, byte, nint, void>)funcTable[1017])(index, type, *((byte*)(&normalized)), (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, uint* value)
		{
			VertexAttribP4uivNative(index, type, normalized, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexAttribP4uivNative(index, type, normalized, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexAttribP4uiv(uint index, GLVertexAttribPointerType type, bool normalized, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexAttribP4uivNative(index, type, normalized, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexAttribPointerNative(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, void*, void>)funcTable[1018])(index, size, type, *((byte*)(&normalized)), stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLVertexAttribPointerType, byte, int, nint, void>)funcTable[1018])(index, size, type, *((byte*)(&normalized)), stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, void* pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, pointer);
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribPointer(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, nint pointer)
		{
			VertexAttribPointerNative(index, size, type, normalized, stride, (void*)pointer);
		}

		/// <summary>
		/// Define an array of generic vertex attribute data
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void VertexAttribPointer<TPointer>(uint index, int size, GLVertexAttribPointerType type, bool normalized, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexAttribPointerNative(index, size, type, normalized, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexBindingDivisorNative(uint bindingindex, uint divisor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1019])(bindingindex, divisor);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[1019])(bindingindex, divisor);
			#endif
		}

		/// <summary>
		/// Modify the rate at which generic vertex attributes
		///     advance
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_attrib_binding</remarks>
		public void VertexBindingDivisor(uint bindingindex, uint divisor)
		{
			VertexBindingDivisorNative(bindingindex, divisor);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexP2uiNative(GLVertexPointerType type, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint, void>)funcTable[1020])(type, value);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint, void>)funcTable[1020])(type, value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP2ui(GLVertexPointerType type, uint value)
		{
			VertexP2uiNative(type, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexP2uivNative(GLVertexPointerType type, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint*, void>)funcTable[1021])(type, value);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, nint, void>)funcTable[1021])(type, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP2uiv(GLVertexPointerType type, uint* value)
		{
			VertexP2uivNative(type, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP2uiv(GLVertexPointerType type, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexP2uivNative(type, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP2uiv(GLVertexPointerType type, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexP2uivNative(type, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexP3uiNative(GLVertexPointerType type, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint, void>)funcTable[1022])(type, value);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint, void>)funcTable[1022])(type, value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP3ui(GLVertexPointerType type, uint value)
		{
			VertexP3uiNative(type, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexP3uivNative(GLVertexPointerType type, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint*, void>)funcTable[1023])(type, value);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, nint, void>)funcTable[1023])(type, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP3uiv(GLVertexPointerType type, uint* value)
		{
			VertexP3uivNative(type, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP3uiv(GLVertexPointerType type, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexP3uivNative(type, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP3uiv(GLVertexPointerType type, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexP3uivNative(type, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexP4uiNative(GLVertexPointerType type, uint value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint, void>)funcTable[1024])(type, value);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint, void>)funcTable[1024])(type, value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP4ui(GLVertexPointerType type, uint value)
		{
			VertexP4uiNative(type, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexP4uivNative(GLVertexPointerType type, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, uint*, void>)funcTable[1025])(type, value);
			#else
			((delegate* unmanaged[Cdecl]<GLVertexPointerType, nint, void>)funcTable[1025])(type, (nint)value);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP4uiv(GLVertexPointerType type, uint* value)
		{
			VertexP4uivNative(type, value);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP4uiv(GLVertexPointerType type, Span<uint> value)
		{
			fixed (uint* pvalue0 = value)
			{
				VertexP4uivNative(type, pvalue0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3 Compat<br/>GL 4.X Compat<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_type_2_10_10_10_rev</remarks>
		public void VertexP4uiv(GLVertexPointerType type, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				VertexP4uivNative(type, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void VertexPointerNative(int size, GLVertexPointerType type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLVertexPointerType, int, void*, void>)funcTable[1026])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLVertexPointerType, int, nint, void>)funcTable[1026])(size, type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void VertexPointer(int size, GLVertexPointerType type, int stride, void* pointer)
		{
			VertexPointerNative(size, type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void VertexPointer(int size, GLVertexPointerType type, int stride, nint pointer)
		{
			VertexPointerNative(size, type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void VertexPointer<TPointer>(int size, GLVertexPointerType type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				VertexPointerNative(size, type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ViewportNative(int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[1027])(x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, void>)funcTable[1027])(x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public void Viewport(int x, int y, int width, int height)
		{
			ViewportNative(x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ViewportArrayvNative(uint first, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[1028])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[1028])(first, count, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ViewportArrayv(uint first, int count, float* v)
		{
			ViewportArrayvNative(first, count, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ViewportArrayv(uint first, int count, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				ViewportArrayvNative(first, count, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ViewportArrayv(uint first, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ViewportArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ViewportIndexedfNative(uint index, float x, float y, float w, float h)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[1029])(index, x, y, w, h);
			#else
			((delegate* unmanaged[Cdecl]<uint, float, float, float, float, void>)funcTable[1029])(index, x, y, w, h);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ViewportIndexedf(uint index, float x, float y, float w, float h)
		{
			ViewportIndexedfNative(index, x, y, w, h);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ViewportIndexedfvNative(uint index, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, float*, void>)funcTable[1030])(index, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, void>)funcTable[1030])(index, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ViewportIndexedfv(uint index, float* v)
		{
			ViewportIndexedfvNative(index, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ViewportIndexedfv(uint index, Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				ViewportIndexedfvNative(index, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public void ViewportIndexedfv(uint index, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				ViewportIndexedfvNative(index, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WaitSyncNative(GLSync sync, GLSyncBehaviorFlags flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncBehaviorFlags, ulong, void>)funcTable[1031])(sync, flags, timeout);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncBehaviorFlags, ulong, void>)funcTable[1031])(sync, flags, timeout);
			#endif
		}

		/// <summary>
		/// Instruct the GL server to block until the specified sync object becomes signaled
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public void WaitSync(GLSync sync, GLSyncBehaviorFlags flags, ulong timeout)
		{
			WaitSyncNative(sync, flags, timeout);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2dNative(double x, double y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[1032])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[1032])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2d(double x, double y)
		{
			WindowPos2dNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[1033])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1033])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2dv(double* v)
		{
			WindowPos2dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				WindowPos2dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				WindowPos2dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2fNative(float x, float y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[1034])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[1034])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2f(float x, float y)
		{
			WindowPos2fNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[1035])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1035])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2fv(float* v)
		{
			WindowPos2fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				WindowPos2fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				WindowPos2fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2iNative(int x, int y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[1036])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[1036])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2i(int x, int y)
		{
			WindowPos2iNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[1037])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1037])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2iv(int* v)
		{
			WindowPos2ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				WindowPos2ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				WindowPos2ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2sNative(short x, short y)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[1038])(x, y);
			#else
			((delegate* unmanaged[Cdecl]<short, short, void>)funcTable[1038])(x, y);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2s(short x, short y)
		{
			WindowPos2sNative(x, y);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos2svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[1039])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1039])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2sv(short* v)
		{
			WindowPos2svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				WindowPos2svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos2sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				WindowPos2svNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3dNative(double x, double y, double z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[1040])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, void>)funcTable[1040])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3d(double x, double y, double z)
		{
			WindowPos3dNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3dvNative(double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[1041])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1041])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3dv(double* v)
		{
			WindowPos3dvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3dv(Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				WindowPos3dvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3dv(ref double v)
		{
			fixed (double* pv0 = &v)
			{
				WindowPos3dvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3fNative(float x, float y, float z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[1042])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, void>)funcTable[1042])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3f(float x, float y, float z)
		{
			WindowPos3fNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3fvNative(float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[1043])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1043])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3fv(float* v)
		{
			WindowPos3fvNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3fv(Span<float> v)
		{
			fixed (float* pv0 = v)
			{
				WindowPos3fvNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3fv(ref float v)
		{
			fixed (float* pv0 = &v)
			{
				WindowPos3fvNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3iNative(int x, int y, int z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[1044])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, void>)funcTable[1044])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3i(int x, int y, int z)
		{
			WindowPos3iNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3ivNative(int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int*, void>)funcTable[1045])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1045])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3iv(int* v)
		{
			WindowPos3ivNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3iv(Span<int> v)
		{
			fixed (int* pv0 = v)
			{
				WindowPos3ivNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3iv(ref int v)
		{
			fixed (int* pv0 = &v)
			{
				WindowPos3ivNative(pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3sNative(short x, short y, short z)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[1046])(x, y, z);
			#else
			((delegate* unmanaged[Cdecl]<short, short, short, void>)funcTable[1046])(x, y, z);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3s(short x, short y, short z)
		{
			WindowPos3sNative(x, y, z);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void WindowPos3svNative(short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<short*, void>)funcTable[1047])(v);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[1047])((nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3sv(short* v)
		{
			WindowPos3svNative(v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3sv(Span<short> v)
		{
			fixed (short* pv0 = v)
			{
				WindowPos3svNative(pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public void WindowPos3sv(ref short v)
		{
			fixed (short* pv0 = &v)
			{
				WindowPos3svNative(pv0);
			}
		}

	}
}
