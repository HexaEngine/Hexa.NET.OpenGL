// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[152])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[152])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// Create vertex array objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateVertexArrays(int n, uint* arrays)
		{
			CreateVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// Create vertex array objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// Create vertex array objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void CreateVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CullFaceNative(GLTriangleFace mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[153])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, void>)funcTable[153])(mode);
			#endif
		}

		/// <summary>
		/// Specify whether front- or back-facing facets can be culled
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void CullFace(GLTriangleFace mode)
		{
			CullFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageCallbackNative(GLDebugProc callback, void* userParam)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[154])((void*)Utils.GetFunctionPointerForDelegate(callback), userParam);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[154])(Utils.GetFunctionPointerForDelegate(callback), (nint)userParam);
			#endif
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageCallback(GLDebugProc callback, void* userParam)
		{
			DebugMessageCallbackNative(callback, userParam);
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageCallback(GLDebugProc callback, nint userParam)
		{
			DebugMessageCallbackNative(callback, (void*)userParam);
		}

		/// <summary>
		/// Specify a callback to receive debugging messages from the GL
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageCallback<TUserParam>(GLDebugProc callback, Span<TUserParam> userParam) where TUserParam : unmanaged
		{
			fixed (TUserParam* puserParam0 = userParam)
			{
				DebugMessageCallbackNative(callback, puserParam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageControlNative(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, bool enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, uint*, byte, void>)funcTable[155])(source, type, severity, count, ids, *((byte*)(&enabled)));
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, nint, byte, void>)funcTable[155])(source, type, severity, count, (nint)ids, *((byte*)(&enabled)));
			#endif
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, bool enabled)
		{
			DebugMessageControlNative(source, type, severity, count, ids, enabled);
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, Span<uint> ids, bool enabled)
		{
			fixed (uint* pids0 = ids)
			{
				DebugMessageControlNative(source, type, severity, count, pids0, enabled);
			}
		}

		/// <summary>
		/// Control the reporting of debug messages in a debug context
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageControl(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, ref uint ids, bool enabled)
		{
			fixed (uint* pids0 = &ids)
			{
				DebugMessageControlNative(source, type, severity, count, pids0, enabled);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageInsertNative(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, byte*, void>)funcTable[156])(source, type, id, severity, length, buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, nint, void>)funcTable[156])(source, type, id, severity, length, (nint)buf);
			#endif
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			DebugMessageInsertNative(source, type, id, severity, length, buf);
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugMessageInsertNative(source, type, id, severity, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, Span<byte> buf)
		{
			fixed (byte* pbuf0 = buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		/// <summary>
		/// Inject an application-supplied message into the debug message queue
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_KHR_debug</remarks>
		public static void DebugMessageInsert(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, ref byte buf)
		{
			fixed (byte* pbuf0 = &buf)
			{
				DebugMessageInsertNative(source, type, id, severity, length, pbuf0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[157])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[157])(n, (nint)buffers);
			#endif
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteBuffers(int n, uint* buffers)
		{
			DeleteBuffersNative(n, buffers);
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteBuffer(uint buffer)
		{
			DeleteBuffersNative(1, &buffer);
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteBuffers(int n, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		/// <summary>
		/// Delete named buffer objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				DeleteBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[158])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[158])(n, (nint)framebuffers);
			#endif
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffers(int n, uint* framebuffers)
		{
			DeleteFramebuffersNative(n, framebuffers);
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffer(uint framebuffer)
		{
			DeleteFramebuffersNative(1, &framebuffer);
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffers(int n, Span<uint> framebuffers)
		{
			fixed (uint* pframebuffers0 = framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		/// <summary>
		/// Delete framebuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteListsNative(uint list, int range)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[159])(list, range);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[159])(list, range);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void DeleteLists(uint list, int range)
		{
			DeleteListsNative(list, range);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramNative(uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[160])(program);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[160])(program);
			#endif
		}

		/// <summary>
		/// Deletes a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DeleteProgram(uint program)
		{
			DeleteProgramNative(program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[161])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[161])(n, (nint)pipelines);
			#endif
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipelines(int n, uint* pipelines)
		{
			DeleteProgramPipelinesNative(n, pipelines);
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipeline(uint pipeline)
		{
			DeleteProgramPipelinesNative(1, &pipeline);
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipelines(int n, Span<uint> pipelines)
		{
			fixed (uint* ppipelines0 = pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		/// <summary>
		/// Delete program pipeline objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void DeleteProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[162])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[162])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteQueries(int n, uint* ids)
		{
			DeleteQueriesNative(n, ids);
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteQuerie(uint id)
		{
			DeleteQueriesNative(1, &id);
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteQueries(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		/// <summary>
		/// Delete named query objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[163])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[163])(n, (nint)renderbuffers);
			#endif
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffers(int n, uint* renderbuffers)
		{
			DeleteRenderbuffersNative(n, renderbuffers);
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffer(uint renderbuffer)
		{
			DeleteRenderbuffersNative(1, &renderbuffer);
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffers(int n, Span<uint> renderbuffers)
		{
			fixed (uint* prenderbuffers0 = renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		/// <summary>
		/// Delete renderbuffer objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void DeleteRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[164])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[164])(count, (nint)samplers);
			#endif
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void DeleteSamplers(int count, uint* samplers)
		{
			DeleteSamplersNative(count, samplers);
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void DeleteSampler(uint sampler)
		{
			DeleteSamplersNative(1, &sampler);
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void DeleteSamplers(int count, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		/// <summary>
		/// Delete named sampler objects
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void DeleteSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteShaderNative(uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[165])(shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[165])(shader);
			#endif
		}

		/// <summary>
		/// Deletes a shader object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DeleteShader(uint shader)
		{
			DeleteShaderNative(shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[166])(sync);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[166])(sync);
			#endif
		}

		/// <summary>
		/// Delete a sync object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static void DeleteSync(GLSync sync)
		{
			DeleteSyncNative(sync);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[167])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[167])(n, (nint)textures);
			#endif
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteTextures(int n, uint* textures)
		{
			DeleteTexturesNative(n, textures);
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteTexture(uint texture)
		{
			DeleteTexturesNative(1, &texture);
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteTextures(int n, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		/// <summary>
		/// Delete named textures
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DeleteTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				DeleteTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[168])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[168])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedbacks(int n, uint* ids)
		{
			DeleteTransformFeedbacksNative(n, ids);
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedback(uint id)
		{
			DeleteTransformFeedbacksNative(1, &id);
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedbacks(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		/// <summary>
		/// Delete transform feedback objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DeleteTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[169])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[169])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArrays(int n, uint* arrays)
		{
			DeleteVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArray(uint array)
		{
			DeleteVertexArraysNative(1, &array);
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// Delete vertex array objects
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void DeleteVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthFuncNative(GLDepthFunction func)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[170])(func);
			#else
			((delegate* unmanaged[Cdecl]<GLDepthFunction, void>)funcTable[170])(func);
			#endif
		}

		/// <summary>
		/// Specify the value used for depth buffer comparisons
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DepthFunc(GLDepthFunction func)
		{
			DepthFuncNative(func);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthMaskNative(bool flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[171])(*((byte*)(&flag)));
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[171])(*((byte*)(&flag)));
			#endif
		}

		/// <summary>
		/// Enable or disable writing into the depth buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DepthMask(bool flag)
		{
			DepthMaskNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeNative(double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[172])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[172])(n, f);
			#endif
		}

		/// <summary>
		/// Specify mapping of depth values from normalized device coordinates to window coordinates
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DepthRange(double n, double f)
		{
			DepthRangeNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeArrayvNative(uint first, int count, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[173])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[173])(first, count, (nint)v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeArrayv(uint first, int count, double* v)
		{
			DepthRangeArrayvNative(first, count, v);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeArrayv(uint first, int count, Span<double> v)
		{
			fixed (double* pv0 = v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeArrayv(uint first, int count, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeIndexedNative(uint index, double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[174])(index, n, f);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[174])(index, n, f);
			#endif
		}

		/// <summary>
		/// Specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_viewport_array</remarks>
		public static void DepthRangeIndexed(uint index, double n, double f)
		{
			DepthRangeIndexedNative(index, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangefNative(float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[175])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[175])(n, f);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_ES2_compatibility</remarks>
		public static void DepthRangef(float n, float f)
		{
			DepthRangefNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachShaderNative(uint program, uint shader)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[176])(program, shader);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[176])(program, shader);
			#endif
		}

		/// <summary>
		/// Detaches a shader object from a program object to which it is attached
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DetachShader(uint program, uint shader)
		{
			DetachShaderNative(program, shader);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[177])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[177])(cap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Disable(GLEnableCap cap)
		{
			DisableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[178])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[178])(array);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void DisableClientState(GLEnableCap array)
		{
			DisableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[179])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[179])(vaobj, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void DisableVertexArrayAttrib(uint vaobj, uint index)
		{
			DisableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[180])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[180])(index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DisableVertexAttribArray(uint index)
		{
			DisableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableiNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[181])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[181])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Disablei(GLEnableCap target, uint index)
		{
			DisableiNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeNative(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[182])(numGroupsX, numGroupsY, numGroupsZ);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[182])(numGroupsX, numGroupsY, numGroupsZ);
			#endif
		}

		/// <summary>
		/// Launch one or more compute work groups
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_compute_shader</remarks>
		public static void DispatchCompute(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			DispatchComputeNative(numGroupsX, numGroupsY, numGroupsZ);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeIndirectNative(nint indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[183])(indirect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[183])(indirect);
			#endif
		}

		/// <summary>
		/// Launch one or more compute work groups using parameters stored in a buffer
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_compute_shader</remarks>
		public static void DispatchComputeIndirect(nint indirect)
		{
			DispatchComputeIndirectNative(indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysNative(GLPrimitiveType mode, int first, int count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[184])(mode, first, count);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, void>)funcTable[184])(mode, first, count);
			#endif
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DrawArrays(GLPrimitiveType mode, int first, int count)
		{
			DrawArraysNative(mode, first, count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysIndirectNative(GLPrimitiveType mode, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, void>)funcTable[185])(mode, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, void>)funcTable[185])(mode, (nint)indirect);
			#endif
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawArraysIndirect(GLPrimitiveType mode, void* indirect)
		{
			DrawArraysIndirectNative(mode, indirect);
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawArraysIndirect(GLPrimitiveType mode, nint indirect)
		{
			DrawArraysIndirectNative(mode, (void*)indirect);
		}

		/// <summary>
		/// Render primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawArraysIndirect<TIndirect>(GLPrimitiveType mode, Span<TIndirect> indirect) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				DrawArraysIndirectNative(mode, pindirect0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedNative(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[186])(mode, first, count, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[186])(mode, first, count, instancecount);
			#endif
		}

		/// <summary>
		/// Draw multiple instances of a range of elements
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X</remarks>
		public static void DrawArraysInstanced(GLPrimitiveType mode, int first, int count, int instancecount)
		{
			DrawArraysInstancedNative(mode, first, count, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedBaseInstanceNative(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[187])(mode, first, count, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[187])(mode, first, count, instancecount, baseinstance);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawArraysInstancedBaseInstance(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			DrawArraysInstancedBaseInstanceNative(mode, first, count, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBufferNative(GLDrawBufferMode buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[188])(buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDrawBufferMode, void>)funcTable[188])(buf);
			#endif
		}

		/// <summary>
		/// Specify which color buffers are to be drawn into
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DrawBuffer(GLDrawBufferMode buf)
		{
			DrawBufferNative(buf);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersNative(int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[189])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[189])(n, bufs);
			#endif
		}

		/// <summary>
		/// Specifies a list of color buffers to be drawn
		///     into
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void DrawBuffers(int n, GLDrawBufferMode bufs)
		{
			DrawBuffersNative(n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, void>)funcTable[190])(mode, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, void>)funcTable[190])(mode, count, type, (nint)indices);
			#endif
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices)
		{
			DrawElementsNative(mode, count, type, indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DrawElements(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices)
		{
			DrawElementsNative(mode, count, type, (void*)indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DrawElements<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsNative(mode, count, type, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[191])(mode, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[191])(mode, count, type, (nint)indices, basevertex);
			#endif
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, (void*)indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsBaseVertex<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int basevertex) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsBaseVertexNative(mode, count, type, pindices0, basevertex);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsIndirectNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, void>)funcTable[192])(mode, type, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, void>)funcTable[192])(mode, type, (nint)indirect);
			#endif
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			DrawElementsIndirectNative(mode, type, indirect);
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, nint indirect)
		{
			DrawElementsIndirectNative(mode, type, (void*)indirect);
		}

		/// <summary>
		/// Render indexed primitives from array data, taking parameters from memory
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_draw_indirect</remarks>
		public static void DrawElementsIndirect<TIndirect>(GLPrimitiveType mode, GLDrawElementsType type, Span<TIndirect> indirect) where TIndirect : unmanaged
		{
			fixed (TIndirect* pindirect0 = indirect)
			{
				DrawElementsIndirectNative(mode, type, pindirect0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[193])(mode, count, type, indices, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[193])(mode, count, type, (nint)indices, instancecount);
			#endif
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X</remarks>
		public static void DrawElementsInstanced(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount)
		{
			DrawElementsInstancedNative(mode, count, type, indices, instancecount);
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X</remarks>
		public static void DrawElementsInstanced(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount)
		{
			DrawElementsInstancedNative(mode, count, type, (void*)indices, instancecount);
		}

		/// <summary>
		/// Draw multiple instances of a set of elements
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X</remarks>
		public static void DrawElementsInstanced<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedNative(mode, count, type, pindices0, instancecount);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, uint, void>)funcTable[194])(mode, count, type, indices, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, uint, void>)funcTable[194])(mode, count, type, (nint)indices, instancecount, baseinstance);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, indices, instancecount, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, (void*)indices, instancecount, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseInstance<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount, uint baseinstance) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedBaseInstanceNative(mode, count, type, pindices0, instancecount, baseinstance);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, void>)funcTable[195])(mode, count, type, indices, instancecount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, void>)funcTable[195])(mode, count, type, (nint)indices, instancecount, basevertex);
			#endif
		}

		/// <summary>
		/// Render multiple instances of a set of primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsInstancedBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexNative(mode, count, type, indices, instancecount, basevertex);
		}

		/// <summary>
		/// Render multiple instances of a set of primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsInstancedBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexNative(mode, count, type, (void*)indices, instancecount, basevertex);
		}

		/// <summary>
		/// Render multiple instances of a set of primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawElementsInstancedBaseVertex<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount, int basevertex) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedBaseVertexNative(mode, count, type, pindices0, instancecount, basevertex);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, uint, void>)funcTable[196])(mode, count, type, indices, instancecount, basevertex, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, uint, void>)funcTable[196])(mode, count, type, (nint)indices, instancecount, basevertex, baseinstance);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseVertexBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			DrawElementsInstancedBaseVertexBaseInstanceNative(mode, count, type, indices, instancecount, basevertex, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseVertexBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, nint indices, int instancecount, int basevertex, uint baseinstance)
		{
			DrawElementsInstancedBaseVertexBaseInstanceNative(mode, count, type, (void*)indices, instancecount, basevertex, baseinstance);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_base_instance</remarks>
		public static void DrawElementsInstancedBaseVertexBaseInstance<TIndices>(GLPrimitiveType mode, int count, GLDrawElementsType type, Span<TIndices> indices, int instancecount, int basevertex, uint baseinstance) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawElementsInstancedBaseVertexBaseInstanceNative(mode, count, type, pindices0, instancecount, basevertex, baseinstance);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawPixelsNative(int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[197])(width, height, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[197])(width, height, format, type, (nint)pixels);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void DrawPixels(int width, int height, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			DrawPixelsNative(width, height, format, type, pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void DrawPixels(int width, int height, GLPixelFormat format, GLPixelType type, nint pixels)
		{
			DrawPixelsNative(width, height, format, type, (void*)pixels);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void DrawPixels<TPixels>(int width, int height, GLPixelFormat format, GLPixelType type, Span<TPixels> pixels) where TPixels : unmanaged
		{
			fixed (TPixels* ppixels0 = pixels)
			{
				DrawPixelsNative(width, height, format, type, ppixels0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, void>)funcTable[198])(mode, start, end, count, type, indices);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, void>)funcTable[198])(mode, start, end, count, type, (nint)indices);
			#endif
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.2 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DrawRangeElements(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices)
		{
			DrawRangeElementsNative(mode, start, end, count, type, indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.2 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DrawRangeElements(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, nint indices)
		{
			DrawRangeElementsNative(mode, start, end, count, type, (void*)indices);
		}

		/// <summary>
		/// Render primitives from array data
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.2 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void DrawRangeElements<TIndices>(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, Span<TIndices> indices) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawRangeElementsNative(mode, start, end, count, type, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsBaseVertexNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, int, void>)funcTable[199])(mode, start, end, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, int, void>)funcTable[199])(mode, start, end, count, type, (nint)indices, basevertex);
			#endif
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawRangeElementsBaseVertex(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawRangeElementsBaseVertexNative(mode, start, end, count, type, indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawRangeElementsBaseVertex(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, nint indices, int basevertex)
		{
			DrawRangeElementsBaseVertexNative(mode, start, end, count, type, (void*)indices, basevertex);
		}

		/// <summary>
		/// Render primitives from array data with a per-element offset
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_draw_elements_base_vertex</remarks>
		public static void DrawRangeElementsBaseVertex<TIndices>(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, Span<TIndices> indices, int basevertex) where TIndices : unmanaged
		{
			fixed (TIndices* pindices0 = indices)
			{
				DrawRangeElementsBaseVertexNative(mode, start, end, count, type, pindices0, basevertex);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackNative(GLPrimitiveType mode, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[200])(mode, id);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[200])(mode, id);
			#endif
		}

		/// <summary>
		/// Render primitives using a count derived from a transform feedback object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void DrawTransformFeedback(GLPrimitiveType mode, uint id)
		{
			DrawTransformFeedbackNative(mode, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackInstancedNative(GLPrimitiveType mode, uint id, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[201])(mode, id, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[201])(mode, id, instancecount);
			#endif
		}

		/// <summary>
		/// Render multiple instances of primitives using a count derived from a transform feedback object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback_instanced</remarks>
		public static void DrawTransformFeedbackInstanced(GLPrimitiveType mode, uint id, int instancecount)
		{
			DrawTransformFeedbackInstancedNative(mode, id, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackStreamNative(GLPrimitiveType mode, uint id, uint stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, void>)funcTable[202])(mode, id, stream);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, void>)funcTable[202])(mode, id, stream);
			#endif
		}

		/// <summary>
		/// Render primitives using a count derived from a specifed stream of a transform feedback object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public static void DrawTransformFeedbackStream(GLPrimitiveType mode, uint id, uint stream)
		{
			DrawTransformFeedbackStreamNative(mode, id, stream);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackStreamInstancedNative(GLPrimitiveType mode, uint id, uint stream, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, void>)funcTable[203])(mode, id, stream, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, void>)funcTable[203])(mode, id, stream, instancecount);
			#endif
		}

		/// <summary>
		/// Render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback_instanced</remarks>
		public static void DrawTransformFeedbackStreamInstanced(GLPrimitiveType mode, uint id, uint stream, int instancecount)
		{
			DrawTransformFeedbackStreamInstancedNative(mode, id, stream, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagNative(bool flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[204])(*((byte*)(&flag)));
			#else
			((delegate* unmanaged[Cdecl]<byte, void>)funcTable[204])(*((byte*)(&flag)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlag(bool flag)
		{
			EdgeFlagNative(flag);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagPointerNative(int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void*, void>)funcTable[205])(stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[205])(stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlagPointer(int stride, void* pointer)
		{
			EdgeFlagPointerNative(stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlagPointer(int stride, nint pointer)
		{
			EdgeFlagPointerNative(stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlagPointer<TPointer>(int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				EdgeFlagPointerNative(stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EdgeFlagvNative(byte* flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[206])(flag);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[206])((nint)flag);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlagv(byte* flag)
		{
			EdgeFlagvNative(flag);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlagv(string flag)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (flag != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(flag);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(flag, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			EdgeFlagvNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlagv(Span<byte> flag)
		{
			fixed (byte* pflag0 = flag)
			{
				EdgeFlagvNative(pflag0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EdgeFlagv(ref byte flag)
		{
			fixed (byte* pflag0 = &flag)
			{
				EdgeFlagvNative(pflag0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableNative(GLEnableCap cap)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[207])(cap);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[207])(cap);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Enable(GLEnableCap cap)
		{
			EnableNative(cap);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableClientStateNative(GLEnableCap array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[208])(array);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, void>)funcTable[208])(array);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EnableClientState(GLEnableCap array)
		{
			EnableClientStateNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[209])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[209])(vaobj, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void EnableVertexArrayAttrib(uint vaobj, uint index)
		{
			EnableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexAttribArrayNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[210])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[210])(index);
			#endif
		}

		/// <summary>
		/// Enable or disable a generic vertex attribute
		///     array
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void EnableVertexAttribArray(uint index)
		{
			EnableVertexAttribArrayNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableiNative(GLEnableCap target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[211])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLEnableCap, uint, void>)funcTable[211])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Enablei(GLEnableCap target, uint index)
		{
			EnableiNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[212])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[212])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void End()
		{
			EndNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndConditionalRenderNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[213])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[213])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void EndConditionalRender()
		{
			EndConditionalRenderNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndListNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[214])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[214])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EndList()
		{
			EndListNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryNative(GLQueryTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[215])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[215])(target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void EndQuery(GLQueryTarget target)
		{
			EndQueryNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryIndexedNative(GLQueryTarget target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[216])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[216])(target, index);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback3</remarks>
		public static void EndQueryIndexed(GLQueryTarget target, uint index)
		{
			EndQueryIndexedNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndTransformFeedbackNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[217])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[217])();
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void EndTransformFeedback()
		{
			EndTransformFeedbackNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1dNative(double u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[218])(u);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[218])(u);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1d(double u)
		{
			EvalCoord1dNative(u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1dvNative(double* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[219])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[219])((nint)u);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1dv(double* u)
		{
			EvalCoord1dvNative(u);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1dv(Span<double> u)
		{
			fixed (double* pu0 = u)
			{
				EvalCoord1dvNative(pu0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1dv(ref double u)
		{
			fixed (double* pu0 = &u)
			{
				EvalCoord1dvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1fNative(float u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[220])(u);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[220])(u);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1f(float u)
		{
			EvalCoord1fNative(u);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord1fvNative(float* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[221])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[221])((nint)u);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1fv(float* u)
		{
			EvalCoord1fvNative(u);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1fv(Span<float> u)
		{
			fixed (float* pu0 = u)
			{
				EvalCoord1fvNative(pu0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord1fv(ref float u)
		{
			fixed (float* pu0 = &u)
			{
				EvalCoord1fvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2dNative(double u, double v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[222])(u, v);
			#else
			((delegate* unmanaged[Cdecl]<double, double, void>)funcTable[222])(u, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2d(double u, double v)
		{
			EvalCoord2dNative(u, v);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2dvNative(double* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[223])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[223])((nint)u);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2dv(double* u)
		{
			EvalCoord2dvNative(u);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2dv(Span<double> u)
		{
			fixed (double* pu0 = u)
			{
				EvalCoord2dvNative(pu0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2dv(ref double u)
		{
			fixed (double* pu0 = &u)
			{
				EvalCoord2dvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2fNative(float u, float v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[224])(u, v);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[224])(u, v);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2f(float u, float v)
		{
			EvalCoord2fNative(u, v);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalCoord2fvNative(float* u)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[225])(u);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[225])((nint)u);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2fv(float* u)
		{
			EvalCoord2fvNative(u);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2fv(Span<float> u)
		{
			fixed (float* pu0 = u)
			{
				EvalCoord2fvNative(pu0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalCoord2fv(ref float u)
		{
			fixed (float* pu0 = &u)
			{
				EvalCoord2fvNative(pu0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalMesh1Native(GLMeshMode1 mode, int i1, int i2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMeshMode1, int, int, void>)funcTable[226])(mode, i1, i2);
			#else
			((delegate* unmanaged[Cdecl]<GLMeshMode1, int, int, void>)funcTable[226])(mode, i1, i2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalMesh1(GLMeshMode1 mode, int i1, int i2)
		{
			EvalMesh1Native(mode, i1, i2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalMesh2Native(GLMeshMode2 mode, int i1, int i2, int j1, int j2)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMeshMode2, int, int, int, int, void>)funcTable[227])(mode, i1, i2, j1, j2);
			#else
			((delegate* unmanaged[Cdecl]<GLMeshMode2, int, int, int, int, void>)funcTable[227])(mode, i1, i2, j1, j2);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalMesh2(GLMeshMode2 mode, int i1, int i2, int j1, int j2)
		{
			EvalMesh2Native(mode, i1, i2, j1, j2);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalPoint1Native(int i)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[228])(i);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[228])(i);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalPoint1(int i)
		{
			EvalPoint1Native(i);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvalPoint2Native(int i, int j)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[229])(i, j);
			#else
			((delegate* unmanaged[Cdecl]<int, int, void>)funcTable[229])(i, j);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void EvalPoint2(int i, int j)
		{
			EvalPoint2Native(i, j);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FeedbackBufferNative(int size, GLFeedbackType type, float* buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLFeedbackType, float*, void>)funcTable[230])(size, type, buffer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLFeedbackType, nint, void>)funcTable[230])(size, type, (nint)buffer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FeedbackBuffer(int size, GLFeedbackType type, float* buffer)
		{
			FeedbackBufferNative(size, type, buffer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FeedbackBuffer(int size, GLFeedbackType type, Span<float> buffer)
		{
			fixed (float* pbuffer0 = buffer)
			{
				FeedbackBufferNative(size, type, pbuffer0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FeedbackBuffer(int size, GLFeedbackType type, ref float buffer)
		{
			fixed (float* pbuffer0 = &buffer)
			{
				FeedbackBufferNative(size, type, pbuffer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLSync FenceSyncNative(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[231])(condition, flags);
			#else
			return (GLSync)((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[231])(condition, flags);
			#endif
		}

		/// <summary>
		/// Create a new sync object and insert it into the GL command stream
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sync</remarks>
		public static GLSync FenceSync(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			GLSync ret = FenceSyncNative(condition, flags);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FinishNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[232])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[232])();
			#endif
		}

		/// <summary>
		/// Block until all GL execution is complete
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Finish()
		{
			FinishNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[233])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[233])();
			#endif
		}

		/// <summary>
		/// Force execution of GL commands in finite time
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void Flush()
		{
			FlushNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedBufferRangeNative(GLBufferTargetARB target, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[234])(target, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[234])(target, offset, length);
			#endif
		}

		/// <summary>
		/// Indicate modifications to a range of a mapped buffer
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_map_buffer_range</remarks>
		public static void FlushMappedBufferRange(GLBufferTargetARB target, nint offset, nint length)
		{
			FlushMappedBufferRangeNative(target, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedNamedBufferRangeNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[235])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[235])(buffer, offset, length);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void FlushMappedNamedBufferRange(uint buffer, nint offset, nint length)
		{
			FlushMappedNamedBufferRangeNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordPointerNative(GLFogPointerTypeEXT type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogPointerTypeEXT, int, void*, void>)funcTable[236])(type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<GLFogPointerTypeEXT, int, nint, void>)funcTable[236])(type, stride, (nint)pointer);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordPointer(GLFogPointerTypeEXT type, int stride, void* pointer)
		{
			FogCoordPointerNative(type, stride, pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordPointer(GLFogPointerTypeEXT type, int stride, nint pointer)
		{
			FogCoordPointerNative(type, stride, (void*)pointer);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordPointer<TPointer>(GLFogPointerTypeEXT type, int stride, Span<TPointer> pointer) where TPointer : unmanaged
		{
			fixed (TPointer* ppointer0 = pointer)
			{
				FogCoordPointerNative(type, stride, ppointer0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoorddNative(double coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[237])(coord);
			#else
			((delegate* unmanaged[Cdecl]<double, void>)funcTable[237])(coord);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordd(double coord)
		{
			FogCoorddNative(coord);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoorddvNative(double* coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[238])(coord);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[238])((nint)coord);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoorddv(double* coord)
		{
			FogCoorddvNative(coord);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoorddv(Span<double> coord)
		{
			fixed (double* pcoord0 = coord)
			{
				FogCoorddvNative(pcoord0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoorddv(ref double coord)
		{
			fixed (double* pcoord0 = &coord)
			{
				FogCoorddvNative(pcoord0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordfNative(float coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[239])(coord);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[239])(coord);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordf(float coord)
		{
			FogCoordfNative(coord);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogCoordfvNative(float* coord)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[240])(coord);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[240])((nint)coord);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordfv(float* coord)
		{
			FogCoordfvNative(coord);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordfv(Span<float> coord)
		{
			fixed (float* pcoord0 = coord)
			{
				FogCoordfvNative(pcoord0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void FogCoordfv(ref float coord)
		{
			fixed (float* pcoord0 = &coord)
			{
				FogCoordfvNative(pcoord0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogfNative(GLFogParameter pname, float param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, float, void>)funcTable[241])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, float, void>)funcTable[241])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogf(GLFogParameter pname, float param)
		{
			FogfNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogfvNative(GLFogParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, float*, void>)funcTable[242])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, nint, void>)funcTable[242])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogfv(GLFogParameter pname, float* @params)
		{
			FogfvNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogfv(GLFogParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				FogfvNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogfv(GLFogParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				FogfvNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogiNative(GLFogParameter pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, int, void>)funcTable[243])(pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, int, void>)funcTable[243])(pname, param);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogi(GLFogParameter pname, int param)
		{
			FogiNative(pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FogivNative(GLFogParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFogParameter, int*, void>)funcTable[244])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFogParameter, nint, void>)funcTable[244])(pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogiv(GLFogParameter pname, int* @params)
		{
			FogivNative(pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogiv(GLFogParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				FogivNative(pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Fogiv(GLFogParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				FogivNative(pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferParameteriNative(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[245])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[245])(target, pname, param);
			#endif
		}

		/// <summary>
		/// Set a named parameter of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.3 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_no_attachments</remarks>
		public static void FramebufferParameteri(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			FramebufferParameteriNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferRenderbufferNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[246])(target, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[246])(target, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		/// <summary>
		/// Attach a renderbuffer as a logical buffer of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferRenderbuffer(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			FramebufferRenderbufferNative(target, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[247])(target, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[247])(target, attachment, texture, level);
			#endif
		}

		/// <summary>
		/// Attach a level of a texture object as a logical buffer of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.2 - GL 3.3<br/>GL 4.X</remarks>
		public static void FramebufferTexture(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			FramebufferTextureNative(target, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture1DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[248])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[248])(target, attachment, textarget, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTexture1D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture1DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture2DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[249])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[249])(target, attachment, textarget, texture, level);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTexture2D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture2DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture3DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[250])(target, attachment, textarget, texture, level, zoffset);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[250])(target, attachment, textarget, texture, level, zoffset);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTexture3D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			FramebufferTexture3DNative(target, attachment, textarget, texture, level, zoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureLayerNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[251])(target, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[251])(target, attachment, texture, level, layer);
			#endif
		}

		/// <summary>
		/// Attach a single layer of a texture object as a logical buffer of a framebuffer object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void FramebufferTextureLayer(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			FramebufferTextureLayerNative(target, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrontFaceNative(GLFrontFaceDirection mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[252])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLFrontFaceDirection, void>)funcTable[252])(mode);
			#endif
		}

		/// <summary>
		/// Define front- and back-facing polygons
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void FrontFace(GLFrontFaceDirection mode)
		{
			FrontFaceNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FrustumNative(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[253])(left, right, bottom, top, zNear, zFar);
			#else
			((delegate* unmanaged[Cdecl]<double, double, double, double, double, double, void>)funcTable[253])(left, right, bottom, top, zNear, zFar);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static void Frustum(double left, double right, double bottom, double top, double zNear, double zFar)
		{
			FrustumNative(left, right, bottom, top, zNear, zFar);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[254])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[254])(n, (nint)buffers);
			#endif
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenBuffers(int n, uint* buffers)
		{
			GenBuffersNative(n, buffers);
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static uint GenBuffer()
		{
			uint result;
			GenBuffersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenBuffers(int n, Span<uint> buffers)
		{
			fixed (uint* pbuffers0 = buffers)
			{
				GenBuffersNative(n, pbuffers0);
			}
		}

		/// <summary>
		/// Generate buffer object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				GenBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[255])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[255])(n, (nint)framebuffers);
			#endif
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenFramebuffers(int n, uint* framebuffers)
		{
			GenFramebuffersNative(n, framebuffers);
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static uint GenFramebuffer()
		{
			uint result;
			GenFramebuffersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenFramebuffers(int n, Span<uint> framebuffers)
		{
			fixed (uint* pframebuffers0 = framebuffers)
			{
				GenFramebuffersNative(n, pframebuffers0);
			}
		}

		/// <summary>
		/// Generate framebuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				GenFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GenListsNative(int range)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, uint>)funcTable[256])(range);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<int, uint>)funcTable[256])(range);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.X<br/>GL 2.X<br/>GL 3.0 - GL 3.1<br/>GL 3.2 Compat - GL 3.3 Compat<br/>GL 4.X Compat</remarks>
		public static uint GenLists(int range)
		{
			uint ret = GenListsNative(range);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[257])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[257])(n, (nint)pipelines);
			#endif
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GenProgramPipelines(int n, uint* pipelines)
		{
			GenProgramPipelinesNative(n, pipelines);
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static uint GenProgramPipeline()
		{
			uint result;
			GenProgramPipelinesNative(1, &result);
			return result;
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GenProgramPipelines(int n, Span<uint> pipelines)
		{
			fixed (uint* ppipelines0 = pipelines)
			{
				GenProgramPipelinesNative(n, ppipelines0);
			}
		}

		/// <summary>
		/// Reserve program pipeline object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.1 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_separate_shader_objects</remarks>
		public static void GenProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				GenProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenQueriesNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[258])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[258])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenQueries(int n, uint* ids)
		{
			GenQueriesNative(n, ids);
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static uint GenQuerie()
		{
			uint result;
			GenQueriesNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenQueries(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				GenQueriesNative(n, pids0);
			}
		}

		/// <summary>
		/// Generate query object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenQueries(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenQueriesNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[259])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[259])(n, (nint)renderbuffers);
			#endif
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenRenderbuffers(int n, uint* renderbuffers)
		{
			GenRenderbuffersNative(n, renderbuffers);
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static uint GenRenderbuffer()
		{
			uint result;
			GenRenderbuffersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenRenderbuffers(int n, Span<uint> renderbuffers)
		{
			fixed (uint* prenderbuffers0 = renderbuffers)
			{
				GenRenderbuffersNative(n, prenderbuffers0);
			}
		}

		/// <summary>
		/// Generate renderbuffer object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				GenRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[260])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[260])(count, (nint)samplers);
			#endif
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GenSamplers(int count, uint* samplers)
		{
			GenSamplersNative(count, samplers);
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static uint GenSampler()
		{
			uint result;
			GenSamplersNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GenSamplers(int count, Span<uint> samplers)
		{
			fixed (uint* psamplers0 = samplers)
			{
				GenSamplersNative(count, psamplers0);
			}
		}

		/// <summary>
		/// Generate sampler object names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_sampler_objects</remarks>
		public static void GenSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				GenSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTexturesNative(int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[261])(n, textures);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[261])(n, (nint)textures);
			#endif
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenTextures(int n, uint* textures)
		{
			GenTexturesNative(n, textures);
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static uint GenTexture()
		{
			uint result;
			GenTexturesNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenTextures(int n, Span<uint> textures)
		{
			fixed (uint* ptextures0 = textures)
			{
				GenTexturesNative(n, ptextures0);
			}
		}

		/// <summary>
		/// Generate texture names
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.1 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X</remarks>
		public static void GenTextures(int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				GenTexturesNative(n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[262])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[262])(n, (nint)ids);
			#endif
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void GenTransformFeedbacks(int n, uint* ids)
		{
			GenTransformFeedbacksNative(n, ids);
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static uint GenTransformFeedback()
		{
			uint result;
			GenTransformFeedbacksNative(1, &result);
			return result;
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void GenTransformFeedbacks(int n, Span<uint> ids)
		{
			fixed (uint* pids0 = ids)
			{
				GenTransformFeedbacksNative(n, pids0);
			}
		}

		/// <summary>
		/// Reserve transform feedback object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_transform_feedback2</remarks>
		public static void GenTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[263])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[263])(n, (nint)arrays);
			#endif
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void GenVertexArrays(int n, uint* arrays)
		{
			GenVertexArraysNative(n, arrays);
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static uint GenVertexArray()
		{
			uint result;
			GenVertexArraysNative(1, &result);
			return result;
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void GenVertexArrays(int n, Span<uint> arrays)
		{
			fixed (uint* parrays0 = arrays)
			{
				GenVertexArraysNative(n, parrays0);
			}
		}

		/// <summary>
		/// Generate vertex array object names
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_vertex_array_object</remarks>
		public static void GenVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				GenVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapNative(GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[264])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[264])(target);
			#endif
		}

		/// <summary>
		/// Generate mipmaps for a specified texture object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_framebuffer_object</remarks>
		public static void GenerateMipmap(GLTextureTarget target)
		{
			GenerateMipmapNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[265])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[265])(texture);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.5 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_direct_state_access</remarks>
		public static void GenerateTextureMipmap(uint texture)
		{
			GenerateTextureMipmapNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAtomicCounterBufferivNative(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, int*, void>)funcTable[266])(program, bufferIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, nint, void>)funcTable[266])(program, bufferIndex, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Retrieve information about the set of active atomic counter buffers for a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_shader_atomic_counters</remarks>
		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, @params);
		}

		/// <summary>
		/// Retrieve information about the set of active atomic counter buffers for a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_shader_atomic_counters</remarks>
		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, out int @params)
		{
			int pparam;
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Retrieve information about the set of active atomic counter buffers for a program
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 4.2 - GL 4.6<br/><br/>Used by Extensions:<br/>GL_ARB_shader_atomic_counters</remarks>
		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAttribNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[267])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[267])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetActiveAttribNative(program, index, bufSize, length, size, type, name);
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveAttribNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveAttribNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = size)
			{
				GetActiveAttribNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveAttribNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveAttribNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, int* size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* psize0 = size)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveAttribNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLAttributeType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					fixed (byte* pname2 = name)
					{
						GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		/// <summary>
		/// Returns information about an active attribute variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[268])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[268])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, name);
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[269])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[269])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, name);
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, Span<int> length, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		/// <summary>
		/// Query the name of an active shader subroutine uniform
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformivNative(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, int*, void>)funcTable[270])(program, shadertype, index, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, nint, void>)funcTable[270])(program, shadertype, index, pname, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			GetActiveSubroutineUniformivNative(program, shadertype, index, pname, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, out int values)
		{
			int pparam;
			GetActiveSubroutineUniformivNative(program, shadertype, index, pname, &pparam);
			values = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.<br/><br/>Used by Extensions:<br/>GL_ARB_shader_subroutine</remarks>
		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, Span<int> values)
		{
			fixed (int* pparams = values)
			{
				GetActiveSubroutineUniformivNative(program, shadertype, index, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNative(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLUniformType, byte*, void>)funcTable[271])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLUniformType, nint, void>)funcTable[271])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			GetActiveUniformNative(program, index, bufSize, length, size, type, name);
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				GetActiveUniformNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, Span<int> size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = size)
			{
				GetActiveUniformNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveUniformNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, int* size, GLUniformType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, Span<int> size, GLUniformType type, Span<byte> name)
		{
			fixed (int* psize0 = size)
			{
				fixed (byte* pname1 = name)
				{
					GetActiveUniformNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, Span<int> length, Span<int> size, GLUniformType type, Span<byte> name)
		{
			fixed (int* plength0 = length)
			{
				fixed (int* psize1 = size)
				{
					fixed (byte* pname2 = name)
					{
						GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		/// <summary>
		/// Returns information about an active uniform variable for the specified program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockNameNative(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[272])(program, uniformBlockIndex, bufSize, length, uniformBlockName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[272])(program, uniformBlockIndex, bufSize, (nint)length, (nint)uniformBlockName);
			#endif
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, uniformBlockName);
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, Span<int> length, byte* uniformBlockName)
		{
			fixed (int* plength0 = length)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, uniformBlockName);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, byte* uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, uniformBlockName);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, Span<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, Span<int> length, Span<byte> uniformBlockName)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* puniformBlockName1 = uniformBlockName)
				{
					GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, puniformBlockName1);
				}
			}
		}

		/// <summary>
		/// Retrieve the name of an active uniform block
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, ref byte uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformBlockName1 = &uniformBlockName)
				{
					GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, puniformBlockName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockivNative(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, int*, void>)funcTable[273])(program, uniformBlockIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, nint, void>)funcTable[273])(program, uniformBlockIndex, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, out int @params)
		{
			int pparam;
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNameNative(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[274])(program, uniformIndex, bufSize, length, uniformName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[274])(program, uniformIndex, bufSize, (nint)length, (nint)uniformName);
			#endif
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, uniformName);
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, Span<int> length, byte* uniformName)
		{
			fixed (int* plength0 = length)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, uniformName);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, byte* uniformName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, uniformName);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, string uniformName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, Span<byte> uniformName)
		{
			fixed (byte* puniformName0 = uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ref byte uniformName)
		{
			fixed (byte* puniformName0 = &uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, Span<int> length, Span<byte> uniformName)
		{
			fixed (int* plength0 = length)
			{
				fixed (byte* puniformName1 = uniformName)
				{
					GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, puniformName1);
				}
			}
		}

		/// <summary>
		/// Query the name of an active uniform
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, ref byte uniformName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformName1 = &uniformName)
				{
					GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, puniformName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformsivNative(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, GLUniformPName, int*, void>)funcTable[275])(program, uniformCount, uniformIndices, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, GLUniformPName, nint, void>)funcTable[275])(program, uniformCount, (nint)uniformIndices, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, @params);
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, out int @params)
		{
			int pparam;
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, pparams);
			}
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, Span<uint> uniformIndices, GLUniformPName pname, int* @params)
		{
			fixed (uint* puniformIndices0 = uniformIndices)
			{
				GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, @params);
			}
		}

		/// <summary>
		/// Returns information about several active uniform variables for the specified program object
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 3.1 - GL 3.3<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_uniform_buffer_object</remarks>
		public static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, GLUniformPName pname, int* @params)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, @params);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAttachedShadersNative(uint program, int maxCount, int* count, uint* shaders)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, uint*, void>)funcTable[276])(program, maxCount, count, shaders);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[276])(program, maxCount, (nint)count, (nint)shaders);
			#endif
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, int* count, uint* shaders)
		{
			GetAttachedShadersNative(program, maxCount, count, shaders);
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, Span<int> count, uint* shaders)
		{
			fixed (int* pcount0 = count)
			{
				GetAttachedShadersNative(program, maxCount, pcount0, shaders);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, ref int count, uint* shaders)
		{
			fixed (int* pcount0 = &count)
			{
				GetAttachedShadersNative(program, maxCount, pcount0, shaders);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, int* count, Span<uint> shaders)
		{
			fixed (uint* pshaders0 = shaders)
			{
				GetAttachedShadersNative(program, maxCount, count, pshaders0);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, int* count, ref uint shaders)
		{
			fixed (uint* pshaders0 = &shaders)
			{
				GetAttachedShadersNative(program, maxCount, count, pshaders0);
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, Span<int> count, Span<uint> shaders)
		{
			fixed (int* pcount0 = count)
			{
				fixed (uint* pshaders1 = shaders)
				{
					GetAttachedShadersNative(program, maxCount, pcount0, pshaders1);
				}
			}
		}

		/// <summary>
		/// Returns the handles of the shader objects attached to a program object
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetAttachedShaders(uint program, int maxCount, ref int count, ref uint shaders)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (uint* pshaders1 = &shaders)
				{
					GetAttachedShadersNative(program, maxCount, pcount0, pshaders1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAttribLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[277])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[277])(program, (nint)name);
			#endif
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, byte* name)
		{
			int ret = GetAttribLocationNative(program, name);
			return ret;
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetAttribLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, Span<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		/// <summary>
		/// Returns the location of an attribute variable
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static int GetAttribLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleani_vNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[278])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[278])(target, index, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleani_vNative(target, index, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, out byte data)
		{
			byte pparam;
			GetBooleani_vNative(target, index, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, Span<byte> data)
		{
			fixed (byte* pparams = data)
			{
				GetBooleani_vNative(target, index, pparams);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleani_vNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleani_v(GLBufferTargetARB target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanvNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[279])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[279])(pname, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, byte* data)
		{
			GetBooleanvNative(pname, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, out byte data)
		{
			byte pparam;
			GetBooleanvNative(pname, &pparam);
			data = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, Span<byte> data)
		{
			fixed (byte* pparams = data)
			{
				GetBooleanvNative(pname, pparams);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanvNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions: All GL versions.</remarks>
		public static void GetBooleanv(GLGetPName pname, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}
	}
}
