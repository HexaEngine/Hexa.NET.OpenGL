// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL
{
	public static unsafe partial class GL
	{

		public static void GenTransformFeedbacks(int n, uint* ids)
		{
			GenTransformFeedbacksNative(n, ids);
		}

		public static void GenTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[263])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[263])(n, (nint)arrays);
			#endif
		}

		public static void GenVertexArrays(int n, uint* arrays)
		{
			GenVertexArraysNative(n, arrays);
		}

		public static void GenVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				GenVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapNative(GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[264])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[264])(target);
			#endif
		}

		public static void GenerateMipmap(GLTextureTarget target)
		{
			GenerateMipmapNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[265])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[265])(texture);
			#endif
		}

		public static void GenerateTextureMipmap(uint texture)
		{
			GenerateTextureMipmapNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAtomicCounterBufferivNative(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, int*, void>)funcTable[266])(program, bufferIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, nint, void>)funcTable[266])(program, bufferIndex, pname, (nint)@params);
			#endif
		}

		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, @params);
		}

		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAttribNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[267])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[267])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetActiveAttribNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveAttribNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveAttribNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveAttribNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveAttribNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveAttrib(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveAttribNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[268])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[268])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, name);
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[269])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[269])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, name);
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformivNative(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, int*, void>)funcTable[270])(program, shadertype, index, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, nint, void>)funcTable[270])(program, shadertype, index, pname, (nint)values);
			#endif
		}

		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			GetActiveSubroutineUniformivNative(program, shadertype, index, pname, values);
		}

		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetActiveSubroutineUniformivNative(program, shadertype, index, pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNative(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLUniformType, byte*, void>)funcTable[271])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLUniformType, nint, void>)funcTable[271])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, byte* name)
		{
			GetActiveUniformNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveUniformNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, GLUniformType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveUniformNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, int* size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, int* length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveUniform(uint program, uint index, int bufSize, ref int length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveUniformNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockNameNative(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[272])(program, uniformBlockIndex, bufSize, length, uniformBlockName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[272])(program, uniformBlockIndex, bufSize, (nint)length, (nint)uniformBlockName);
			#endif
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, uniformBlockName);
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, byte* uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, uniformBlockName);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ReadOnlySpan<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, ref byte uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformBlockName1 = &uniformBlockName)
				{
					GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, puniformBlockName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockivNative(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, int*, void>)funcTable[273])(program, uniformBlockIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, nint, void>)funcTable[273])(program, uniformBlockIndex, pname, (nint)@params);
			#endif
		}

		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, @params);
		}

		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNameNative(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[274])(program, uniformIndex, bufSize, length, uniformName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[274])(program, uniformIndex, bufSize, (nint)length, (nint)uniformName);
			#endif
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, uniformName);
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, byte* uniformName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, uniformName);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, string uniformName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ReadOnlySpan<byte> uniformName)
		{
			fixed (byte* puniformName0 = uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ref byte uniformName)
		{
			fixed (byte* puniformName0 = &uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, ref byte uniformName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformName1 = &uniformName)
				{
					GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, puniformName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformsivNative(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, GLUniformPName, int*, void>)funcTable[275])(program, uniformCount, uniformIndices, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, GLUniformPName, nint, void>)funcTable[275])(program, uniformCount, (nint)uniformIndices, pname, (nint)@params);
			#endif
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, @params);
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, GLUniformPName pname, int* @params)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, @params);
			}
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, pparams0);
			}
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, GLUniformPName pname, ref int @params)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				fixed (int* pparams1 = &@params)
				{
					GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, pparams1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAttachedShadersNative(uint program, int maxCount, int* count, uint* shaders)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, uint*, void>)funcTable[276])(program, maxCount, count, shaders);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[276])(program, maxCount, (nint)count, (nint)shaders);
			#endif
		}

		public static void GetAttachedShaders(uint program, int maxCount, int* count, uint* shaders)
		{
			GetAttachedShadersNative(program, maxCount, count, shaders);
		}

		public static void GetAttachedShaders(uint program, int maxCount, ref int count, uint* shaders)
		{
			fixed (int* pcount0 = &count)
			{
				GetAttachedShadersNative(program, maxCount, pcount0, shaders);
			}
		}

		public static void GetAttachedShaders(uint program, int maxCount, int* count, ref uint shaders)
		{
			fixed (uint* pshaders0 = &shaders)
			{
				GetAttachedShadersNative(program, maxCount, count, pshaders0);
			}
		}

		public static void GetAttachedShaders(uint program, int maxCount, ref int count, ref uint shaders)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (uint* pshaders1 = &shaders)
				{
					GetAttachedShadersNative(program, maxCount, pcount0, pshaders1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAttribLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[277])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[277])(program, (nint)name);
			#endif
		}

		public static int GetAttribLocation(uint program, byte* name)
		{
			int ret = GetAttribLocationNative(program, name);
			return ret;
		}

		public static int GetAttribLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetAttribLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetAttribLocation(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetAttribLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetAttribLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleani_vNative(GLBufferTargetARB target, uint index, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, byte*, void>)funcTable[278])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, nint, void>)funcTable[278])(target, index, (nint)data);
			#endif
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, byte* data)
		{
			GetBooleani_vNative(target, index, data);
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleani_vNative(target, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		public static void GetBooleani_v(GLBufferTargetARB target, uint index, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleani_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBooleanvNative(GLGetPName pname, byte* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, byte*, void>)funcTable[279])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[279])(pname, (nint)data);
			#endif
		}

		public static void GetBooleanv(GLGetPName pname, byte* data)
		{
			GetBooleanvNative(pname, data);
		}

		public static void GetBooleanv(GLGetPName pname, string data)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (data != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(data);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(data, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetBooleanvNative(pname, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, ReadOnlySpan<byte> data)
		{
			fixed (byte* pdata0 = data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		public static void GetBooleanv(GLGetPName pname, ref byte data)
		{
			fixed (byte* pdata0 = &data)
			{
				GetBooleanvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameteri64vNative(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, long*, void>)funcTable[280])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[280])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, long* @params)
		{
			GetBufferParameteri64vNative(target, pname, @params);
		}

		public static void GetBufferParameteri64v(GLBufferTargetARB target, GLBufferPNameARB pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetBufferParameteri64vNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameterivNative(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, int*, void>)funcTable[281])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[281])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			GetBufferParameterivNative(target, pname, @params);
		}

		public static void GetBufferParameteriv(GLBufferTargetARB target, GLBufferPNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetBufferParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferPointervNative(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, void**, void>)funcTable[282])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, nint, void>)funcTable[282])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferPointerv(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			GetBufferPointervNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferSubDataNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[283])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[283])(target, offset, size, (nint)data);
			#endif
		}

		public static void GetBufferSubData(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			GetBufferSubDataNative(target, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetClipPlaneNative(GLClipPlaneName plane, double* equation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, double*, void>)funcTable[284])(plane, equation);
			#else
			((delegate* unmanaged[Cdecl]<GLClipPlaneName, nint, void>)funcTable[284])(plane, (nint)equation);
			#endif
		}

		public static void GetClipPlane(GLClipPlaneName plane, double* equation)
		{
			GetClipPlaneNative(plane, equation);
		}

		public static void GetClipPlane(GLClipPlaneName plane, ref double equation)
		{
			fixed (double* pequation0 = &equation)
			{
				GetClipPlaneNative(plane, pequation0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTexImageNative(GLTextureTarget target, int level, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, void*, void>)funcTable[285])(target, level, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[285])(target, level, (nint)img);
			#endif
		}

		public static void GetCompressedTexImage(GLTextureTarget target, int level, void* img)
		{
			GetCompressedTexImageNative(target, level, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureImageNative(uint texture, int level, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void*, void>)funcTable[286])(texture, level, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[286])(texture, level, bufSize, (nint)pixels);
			#endif
		}

		public static void GetCompressedTextureImage(uint texture, int level, int bufSize, void* pixels)
		{
			GetCompressedTextureImageNative(texture, level, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void*, void>)funcTable[287])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, nint, void>)funcTable[287])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, (nint)pixels);
			#endif
		}

		public static void GetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			GetCompressedTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetDebugMessageLogNative(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, uint*, GLDebugSeverity, int*, byte*, uint>)funcTable[288])(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, nint, GLDebugSeverity, nint, nint, uint>)funcTable[288])(count, bufSize, sources, types, (nint)ids, severities, (nint)lengths, (nint)messageLog);
			#endif
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			return ret;
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, messageLog);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, messageLog);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, messageLog);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, string messageLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (messageLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(messageLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(messageLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, ReadOnlySpan<byte> messageLog)
		{
			fixed (byte* pmessageLog0 = messageLog)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (byte* pmessageLog0 = &messageLog)
			{
				uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, lengths, pmessageLog1);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, ids, severities, plengths0, pmessageLog1);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLog(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					fixed (byte* pmessageLog2 = &messageLog)
					{
						uint ret = GetDebugMessageLogNative(count, bufSize, sources, types, pids0, severities, plengths1, pmessageLog2);
						return ret;
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublei_vNative(GLGetPName target, uint index, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[289])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[289])(target, index, (nint)data);
			#endif
		}

		public static void GetDoublei_v(GLGetPName target, uint index, double* data)
		{
			GetDoublei_vNative(target, index, data);
		}

		public static void GetDoublei_v(GLGetPName target, uint index, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoublei_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublevNative(GLGetPName pname, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, double*, void>)funcTable[290])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[290])(pname, (nint)data);
			#endif
		}

		public static void GetDoublev(GLGetPName pname, double* data)
		{
			GetDoublevNative(pname, data);
		}

		public static void GetDoublev(GLGetPName pname, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoublevNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetErrorNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[291])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[291])();
			#endif
		}

		public static GLEnum GetError()
		{
			GLEnum ret = GetErrorNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloati_vNative(GLGetPName target, uint index, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[292])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[292])(target, index, (nint)data);
			#endif
		}

		public static void GetFloati_v(GLGetPName target, uint index, float* data)
		{
			GetFloati_vNative(target, index, data);
		}

		public static void GetFloati_v(GLGetPName target, uint index, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloati_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloatvNative(GLGetPName pname, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, float*, void>)funcTable[293])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[293])(pname, (nint)data);
			#endif
		}

		public static void GetFloatv(GLGetPName pname, float* data)
		{
			GetFloatvNative(pname, data);
		}

		public static void GetFloatv(GLGetPName pname, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloatvNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataIndexNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[294])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[294])(program, (nint)name);
			#endif
		}

		public static int GetFragDataIndex(uint program, byte* name)
		{
			int ret = GetFragDataIndexNative(program, name);
			return ret;
		}

		public static int GetFragDataIndex(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetFragDataIndex(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		public static int GetFragDataIndex(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[295])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[295])(program, (nint)name);
			#endif
		}

		public static int GetFragDataLocation(uint program, byte* name)
		{
			int ret = GetFragDataLocationNative(program, name);
			return ret;
		}

		public static int GetFragDataLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetFragDataLocation(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetFragDataLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferAttachmentParameterivNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[296])(target, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[296])(target, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferAttachmentParameterivNative(target, attachment, pname, @params);
		}

		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFramebufferAttachmentParameterivNative(target, attachment, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferParameterivNative(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachmentParameterName, int*, void>)funcTable[297])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachmentParameterName, nint, void>)funcTable[297])(target, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferParameteriv(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferParameterivNative(target, pname, @params);
		}

		public static void GetFramebufferParameteriv(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFramebufferParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetGraphicsResetStatusNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[298])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[298])();
			#endif
		}

		public static GLEnum GetGraphicsResetStatus()
		{
			GLEnum ret = GetGraphicsResetStatusNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64i_vNative(GLGetPName target, uint index, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, long*, void>)funcTable[299])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[299])(target, index, (nint)data);
			#endif
		}

		public static void GetInteger64i_v(GLGetPName target, uint index, long* data)
		{
			GetInteger64i_vNative(target, index, data);
		}

		public static void GetInteger64i_v(GLGetPName target, uint index, ref long data)
		{
			fixed (long* pdata0 = &data)
			{
				GetInteger64i_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64vNative(GLGetPName pname, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, long*, void>)funcTable[300])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[300])(pname, (nint)data);
			#endif
		}

		public static void GetInteger64v(GLGetPName pname, long* data)
		{
			GetInteger64vNative(pname, data);
		}

		public static void GetInteger64v(GLGetPName pname, ref long data)
		{
			fixed (long* pdata0 = &data)
			{
				GetInteger64vNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegeri_vNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[301])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[301])(target, index, (nint)data);
			#endif
		}

		public static void GetIntegeri_v(GLGetPName target, uint index, int* data)
		{
			GetIntegeri_vNative(target, index, data);
		}

		public static void GetIntegeri_v(GLGetPName target, uint index, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegeri_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegervNative(GLGetPName pname, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, int*, void>)funcTable[302])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[302])(pname, (nint)data);
			#endif
		}

		public static void GetIntegerv(GLGetPName pname, int* data)
		{
			GetIntegervNative(pname, data);
		}

		public static void GetIntegerv(GLGetPName pname, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegervNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformati64vNative(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, long*, void>)funcTable[303])(target, internalformat, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, nint, void>)funcTable[303])(target, internalformat, pname, count, (nint)@params);
			#endif
		}

		public static void GetInternalformati64v(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, long* @params)
		{
			GetInternalformati64vNative(target, internalformat, pname, count, @params);
		}

		public static void GetInternalformati64v(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetInternalformati64vNative(target, internalformat, pname, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformativNative(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, int*, void>)funcTable[304])(target, internalformat, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, nint, void>)funcTable[304])(target, internalformat, pname, count, (nint)@params);
			#endif
		}

		public static void GetInternalformativ(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, int* @params)
		{
			GetInternalformativNative(target, internalformat, pname, count, @params);
		}

		public static void GetInternalformativ(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetInternalformativNative(target, internalformat, pname, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightfvNative(GLLightName light, GLLightParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, float*, void>)funcTable[305])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[305])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightfv(GLLightName light, GLLightParameter pname, float* @params)
		{
			GetLightfvNative(light, pname, @params);
		}

		public static void GetLightfv(GLLightName light, GLLightParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetLightfvNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetLightivNative(GLLightName light, GLLightParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, int*, void>)funcTable[306])(light, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLLightName, GLLightParameter, nint, void>)funcTable[306])(light, pname, (nint)@params);
			#endif
		}

		public static void GetLightiv(GLLightName light, GLLightParameter pname, int* @params)
		{
			GetLightivNative(light, pname, @params);
		}

		public static void GetLightiv(GLLightName light, GLLightParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetLightivNative(light, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapdvNative(GLMapTarget target, GLGetMapQuery query, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, double*, void>)funcTable[307])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[307])(target, query, (nint)v);
			#endif
		}

		public static void GetMapdv(GLMapTarget target, GLGetMapQuery query, double* v)
		{
			GetMapdvNative(target, query, v);
		}

		public static void GetMapdv(GLMapTarget target, GLGetMapQuery query, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				GetMapdvNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapfvNative(GLMapTarget target, GLGetMapQuery query, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, float*, void>)funcTable[308])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[308])(target, query, (nint)v);
			#endif
		}

		public static void GetMapfv(GLMapTarget target, GLGetMapQuery query, float* v)
		{
			GetMapfvNative(target, query, v);
		}

		public static void GetMapfv(GLMapTarget target, GLGetMapQuery query, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetMapfvNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMapivNative(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, int*, void>)funcTable[309])(target, query, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLGetMapQuery, nint, void>)funcTable[309])(target, query, (nint)v);
			#endif
		}

		public static void GetMapiv(GLMapTarget target, GLGetMapQuery query, int* v)
		{
			GetMapivNative(target, query, v);
		}

		public static void GetMapiv(GLMapTarget target, GLGetMapQuery query, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				GetMapivNative(target, query, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialfvNative(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, float*, void>)funcTable[310])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[310])(face, pname, (nint)@params);
			#endif
		}

		public static void GetMaterialfv(GLTriangleFace face, GLMaterialParameter pname, float* @params)
		{
			GetMaterialfvNative(face, pname, @params);
		}

		public static void GetMaterialfv(GLTriangleFace face, GLMaterialParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMaterialfvNative(face, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMaterialivNative(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, int*, void>)funcTable[311])(face, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTriangleFace, GLMaterialParameter, nint, void>)funcTable[311])(face, pname, (nint)@params);
			#endif
		}

		public static void GetMaterialiv(GLTriangleFace face, GLMaterialParameter pname, int* @params)
		{
			GetMaterialivNative(face, pname, @params);
		}

		public static void GetMaterialiv(GLTriangleFace face, GLMaterialParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMaterialivNative(face, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultisamplefvNative(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, float*, void>)funcTable[312])(pname, index, val);
			#else
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, nint, void>)funcTable[312])(pname, index, (nint)val);
			#endif
		}

		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			GetMultisamplefvNative(pname, index, val);
		}

		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, ref float val)
		{
			fixed (float* pval0 = &val)
			{
				GetMultisamplefvNative(pname, index, pval0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameteri64vNative(uint buffer, GLBufferPNameARB pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, long*, void>)funcTable[313])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[313])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferParameteri64v(uint buffer, GLBufferPNameARB pname, long* @params)
		{
			GetNamedBufferParameteri64vNative(buffer, pname, @params);
		}

		public static void GetNamedBufferParameteri64v(uint buffer, GLBufferPNameARB pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetNamedBufferParameteri64vNative(buffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameterivNative(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, int*, void>)funcTable[314])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[314])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferParameteriv(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			GetNamedBufferParameterivNative(buffer, pname, @params);
		}

		public static void GetNamedBufferParameteriv(uint buffer, GLBufferPNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedBufferParameterivNative(buffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferPointervNative(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, void**, void>)funcTable[315])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, nint, void>)funcTable[315])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferPointerv(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			GetNamedBufferPointervNative(buffer, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferSubDataNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[316])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[316])(buffer, offset, size, (nint)data);
			#endif
		}

		public static void GetNamedBufferSubData(uint buffer, nint offset, nint size, void* data)
		{
			GetNamedBufferSubDataNative(buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferAttachmentParameterivNative(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[317])(framebuffer, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[317])(framebuffer, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetNamedFramebufferAttachmentParameterivNative(framebuffer, attachment, pname, @params);
		}

		public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedFramebufferAttachmentParameterivNative(framebuffer, attachment, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferParameterivNative(uint framebuffer, GLGetFramebufferParameter pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[318])(framebuffer, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[318])(framebuffer, pname, (nint)param);
			#endif
		}

		public static void GetNamedFramebufferParameteriv(uint framebuffer, GLGetFramebufferParameter pname, int* param)
		{
			GetNamedFramebufferParameterivNative(framebuffer, pname, param);
		}

		public static void GetNamedFramebufferParameteriv(uint framebuffer, GLGetFramebufferParameter pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetNamedFramebufferParameterivNative(framebuffer, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedRenderbufferParameterivNative(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, int*, void>)funcTable[319])(renderbuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, nint, void>)funcTable[319])(renderbuffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedRenderbufferParameteriv(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			GetNamedRenderbufferParameterivNative(renderbuffer, pname, @params);
		}

		public static void GetNamedRenderbufferParameteriv(uint renderbuffer, GLRenderbufferParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedRenderbufferParameterivNative(renderbuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectLabelNative(GLObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLObjectIdentifier, uint, int, int*, byte*, void>)funcTable[320])(identifier, name, bufSize, length, label);
			#else
			((delegate* unmanaged[Cdecl]<GLObjectIdentifier, uint, int, nint, nint, void>)funcTable[320])(identifier, name, bufSize, (nint)length, (nint)label);
			#endif
		}

		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, byte* label)
		{
			GetObjectLabelNative(identifier, name, bufSize, length, label);
		}

		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, ref int length, byte* label)
		{
			fixed (int* plength0 = &length)
			{
				GetObjectLabelNative(identifier, name, bufSize, plength0, label);
			}
		}

		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetObjectLabelNative(identifier, name, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				GetObjectLabelNative(identifier, name, bufSize, length, plabel0);
			}
		}

		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, int* length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				GetObjectLabelNative(identifier, name, bufSize, length, plabel0);
			}
		}

		public static void GetObjectLabel(GLObjectIdentifier identifier, uint name, int bufSize, ref int length, ref byte label)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* plabel1 = &label)
				{
					GetObjectLabelNative(identifier, name, bufSize, plength0, plabel1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectPtrLabelNative(void* ptr, int bufSize, int* length, byte* label)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, int, int*, byte*, void>)funcTable[321])(ptr, bufSize, length, label);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, nint, nint, void>)funcTable[321])((nint)ptr, bufSize, (nint)length, (nint)label);
			#endif
		}

		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, byte* label)
		{
			GetObjectPtrLabelNative(ptr, bufSize, length, label);
		}

		public static void GetObjectPtrLabel(void* ptr, int bufSize, ref int length, byte* label)
		{
			fixed (int* plength0 = &length)
			{
				GetObjectPtrLabelNative(ptr, bufSize, plength0, label);
			}
		}

		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, string label)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (label != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(label);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(label, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetObjectPtrLabelNative(ptr, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, ReadOnlySpan<byte> label)
		{
			fixed (byte* plabel0 = label)
			{
				GetObjectPtrLabelNative(ptr, bufSize, length, plabel0);
			}
		}

		public static void GetObjectPtrLabel(void* ptr, int bufSize, int* length, ref byte label)
		{
			fixed (byte* plabel0 = &label)
			{
				GetObjectPtrLabelNative(ptr, bufSize, length, plabel0);
			}
		}

		public static void GetObjectPtrLabel(void* ptr, int bufSize, ref int length, ref byte label)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* plabel1 = &label)
				{
					GetObjectPtrLabelNative(ptr, bufSize, plength0, plabel1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapfvNative(GLPixelMap map, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, float*, void>)funcTable[322])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[322])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapfv(GLPixelMap map, float* values)
		{
			GetPixelMapfvNative(map, values);
		}

		public static void GetPixelMapfv(GLPixelMap map, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				GetPixelMapfvNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapuivNative(GLPixelMap map, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, uint*, void>)funcTable[323])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[323])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapuiv(GLPixelMap map, uint* values)
		{
			GetPixelMapuivNative(map, values);
		}

		public static void GetPixelMapuiv(GLPixelMap map, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				GetPixelMapuivNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPixelMapusvNative(GLPixelMap map, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, ushort*, void>)funcTable[324])(map, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, nint, void>)funcTable[324])(map, (nint)values);
			#endif
		}

		public static void GetPixelMapusv(GLPixelMap map, ushort* values)
		{
			GetPixelMapusvNative(map, values);
		}

		public static void GetPixelMapusv(GLPixelMap map, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				GetPixelMapusvNative(map, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPointervNative(GLGetPointervPName pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, void**, void>)funcTable[325])(pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPointervPName, nint, void>)funcTable[325])(pname, (nint)@params);
			#endif
		}

		public static void GetPointerv(GLGetPointervPName pname, void** @params)
		{
			GetPointervNative(pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetPolygonStippleNative(byte* mask)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<byte*, void>)funcTable[326])(mask);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[326])((nint)mask);
			#endif
		}

		public static void GetPolygonStipple(byte* mask)
		{
			GetPolygonStippleNative(mask);
		}

		public static void GetPolygonStipple(string mask)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (mask != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(mask);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(mask, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetPolygonStippleNative(pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetPolygonStipple(ReadOnlySpan<byte> mask)
		{
			fixed (byte* pmask0 = mask)
			{
				GetPolygonStippleNative(pmask0);
			}
		}

		public static void GetPolygonStipple(ref byte mask)
		{
			fixed (byte* pmask0 = &mask)
			{
				GetPolygonStippleNative(pmask0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramBinaryNative(uint program, int bufSize, int* length, GLEnum* binaryFormat, void* binary)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, GLEnum*, void*, void>)funcTable[327])(program, bufSize, length, binaryFormat, binary);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, nint, void>)funcTable[327])(program, bufSize, (nint)length, (nint)binaryFormat, (nint)binary);
			#endif
		}

		public static void GetProgramBinary(uint program, int bufSize, int* length, GLEnum* binaryFormat, void* binary)
		{
			GetProgramBinaryNative(program, bufSize, length, binaryFormat, binary);
		}

		public static void GetProgramBinary(uint program, int bufSize, ref int length, GLEnum* binaryFormat, void* binary)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramBinaryNative(program, bufSize, plength0, binaryFormat, binary);
			}
		}

		public static void GetProgramBinary(uint program, int bufSize, int* length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (GLEnum* pbinaryFormat0 = &binaryFormat)
			{
				GetProgramBinaryNative(program, bufSize, length, pbinaryFormat0, binary);
			}
		}

		public static void GetProgramBinary(uint program, int bufSize, ref int length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (int* plength0 = &length)
			{
				fixed (GLEnum* pbinaryFormat1 = &binaryFormat)
				{
					GetProgramBinaryNative(program, bufSize, plength0, pbinaryFormat1, binary);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInfoLogNative(uint program, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[328])(program, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[328])(program, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, byte* infoLog)
		{
			GetProgramInfoLogNative(program, bufSize, length, infoLog);
		}

		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramInfoLogNative(program, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramInfoLogNative(program, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramInfoLogNative(program, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramInfoLog(uint program, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramInfoLogNative(program, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInterfaceivNative(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, int*, void>)funcTable[329])(program, programInterface, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, nint, void>)funcTable[329])(program, programInterface, pname, (nint)@params);
			#endif
		}

		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			GetProgramInterfaceivNative(program, programInterface, pname, @params);
		}

		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramInterfaceivNative(program, programInterface, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineInfoLogNative(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[330])(pipeline, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[330])(pipeline, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, infoLog);
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineivNative(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, int*, void>)funcTable[331])(pipeline, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, nint, void>)funcTable[331])(pipeline, pname, (nint)@params);
			#endif
		}

		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			GetProgramPipelineivNative(pipeline, pname, @params);
		}

		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramPipelineivNative(pipeline, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetProgramResourceIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, uint>)funcTable[332])(program, programInterface, name);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, uint>)funcTable[332])(program, programInterface, (nint)name);
			#endif
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			uint ret = GetProgramResourceIndexNative(program, programInterface, name);
			return ret;
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetProgramResourceIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[333])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[333])(program, programInterface, (nint)name);
			#endif
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationNative(program, programInterface, name);
			return ret;
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[334])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[334])(program, programInterface, (nint)name);
			#endif
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, name);
			return ret;
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourceNameNative(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, int*, byte*, void>)funcTable[335])(program, programInterface, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, nint, nint, void>)funcTable[335])(program, programInterface, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, name);
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, name);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pname0);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pname0);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourceivNative(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLProgramResourceProperty, int, int*, int*, void>)funcTable[336])(program, programInterface, index, propCount, props, count, length, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLProgramResourceProperty, int, nint, nint, void>)funcTable[336])(program, programInterface, index, propCount, props, count, (nint)length, (nint)@params);
			#endif
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, int* @params)
		{
			GetProgramResourceivNative(program, programInterface, index, propCount, props, count, length, @params);
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, ref int length, int* @params)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourceivNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramResourceivNative(program, programInterface, index, propCount, props, count, length, pparams0);
			}
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, ref int length, ref int @params)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* pparams1 = &@params)
				{
					GetProgramResourceivNative(program, programInterface, index, propCount, props, count, plength0, pparams1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramStageivNative(uint program, GLShaderType shadertype, GLProgramStagePName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, GLProgramStagePName, int*, void>)funcTable[337])(program, shadertype, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, GLProgramStagePName, nint, void>)funcTable[337])(program, shadertype, pname, (nint)values);
			#endif
		}

		public static void GetProgramStageiv(uint program, GLShaderType shadertype, GLProgramStagePName pname, int* values)
		{
			GetProgramStageivNative(program, shadertype, pname, values);
		}

		public static void GetProgramStageiv(uint program, GLShaderType shadertype, GLProgramStagePName pname, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetProgramStageivNative(program, shadertype, pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramivNative(uint program, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, int*, void>)funcTable[338])(program, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramPropertyARB, nint, void>)funcTable[338])(program, pname, (nint)@params);
			#endif
		}

		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, int* @params)
		{
			GetProgramivNative(program, pname, @params);
		}

		public static void GetProgramiv(uint program, GLProgramPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramivNative(program, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjecti64vNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[339])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[339])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjecti64v(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjecti64vNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectivNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[340])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[340])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjectiv(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectivNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectui64vNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[341])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[341])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjectui64v(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectui64vNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectuivNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[342])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[342])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjectuiv(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectuivNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryIndexedivNative(GLQueryTarget target, uint index, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, GLQueryParameterName, int*, void>)funcTable[343])(target, index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, GLQueryParameterName, nint, void>)funcTable[343])(target, index, pname, (nint)@params);
			#endif
		}

		public static void GetQueryIndexediv(GLQueryTarget target, uint index, GLQueryParameterName pname, int* @params)
		{
			GetQueryIndexedivNative(target, index, pname, @params);
		}

		public static void GetQueryIndexediv(GLQueryTarget target, uint index, GLQueryParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryIndexedivNative(target, index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjecti64vNative(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, long*, void>)funcTable[344])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[344])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			GetQueryObjecti64vNative(id, pname, @params);
		}

		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetQueryObjecti64vNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectivNative(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, int*, void>)funcTable[345])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[345])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			GetQueryObjectivNative(id, pname, @params);
		}

		public static void GetQueryObjectiv(uint id, GLQueryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryObjectivNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectui64vNative(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, ulong*, void>)funcTable[346])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[346])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			GetQueryObjectui64vNative(id, pname, @params);
		}

		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetQueryObjectui64vNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectuivNative(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, uint*, void>)funcTable[347])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[347])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			GetQueryObjectuivNative(id, pname, @params);
		}

		public static void GetQueryObjectuiv(uint id, GLQueryObjectParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetQueryObjectuivNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryivNative(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, int*, void>)funcTable[348])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, nint, void>)funcTable[348])(target, pname, (nint)@params);
			#endif
		}

		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			GetQueryivNative(target, pname, @params);
		}

		public static void GetQueryiv(GLQueryTarget target, GLQueryParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRenderbufferParameterivNative(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, int*, void>)funcTable[349])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, nint, void>)funcTable[349])(target, pname, (nint)@params);
			#endif
		}

		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			GetRenderbufferParameterivNative(target, pname, @params);
		}

		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetRenderbufferParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[350])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[350])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterIivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetSamplerParameterIivNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIuivNative(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[351])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[351])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			GetSamplerParameterIuivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetSamplerParameterIuivNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterfvNative(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float*, void>)funcTable[352])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, nint, void>)funcTable[352])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			GetSamplerParameterfvNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetSamplerParameterfvNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[353])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[353])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetSamplerParameterivNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderInfoLogNative(uint shader, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[354])(shader, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[354])(shader, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, byte* infoLog)
		{
			GetShaderInfoLogNative(shader, bufSize, length, infoLog);
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderInfoLogNative(shader, bufSize, plength0, infoLog);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderInfoLogNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetShaderInfoLogNative(shader, bufSize, length, pinfoLog0);
			}
		}

		public static void GetShaderInfoLog(uint shader, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetShaderInfoLogNative(shader, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderPrecisionFormatNative(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, int*, int*, void>)funcTable[355])(shadertype, precisiontype, range, precision);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, nint, nint, void>)funcTable[355])(shadertype, precisiontype, (nint)range, (nint)precision);
			#endif
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			GetShaderPrecisionFormatNative(shadertype, precisiontype, range, precision);
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, int* precision)
		{
			fixed (int* prange0 = &range)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, precision);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, ref int precision)
		{
			fixed (int* pprecision0 = &precision)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, range, pprecision0);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, ref int precision)
		{
			fixed (int* prange0 = &range)
			{
				fixed (int* pprecision1 = &precision)
				{
					GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, pprecision1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderSourceNative(uint shader, int bufSize, int* length, byte* source)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[356])(shader, bufSize, length, source);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[356])(shader, bufSize, (nint)length, (nint)source);
			#endif
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, byte* source)
		{
			GetShaderSourceNative(shader, bufSize, length, source);
		}

		public static void GetShaderSource(uint shader, int bufSize, ref int length, byte* source)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderSourceNative(shader, bufSize, plength0, source);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderSourceNative(shader, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, ReadOnlySpan<byte> source)
		{
			fixed (byte* psource0 = source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, int* length, ref byte source)
		{
			fixed (byte* psource0 = &source)
			{
				GetShaderSourceNative(shader, bufSize, length, psource0);
			}
		}

		public static void GetShaderSource(uint shader, int bufSize, ref int length, ref byte source)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* psource1 = &source)
				{
					GetShaderSourceNative(shader, bufSize, plength0, psource1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderivNative(uint shader, GLShaderParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, int*, void>)funcTable[357])(shader, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderParameterName, nint, void>)funcTable[357])(shader, pname, (nint)@params);
			#endif
		}

		public static void GetShaderiv(uint shader, GLShaderParameterName pname, int* @params)
		{
			GetShaderivNative(shader, pname, @params);
		}

		public static void GetShaderiv(uint shader, GLShaderParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetShaderivNative(shader, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringNative(GLStringName name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLStringName, byte*>)funcTable[358])(name);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GLStringName, nint>)funcTable[358])(name);
			#endif
		}

		public static byte* GetString(GLStringName name)
		{
			byte* ret = GetStringNative(name);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte* GetStringiNative(GLStringName name, uint index)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLStringName, uint, byte*>)funcTable[359])(name, index);
			#else
			return (byte*)((delegate* unmanaged[Cdecl]<GLStringName, uint, nint>)funcTable[359])(name, index);
			#endif
		}

		public static byte* GetStringi(GLStringName name, uint index)
		{
			byte* ret = GetStringiNative(name, index);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSubroutineIndexNative(uint program, GLShaderType shadertype, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLShaderType, byte*, uint>)funcTable[360])(program, shadertype, name);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, GLShaderType, nint, uint>)funcTable[360])(program, shadertype, (nint)name);
			#endif
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, byte* name)
		{
			uint ret = GetSubroutineIndexNative(program, shadertype, name);
			return ret;
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetSubroutineIndexNative(program, shadertype, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				uint ret = GetSubroutineIndexNative(program, shadertype, pname0);
				return ret;
			}
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				uint ret = GetSubroutineIndexNative(program, shadertype, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSubroutineUniformLocationNative(uint program, GLShaderType shadertype, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLShaderType, byte*, int>)funcTable[361])(program, shadertype, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLShaderType, nint, int>)funcTable[361])(program, shadertype, (nint)name);
			#endif
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, byte* name)
		{
			int ret = GetSubroutineUniformLocationNative(program, shadertype, name);
			return ret;
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetSubroutineUniformLocationNative(program, shadertype, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetSubroutineUniformLocationNative(program, shadertype, pname0);
				return ret;
			}
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetSubroutineUniformLocationNative(program, shadertype, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSyncivNative(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, int*, int*, void>)funcTable[362])(sync, pname, count, length, values);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, nint, nint, void>)funcTable[362])(sync, pname, count, (nint)length, (nint)values);
			#endif
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			GetSyncivNative(sync, pname, count, length, values);
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, int* values)
		{
			fixed (int* plength0 = &length)
			{
				GetSyncivNative(sync, pname, count, plength0, values);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetSyncivNative(sync, pname, count, length, pvalues0);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, ref int values)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* pvalues1 = &values)
				{
					GetSyncivNative(sync, pname, count, plength0, pvalues1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvfvNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, float*, void>)funcTable[363])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[363])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, float* @params)
		{
			GetTexEnvfvNative(target, pname, @params);
		}

		public static void GetTexEnvfv(GLTextureEnvTarget target, GLTextureEnvParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexEnvfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexEnvivNative(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, int*, void>)funcTable[364])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureEnvTarget, GLTextureEnvParameter, nint, void>)funcTable[364])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, int* @params)
		{
			GetTexEnvivNative(target, pname, @params);
		}

		public static void GetTexEnviv(GLTextureEnvTarget target, GLTextureEnvParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexEnvivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGendvNative(GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, double*, void>)funcTable[365])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[365])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGendv(GLTextureCoordName coord, GLTextureGenParameter pname, double* @params)
		{
			GetTexGendvNative(coord, pname, @params);
		}

		public static void GetTexGendv(GLTextureCoordName coord, GLTextureGenParameter pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetTexGendvNative(coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGenfvNative(GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, float*, void>)funcTable[366])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[366])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGenfv(GLTextureCoordName coord, GLTextureGenParameter pname, float* @params)
		{
			GetTexGenfvNative(coord, pname, @params);
		}

		public static void GetTexGenfv(GLTextureCoordName coord, GLTextureGenParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexGenfvNative(coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexGenivNative(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, int*, void>)funcTable[367])(coord, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureCoordName, GLTextureGenParameter, nint, void>)funcTable[367])(coord, pname, (nint)@params);
			#endif
		}

		public static void GetTexGeniv(GLTextureCoordName coord, GLTextureGenParameter pname, int* @params)
		{
			GetTexGenivNative(coord, pname, @params);
		}

		public static void GetTexGeniv(GLTextureCoordName coord, GLTextureGenParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexGenivNative(coord, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexImageNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[368])(target, level, format, type, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[368])(target, level, format, type, (nint)pixels);
			#endif
		}

		public static void GetTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, void* pixels)
		{
			GetTexImageNative(target, level, format, type, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterfvNative(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, float*, void>)funcTable[369])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[369])(target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTexLevelParameterfvNative(target, level, pname, @params);
		}

		public static void GetTexLevelParameterfv(GLTextureTarget target, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexLevelParameterfvNative(target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexLevelParameterivNative(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, int*, void>)funcTable[370])(target, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLGetTextureParameter, nint, void>)funcTable[370])(target, level, pname, (nint)@params);
			#endif
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTexLevelParameterivNative(target, level, pname, @params);
		}

		public static void GetTexLevelParameteriv(GLTextureTarget target, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexLevelParameterivNative(target, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[371])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[371])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterIivNative(target, pname, @params);
		}

		public static void GetTexParameterIiv(GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexParameterIivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterIuivNative(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, uint*, void>)funcTable[372])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[372])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, uint* @params)
		{
			GetTexParameterIuivNative(target, pname, @params);
		}

		public static void GetTexParameterIuiv(GLTextureTarget target, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetTexParameterIuivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterfvNative(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, float*, void>)funcTable[373])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[373])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, float* @params)
		{
			GetTexParameterfvNative(target, pname, @params);
		}

		public static void GetTexParameterfv(GLTextureTarget target, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTexParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTexParameterivNative(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, int*, void>)funcTable[374])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLGetTextureParameter, nint, void>)funcTable[374])(target, pname, (nint)@params);
			#endif
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, int* @params)
		{
			GetTexParameterivNative(target, pname, @params);
		}

		public static void GetTexParameteriv(GLTextureTarget target, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTexParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureImageNative(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[375])(texture, level, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[375])(texture, level, format, type, bufSize, (nint)pixels);
			#endif
		}

		public static void GetTextureImage(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetTextureImageNative(texture, level, format, type, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterfvNative(uint texture, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, float*, void>)funcTable[376])(texture, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, nint, void>)funcTable[376])(texture, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameterfv(uint texture, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTextureLevelParameterfvNative(texture, level, pname, @params);
		}

		public static void GetTextureLevelParameterfv(uint texture, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureLevelParameterfvNative(texture, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterivNative(uint texture, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, int*, void>)funcTable[377])(texture, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, nint, void>)funcTable[377])(texture, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameteriv(uint texture, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTextureLevelParameterivNative(texture, level, pname, @params);
		}

		public static void GetTextureLevelParameteriv(uint texture, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureLevelParameterivNative(texture, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIivNative(uint texture, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, int*, void>)funcTable[378])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[378])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIiv(uint texture, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterIivNative(texture, pname, @params);
		}

		public static void GetTextureParameterIiv(uint texture, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterIivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIuivNative(uint texture, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, uint*, void>)funcTable[379])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[379])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIuiv(uint texture, GLGetTextureParameter pname, uint* @params)
		{
			GetTextureParameterIuivNative(texture, pname, @params);
		}

		public static void GetTextureParameterIuiv(uint texture, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetTextureParameterIuivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterfvNative(uint texture, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, float*, void>)funcTable[380])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[380])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterfv(uint texture, GLGetTextureParameter pname, float* @params)
		{
			GetTextureParameterfvNative(texture, pname, @params);
		}

		public static void GetTextureParameterfv(uint texture, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureParameterfvNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterivNative(uint texture, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, int*, void>)funcTable[381])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[381])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameteriv(uint texture, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterivNative(texture, pname, @params);
		}

		public static void GetTextureParameteriv(uint texture, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[382])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[382])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, (nint)pixels);
			#endif
		}

		public static void GetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackVaryingNative(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[383])(program, index, bufSize, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[383])(program, index, bufSize, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, name);
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, name);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, name);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, name);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetTransformFeedbackVaryingNative(program, index, bufSize, length, size, type, pname0);
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, size, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetTransformFeedbackVaryingNative(program, index, bufSize, length, psize0, type, pname1);
				}
			}
		}

		public static void GetTransformFeedbackVarying(uint program, uint index, int bufSize, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetTransformFeedbackVaryingNative(program, index, bufSize, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbacki64_vNative(uint xfb, GLTransformFeedbackPName pname, uint index, long* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, long*, void>)funcTable[384])(xfb, pname, index, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, nint, void>)funcTable[384])(xfb, pname, index, (nint)param);
			#endif
		}

		public static void GetTransformFeedbacki64_v(uint xfb, GLTransformFeedbackPName pname, uint index, long* param)
		{
			GetTransformFeedbacki64_vNative(xfb, pname, index, param);
		}

		public static void GetTransformFeedbacki64_v(uint xfb, GLTransformFeedbackPName pname, uint index, ref long param)
		{
			fixed (long* pparam0 = &param)
			{
				GetTransformFeedbacki64_vNative(xfb, pname, index, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbacki_vNative(uint xfb, GLTransformFeedbackPName pname, uint index, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, int*, void>)funcTable[385])(xfb, pname, index, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, nint, void>)funcTable[385])(xfb, pname, index, (nint)param);
			#endif
		}

		public static void GetTransformFeedbacki_v(uint xfb, GLTransformFeedbackPName pname, uint index, int* param)
		{
			GetTransformFeedbacki_vNative(xfb, pname, index, param);
		}

		public static void GetTransformFeedbacki_v(uint xfb, GLTransformFeedbackPName pname, uint index, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetTransformFeedbacki_vNative(xfb, pname, index, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackivNative(uint xfb, GLTransformFeedbackPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, int*, void>)funcTable[386])(xfb, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, nint, void>)funcTable[386])(xfb, pname, (nint)param);
			#endif
		}

		public static void GetTransformFeedbackiv(uint xfb, GLTransformFeedbackPName pname, int* param)
		{
			GetTransformFeedbackivNative(xfb, pname, param);
		}

		public static void GetTransformFeedbackiv(uint xfb, GLTransformFeedbackPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetTransformFeedbackivNative(xfb, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUniformBlockIndexNative(uint program, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, uint>)funcTable[387])(program, uniformBlockName);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint>)funcTable[387])(program, (nint)uniformBlockName);
			#endif
		}

		public static uint GetUniformBlockIndex(uint program, byte* uniformBlockName)
		{
			uint ret = GetUniformBlockIndexNative(program, uniformBlockName);
			return ret;
		}

		public static uint GetUniformBlockIndex(uint program, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetUniformBlockIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetUniformBlockIndex(uint program, ReadOnlySpan<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		public static uint GetUniformBlockIndex(uint program, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformIndicesNative(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, uint*, void>)funcTable[388])(program, uniformCount, uniformNames, uniformIndices);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[388])(program, uniformCount, (nint)uniformNames, (nint)uniformIndices);
			#endif
		}

		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			GetUniformIndicesNative(program, uniformCount, uniformNames, uniformIndices);
		}

		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUniformLocationNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[389])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[389])(program, (nint)name);
			#endif
		}

		public static int GetUniformLocation(uint program, byte* name)
		{
			int ret = GetUniformLocationNative(program, name);
			return ret;
		}

		public static int GetUniformLocation(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetUniformLocationNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetUniformLocation(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		public static int GetUniformLocation(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetUniformLocationNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformSubroutineuivNative(GLShaderType shadertype, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, int, uint*, void>)funcTable[390])(shadertype, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, void>)funcTable[390])(shadertype, location, (nint)@params);
			#endif
		}

		public static void GetUniformSubroutineuiv(GLShaderType shadertype, int location, uint* @params)
		{
			GetUniformSubroutineuivNative(shadertype, location, @params);
		}

		public static void GetUniformSubroutineuiv(GLShaderType shadertype, int location, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetUniformSubroutineuivNative(shadertype, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformdvNative(uint program, int location, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[391])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[391])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformdv(uint program, int location, double* @params)
		{
			GetUniformdvNative(program, location, @params);
		}

		public static void GetUniformdv(uint program, int location, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetUniformdvNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformfvNative(uint program, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[392])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[392])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformfv(uint program, int location, float* @params)
		{
			GetUniformfvNative(program, location, @params);
		}

		public static void GetUniformfv(uint program, int location, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetUniformfvNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformivNative(uint program, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[393])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[393])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformiv(uint program, int location, int* @params)
		{
			GetUniformivNative(program, location, @params);
		}

		public static void GetUniformiv(uint program, int location, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetUniformivNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformuivNative(uint program, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[394])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[394])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformuiv(uint program, int location, uint* @params)
		{
			GetUniformuivNative(program, location, @params);
		}

		public static void GetUniformuiv(uint program, int location, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetUniformuivNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIndexed64ivNative(uint vaobj, uint index, GLVertexArrayPName pname, long* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, long*, void>)funcTable[395])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[395])(vaobj, index, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayIndexed64iv(uint vaobj, uint index, GLVertexArrayPName pname, long* param)
		{
			GetVertexArrayIndexed64ivNative(vaobj, index, pname, param);
		}

		public static void GetVertexArrayIndexed64iv(uint vaobj, uint index, GLVertexArrayPName pname, ref long param)
		{
			fixed (long* pparam0 = &param)
			{
				GetVertexArrayIndexed64ivNative(vaobj, index, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIndexedivNative(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, int*, void>)funcTable[396])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[396])(vaobj, index, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayIndexediv(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIndexedivNative(vaobj, index, pname, param);
		}

		public static void GetVertexArrayIndexediv(uint vaobj, uint index, GLVertexArrayPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetVertexArrayIndexedivNative(vaobj, index, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayivNative(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, int*, void>)funcTable[397])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[397])(vaobj, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayiv(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayivNative(vaobj, pname, param);
		}

		public static void GetVertexArrayiv(uint vaobj, GLVertexArrayPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetVertexArrayivNative(vaobj, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIivNative(uint index, GLVertexAttribEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, int*, void>)funcTable[398])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[398])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, int* @params)
		{
			GetVertexAttribIivNative(index, pname, @params);
		}

		public static void GetVertexAttribIiv(uint index, GLVertexAttribEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVertexAttribIivNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribIuivNative(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, uint*, void>)funcTable[399])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[399])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, uint* @params)
		{
			GetVertexAttribIuivNative(index, pname, @params);
		}

		public static void GetVertexAttribIuiv(uint index, GLVertexAttribEnum pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetVertexAttribIuivNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribLdvNative(uint index, GLVertexAttribEnum pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, double*, void>)funcTable[400])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[400])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribLdv(uint index, GLVertexAttribEnum pname, double* @params)
		{
			GetVertexAttribLdvNative(index, pname, @params);
		}

		public static void GetVertexAttribLdv(uint index, GLVertexAttribEnum pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribLdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[401])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[401])(index, pname, (nint)pointer);
			#endif
		}

		public static void GetVertexAttribPointerv(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[402])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[402])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvNative(index, pname, @params);
		}

		public static void GetVertexAttribdv(uint index, GLVertexAttribPropertyARB pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[403])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[403])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvNative(index, pname, @params);
		}

		public static void GetVertexAttribfv(uint index, GLVertexAttribPropertyARB pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetVertexAttribfvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[404])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[404])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivNative(index, pname, @params);
		}

		public static void GetVertexAttribiv(uint index, GLVertexAttribPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVertexAttribivNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnColorTableNative(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[405])(target, format, type, bufSize, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[405])(target, format, type, bufSize, (nint)table);
			#endif
		}

		public static void GetnColorTable(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* table)
		{
			GetnColorTableNative(target, format, type, bufSize, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnCompressedTexImageNative(GLTextureTarget target, int lod, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, void*, void>)funcTable[406])(target, lod, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, nint, void>)funcTable[406])(target, lod, bufSize, (nint)pixels);
			#endif
		}

		public static void GetnCompressedTexImage(GLTextureTarget target, int lod, int bufSize, void* pixels)
		{
			GetnCompressedTexImageNative(target, lod, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnConvolutionFilterNative(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[407])(target, format, type, bufSize, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[407])(target, format, type, bufSize, (nint)image);
			#endif
		}

		public static void GetnConvolutionFilter(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* image)
		{
			GetnConvolutionFilterNative(target, format, type, bufSize, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnHistogramNative(GLHistogramTarget target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTarget, byte, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[408])(target, reset, format, type, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTarget, byte, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[408])(target, reset, format, type, bufSize, (nint)values);
			#endif
		}

		public static void GetnHistogram(GLHistogramTarget target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			GetnHistogramNative(target, reset, format, type, bufSize, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapdvNative(GLMapTarget target, GLMapQuery query, int bufSize, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, double*, void>)funcTable[409])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[409])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapdv(GLMapTarget target, GLMapQuery query, int bufSize, double* v)
		{
			GetnMapdvNative(target, query, bufSize, v);
		}

		public static void GetnMapdv(GLMapTarget target, GLMapQuery query, int bufSize, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				GetnMapdvNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapfvNative(GLMapTarget target, GLMapQuery query, int bufSize, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, float*, void>)funcTable[410])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[410])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapfv(GLMapTarget target, GLMapQuery query, int bufSize, float* v)
		{
			GetnMapfvNative(target, query, bufSize, v);
		}

		public static void GetnMapfv(GLMapTarget target, GLMapQuery query, int bufSize, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetnMapfvNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapivNative(GLMapTarget target, GLMapQuery query, int bufSize, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, int*, void>)funcTable[411])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[411])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapiv(GLMapTarget target, GLMapQuery query, int bufSize, int* v)
		{
			GetnMapivNative(target, query, bufSize, v);
		}

		public static void GetnMapiv(GLMapTarget target, GLMapQuery query, int bufSize, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				GetnMapivNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMinmaxNative(GLMinmaxTarget target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTarget, byte, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[412])(target, reset, format, type, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTarget, byte, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[412])(target, reset, format, type, bufSize, (nint)values);
			#endif
		}

		public static void GetnMinmax(GLMinmaxTarget target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			GetnMinmaxNative(target, reset, format, type, bufSize, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapfvNative(GLPixelMap map, int bufSize, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, float*, void>)funcTable[413])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[413])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapfv(GLPixelMap map, int bufSize, float* values)
		{
			GetnPixelMapfvNative(map, bufSize, values);
		}

		public static void GetnPixelMapfv(GLPixelMap map, int bufSize, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				GetnPixelMapfvNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapuivNative(GLPixelMap map, int bufSize, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, uint*, void>)funcTable[414])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[414])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapuiv(GLPixelMap map, int bufSize, uint* values)
		{
			GetnPixelMapuivNative(map, bufSize, values);
		}

		public static void GetnPixelMapuiv(GLPixelMap map, int bufSize, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				GetnPixelMapuivNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapusvNative(GLPixelMap map, int bufSize, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, ushort*, void>)funcTable[415])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[415])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapusv(GLPixelMap map, int bufSize, ushort* values)
		{
			GetnPixelMapusvNative(map, bufSize, values);
		}

		public static void GetnPixelMapusv(GLPixelMap map, int bufSize, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				GetnPixelMapusvNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPolygonStippleNative(int bufSize, byte* pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[416])(bufSize, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[416])(bufSize, (nint)pattern);
			#endif
		}

		public static void GetnPolygonStipple(int bufSize, byte* pattern)
		{
			GetnPolygonStippleNative(bufSize, pattern);
		}

		public static void GetnPolygonStipple(int bufSize, string pattern)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetnPolygonStippleNative(bufSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetnPolygonStipple(int bufSize, ReadOnlySpan<byte> pattern)
		{
			fixed (byte* ppattern0 = pattern)
			{
				GetnPolygonStippleNative(bufSize, ppattern0);
			}
		}

		public static void GetnPolygonStipple(int bufSize, ref byte pattern)
		{
			fixed (byte* ppattern0 = &pattern)
			{
				GetnPolygonStippleNative(bufSize, ppattern0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnSeparableFilterNative(GLSeparableTarget target, GLPixelFormat format, GLPixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTarget, GLPixelFormat, GLPixelType, int, void*, int, void*, void*, void>)funcTable[417])(target, format, type, rowBufSize, row, columnBufSize, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTarget, GLPixelFormat, GLPixelType, int, nint, int, nint, nint, void>)funcTable[417])(target, format, type, rowBufSize, (nint)row, columnBufSize, (nint)column, (nint)span);
			#endif
		}

		public static void GetnSeparableFilter(GLSeparableTarget target, GLPixelFormat format, GLPixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
		{
			GetnSeparableFilterNative(target, format, type, rowBufSize, row, columnBufSize, column, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnTexImageNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[418])(target, level, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[418])(target, level, format, type, bufSize, (nint)pixels);
			#endif
		}

		public static void GetnTexImage(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetnTexImageNative(target, level, format, type, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformdvNative(uint program, int location, int bufSize, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[419])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[419])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformdv(uint program, int location, int bufSize, double* @params)
		{
			GetnUniformdvNative(program, location, bufSize, @params);
		}

		public static void GetnUniformdv(uint program, int location, int bufSize, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetnUniformdvNative(program, location, bufSize, pparams0);
			}
		}
	}
}
