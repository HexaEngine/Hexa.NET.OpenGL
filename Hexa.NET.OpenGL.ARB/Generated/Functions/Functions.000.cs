// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.ARB
{
	public static unsafe partial class GLArb
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveShaderProgramNative(uint pipeline, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[0])(pipeline, program);
			#endif
		}

		public static void ActiveShaderProgram(uint pipeline, uint program)
		{
			ActiveShaderProgramNative(pipeline, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ActiveTextureARBNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[1])(texture);
			#endif
		}

		public static void ActiveTextureARB(GLTextureUnit texture)
		{
			ActiveTextureARBNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void AttachObjectARBNative(uint containerObj, uint obj)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[2])(containerObj, obj);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[2])(containerObj, obj);
			#endif
		}

		public static void AttachObjectARB(uint containerObj, uint obj)
		{
			AttachObjectARBNative(containerObj, obj);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryARBNative(GLQueryTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[3])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[3])(target, id);
			#endif
		}

		public static void BeginQueryARB(GLQueryTarget target, uint id)
		{
			BeginQueryARBNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BeginQueryIndexedNative(GLQueryTarget target, uint index, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[4])(target, index, id);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, uint, void>)funcTable[4])(target, index, id);
			#endif
		}

		public static void BeginQueryIndexed(GLQueryTarget target, uint index, uint id)
		{
			BeginQueryIndexedNative(target, index, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindAttribLocationARBNative(uint programObj, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, byte*, void>)funcTable[5])(programObj, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, void>)funcTable[5])(programObj, index, (nint)name);
			#endif
		}

		public static void BindAttribLocationARB(uint programObj, uint index, byte* name)
		{
			BindAttribLocationARBNative(programObj, index, name);
		}

		public static void BindAttribLocationARB(uint programObj, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindAttribLocationARBNative(programObj, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindAttribLocationARB(uint programObj, uint index, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindAttribLocationARBNative(programObj, index, pname0);
			}
		}

		public static void BindAttribLocationARB(uint programObj, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindAttribLocationARBNative(programObj, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferARBNative(GLBufferTargetARB target, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[6])(target, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, void>)funcTable[6])(target, buffer);
			#endif
		}

		public static void BindBufferARB(GLBufferTargetARB target, uint buffer)
		{
			BindBufferARBNative(target, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferBaseNative(GLBufferTargetARB target, uint index, uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[7])(target, index, buffer);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, void>)funcTable[7])(target, index, buffer);
			#endif
		}

		public static void BindBufferBase(GLBufferTargetARB target, uint index, uint buffer)
		{
			BindBufferBaseNative(target, index, buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBufferRangeNative(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[8])(target, index, buffer, offset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, uint, nint, nint, void>)funcTable[8])(target, index, buffer, offset, size);
			#endif
		}

		public static void BindBufferRange(GLBufferTargetARB target, uint index, uint buffer, nint offset, nint size)
		{
			BindBufferRangeNative(target, index, buffer, offset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBuffersBaseNative(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, void>)funcTable[9])(target, first, count, buffers);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, void>)funcTable[9])(target, first, count, (nint)buffers);
			#endif
		}

		public static void BindBuffersBase(GLBufferTargetARB target, uint first, int count, uint* buffers)
		{
			BindBuffersBaseNative(target, first, count, buffers);
		}

		public static void BindBuffersBase(GLBufferTargetARB target, uint first, int count, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersBaseNative(target, first, count, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindBuffersRangeNative(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, uint*, nint*, nint*, void>)funcTable[10])(target, first, count, buffers, offsets, sizes);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, uint, int, nint, nint, nint, void>)funcTable[10])(target, first, count, (nint)buffers, (nint)offsets, (nint)sizes);
			#endif
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, nint* sizes)
		{
			BindBuffersRangeNative(target, first, count, buffers, offsets, sizes);
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindBuffersRangeNative(target, first, count, pbuffers0, offsets, sizes);
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, nint* sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindBuffersRangeNative(target, first, count, buffers, poffsets0, sizes);
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, nint* sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, sizes);
				}
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, nint* offsets, ref nint sizes)
		{
			fixed (nint* psizes0 = &sizes)
			{
				BindBuffersRangeNative(target, first, count, buffers, offsets, psizes0);
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, nint* offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, pbuffers0, offsets, psizes1);
				}
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, uint* buffers, ref nint offsets, ref nint sizes)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (nint* psizes1 = &sizes)
				{
					BindBuffersRangeNative(target, first, count, buffers, poffsets0, psizes1);
				}
			}
		}

		public static void BindBuffersRange(GLBufferTargetARB target, uint first, int count, ref uint buffers, ref nint offsets, ref nint sizes)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (nint* psizes2 = &sizes)
					{
						BindBuffersRangeNative(target, first, count, pbuffers0, poffsets1, psizes2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFragDataLocationIndexedNative(uint program, uint colorNumber, uint index, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, byte*, void>)funcTable[11])(program, colorNumber, index, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, nint, void>)funcTable[11])(program, colorNumber, index, (nint)name);
			#endif
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, byte* name)
		{
			BindFragDataLocationIndexedNative(program, colorNumber, index, name);
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			BindFragDataLocationIndexedNative(program, colorNumber, index, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		public static void BindFragDataLocationIndexed(uint program, uint colorNumber, uint index, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				BindFragDataLocationIndexedNative(program, colorNumber, index, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindFramebufferNative(GLFramebufferTarget target, uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[12])(target, framebuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, void>)funcTable[12])(target, framebuffer);
			#endif
		}

		public static void BindFramebuffer(GLFramebufferTarget target, uint framebuffer)
		{
			BindFramebufferNative(target, framebuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindImageTextureNative(uint unit, uint texture, int level, byte layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[13])(unit, texture, level, layered, layer, access, format);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, byte, int, GLBufferAccessARB, GLInternalFormat, void>)funcTable[13])(unit, texture, level, layered, layer, access, format);
			#endif
		}

		public static void BindImageTexture(uint unit, uint texture, int level, byte layered, int layer, GLBufferAccessARB access, GLInternalFormat format)
		{
			BindImageTextureNative(unit, texture, level, layered, layer, access, format);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindImageTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[14])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[14])(first, count, (nint)textures);
			#endif
		}

		public static void BindImageTextures(uint first, int count, uint* textures)
		{
			BindImageTexturesNative(first, count, textures);
		}

		public static void BindImageTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindImageTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindProgramARBNative(GLProgramTarget target, uint program)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, void>)funcTable[15])(target, program);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, void>)funcTable[15])(target, program);
			#endif
		}

		public static void BindProgramARB(GLProgramTarget target, uint program)
		{
			BindProgramARBNative(target, program);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[16])(pipeline);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[16])(pipeline);
			#endif
		}

		public static void BindProgramPipeline(uint pipeline)
		{
			BindProgramPipelineNative(pipeline);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindRenderbufferNative(GLRenderbufferTarget target, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[17])(target, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, uint, void>)funcTable[17])(target, renderbuffer);
			#endif
		}

		public static void BindRenderbuffer(GLRenderbufferTarget target, uint renderbuffer)
		{
			BindRenderbufferNative(target, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindSamplerNative(uint unit, uint sampler)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[18])(unit, sampler);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[18])(unit, sampler);
			#endif
		}

		public static void BindSampler(uint unit, uint sampler)
		{
			BindSamplerNative(unit, sampler);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindSamplersNative(uint first, int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[19])(first, count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[19])(first, count, (nint)samplers);
			#endif
		}

		public static void BindSamplers(uint first, int count, uint* samplers)
		{
			BindSamplersNative(first, count, samplers);
		}

		public static void BindSamplers(uint first, int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				BindSamplersNative(first, count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTextureUnitNative(uint unit, uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[20])(unit, texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[20])(unit, texture);
			#endif
		}

		public static void BindTextureUnit(uint unit, uint texture)
		{
			BindTextureUnitNative(unit, texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTexturesNative(uint first, int count, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, void>)funcTable[21])(first, count, textures);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[21])(first, count, (nint)textures);
			#endif
		}

		public static void BindTextures(uint first, int count, uint* textures)
		{
			BindTexturesNative(first, count, textures);
		}

		public static void BindTextures(uint first, int count, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				BindTexturesNative(first, count, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindTransformFeedbackNative(GLBindTransformFeedbackTarget target, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[22])(target, id);
			#else
			((delegate* unmanaged[Cdecl]<GLBindTransformFeedbackTarget, uint, void>)funcTable[22])(target, id);
			#endif
		}

		public static void BindTransformFeedback(GLBindTransformFeedbackTarget target, uint id)
		{
			BindTransformFeedbackNative(target, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[23])(array);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[23])(array);
			#endif
		}

		public static void BindVertexArray(uint array)
		{
			BindVertexArrayNative(array);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexBufferNative(uint bindingindex, uint buffer, nint offset, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[24])(bindingindex, buffer, offset, stride);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, int, void>)funcTable[24])(bindingindex, buffer, offset, stride);
			#endif
		}

		public static void BindVertexBuffer(uint bindingindex, uint buffer, nint offset, int stride)
		{
			BindVertexBufferNative(bindingindex, buffer, offset, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BindVertexBuffersNative(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, nint*, int*, void>)funcTable[25])(first, count, buffers, offsets, strides);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, nint, void>)funcTable[25])(first, count, (nint)buffers, (nint)offsets, (nint)strides);
			#endif
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, int* strides)
		{
			BindVertexBuffersNative(first, count, buffers, offsets, strides);
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				BindVertexBuffersNative(first, count, pbuffers0, offsets, strides);
			}
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, int* strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				BindVertexBuffersNative(first, count, buffers, poffsets0, strides);
			}
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, int* strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					BindVertexBuffersNative(first, count, pbuffers0, poffsets1, strides);
				}
			}
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, nint* offsets, ref int strides)
		{
			fixed (int* pstrides0 = &strides)
			{
				BindVertexBuffersNative(first, count, buffers, offsets, pstrides0);
			}
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, nint* offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, pbuffers0, offsets, pstrides1);
				}
			}
		}

		public static void BindVertexBuffers(uint first, int count, uint* buffers, ref nint offsets, ref int strides)
		{
			fixed (nint* poffsets0 = &offsets)
			{
				fixed (int* pstrides1 = &strides)
				{
					BindVertexBuffersNative(first, count, buffers, poffsets0, pstrides1);
				}
			}
		}

		public static void BindVertexBuffers(uint first, int count, ref uint buffers, ref nint offsets, ref int strides)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				fixed (nint* poffsets1 = &offsets)
				{
					fixed (int* pstrides2 = &strides)
					{
						BindVertexBuffersNative(first, count, pbuffers0, poffsets1, pstrides2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[26])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[26])(red, green, blue, alpha);
			#endif
		}

		public static void BlendColor(float red, float green, float blue, float alpha)
		{
			BlendColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[27])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[27])(mode);
			#endif
		}

		public static void BlendEquation(GLBlendEquationModeEXT mode)
		{
			BlendEquationNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationSeparateiARBNative(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[28])(buf, modeRGB, modeAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, GLBlendEquationModeEXT, void>)funcTable[28])(buf, modeRGB, modeAlpha);
			#endif
		}

		public static void BlendEquationSeparateiARB(uint buf, GLBlendEquationModeEXT modeRGB, GLBlendEquationModeEXT modeAlpha)
		{
			BlendEquationSeparateiARBNative(buf, modeRGB, modeAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationiARBNative(uint buf, GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[29])(buf, mode);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendEquationModeEXT, void>)funcTable[29])(buf, mode);
			#endif
		}

		public static void BlendEquationiARB(uint buf, GLBlendEquationModeEXT mode)
		{
			BlendEquationiARBNative(buf, mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFuncSeparateiARBNative(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[30])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, GLBlendingFactor, void>)funcTable[30])(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
			#endif
		}

		public static void BlendFuncSeparateiARB(uint buf, GLBlendingFactor srcRGB, GLBlendingFactor dstRGB, GLBlendingFactor srcAlpha, GLBlendingFactor dstAlpha)
		{
			BlendFuncSeparateiARBNative(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendFunciARBNative(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[31])(buf, src, dst);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBlendingFactor, GLBlendingFactor, void>)funcTable[31])(buf, src, dst);
			#endif
		}

		public static void BlendFunciARB(uint buf, GLBlendingFactor src, GLBlendingFactor dst)
		{
			BlendFunciARBNative(buf, src, dst);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitFramebufferNative(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[32])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[32])(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitFramebufferNative(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlitNamedFramebufferNative(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[33])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, int, int, int, int, int, int, int, GLClearBufferMask, GLBlitFramebufferFilter, void>)funcTable[33])(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
			#endif
		}

		public static void BlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, GLClearBufferMask mask, GLBlitFramebufferFilter filter)
		{
			BlitNamedFramebufferNative(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferDataARBNative(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, void*, GLBufferUsageARB, void>)funcTable[34])(target, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLBufferUsageARB, void>)funcTable[34])(target, size, (nint)data, usage);
			#endif
		}

		public static void BufferDataARB(GLBufferTargetARB target, nint size, void* data, GLBufferUsageARB usage)
		{
			BufferDataARBNative(target, size, data, usage);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferPageCommitmentARBNative(GLEnum target, nint offset, nint size, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, byte, void>)funcTable[35])(target, offset, size, commit);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, nint, nint, byte, void>)funcTable[35])(target, offset, size, commit);
			#endif
		}

		public static void BufferPageCommitmentARB(GLEnum target, nint offset, nint size, byte commit)
		{
			BufferPageCommitmentARBNative(target, offset, size, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferStorageNative(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, void*, GLBufferStorageMask, void>)funcTable[36])(target, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, nint, nint, GLBufferStorageMask, void>)funcTable[36])(target, size, (nint)data, flags);
			#endif
		}

		public static void BufferStorage(GLBufferStorageTarget target, nint size, void* data, GLBufferStorageMask flags)
		{
			BufferStorageNative(target, size, data, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BufferSubDataARBNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[37])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[37])(target, offset, size, (nint)data);
			#endif
		}

		public static void BufferSubDataARB(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			BufferSubDataARBNative(target, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckFramebufferStatusNative(GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[38])(target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLEnum>)funcTable[38])(target);
			#endif
		}

		public static GLEnum CheckFramebufferStatus(GLFramebufferTarget target)
		{
			GLEnum ret = CheckFramebufferStatusNative(target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum CheckNamedFramebufferStatusNative(uint framebuffer, GLFramebufferTarget target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[39])(framebuffer, target);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<uint, GLFramebufferTarget, GLEnum>)funcTable[39])(framebuffer, target);
			#endif
		}

		public static GLEnum CheckNamedFramebufferStatus(uint framebuffer, GLFramebufferTarget target)
		{
			GLEnum ret = CheckNamedFramebufferStatusNative(framebuffer, target);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClampColorARBNative(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[40])(target, clamp);
			#else
			((delegate* unmanaged[Cdecl]<GLClampColorTargetARB, GLClampColorModeARB, void>)funcTable[40])(target, clamp);
			#endif
		}

		public static void ClampColorARB(GLClampColorTargetARB target, GLClampColorModeARB clamp)
		{
			ClampColorARBNative(target, clamp);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferDataNative(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[41])(target, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferStorageTarget, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[41])(target, internalformat, format, type, (nint)data);
			#endif
		}

		public static void ClearBufferData(GLBufferStorageTarget target, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferDataNative(target, internalformat, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearBufferSubDataNative(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[42])(target, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[42])(target, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		public static void ClearBufferSubData(GLBufferTargetARB target, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearBufferSubDataNative(target, internalformat, offset, size, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthfNative(float d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[43])(d);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[43])(d);
			#endif
		}

		public static void ClearDepthf(float d)
		{
			ClearDepthfNative(d);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferDataNative(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, void*, void>)funcTable[44])(buffer, internalformat, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, GLPixelFormat, GLPixelType, nint, void>)funcTable[44])(buffer, internalformat, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferData(uint buffer, GLSizedInternalFormat internalformat, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferDataNative(buffer, internalformat, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedBufferSubDataNative(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, void*, void>)funcTable[45])(buffer, internalformat, offset, size, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSizedInternalFormat, nint, nint, GLPixelFormat, GLPixelType, nint, void>)funcTable[45])(buffer, internalformat, offset, size, format, type, (nint)data);
			#endif
		}

		public static void ClearNamedBufferSubData(uint buffer, GLSizedInternalFormat internalformat, nint offset, nint size, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearNamedBufferSubDataNative(buffer, internalformat, offset, size, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferfiNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[46])(framebuffer, buffer, drawbuffer, depth, stencil);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float, int, void>)funcTable[46])(framebuffer, buffer, drawbuffer, depth, stencil);
			#endif
		}

		public static void ClearNamedFramebufferfi(uint framebuffer, GLBuffer buffer, int drawbuffer, float depth, int stencil)
		{
			ClearNamedFramebufferfiNative(framebuffer, buffer, drawbuffer, depth, stencil);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferfvNative(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, float*, void>)funcTable[47])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[47])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, float* value)
		{
			ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, value);
		}

		public static void ClearNamedFramebufferfv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref float value)
		{
			fixed (float* pvalue0 = &value)
			{
				ClearNamedFramebufferfvNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, int*, void>)funcTable[48])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[48])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, int* value)
		{
			ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, value);
		}

		public static void ClearNamedFramebufferiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref int value)
		{
			fixed (int* pvalue0 = &value)
			{
				ClearNamedFramebufferivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearNamedFramebufferuivNative(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, uint*, void>)funcTable[49])(framebuffer, buffer, drawbuffer, value);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBuffer, int, nint, void>)funcTable[49])(framebuffer, buffer, drawbuffer, (nint)value);
			#endif
		}

		public static void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, uint* value)
		{
			ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, value);
		}

		public static void ClearNamedFramebufferuiv(uint framebuffer, GLBuffer buffer, int drawbuffer, ref uint value)
		{
			fixed (uint* pvalue0 = &value)
			{
				ClearNamedFramebufferuivNative(framebuffer, buffer, drawbuffer, pvalue0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexImageNative(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[50])(texture, level, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[50])(texture, level, format, type, (nint)data);
			#endif
		}

		public static void ClearTexImage(uint texture, int level, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexImageNative(texture, level, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearTexSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[51])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[51])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (nint)data);
			#endif
		}

		public static void ClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, void* data)
		{
			ClearTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClientActiveTextureARBNative(GLTextureUnit texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[52])(texture);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, void>)funcTable[52])(texture);
			#endif
		}

		public static void ClientActiveTextureARB(GLTextureUnit texture)
		{
			ClientActiveTextureARBNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum ClientWaitSyncNative(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[53])(sync, flags, timeout);
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLSync, GLSyncObjectMask, ulong, GLEnum>)funcTable[53])(sync, flags, timeout);
			#endif
		}

		public static GLEnum ClientWaitSync(GLSync sync, GLSyncObjectMask flags, ulong timeout)
		{
			GLEnum ret = ClientWaitSyncNative(sync, flags, timeout);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClipControlNative(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[54])(origin, depth);
			#else
			((delegate* unmanaged[Cdecl]<GLClipControlOrigin, GLClipControlDepth, void>)funcTable[54])(origin, depth);
			#endif
		}

		public static void ClipControl(GLClipControlOrigin origin, GLClipControlDepth depth)
		{
			ClipControlNative(origin, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorP3uiNative(GLColorPointerType type, uint color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorPointerType, uint, void>)funcTable[55])(type, color);
			#else
			((delegate* unmanaged[Cdecl]<GLColorPointerType, uint, void>)funcTable[55])(type, color);
			#endif
		}

		public static void ColorP3ui(GLColorPointerType type, uint color)
		{
			ColorP3uiNative(type, color);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorP3uivNative(GLColorPointerType type, uint* color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorPointerType, uint*, void>)funcTable[56])(type, color);
			#else
			((delegate* unmanaged[Cdecl]<GLColorPointerType, nint, void>)funcTable[56])(type, (nint)color);
			#endif
		}

		public static void ColorP3uiv(GLColorPointerType type, uint* color)
		{
			ColorP3uivNative(type, color);
		}

		public static void ColorP3uiv(GLColorPointerType type, ref uint color)
		{
			fixed (uint* pcolor0 = &color)
			{
				ColorP3uivNative(type, pcolor0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorP4uiNative(GLColorPointerType type, uint color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorPointerType, uint, void>)funcTable[57])(type, color);
			#else
			((delegate* unmanaged[Cdecl]<GLColorPointerType, uint, void>)funcTable[57])(type, color);
			#endif
		}

		public static void ColorP4ui(GLColorPointerType type, uint color)
		{
			ColorP4uiNative(type, color);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorP4uivNative(GLColorPointerType type, uint* color)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorPointerType, uint*, void>)funcTable[58])(type, color);
			#else
			((delegate* unmanaged[Cdecl]<GLColorPointerType, nint, void>)funcTable[58])(type, (nint)color);
			#endif
		}

		public static void ColorP4uiv(GLColorPointerType type, uint* color)
		{
			ColorP4uivNative(type, color);
		}

		public static void ColorP4uiv(GLColorPointerType type, ref uint color)
		{
			fixed (uint* pcolor0 = &color)
			{
				ColorP4uivNative(type, pcolor0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorSubTableNative(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[59])(target, start, count, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[59])(target, start, count, format, type, (nint)data);
			#endif
		}

		public static void ColorSubTable(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			ColorSubTableNative(target, start, count, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableNative(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[60])(target, internalformat, width, format, type, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[60])(target, internalformat, width, format, type, (nint)table);
			#endif
		}

		public static void ColorTable(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			ColorTableNative(target, internalformat, width, format, type, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableParameterfvNative(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, float*, void>)funcTable[61])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[61])(target, pname, (nint)@params);
			#endif
		}

		public static void ColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			ColorTableParameterfvNative(target, pname, @params);
		}

		public static void ColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ColorTableParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableParameterivNative(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, int*, void>)funcTable[62])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[62])(target, pname, (nint)@params);
			#endif
		}

		public static void ColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			ColorTableParameterivNative(target, pname, @params);
		}

		public static void ColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ColorTableParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileShaderARBNative(uint shaderObj)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[63])(shaderObj);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[63])(shaderObj);
			#endif
		}

		public static void CompileShaderARB(uint shaderObj)
		{
			CompileShaderARBNative(shaderObj);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompileShaderIncludeARBNative(uint shader, int count, byte** path, int* length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, int*, void>)funcTable[64])(shader, count, path, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[64])(shader, count, (nint)path, (nint)length);
			#endif
		}

		public static void CompileShaderIncludeARB(uint shader, int count, byte** path, int* length)
		{
			CompileShaderIncludeARBNative(shader, count, path, length);
		}

		public static void CompileShaderIncludeARB(uint shader, int count, byte** path, ref int length)
		{
			fixed (int* plength0 = &length)
			{
				CompileShaderIncludeARBNative(shader, count, path, plength0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage1DARBNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, void*, void>)funcTable[65])(target, level, internalformat, width, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, nint, void>)funcTable[65])(target, level, internalformat, width, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage1DARB(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int border, int imageSize, void* data)
		{
			CompressedTexImage1DARBNative(target, level, internalformat, width, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage2DARBNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, void*, void>)funcTable[66])(target, level, internalformat, width, height, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, nint, void>)funcTable[66])(target, level, internalformat, width, height, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage2DARB(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int border, int imageSize, void* data)
		{
			CompressedTexImage2DARBNative(target, level, internalformat, width, height, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexImage3DARBNative(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, void*, void>)funcTable[67])(target, level, internalformat, width, height, depth, border, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLInternalFormat, int, int, int, int, int, nint, void>)funcTable[67])(target, level, internalformat, width, height, depth, border, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexImage3DARB(GLTextureTarget target, int level, GLInternalFormat internalformat, int width, int height, int depth, int border, int imageSize, void* data)
		{
			CompressedTexImage3DARBNative(target, level, internalformat, width, height, depth, border, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage1DARBNative(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, void*, void>)funcTable[68])(target, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, GLInternalFormat, int, nint, void>)funcTable[68])(target, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage1DARB(GLTextureTarget target, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage1DARBNative(target, level, xoffset, width, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage2DARBNative(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[69])(target, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[69])(target, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage2DARB(GLTextureTarget target, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage2DARBNative(target, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTexSubImage3DARBNative(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[70])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[70])(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTexSubImage3DARB(GLTextureTarget target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTexSubImage3DARBNative(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage1DNative(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, void*, void>)funcTable[71])(texture, level, xoffset, width, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, GLInternalFormat, int, nint, void>)funcTable[71])(texture, level, xoffset, width, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage1DNative(texture, level, xoffset, width, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[72])(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[72])(texture, level, xoffset, yoffset, width, height, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage2DNative(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CompressedTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, void*, void>)funcTable[73])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLInternalFormat, int, nint, void>)funcTable[73])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (nint)data);
			#endif
		}

		public static void CompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLInternalFormat format, int imageSize, void* data)
		{
			CompressedTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter1DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[74])(target, internalformat, width, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[74])(target, internalformat, width, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter1D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter1DNative(target, internalformat, width, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter2DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[75])(target, internalformat, width, height, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[75])(target, internalformat, width, height, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter2D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter2DNative(target, internalformat, width, height, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfNative(GLConvolutionTarget target, GLConvolutionParameter pname, float @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float, void>)funcTable[76])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float, void>)funcTable[76])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameterf(GLConvolutionTarget target, GLConvolutionParameter pname, float @params)
		{
			ConvolutionParameterfNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfvNative(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float*, void>)funcTable[77])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[77])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			ConvolutionParameterfvNative(target, pname, @params);
		}

		public static void ConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ConvolutionParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameteriNative(GLConvolutionTarget target, GLConvolutionParameter pname, int @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int, void>)funcTable[78])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int, void>)funcTable[78])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameteri(GLConvolutionTarget target, GLConvolutionParameter pname, int @params)
		{
			ConvolutionParameteriNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterivNative(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int*, void>)funcTable[79])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[79])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			ConvolutionParameterivNative(target, pname, @params);
		}

		public static void ConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ConvolutionParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyBufferSubDataNative(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[80])(readTarget, writeTarget, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<GLCopyBufferSubDataTarget, GLCopyBufferSubDataTarget, nint, nint, nint, void>)funcTable[80])(readTarget, writeTarget, readOffset, writeOffset, size);
			#endif
		}

		public static void CopyBufferSubData(GLCopyBufferSubDataTarget readTarget, GLCopyBufferSubDataTarget writeTarget, nint readOffset, nint writeOffset, nint size)
		{
			CopyBufferSubDataNative(readTarget, writeTarget, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyColorSubTableNative(GLColorTableTarget target, int start, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[81])(target, start, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[81])(target, start, x, y, width);
			#endif
		}

		public static void CopyColorSubTable(GLColorTableTarget target, int start, int x, int y, int width)
		{
			CopyColorSubTableNative(target, start, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyColorTableNative(GLColorTableTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, int, int, void>)funcTable[82])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, int, int, void>)funcTable[82])(target, internalformat, x, y, width);
			#endif
		}

		public static void CopyColorTable(GLColorTableTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyColorTableNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter1DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, void>)funcTable[83])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, void>)funcTable[83])(target, internalformat, x, y, width);
			#endif
		}

		public static void CopyConvolutionFilter1D(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyConvolutionFilter1DNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter2DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, int, void>)funcTable[84])(target, internalformat, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, int, void>)funcTable[84])(target, internalformat, x, y, width, height);
			#endif
		}

		public static void CopyConvolutionFilter2D(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			CopyConvolutionFilter2DNative(target, internalformat, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyImageSubDataNative(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[85])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLCopyImageSubDataTarget, int, int, int, int, uint, GLCopyImageSubDataTarget, int, int, int, int, int, int, int, void>)funcTable[85])(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
			#endif
		}

		public static void CopyImageSubData(uint srcName, GLCopyImageSubDataTarget srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, GLCopyImageSubDataTarget dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth)
		{
			CopyImageSubDataNative(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyNamedBufferSubDataNative(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[86])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, nint, nint, nint, void>)funcTable[86])(readBuffer, writeBuffer, readOffset, writeOffset, size);
			#endif
		}

		public static void CopyNamedBufferSubData(uint readBuffer, uint writeBuffer, nint readOffset, nint writeOffset, nint size)
		{
			CopyNamedBufferSubDataNative(readBuffer, writeBuffer, readOffset, writeOffset, size);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage1DNative(uint texture, int level, int xoffset, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[87])(texture, level, xoffset, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, void>)funcTable[87])(texture, level, xoffset, x, y, width);
			#endif
		}

		public static void CopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width)
		{
			CopyTextureSubImage1DNative(texture, level, xoffset, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage2DNative(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[88])(texture, level, xoffset, yoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[88])(texture, level, xoffset, yoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage2DNative(texture, level, xoffset, yoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyTextureSubImage3DNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[89])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void>)funcTable[89])(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
			#endif
		}

		public static void CopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height)
		{
			CopyTextureSubImage3DNative(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateBuffersNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[90])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[90])(n, (nint)buffers);
			#endif
		}

		public static void CreateBuffers(int n, uint* buffers)
		{
			CreateBuffersNative(n, buffers);
		}

		public static void CreateBuffers(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				CreateBuffersNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[91])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[91])(n, (nint)framebuffers);
			#endif
		}

		public static void CreateFramebuffers(int n, uint* framebuffers)
		{
			CreateFramebuffersNative(n, framebuffers);
		}

		public static void CreateFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				CreateFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateProgramObjectARBNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint>)funcTable[92])();
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint>)funcTable[92])();
			#endif
		}

		public static uint CreateProgramObjectARB()
		{
			uint ret = CreateProgramObjectARBNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[93])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[93])(n, (nint)pipelines);
			#endif
		}

		public static void CreateProgramPipelines(int n, uint* pipelines)
		{
			CreateProgramPipelinesNative(n, pipelines);
		}

		public static void CreateProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				CreateProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateQueriesNative(GLQueryTarget target, int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, uint*, void>)funcTable[94])(target, n, ids);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, int, nint, void>)funcTable[94])(target, n, (nint)ids);
			#endif
		}

		public static void CreateQueries(GLQueryTarget target, int n, uint* ids)
		{
			CreateQueriesNative(target, n, ids);
		}

		public static void CreateQueries(GLQueryTarget target, int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateQueriesNative(target, n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[95])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[95])(n, (nint)renderbuffers);
			#endif
		}

		public static void CreateRenderbuffers(int n, uint* renderbuffers)
		{
			CreateRenderbuffersNative(n, renderbuffers);
		}

		public static void CreateRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				CreateRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateSamplersNative(int n, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[96])(n, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[96])(n, (nint)samplers);
			#endif
		}

		public static void CreateSamplers(int n, uint* samplers)
		{
			CreateSamplersNative(n, samplers);
		}

		public static void CreateSamplers(int n, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				CreateSamplersNative(n, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderObjectARBNative(GLShaderType shaderType)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[97])(shaderType);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, uint>)funcTable[97])(shaderType);
			#endif
		}

		public static uint CreateShaderObjectARB(GLShaderType shaderType)
		{
			uint ret = CreateShaderObjectARBNative(shaderType);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint CreateShaderProgramvNative(GLShaderType type, int count, byte** strings)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLShaderType, int, byte**, uint>)funcTable[98])(type, count, strings);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, uint>)funcTable[98])(type, count, (nint)strings);
			#endif
		}

		public static uint CreateShaderProgramv(GLShaderType type, int count, byte** strings)
		{
			uint ret = CreateShaderProgramvNative(type, count, strings);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLSync CreateSyncFromCLeventARBNative(ClContext* context, ClEvent* evnt, uint flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ClContext*, ClEvent*, uint, GLSync>)funcTable[99])(context, evnt, flags);
			#else
			return (GLSync)((delegate* unmanaged[Cdecl]<nint, nint, uint, GLSync>)funcTable[99])((nint)context, (nint)evnt, flags);
			#endif
		}

		public static GLSync CreateSyncFromCLeventARB(ClContext* context, ClEvent* evnt, uint flags)
		{
			GLSync ret = CreateSyncFromCLeventARBNative(context, evnt, flags);
			return ret;
		}

		public static GLSync CreateSyncFromCLeventARB(ref ClContext context, ClEvent* evnt, uint flags)
		{
			fixed (ClContext* pcontext0 = &context)
			{
				GLSync ret = CreateSyncFromCLeventARBNative(pcontext0, evnt, flags);
				return ret;
			}
		}

		public static GLSync CreateSyncFromCLeventARB(ClContext* context, ref ClEvent evnt, uint flags)
		{
			fixed (ClEvent* pevnt0 = &evnt)
			{
				GLSync ret = CreateSyncFromCLeventARBNative(context, pevnt0, flags);
				return ret;
			}
		}

		public static GLSync CreateSyncFromCLeventARB(ref ClContext context, ref ClEvent evnt, uint flags)
		{
			fixed (ClContext* pcontext0 = &context)
			{
				fixed (ClEvent* pevnt1 = &evnt)
				{
					GLSync ret = CreateSyncFromCLeventARBNative(pcontext0, pevnt1, flags);
					return ret;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateTexturesNative(GLTextureTarget target, int n, uint* textures)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, uint*, void>)funcTable[100])(target, n, textures);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[100])(target, n, (nint)textures);
			#endif
		}

		public static void CreateTextures(GLTextureTarget target, int n, uint* textures)
		{
			CreateTexturesNative(target, n, textures);
		}

		public static void CreateTextures(GLTextureTarget target, int n, ref uint textures)
		{
			fixed (uint* ptextures0 = &textures)
			{
				CreateTexturesNative(target, n, ptextures0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[101])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[101])(n, (nint)ids);
			#endif
		}

		public static void CreateTransformFeedbacks(int n, uint* ids)
		{
			CreateTransformFeedbacksNative(n, ids);
		}

		public static void CreateTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				CreateTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CreateVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[102])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[102])(n, (nint)arrays);
			#endif
		}

		public static void CreateVertexArrays(int n, uint* arrays)
		{
			CreateVertexArraysNative(n, arrays);
		}

		public static void CreateVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				CreateVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CurrentPaletteMatrixARBNative(int index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[103])(index);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)funcTable[103])(index);
			#endif
		}

		public static void CurrentPaletteMatrixARB(int index)
		{
			CurrentPaletteMatrixARBNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageCallbackARBNative(GLDebugProcARB callback, void* userParam)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void*, void*, void>)funcTable[104])((void*)Utils.GetFunctionPointerForDelegate(callback), userParam);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)funcTable[104])(Utils.GetFunctionPointerForDelegate(callback), (nint)userParam);
			#endif
		}

		public static void DebugMessageCallbackARB(GLDebugProcARB callback, void* userParam)
		{
			DebugMessageCallbackARBNative(callback, userParam);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageControlARBNative(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, byte enabled)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, uint*, byte, void>)funcTable[105])(source, type, severity, count, ids, enabled);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, GLDebugSeverity, int, nint, byte, void>)funcTable[105])(source, type, severity, count, (nint)ids, enabled);
			#endif
		}

		public static void DebugMessageControlARB(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, uint* ids, byte enabled)
		{
			DebugMessageControlARBNative(source, type, severity, count, ids, enabled);
		}

		public static void DebugMessageControlARB(GLDebugSource source, GLDebugType type, GLDebugSeverity severity, int count, ref uint ids, byte enabled)
		{
			fixed (uint* pids0 = &ids)
			{
				DebugMessageControlARBNative(source, type, severity, count, pids0, enabled);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DebugMessageInsertARBNative(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, byte*, void>)funcTable[106])(source, type, id, severity, length, buf);
			#else
			((delegate* unmanaged[Cdecl]<GLDebugSource, GLDebugType, uint, GLDebugSeverity, int, nint, void>)funcTable[106])(source, type, id, severity, length, (nint)buf);
			#endif
		}

		public static void DebugMessageInsertARB(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, byte* buf)
		{
			DebugMessageInsertARBNative(source, type, id, severity, length, buf);
		}

		public static void DebugMessageInsertARB(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, string buf)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (buf != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(buf);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(buf, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DebugMessageInsertARBNative(source, type, id, severity, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DebugMessageInsertARB(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, ReadOnlySpan<byte> buf)
		{
			fixed (byte* pbuf0 = buf)
			{
				DebugMessageInsertARBNative(source, type, id, severity, length, pbuf0);
			}
		}

		public static void DebugMessageInsertARB(GLDebugSource source, GLDebugType type, uint id, GLDebugSeverity severity, int length, ref byte buf)
		{
			fixed (byte* pbuf0 = &buf)
			{
				DebugMessageInsertARBNative(source, type, id, severity, length, pbuf0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteBuffersARBNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[107])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[107])(n, (nint)buffers);
			#endif
		}

		public static void DeleteBuffersARB(int n, uint* buffers)
		{
			DeleteBuffersARBNative(n, buffers);
		}

		public static void DeleteBuffersARB(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				DeleteBuffersARBNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[108])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[108])(n, (nint)framebuffers);
			#endif
		}

		public static void DeleteFramebuffers(int n, uint* framebuffers)
		{
			DeleteFramebuffersNative(n, framebuffers);
		}

		public static void DeleteFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				DeleteFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteNamedStringARBNative(int namelen, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[109])(namelen, name);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[109])(namelen, (nint)name);
			#endif
		}

		public static void DeleteNamedStringARB(int namelen, byte* name)
		{
			DeleteNamedStringARBNative(namelen, name);
		}

		public static void DeleteNamedStringARB(int namelen, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			DeleteNamedStringARBNative(namelen, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void DeleteNamedStringARB(int namelen, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				DeleteNamedStringARBNative(namelen, pname0);
			}
		}

		public static void DeleteNamedStringARB(int namelen, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				DeleteNamedStringARBNative(namelen, pname0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteObjectARBNative(uint obj)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[110])(obj);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[110])(obj);
			#endif
		}

		public static void DeleteObjectARB(uint obj)
		{
			DeleteObjectARBNative(obj);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[111])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[111])(n, (nint)pipelines);
			#endif
		}

		public static void DeleteProgramPipelines(int n, uint* pipelines)
		{
			DeleteProgramPipelinesNative(n, pipelines);
		}

		public static void DeleteProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				DeleteProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteProgramsARBNative(int n, uint* programs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[112])(n, programs);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[112])(n, (nint)programs);
			#endif
		}

		public static void DeleteProgramsARB(int n, uint* programs)
		{
			DeleteProgramsARBNative(n, programs);
		}

		public static void DeleteProgramsARB(int n, ref uint programs)
		{
			fixed (uint* pprograms0 = &programs)
			{
				DeleteProgramsARBNative(n, pprograms0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteQueriesARBNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[113])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[113])(n, (nint)ids);
			#endif
		}

		public static void DeleteQueriesARB(int n, uint* ids)
		{
			DeleteQueriesARBNative(n, ids);
		}

		public static void DeleteQueriesARB(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteQueriesARBNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[114])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[114])(n, (nint)renderbuffers);
			#endif
		}

		public static void DeleteRenderbuffers(int n, uint* renderbuffers)
		{
			DeleteRenderbuffersNative(n, renderbuffers);
		}

		public static void DeleteRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				DeleteRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[115])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[115])(count, (nint)samplers);
			#endif
		}

		public static void DeleteSamplers(int count, uint* samplers)
		{
			DeleteSamplersNative(count, samplers);
		}

		public static void DeleteSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				DeleteSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[116])(sync);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, void>)funcTable[116])(sync);
			#endif
		}

		public static void DeleteSync(GLSync sync)
		{
			DeleteSyncNative(sync);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[117])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[117])(n, (nint)ids);
			#endif
		}

		public static void DeleteTransformFeedbacks(int n, uint* ids)
		{
			DeleteTransformFeedbacksNative(n, ids);
		}

		public static void DeleteTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				DeleteTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DeleteVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[118])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[118])(n, (nint)arrays);
			#endif
		}

		public static void DeleteVertexArrays(int n, uint* arrays)
		{
			DeleteVertexArraysNative(n, arrays);
		}

		public static void DeleteVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				DeleteVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeArraydvNVNative(uint first, int count, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[119])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[119])(first, count, (nint)v);
			#endif
		}

		public static void DepthRangeArraydvNV(uint first, int count, double* v)
		{
			DepthRangeArraydvNVNative(first, count, v);
		}

		public static void DepthRangeArraydvNV(uint first, int count, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				DepthRangeArraydvNVNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeArrayvNative(uint first, int count, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[120])(first, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[120])(first, count, (nint)v);
			#endif
		}

		public static void DepthRangeArrayv(uint first, int count, double* v)
		{
			DepthRangeArrayvNative(first, count, v);
		}

		public static void DepthRangeArrayv(uint first, int count, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				DepthRangeArrayvNative(first, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeIndexedNative(uint index, double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[121])(index, n, f);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[121])(index, n, f);
			#endif
		}

		public static void DepthRangeIndexed(uint index, double n, double f)
		{
			DepthRangeIndexedNative(index, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangeIndexeddNVNative(uint index, double n, double f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[122])(index, n, f);
			#else
			((delegate* unmanaged[Cdecl]<uint, double, double, void>)funcTable[122])(index, n, f);
			#endif
		}

		public static void DepthRangeIndexeddNV(uint index, double n, double f)
		{
			DepthRangeIndexeddNVNative(index, n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangefNative(float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[123])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[123])(n, f);
			#endif
		}

		public static void DepthRangef(float n, float f)
		{
			DepthRangefNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DetachObjectARBNative(uint containerObj, uint attachedObj)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[124])(containerObj, attachedObj);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[124])(containerObj, attachedObj);
			#endif
		}

		public static void DetachObjectARB(uint containerObj, uint attachedObj)
		{
			DetachObjectARBNative(containerObj, attachedObj);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[125])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[125])(vaobj, index);
			#endif
		}

		public static void DisableVertexArrayAttrib(uint vaobj, uint index)
		{
			DisableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DisableVertexAttribArrayARBNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[126])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[126])(index);
			#endif
		}

		public static void DisableVertexAttribArrayARB(uint index)
		{
			DisableVertexAttribArrayARBNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeNative(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[127])(numGroupsX, numGroupsY, numGroupsZ);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, void>)funcTable[127])(numGroupsX, numGroupsY, numGroupsZ);
			#endif
		}

		public static void DispatchCompute(uint numGroupsX, uint numGroupsY, uint numGroupsZ)
		{
			DispatchComputeNative(numGroupsX, numGroupsY, numGroupsZ);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeGroupSizeARBNative(uint numGroupsX, uint numGroupsY, uint numGroupsZ, uint groupSizeX, uint groupSizeY, uint groupSizeZ)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, uint, void>)funcTable[128])(numGroupsX, numGroupsY, numGroupsZ, groupSizeX, groupSizeY, groupSizeZ);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, uint, uint, uint, uint, void>)funcTable[128])(numGroupsX, numGroupsY, numGroupsZ, groupSizeX, groupSizeY, groupSizeZ);
			#endif
		}

		public static void DispatchComputeGroupSizeARB(uint numGroupsX, uint numGroupsY, uint numGroupsZ, uint groupSizeX, uint groupSizeY, uint groupSizeZ)
		{
			DispatchComputeGroupSizeARBNative(numGroupsX, numGroupsY, numGroupsZ, groupSizeX, groupSizeY, groupSizeZ);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DispatchComputeIndirectNative(nint indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[129])(indirect);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[129])(indirect);
			#endif
		}

		public static void DispatchComputeIndirect(nint indirect)
		{
			DispatchComputeIndirectNative(indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysIndirectNative(GLPrimitiveType mode, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, void>)funcTable[130])(mode, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, void>)funcTable[130])(mode, (nint)indirect);
			#endif
		}

		public static void DrawArraysIndirect(GLPrimitiveType mode, void* indirect)
		{
			DrawArraysIndirectNative(mode, indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedARBNative(GLPrimitiveType mode, int first, int count, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[131])(mode, first, count, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, void>)funcTable[131])(mode, first, count, primcount);
			#endif
		}

		public static void DrawArraysInstancedARB(GLPrimitiveType mode, int first, int count, int primcount)
		{
			DrawArraysInstancedARBNative(mode, first, count, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawArraysInstancedBaseInstanceNative(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[132])(mode, first, count, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, int, int, uint, void>)funcTable[132])(mode, first, count, instancecount, baseinstance);
			#endif
		}

		public static void DrawArraysInstancedBaseInstance(GLPrimitiveType mode, int first, int count, int instancecount, uint baseinstance)
		{
			DrawArraysInstancedBaseInstanceNative(mode, first, count, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawBuffersARBNative(int n, GLDrawBufferMode bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[133])(n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<int, GLDrawBufferMode, void>)funcTable[133])(n, bufs);
			#endif
		}

		public static void DrawBuffersARB(int n, GLDrawBufferMode bufs)
		{
			DrawBuffersARBNative(n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[134])(mode, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[134])(mode, count, type, (nint)indices, basevertex);
			#endif
		}

		public static void DrawElementsBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawElementsBaseVertexNative(mode, count, type, indices, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsIndirectNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, void>)funcTable[135])(mode, type, indirect);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, void>)funcTable[135])(mode, type, (nint)indirect);
			#endif
		}

		public static void DrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, void* indirect)
		{
			DrawElementsIndirectNative(mode, type, indirect);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedARBNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, void>)funcTable[136])(mode, count, type, indices, primcount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, void>)funcTable[136])(mode, count, type, (nint)indices, primcount);
			#endif
		}

		public static void DrawElementsInstancedARB(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int primcount)
		{
			DrawElementsInstancedARBNative(mode, count, type, indices, primcount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, uint, void>)funcTable[137])(mode, count, type, indices, instancecount, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, uint, void>)funcTable[137])(mode, count, type, (nint)indices, instancecount, baseinstance);
			#endif
		}

		public static void DrawElementsInstancedBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, uint baseinstance)
		{
			DrawElementsInstancedBaseInstanceNative(mode, count, type, indices, instancecount, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, void>)funcTable[138])(mode, count, type, indices, instancecount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, void>)funcTable[138])(mode, count, type, (nint)indices, instancecount, basevertex);
			#endif
		}

		public static void DrawElementsInstancedBaseVertex(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex)
		{
			DrawElementsInstancedBaseVertexNative(mode, count, type, indices, instancecount, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawElementsInstancedBaseVertexBaseInstanceNative(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, void*, int, int, uint, void>)funcTable[139])(mode, count, type, indices, instancecount, basevertex, baseinstance);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int, GLDrawElementsType, nint, int, int, uint, void>)funcTable[139])(mode, count, type, (nint)indices, instancecount, basevertex, baseinstance);
			#endif
		}

		public static void DrawElementsInstancedBaseVertexBaseInstance(GLPrimitiveType mode, int count, GLDrawElementsType type, void* indices, int instancecount, int basevertex, uint baseinstance)
		{
			DrawElementsInstancedBaseVertexBaseInstanceNative(mode, count, type, indices, instancecount, basevertex, baseinstance);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawRangeElementsBaseVertexNative(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, void*, int, void>)funcTable[140])(mode, start, end, count, type, indices, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, GLDrawElementsType, nint, int, void>)funcTable[140])(mode, start, end, count, type, (nint)indices, basevertex);
			#endif
		}

		public static void DrawRangeElementsBaseVertex(GLPrimitiveType mode, uint start, uint end, int count, GLDrawElementsType type, void* indices, int basevertex)
		{
			DrawRangeElementsBaseVertexNative(mode, start, end, count, type, indices, basevertex);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackNative(GLPrimitiveType mode, uint id)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[141])(mode, id);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, void>)funcTable[141])(mode, id);
			#endif
		}

		public static void DrawTransformFeedback(GLPrimitiveType mode, uint id)
		{
			DrawTransformFeedbackNative(mode, id);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackInstancedNative(GLPrimitiveType mode, uint id, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[142])(mode, id, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, int, void>)funcTable[142])(mode, id, instancecount);
			#endif
		}

		public static void DrawTransformFeedbackInstanced(GLPrimitiveType mode, uint id, int instancecount)
		{
			DrawTransformFeedbackInstancedNative(mode, id, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackStreamNative(GLPrimitiveType mode, uint id, uint stream)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, void>)funcTable[143])(mode, id, stream);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, void>)funcTable[143])(mode, id, stream);
			#endif
		}

		public static void DrawTransformFeedbackStream(GLPrimitiveType mode, uint id, uint stream)
		{
			DrawTransformFeedbackStreamNative(mode, id, stream);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DrawTransformFeedbackStreamInstancedNative(GLPrimitiveType mode, uint id, uint stream, int instancecount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, void>)funcTable[144])(mode, id, stream, instancecount);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, uint, uint, int, void>)funcTable[144])(mode, id, stream, instancecount);
			#endif
		}

		public static void DrawTransformFeedbackStreamInstanced(GLPrimitiveType mode, uint id, uint stream, int instancecount)
		{
			DrawTransformFeedbackStreamInstancedNative(mode, id, stream, instancecount);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexArrayAttribNative(uint vaobj, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[145])(vaobj, index);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, void>)funcTable[145])(vaobj, index);
			#endif
		}

		public static void EnableVertexArrayAttrib(uint vaobj, uint index)
		{
			EnableVertexArrayAttribNative(vaobj, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EnableVertexAttribArrayARBNative(uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[146])(index);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[146])(index);
			#endif
		}

		public static void EnableVertexAttribArrayARB(uint index)
		{
			EnableVertexAttribArrayARBNative(index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryARBNative(GLQueryTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[147])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, void>)funcTable[147])(target);
			#endif
		}

		public static void EndQueryARB(GLQueryTarget target)
		{
			EndQueryARBNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EndQueryIndexedNative(GLQueryTarget target, uint index)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[148])(target, index);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, void>)funcTable[148])(target, index);
			#endif
		}

		public static void EndQueryIndexed(GLQueryTarget target, uint index)
		{
			EndQueryIndexedNative(target, index);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void EvaluateDepthValuesARBNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[149])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[149])();
			#endif
		}

		public static void EvaluateDepthValuesARB()
		{
			EvaluateDepthValuesARBNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLSync FenceSyncNative(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[150])(condition, flags);
			#else
			return (GLSync)((delegate* unmanaged[Cdecl]<GLSyncCondition, GLSyncBehaviorFlags, GLSync>)funcTable[150])(condition, flags);
			#endif
		}

		public static GLSync FenceSync(GLSyncCondition condition, GLSyncBehaviorFlags flags)
		{
			GLSync ret = FenceSyncNative(condition, flags);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedBufferRangeNative(GLBufferTargetARB target, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[151])(target, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void>)funcTable[151])(target, offset, length);
			#endif
		}

		public static void FlushMappedBufferRange(GLBufferTargetARB target, nint offset, nint length)
		{
			FlushMappedBufferRangeNative(target, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FlushMappedNamedBufferRangeNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[152])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[152])(buffer, offset, length);
			#endif
		}

		public static void FlushMappedNamedBufferRange(uint buffer, nint offset, nint length)
		{
			FlushMappedNamedBufferRangeNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferParameteriNative(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[153])(target, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferParameterName, int, void>)funcTable[153])(target, pname, param);
			#endif
		}

		public static void FramebufferParameteri(GLFramebufferTarget target, GLFramebufferParameterName pname, int param)
		{
			FramebufferParameteriNative(target, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferRenderbufferNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[154])(target, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[154])(target, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		public static void FramebufferRenderbuffer(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			FramebufferRenderbufferNative(target, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferSampleLocationsfvARBNative(GLFramebufferTarget target, uint start, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, int, float*, void>)funcTable[155])(target, start, count, v);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, uint, int, nint, void>)funcTable[155])(target, start, count, (nint)v);
			#endif
		}

		public static void FramebufferSampleLocationsfvARB(GLFramebufferTarget target, uint start, int count, float* v)
		{
			FramebufferSampleLocationsfvARBNative(target, start, count, v);
		}

		public static void FramebufferSampleLocationsfvARB(GLFramebufferTarget target, uint start, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				FramebufferSampleLocationsfvARBNative(target, start, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture1DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[156])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[156])(target, attachment, textarget, texture, level);
			#endif
		}

		public static void FramebufferTexture1D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture1DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture2DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[157])(target, attachment, textarget, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, void>)funcTable[157])(target, attachment, textarget, texture, level);
			#endif
		}

		public static void FramebufferTexture2D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level)
		{
			FramebufferTexture2DNative(target, attachment, textarget, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTexture3DNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[158])(target, attachment, textarget, texture, level, zoffset);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLTextureTarget, uint, int, int, void>)funcTable[158])(target, attachment, textarget, texture, level, zoffset);
			#endif
		}

		public static void FramebufferTexture3D(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLTextureTarget textarget, uint texture, int level, int zoffset)
		{
			FramebufferTexture3DNative(target, attachment, textarget, texture, level, zoffset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureARBNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[159])(target, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, void>)funcTable[159])(target, attachment, texture, level);
			#endif
		}

		public static void FramebufferTextureARB(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level)
		{
			FramebufferTextureARBNative(target, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureFaceARBNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[160])(target, attachment, texture, level, face);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, GLTextureTarget, void>)funcTable[160])(target, attachment, texture, level, face);
			#endif
		}

		public static void FramebufferTextureFaceARB(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, GLTextureTarget face)
		{
			FramebufferTextureFaceARBNative(target, attachment, texture, level, face);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureLayerNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[161])(target, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[161])(target, attachment, texture, level, layer);
			#endif
		}

		public static void FramebufferTextureLayer(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			FramebufferTextureLayerNative(target, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void FramebufferTextureLayerARBNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[162])(target, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, uint, int, int, void>)funcTable[162])(target, attachment, texture, level, layer);
			#endif
		}

		public static void FramebufferTextureLayerARB(GLFramebufferTarget target, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			FramebufferTextureLayerARBNative(target, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenBuffersARBNative(int n, uint* buffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[163])(n, buffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[163])(n, (nint)buffers);
			#endif
		}

		public static void GenBuffersARB(int n, uint* buffers)
		{
			GenBuffersARBNative(n, buffers);
		}

		public static void GenBuffersARB(int n, ref uint buffers)
		{
			fixed (uint* pbuffers0 = &buffers)
			{
				GenBuffersARBNative(n, pbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenFramebuffersNative(int n, uint* framebuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[164])(n, framebuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[164])(n, (nint)framebuffers);
			#endif
		}

		public static void GenFramebuffers(int n, uint* framebuffers)
		{
			GenFramebuffersNative(n, framebuffers);
		}

		public static void GenFramebuffers(int n, ref uint framebuffers)
		{
			fixed (uint* pframebuffers0 = &framebuffers)
			{
				GenFramebuffersNative(n, pframebuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramPipelinesNative(int n, uint* pipelines)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[165])(n, pipelines);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[165])(n, (nint)pipelines);
			#endif
		}

		public static void GenProgramPipelines(int n, uint* pipelines)
		{
			GenProgramPipelinesNative(n, pipelines);
		}

		public static void GenProgramPipelines(int n, ref uint pipelines)
		{
			fixed (uint* ppipelines0 = &pipelines)
			{
				GenProgramPipelinesNative(n, ppipelines0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenProgramsARBNative(int n, uint* programs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[166])(n, programs);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[166])(n, (nint)programs);
			#endif
		}

		public static void GenProgramsARB(int n, uint* programs)
		{
			GenProgramsARBNative(n, programs);
		}

		public static void GenProgramsARB(int n, ref uint programs)
		{
			fixed (uint* pprograms0 = &programs)
			{
				GenProgramsARBNative(n, pprograms0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenQueriesARBNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[167])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[167])(n, (nint)ids);
			#endif
		}

		public static void GenQueriesARB(int n, uint* ids)
		{
			GenQueriesARBNative(n, ids);
		}

		public static void GenQueriesARB(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenQueriesARBNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenRenderbuffersNative(int n, uint* renderbuffers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[168])(n, renderbuffers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[168])(n, (nint)renderbuffers);
			#endif
		}

		public static void GenRenderbuffers(int n, uint* renderbuffers)
		{
			GenRenderbuffersNative(n, renderbuffers);
		}

		public static void GenRenderbuffers(int n, ref uint renderbuffers)
		{
			fixed (uint* prenderbuffers0 = &renderbuffers)
			{
				GenRenderbuffersNative(n, prenderbuffers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenSamplersNative(int count, uint* samplers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[169])(count, samplers);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[169])(count, (nint)samplers);
			#endif
		}

		public static void GenSamplers(int count, uint* samplers)
		{
			GenSamplersNative(count, samplers);
		}

		public static void GenSamplers(int count, ref uint samplers)
		{
			fixed (uint* psamplers0 = &samplers)
			{
				GenSamplersNative(count, psamplers0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenTransformFeedbacksNative(int n, uint* ids)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[170])(n, ids);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[170])(n, (nint)ids);
			#endif
		}

		public static void GenTransformFeedbacks(int n, uint* ids)
		{
			GenTransformFeedbacksNative(n, ids);
		}

		public static void GenTransformFeedbacks(int n, ref uint ids)
		{
			fixed (uint* pids0 = &ids)
			{
				GenTransformFeedbacksNative(n, pids0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenVertexArraysNative(int n, uint* arrays)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[171])(n, arrays);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[171])(n, (nint)arrays);
			#endif
		}

		public static void GenVertexArrays(int n, uint* arrays)
		{
			GenVertexArraysNative(n, arrays);
		}

		public static void GenVertexArrays(int n, ref uint arrays)
		{
			fixed (uint* parrays0 = &arrays)
			{
				GenVertexArraysNative(n, parrays0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateMipmapNative(GLTextureTarget target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[172])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, void>)funcTable[172])(target);
			#endif
		}

		public static void GenerateMipmap(GLTextureTarget target)
		{
			GenerateMipmapNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GenerateTextureMipmapNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[173])(texture);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[173])(texture);
			#endif
		}

		public static void GenerateTextureMipmap(uint texture)
		{
			GenerateTextureMipmapNative(texture);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAtomicCounterBufferivNative(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, int*, void>)funcTable[174])(program, bufferIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLAtomicCounterBufferPName, nint, void>)funcTable[174])(program, bufferIndex, pname, (nint)@params);
			#endif
		}

		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, int* @params)
		{
			GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, @params);
		}

		public static void GetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, GLAtomicCounterBufferPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetActiveAtomicCounterBufferivNative(program, bufferIndex, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveAttribARBNative(uint programObj, uint index, int maxLength, int* length, int* size, GLAttributeType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLAttributeType, byte*, void>)funcTable[175])(programObj, index, maxLength, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLAttributeType, nint, void>)funcTable[175])(programObj, index, maxLength, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, int* size, GLAttributeType type, byte* name)
		{
			GetActiveAttribARBNative(programObj, index, maxLength, length, size, type, name);
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, ref int length, int* size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveAttribARBNative(programObj, index, maxLength, plength0, size, type, name);
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveAttribARBNative(programObj, index, maxLength, length, psize0, type, name);
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, ref int length, ref int size, GLAttributeType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveAttribARBNative(programObj, index, maxLength, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, int* size, GLAttributeType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveAttribARBNative(programObj, index, maxLength, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, int* size, GLAttributeType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveAttribARBNative(programObj, index, maxLength, length, size, type, pname0);
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveAttribARBNative(programObj, index, maxLength, length, size, type, pname0);
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, ref int length, int* size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribARBNative(programObj, index, maxLength, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveAttribARBNative(programObj, index, maxLength, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveAttribARB(uint programObj, uint index, int maxLength, ref int length, ref int size, GLAttributeType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveAttribARBNative(programObj, index, maxLength, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[176])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[176])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, name);
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformNameNative(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, int*, byte*, void>)funcTable[177])(program, shadertype, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, int, nint, nint, void>)funcTable[177])(program, shadertype, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, byte* name)
		{
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, name);
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, name);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, length, pname0);
			}
		}

		public static void GetActiveSubroutineUniformName(uint program, GLShaderType shadertype, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveSubroutineUniformNameNative(program, shadertype, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveSubroutineUniformivNative(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, int*, void>)funcTable[178])(program, shadertype, index, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, uint, GLSubroutineParameterName, nint, void>)funcTable[178])(program, shadertype, index, pname, (nint)values);
			#endif
		}

		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, int* values)
		{
			GetActiveSubroutineUniformivNative(program, shadertype, index, pname, values);
		}

		public static void GetActiveSubroutineUniformiv(uint program, GLShaderType shadertype, uint index, GLSubroutineParameterName pname, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetActiveSubroutineUniformivNative(program, shadertype, index, pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformARBNative(uint programObj, uint index, int maxLength, int* length, int* size, GLUniformType type, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, int*, GLUniformType, byte*, void>)funcTable[179])(programObj, index, maxLength, length, size, type, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, GLUniformType, nint, void>)funcTable[179])(programObj, index, maxLength, (nint)length, (nint)size, type, (nint)name);
			#endif
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, int* size, GLUniformType type, byte* name)
		{
			GetActiveUniformARBNative(programObj, index, maxLength, length, size, type, name);
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, ref int length, int* size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformARBNative(programObj, index, maxLength, plength0, size, type, name);
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* psize0 = &size)
			{
				GetActiveUniformARBNative(programObj, index, maxLength, length, psize0, type, name);
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, ref int length, ref int size, GLUniformType type, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					GetActiveUniformARBNative(programObj, index, maxLength, plength0, psize1, type, name);
				}
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, int* size, GLUniformType type, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformARBNative(programObj, index, maxLength, length, size, type, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, int* size, GLUniformType type, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetActiveUniformARBNative(programObj, index, maxLength, length, size, type, pname0);
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, int* size, GLUniformType type, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetActiveUniformARBNative(programObj, index, maxLength, length, size, type, pname0);
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, ref int length, int* size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformARBNative(programObj, index, maxLength, plength0, size, type, pname1);
				}
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* psize0 = &size)
			{
				fixed (byte* pname1 = &name)
				{
					GetActiveUniformARBNative(programObj, index, maxLength, length, psize0, type, pname1);
				}
			}
		}

		public static void GetActiveUniformARB(uint programObj, uint index, int maxLength, ref int length, ref int size, GLUniformType type, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* psize1 = &size)
				{
					fixed (byte* pname2 = &name)
					{
						GetActiveUniformARBNative(programObj, index, maxLength, plength0, psize1, type, pname2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockNameNative(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[180])(program, uniformBlockIndex, bufSize, length, uniformBlockName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[180])(program, uniformBlockIndex, bufSize, (nint)length, (nint)uniformBlockName);
			#endif
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, byte* uniformBlockName)
		{
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, uniformBlockName);
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, byte* uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, uniformBlockName);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ReadOnlySpan<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, length, puniformBlockName0);
			}
		}

		public static void GetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, ref int length, ref byte uniformBlockName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformBlockName1 = &uniformBlockName)
				{
					GetActiveUniformBlockNameNative(program, uniformBlockIndex, bufSize, plength0, puniformBlockName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformBlockivNative(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, int*, void>)funcTable[181])(program, uniformBlockIndex, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLUniformBlockPName, nint, void>)funcTable[181])(program, uniformBlockIndex, pname, (nint)@params);
			#endif
		}

		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, int* @params)
		{
			GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, @params);
		}

		public static void GetActiveUniformBlockiv(uint program, uint uniformBlockIndex, GLUniformBlockPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetActiveUniformBlockivNative(program, uniformBlockIndex, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformNameNative(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, int*, byte*, void>)funcTable[182])(program, uniformIndex, bufSize, length, uniformName);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, nint, void>)funcTable[182])(program, uniformIndex, bufSize, (nint)length, (nint)uniformName);
			#endif
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, byte* uniformName)
		{
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, uniformName);
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, byte* uniformName)
		{
			fixed (int* plength0 = &length)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, uniformName);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, string uniformName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetActiveUniformNameNative(program, uniformIndex, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ReadOnlySpan<byte> uniformName)
		{
			fixed (byte* puniformName0 = uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, ref byte uniformName)
		{
			fixed (byte* puniformName0 = &uniformName)
			{
				GetActiveUniformNameNative(program, uniformIndex, bufSize, length, puniformName0);
			}
		}

		public static void GetActiveUniformName(uint program, uint uniformIndex, int bufSize, ref int length, ref byte uniformName)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* puniformName1 = &uniformName)
				{
					GetActiveUniformNameNative(program, uniformIndex, bufSize, plength0, puniformName1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetActiveUniformsivNative(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, uint*, GLUniformPName, int*, void>)funcTable[183])(program, uniformCount, uniformIndices, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, GLUniformPName, nint, void>)funcTable[183])(program, uniformCount, (nint)uniformIndices, pname, (nint)@params);
			#endif
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, int* @params)
		{
			GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, @params);
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, GLUniformPName pname, int* @params)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, @params);
			}
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, GLUniformPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetActiveUniformsivNative(program, uniformCount, uniformIndices, pname, pparams0);
			}
		}

		public static void GetActiveUniformsiv(uint program, int uniformCount, ref uint uniformIndices, GLUniformPName pname, ref int @params)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				fixed (int* pparams1 = &@params)
				{
					GetActiveUniformsivNative(program, uniformCount, puniformIndices0, pname, pparams1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetAttachedObjectsARBNative(uint containerObj, int maxCount, int* count, uint* obj)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, uint*, void>)funcTable[184])(containerObj, maxCount, count, obj);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[184])(containerObj, maxCount, (nint)count, (nint)obj);
			#endif
		}

		public static void GetAttachedObjectsARB(uint containerObj, int maxCount, int* count, uint* obj)
		{
			GetAttachedObjectsARBNative(containerObj, maxCount, count, obj);
		}

		public static void GetAttachedObjectsARB(uint containerObj, int maxCount, ref int count, uint* obj)
		{
			fixed (int* pcount0 = &count)
			{
				GetAttachedObjectsARBNative(containerObj, maxCount, pcount0, obj);
			}
		}

		public static void GetAttachedObjectsARB(uint containerObj, int maxCount, int* count, ref uint obj)
		{
			fixed (uint* pobj0 = &obj)
			{
				GetAttachedObjectsARBNative(containerObj, maxCount, count, pobj0);
			}
		}

		public static void GetAttachedObjectsARB(uint containerObj, int maxCount, ref int count, ref uint obj)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (uint* pobj1 = &obj)
				{
					GetAttachedObjectsARBNative(containerObj, maxCount, pcount0, pobj1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetAttribLocationARBNative(uint programObj, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[185])(programObj, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[185])(programObj, (nint)name);
			#endif
		}

		public static int GetAttribLocationARB(uint programObj, byte* name)
		{
			int ret = GetAttribLocationARBNative(programObj, name);
			return ret;
		}

		public static int GetAttribLocationARB(uint programObj, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetAttribLocationARBNative(programObj, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetAttribLocationARB(uint programObj, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetAttribLocationARBNative(programObj, pname0);
				return ret;
			}
		}

		public static int GetAttribLocationARB(uint programObj, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetAttribLocationARBNative(programObj, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferParameterivARBNative(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, int*, void>)funcTable[186])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPNameARB, nint, void>)funcTable[186])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferParameterivARB(GLBufferTargetARB target, GLBufferPNameARB pname, int* @params)
		{
			GetBufferParameterivARBNative(target, pname, @params);
		}

		public static void GetBufferParameterivARB(GLBufferTargetARB target, GLBufferPNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetBufferParameterivARBNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferPointervARBNative(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, void**, void>)funcTable[187])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferPointerNameARB, nint, void>)funcTable[187])(target, pname, (nint)@params);
			#endif
		}

		public static void GetBufferPointervARB(GLBufferTargetARB target, GLBufferPointerNameARB pname, void** @params)
		{
			GetBufferPointervARBNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetBufferSubDataARBNative(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, void*, void>)funcTable[188])(target, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, nint, void>)funcTable[188])(target, offset, size, (nint)data);
			#endif
		}

		public static void GetBufferSubDataARB(GLBufferTargetARB target, nint offset, nint size, void* data)
		{
			GetBufferSubDataARBNative(target, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableNative(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, void*, void>)funcTable[189])(target, format, type, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, nint, void>)funcTable[189])(target, format, type, (nint)table);
			#endif
		}

		public static void GetColorTable(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* table)
		{
			GetColorTableNative(target, format, type, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterfvNative(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, float*, void>)funcTable[190])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[190])(target, pname, (nint)@params);
			#endif
		}

		public static void GetColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			GetColorTableParameterfvNative(target, pname, @params);
		}

		public static void GetColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetColorTableParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterivNative(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, int*, void>)funcTable[191])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[191])(target, pname, (nint)@params);
			#endif
		}

		public static void GetColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			GetColorTableParameterivNative(target, pname, @params);
		}

		public static void GetColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetColorTableParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTexImageARBNative(GLTextureTarget target, int level, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, void*, void>)funcTable[192])(target, level, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, nint, void>)funcTable[192])(target, level, (nint)img);
			#endif
		}

		public static void GetCompressedTexImageARB(GLTextureTarget target, int level, void* img)
		{
			GetCompressedTexImageARBNative(target, level, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureImageNative(uint texture, int level, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, void*, void>)funcTable[193])(texture, level, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[193])(texture, level, bufSize, (nint)pixels);
			#endif
		}

		public static void GetCompressedTextureImage(uint texture, int level, int bufSize, void* pixels)
		{
			GetCompressedTextureImageNative(texture, level, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetCompressedTextureSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, void*, void>)funcTable[194])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, int, nint, void>)funcTable[194])(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, (nint)pixels);
			#endif
		}

		public static void GetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, void* pixels)
		{
			GetCompressedTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionFilterNative(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, void*, void>)funcTable[195])(target, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, nint, void>)funcTable[195])(target, format, type, (nint)image);
			#endif
		}

		public static void GetConvolutionFilter(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, void* image)
		{
			GetConvolutionFilterNative(target, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterfvNative(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float*, void>)funcTable[196])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[196])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			GetConvolutionParameterfvNative(target, pname, @params);
		}

		public static void GetConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetConvolutionParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterivNative(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int*, void>)funcTable[197])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[197])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			GetConvolutionParameterivNative(target, pname, @params);
		}

		public static void GetConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetConvolutionParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetDebugMessageLogARBNative(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, uint*, GLDebugSeverity, int*, byte*, uint>)funcTable[198])(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, int, GLDebugSource, GLDebugType, nint, GLDebugSeverity, nint, nint, uint>)funcTable[198])(count, bufSize, sources, types, (nint)ids, severities, (nint)lengths, (nint)messageLog);
			#endif
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, ids, severities, lengths, messageLog);
			return ret;
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, pids0, severities, lengths, messageLog);
				return ret;
			}
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, ids, severities, plengths0, messageLog);
				return ret;
			}
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, byte* messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, pids0, severities, plengths1, messageLog);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, string messageLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (messageLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(messageLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(messageLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, ids, severities, lengths, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, ReadOnlySpan<byte> messageLog)
		{
			fixed (byte* pmessageLog0 = messageLog)
			{
				uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (byte* pmessageLog0 = &messageLog)
			{
				uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, ids, severities, lengths, pmessageLog0);
				return ret;
			}
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, int* lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, pids0, severities, lengths, pmessageLog1);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, uint* ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (int* plengths0 = &lengths)
			{
				fixed (byte* pmessageLog1 = &messageLog)
				{
					uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, ids, severities, plengths0, pmessageLog1);
					return ret;
				}
			}
		}

		public static uint GetDebugMessageLogARB(uint count, int bufSize, GLDebugSource sources, GLDebugType types, ref uint ids, GLDebugSeverity severities, ref int lengths, ref byte messageLog)
		{
			fixed (uint* pids0 = &ids)
			{
				fixed (int* plengths1 = &lengths)
				{
					fixed (byte* pmessageLog2 = &messageLog)
					{
						uint ret = GetDebugMessageLogARBNative(count, bufSize, sources, types, pids0, severities, plengths1, pmessageLog2);
						return ret;
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetDoublei_vNative(GLGetPName target, uint index, double* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, double*, void>)funcTable[199])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[199])(target, index, (nint)data);
			#endif
		}

		public static void GetDoublei_v(GLGetPName target, uint index, double* data)
		{
			GetDoublei_vNative(target, index, data);
		}

		public static void GetDoublei_v(GLGetPName target, uint index, ref double data)
		{
			fixed (double* pdata0 = &data)
			{
				GetDoublei_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFloati_vNative(GLGetPName target, uint index, float* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, float*, void>)funcTable[200])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[200])(target, index, (nint)data);
			#endif
		}

		public static void GetFloati_v(GLGetPName target, uint index, float* data)
		{
			GetFloati_vNative(target, index, data);
		}

		public static void GetFloati_v(GLGetPName target, uint index, ref float data)
		{
			fixed (float* pdata0 = &data)
			{
				GetFloati_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetFragDataIndexNative(uint program, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[201])(program, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[201])(program, (nint)name);
			#endif
		}

		public static int GetFragDataIndex(uint program, byte* name)
		{
			int ret = GetFragDataIndexNative(program, name);
			return ret;
		}

		public static int GetFragDataIndex(uint program, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetFragDataIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetFragDataIndex(uint program, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		public static int GetFragDataIndex(uint program, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetFragDataIndexNative(program, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferAttachmentParameterivNative(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[202])(target, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[202])(target, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferAttachmentParameterivNative(target, attachment, pname, @params);
		}

		public static void GetFramebufferAttachmentParameteriv(GLFramebufferTarget target, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFramebufferAttachmentParameterivNative(target, attachment, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetFramebufferParameterivNative(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachmentParameterName, int*, void>)funcTable[203])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, GLFramebufferAttachmentParameterName, nint, void>)funcTable[203])(target, pname, (nint)@params);
			#endif
		}

		public static void GetFramebufferParameteriv(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetFramebufferParameterivNative(target, pname, @params);
		}

		public static void GetFramebufferParameteriv(GLFramebufferTarget target, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetFramebufferParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetGraphicsResetStatusARBNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[204])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[204])();
			#endif
		}

		public static GLEnum GetGraphicsResetStatusARB()
		{
			GLEnum ret = GetGraphicsResetStatusARBNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetHandleARBNative(GLContainerType pname)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLContainerType, uint>)funcTable[205])(pname);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<GLContainerType, uint>)funcTable[205])(pname);
			#endif
		}

		public static uint GetHandleARB(GLContainerType pname)
		{
			uint ret = GetHandleARBNative(pname);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramNative(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[206])(target, reset, format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[206])(target, reset, format, type, (nint)values);
			#endif
		}

		public static void GetHistogram(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetHistogramNative(target, reset, format, type, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterfvNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, float*, void>)funcTable[207])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[207])(target, pname, (nint)@params);
			#endif
		}

		public static void GetHistogramParameterfv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			GetHistogramParameterfvNative(target, pname, @params);
		}

		public static void GetHistogramParameterfv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetHistogramParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterivNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, int*, void>)funcTable[208])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[208])(target, pname, (nint)@params);
			#endif
		}

		public static void GetHistogramParameteriv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			GetHistogramParameterivNative(target, pname, @params);
		}

		public static void GetHistogramParameteriv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetHistogramParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetImageHandleARBNative(uint texture, int level, byte layered, int layer, GLPixelFormat format)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, int, byte, int, GLPixelFormat, ulong>)funcTable[209])(texture, level, layered, layer, format);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, int, byte, int, GLPixelFormat, ulong>)funcTable[209])(texture, level, layered, layer, format);
			#endif
		}

		public static ulong GetImageHandleARB(uint texture, int level, byte layered, int layer, GLPixelFormat format)
		{
			ulong ret = GetImageHandleARBNative(texture, level, layered, layer, format);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInfoLogARBNative(uint obj, int maxLength, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[210])(obj, maxLength, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[210])(obj, maxLength, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetInfoLogARB(uint obj, int maxLength, int* length, byte* infoLog)
		{
			GetInfoLogARBNative(obj, maxLength, length, infoLog);
		}

		public static void GetInfoLogARB(uint obj, int maxLength, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetInfoLogARBNative(obj, maxLength, plength0, infoLog);
			}
		}

		public static void GetInfoLogARB(uint obj, int maxLength, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetInfoLogARBNative(obj, maxLength, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetInfoLogARB(uint obj, int maxLength, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetInfoLogARBNative(obj, maxLength, length, pinfoLog0);
			}
		}

		public static void GetInfoLogARB(uint obj, int maxLength, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetInfoLogARBNative(obj, maxLength, length, pinfoLog0);
			}
		}

		public static void GetInfoLogARB(uint obj, int maxLength, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetInfoLogARBNative(obj, maxLength, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInteger64vNative(GLGetPName pname, long* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, long*, void>)funcTable[211])(pname, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, nint, void>)funcTable[211])(pname, (nint)data);
			#endif
		}

		public static void GetInteger64v(GLGetPName pname, long* data)
		{
			GetInteger64vNative(pname, data);
		}

		public static void GetInteger64v(GLGetPName pname, ref long data)
		{
			fixed (long* pdata0 = &data)
			{
				GetInteger64vNative(pname, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetIntegeri_vNative(GLGetPName target, uint index, int* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, int*, void>)funcTable[212])(target, index, data);
			#else
			((delegate* unmanaged[Cdecl]<GLGetPName, uint, nint, void>)funcTable[212])(target, index, (nint)data);
			#endif
		}

		public static void GetIntegeri_v(GLGetPName target, uint index, int* data)
		{
			GetIntegeri_vNative(target, index, data);
		}

		public static void GetIntegeri_v(GLGetPName target, uint index, ref int data)
		{
			fixed (int* pdata0 = &data)
			{
				GetIntegeri_vNative(target, index, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformati64vNative(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, long*, void>)funcTable[213])(target, internalformat, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, nint, void>)funcTable[213])(target, internalformat, pname, count, (nint)@params);
			#endif
		}

		public static void GetInternalformati64v(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, long* @params)
		{
			GetInternalformati64vNative(target, internalformat, pname, count, @params);
		}

		public static void GetInternalformati64v(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetInternalformati64vNative(target, internalformat, pname, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetInternalformativNative(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, int*, void>)funcTable[214])(target, internalformat, pname, count, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, GLInternalFormat, GLInternalFormatPName, int, nint, void>)funcTable[214])(target, internalformat, pname, count, (nint)@params);
			#endif
		}

		public static void GetInternalformativ(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, int* @params)
		{
			GetInternalformativNative(target, internalformat, pname, count, @params);
		}

		public static void GetInternalformativ(GLTextureTarget target, GLInternalFormat internalformat, GLInternalFormatPName pname, int count, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetInternalformativNative(target, internalformat, pname, count, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxNative(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[215])(target, reset, format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[215])(target, reset, format, type, (nint)values);
			#endif
		}

		public static void GetMinmax(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetMinmaxNative(target, reset, format, type, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterfvNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, float*, void>)funcTable[216])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[216])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMinmaxParameterfv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			GetMinmaxParameterfvNative(target, pname, @params);
		}

		public static void GetMinmaxParameterfv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMinmaxParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterivNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, int*, void>)funcTable[217])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[217])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMinmaxParameteriv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			GetMinmaxParameterivNative(target, pname, @params);
		}

		public static void GetMinmaxParameteriv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMinmaxParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMultisamplefvNative(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, float*, void>)funcTable[218])(pname, index, val);
			#else
			((delegate* unmanaged[Cdecl]<GLGetMultisamplePNameNV, uint, nint, void>)funcTable[218])(pname, index, (nint)val);
			#endif
		}

		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, float* val)
		{
			GetMultisamplefvNative(pname, index, val);
		}

		public static void GetMultisamplefv(GLGetMultisamplePNameNV pname, uint index, ref float val)
		{
			fixed (float* pval0 = &val)
			{
				GetMultisamplefvNative(pname, index, pval0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameteri64vNative(uint buffer, GLBufferPNameARB pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, long*, void>)funcTable[219])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[219])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferParameteri64v(uint buffer, GLBufferPNameARB pname, long* @params)
		{
			GetNamedBufferParameteri64vNative(buffer, pname, @params);
		}

		public static void GetNamedBufferParameteri64v(uint buffer, GLBufferPNameARB pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetNamedBufferParameteri64vNative(buffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferParameterivNative(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, int*, void>)funcTable[220])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPNameARB, nint, void>)funcTable[220])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferParameteriv(uint buffer, GLBufferPNameARB pname, int* @params)
		{
			GetNamedBufferParameterivNative(buffer, pname, @params);
		}

		public static void GetNamedBufferParameteriv(uint buffer, GLBufferPNameARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedBufferParameterivNative(buffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferPointervNative(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, void**, void>)funcTable[221])(buffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLBufferPointerNameARB, nint, void>)funcTable[221])(buffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedBufferPointerv(uint buffer, GLBufferPointerNameARB pname, void** @params)
		{
			GetNamedBufferPointervNative(buffer, pname, @params);
		}
	}
}
