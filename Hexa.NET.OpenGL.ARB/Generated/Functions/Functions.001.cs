// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.ARB
{
	public static unsafe partial class GLArb
	{

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedBufferSubDataNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[222])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[222])(buffer, offset, size, (nint)data);
			#endif
		}

		public static void GetNamedBufferSubData(uint buffer, nint offset, nint size, void* data)
		{
			GetNamedBufferSubDataNative(buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferAttachmentParameterivNative(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, int*, void>)funcTable[223])(framebuffer, attachment, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLFramebufferAttachmentParameterName, nint, void>)funcTable[223])(framebuffer, attachment, pname, (nint)@params);
			#endif
		}

		public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, int* @params)
		{
			GetNamedFramebufferAttachmentParameterivNative(framebuffer, attachment, pname, @params);
		}

		public static void GetNamedFramebufferAttachmentParameteriv(uint framebuffer, GLFramebufferAttachment attachment, GLFramebufferAttachmentParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedFramebufferAttachmentParameterivNative(framebuffer, attachment, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedFramebufferParameterivNative(uint framebuffer, GLGetFramebufferParameter pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, int*, void>)funcTable[224])(framebuffer, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetFramebufferParameter, nint, void>)funcTable[224])(framebuffer, pname, (nint)param);
			#endif
		}

		public static void GetNamedFramebufferParameteriv(uint framebuffer, GLGetFramebufferParameter pname, int* param)
		{
			GetNamedFramebufferParameterivNative(framebuffer, pname, param);
		}

		public static void GetNamedFramebufferParameteriv(uint framebuffer, GLGetFramebufferParameter pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetNamedFramebufferParameterivNative(framebuffer, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedRenderbufferParameterivNative(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, int*, void>)funcTable[225])(renderbuffer, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLRenderbufferParameterName, nint, void>)funcTable[225])(renderbuffer, pname, (nint)@params);
			#endif
		}

		public static void GetNamedRenderbufferParameteriv(uint renderbuffer, GLRenderbufferParameterName pname, int* @params)
		{
			GetNamedRenderbufferParameterivNative(renderbuffer, pname, @params);
		}

		public static void GetNamedRenderbufferParameteriv(uint renderbuffer, GLRenderbufferParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedRenderbufferParameterivNative(renderbuffer, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedStringARBNative(int namelen, byte* name, int bufSize, int* stringlen, byte* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, int, int*, byte*, void>)funcTable[226])(namelen, name, bufSize, stringlen, str);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, int, nint, nint, void>)funcTable[226])(namelen, (nint)name, bufSize, (nint)stringlen, (nint)str);
			#endif
		}

		public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, byte* str)
		{
			GetNamedStringARBNative(namelen, name, bufSize, stringlen, str);
		}

		public static void GetNamedStringARB(int namelen, string name, int bufSize, int* stringlen, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetNamedStringARBNative(namelen, pStr0, bufSize, stringlen, str);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetNamedStringARB(int namelen, ReadOnlySpan<byte> name, int bufSize, int* stringlen, byte* str)
		{
			fixed (byte* pname0 = name)
			{
				GetNamedStringARBNative(namelen, pname0, bufSize, stringlen, str);
			}
		}

		public static void GetNamedStringARB(int namelen, ref byte name, int bufSize, int* stringlen, byte* str)
		{
			fixed (byte* pname0 = &name)
			{
				GetNamedStringARBNative(namelen, pname0, bufSize, stringlen, str);
			}
		}

		public static void GetNamedStringARB(int namelen, byte* name, int bufSize, ref int stringlen, byte* str)
		{
			fixed (int* pstringlen0 = &stringlen)
			{
				GetNamedStringARBNative(namelen, name, bufSize, pstringlen0, str);
			}
		}

		public static void GetNamedStringARB(int namelen, ref byte name, int bufSize, ref int stringlen, byte* str)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (int* pstringlen1 = &stringlen)
				{
					GetNamedStringARBNative(namelen, pname0, bufSize, pstringlen1, str);
				}
			}
		}

		public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetNamedStringARBNative(namelen, name, bufSize, stringlen, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr0 = str)
			{
				GetNamedStringARBNative(namelen, name, bufSize, stringlen, pstr0);
			}
		}

		public static void GetNamedStringARB(int namelen, byte* name, int bufSize, int* stringlen, ref byte str)
		{
			fixed (byte* pstr0 = &str)
			{
				GetNamedStringARBNative(namelen, name, bufSize, stringlen, pstr0);
			}
		}

		public static void GetNamedStringARB(int namelen, string name, int bufSize, int* stringlen, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			GetNamedStringARBNative(namelen, pStr0, bufSize, stringlen, pStr1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
		}

		public static void GetNamedStringARB(int namelen, ReadOnlySpan<byte> name, int bufSize, int* stringlen, ReadOnlySpan<byte> str)
		{
			fixed (byte* pname0 = name)
			{
				fixed (byte* pstr1 = str)
				{
					GetNamedStringARBNative(namelen, pname0, bufSize, stringlen, pstr1);
				}
			}
		}

		public static void GetNamedStringARB(int namelen, ref byte name, int bufSize, int* stringlen, ref byte str)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (byte* pstr1 = &str)
				{
					GetNamedStringARBNative(namelen, pname0, bufSize, stringlen, pstr1);
				}
			}
		}

		public static void GetNamedStringARB(int namelen, byte* name, int bufSize, ref int stringlen, ref byte str)
		{
			fixed (int* pstringlen0 = &stringlen)
			{
				fixed (byte* pstr1 = &str)
				{
					GetNamedStringARBNative(namelen, name, bufSize, pstringlen0, pstr1);
				}
			}
		}

		public static void GetNamedStringARB(int namelen, ref byte name, int bufSize, ref int stringlen, ref byte str)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (int* pstringlen1 = &stringlen)
				{
					fixed (byte* pstr2 = &str)
					{
						GetNamedStringARBNative(namelen, pname0, bufSize, pstringlen1, pstr2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetNamedStringivARBNative(int namelen, byte* name, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, GLEnum, int*, void>)funcTable[227])(namelen, name, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, GLEnum, nint, void>)funcTable[227])(namelen, (nint)name, pname, (nint)@params);
			#endif
		}

		public static void GetNamedStringivARB(int namelen, byte* name, GLEnum pname, int* @params)
		{
			GetNamedStringivARBNative(namelen, name, pname, @params);
		}

		public static void GetNamedStringivARB(int namelen, string name, GLEnum pname, int* @params)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetNamedStringivARBNative(namelen, pStr0, pname, @params);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetNamedStringivARB(int namelen, ReadOnlySpan<byte> name, GLEnum pname, int* @params)
		{
			fixed (byte* pname0 = name)
			{
				GetNamedStringivARBNative(namelen, pname0, pname, @params);
			}
		}

		public static void GetNamedStringivARB(int namelen, ref byte name, GLEnum pname, int* @params)
		{
			fixed (byte* pname0 = &name)
			{
				GetNamedStringivARBNative(namelen, pname0, pname, @params);
			}
		}

		public static void GetNamedStringivARB(int namelen, byte* name, GLEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetNamedStringivARBNative(namelen, name, pname, pparams0);
			}
		}

		public static void GetNamedStringivARB(int namelen, ref byte name, GLEnum pname, ref int @params)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (int* pparams1 = &@params)
				{
					GetNamedStringivARBNative(namelen, pname0, pname, pparams1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectParameterfvARBNative(uint obj, GLEnum pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, float*, void>)funcTable[228])(obj, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void>)funcTable[228])(obj, pname, (nint)@params);
			#endif
		}

		public static void GetObjectParameterfvARB(uint obj, GLEnum pname, float* @params)
		{
			GetObjectParameterfvARBNative(obj, pname, @params);
		}

		public static void GetObjectParameterfvARB(uint obj, GLEnum pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetObjectParameterfvARBNative(obj, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetObjectParameterivARBNative(uint obj, GLEnum pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLEnum, int*, void>)funcTable[229])(obj, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLEnum, nint, void>)funcTable[229])(obj, pname, (nint)@params);
			#endif
		}

		public static void GetObjectParameterivARB(uint obj, GLEnum pname, int* @params)
		{
			GetObjectParameterivARBNative(obj, pname, @params);
		}

		public static void GetObjectParameterivARB(uint obj, GLEnum pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetObjectParameterivARBNative(obj, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramBinaryNative(uint program, int bufSize, int* length, GLEnum* binaryFormat, void* binary)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, GLEnum*, void*, void>)funcTable[230])(program, bufSize, length, binaryFormat, binary);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, nint, void>)funcTable[230])(program, bufSize, (nint)length, (nint)binaryFormat, (nint)binary);
			#endif
		}

		public static void GetProgramBinary(uint program, int bufSize, int* length, GLEnum* binaryFormat, void* binary)
		{
			GetProgramBinaryNative(program, bufSize, length, binaryFormat, binary);
		}

		public static void GetProgramBinary(uint program, int bufSize, ref int length, GLEnum* binaryFormat, void* binary)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramBinaryNative(program, bufSize, plength0, binaryFormat, binary);
			}
		}

		public static void GetProgramBinary(uint program, int bufSize, int* length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (GLEnum* pbinaryFormat0 = &binaryFormat)
			{
				GetProgramBinaryNative(program, bufSize, length, pbinaryFormat0, binary);
			}
		}

		public static void GetProgramBinary(uint program, int bufSize, ref int length, ref GLEnum binaryFormat, void* binary)
		{
			fixed (int* plength0 = &length)
			{
				fixed (GLEnum* pbinaryFormat1 = &binaryFormat)
				{
					GetProgramBinaryNative(program, bufSize, plength0, pbinaryFormat1, binary);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramEnvParameterdvARBNative(GLProgramTarget target, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, double*, void>)funcTable[231])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[231])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramEnvParameterdvARB(GLProgramTarget target, uint index, double* @params)
		{
			GetProgramEnvParameterdvARBNative(target, index, @params);
		}

		public static void GetProgramEnvParameterdvARB(GLProgramTarget target, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetProgramEnvParameterdvARBNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramEnvParameterfvARBNative(GLProgramTarget target, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, float*, void>)funcTable[232])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[232])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramEnvParameterfvARB(GLProgramTarget target, uint index, float* @params)
		{
			GetProgramEnvParameterfvARBNative(target, index, @params);
		}

		public static void GetProgramEnvParameterfvARB(GLProgramTarget target, uint index, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetProgramEnvParameterfvARBNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramInterfaceivNative(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, int*, void>)funcTable[233])(program, programInterface, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, GLProgramInterfacePName, nint, void>)funcTable[233])(program, programInterface, pname, (nint)@params);
			#endif
		}

		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, int* @params)
		{
			GetProgramInterfaceivNative(program, programInterface, pname, @params);
		}

		public static void GetProgramInterfaceiv(uint program, GLProgramInterface programInterface, GLProgramInterfacePName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramInterfaceivNative(program, programInterface, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramLocalParameterdvARBNative(GLProgramTarget target, uint index, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, double*, void>)funcTable[234])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[234])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramLocalParameterdvARB(GLProgramTarget target, uint index, double* @params)
		{
			GetProgramLocalParameterdvARBNative(target, index, @params);
		}

		public static void GetProgramLocalParameterdvARB(GLProgramTarget target, uint index, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetProgramLocalParameterdvARBNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramLocalParameterfvARBNative(GLProgramTarget target, uint index, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, float*, void>)funcTable[235])(target, index, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, uint, nint, void>)funcTable[235])(target, index, (nint)@params);
			#endif
		}

		public static void GetProgramLocalParameterfvARB(GLProgramTarget target, uint index, float* @params)
		{
			GetProgramLocalParameterfvARBNative(target, index, @params);
		}

		public static void GetProgramLocalParameterfvARB(GLProgramTarget target, uint index, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetProgramLocalParameterfvARBNative(target, index, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineInfoLogNative(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[236])(pipeline, bufSize, length, infoLog);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[236])(pipeline, bufSize, (nint)length, (nint)infoLog);
			#endif
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, byte* infoLog)
		{
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, infoLog);
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, byte* infoLog)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, infoLog);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, string infoLog)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (infoLog != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(infoLog);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(infoLog, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, ReadOnlySpan<byte> infoLog)
		{
			fixed (byte* pinfoLog0 = infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, ref byte infoLog)
		{
			fixed (byte* pinfoLog0 = &infoLog)
			{
				GetProgramPipelineInfoLogNative(pipeline, bufSize, length, pinfoLog0);
			}
		}

		public static void GetProgramPipelineInfoLog(uint pipeline, int bufSize, ref int length, ref byte infoLog)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pinfoLog1 = &infoLog)
				{
					GetProgramPipelineInfoLogNative(pipeline, bufSize, plength0, pinfoLog1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramPipelineivNative(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, int*, void>)funcTable[237])(pipeline, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLPipelineParameterName, nint, void>)funcTable[237])(pipeline, pname, (nint)@params);
			#endif
		}

		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, int* @params)
		{
			GetProgramPipelineivNative(pipeline, pname, @params);
		}

		public static void GetProgramPipelineiv(uint pipeline, GLPipelineParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramPipelineivNative(pipeline, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetProgramResourceIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, uint>)funcTable[238])(program, programInterface, name);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, uint>)funcTable[238])(program, programInterface, (nint)name);
			#endif
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			uint ret = GetProgramResourceIndexNative(program, programInterface, name);
			return ret;
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetProgramResourceIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		public static uint GetProgramResourceIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				uint ret = GetProgramResourceIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[239])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[239])(program, programInterface, (nint)name);
			#endif
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationNative(program, programInterface, name);
			return ret;
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		public static int GetProgramResourceLocation(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetProgramResourceLocationIndexNative(uint program, GLProgramInterface programInterface, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, byte*, int>)funcTable[240])(program, programInterface, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, nint, int>)funcTable[240])(program, programInterface, (nint)name);
			#endif
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, byte* name)
		{
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, name);
			return ret;
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetProgramResourceLocationIndexNative(program, programInterface, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		public static int GetProgramResourceLocationIndex(uint program, GLProgramInterface programInterface, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetProgramResourceLocationIndexNative(program, programInterface, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourceNameNative(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, int*, byte*, void>)funcTable[241])(program, programInterface, index, bufSize, length, name);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, nint, nint, void>)funcTable[241])(program, programInterface, index, bufSize, (nint)length, (nint)name);
			#endif
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, byte* name)
		{
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, name);
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, ref int length, byte* name)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, name);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pname0);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, int* length, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				GetProgramResourceNameNative(program, programInterface, index, bufSize, length, pname0);
			}
		}

		public static void GetProgramResourceName(uint program, GLProgramInterface programInterface, uint index, int bufSize, ref int length, ref byte name)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* pname1 = &name)
				{
					GetProgramResourceNameNative(program, programInterface, index, bufSize, plength0, pname1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramResourceivNative(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLProgramResourceProperty, int, int*, int*, void>)funcTable[242])(program, programInterface, index, propCount, props, count, length, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLProgramInterface, uint, int, GLProgramResourceProperty, int, nint, nint, void>)funcTable[242])(program, programInterface, index, propCount, props, count, (nint)length, (nint)@params);
			#endif
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, int* @params)
		{
			GetProgramResourceivNative(program, programInterface, index, propCount, props, count, length, @params);
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, ref int length, int* @params)
		{
			fixed (int* plength0 = &length)
			{
				GetProgramResourceivNative(program, programInterface, index, propCount, props, count, plength0, @params);
			}
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, int* length, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramResourceivNative(program, programInterface, index, propCount, props, count, length, pparams0);
			}
		}

		public static void GetProgramResourceiv(uint program, GLProgramInterface programInterface, uint index, int propCount, GLProgramResourceProperty props, int count, ref int length, ref int @params)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* pparams1 = &@params)
				{
					GetProgramResourceivNative(program, programInterface, index, propCount, props, count, plength0, pparams1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramStageivNative(uint program, GLShaderType shadertype, GLProgramStagePName pname, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, GLProgramStagePName, int*, void>)funcTable[243])(program, shadertype, pname, values);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLShaderType, GLProgramStagePName, nint, void>)funcTable[243])(program, shadertype, pname, (nint)values);
			#endif
		}

		public static void GetProgramStageiv(uint program, GLShaderType shadertype, GLProgramStagePName pname, int* values)
		{
			GetProgramStageivNative(program, shadertype, pname, values);
		}

		public static void GetProgramStageiv(uint program, GLShaderType shadertype, GLProgramStagePName pname, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetProgramStageivNative(program, shadertype, pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramStringARBNative(GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, GLProgramStringProperty, void*, void>)funcTable[244])(target, pname, str);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, GLProgramStringProperty, nint, void>)funcTable[244])(target, pname, (nint)str);
			#endif
		}

		public static void GetProgramStringARB(GLProgramTarget target, GLProgramStringProperty pname, void* str)
		{
			GetProgramStringARBNative(target, pname, str);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetProgramivARBNative(GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLProgramTarget, GLProgramPropertyARB, int*, void>)funcTable[245])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLProgramTarget, GLProgramPropertyARB, nint, void>)funcTable[245])(target, pname, (nint)@params);
			#endif
		}

		public static void GetProgramivARB(GLProgramTarget target, GLProgramPropertyARB pname, int* @params)
		{
			GetProgramivARBNative(target, pname, @params);
		}

		public static void GetProgramivARB(GLProgramTarget target, GLProgramPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetProgramivARBNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjecti64vNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[246])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[246])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjecti64v(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjecti64vNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectivNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[247])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[247])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjectiv(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectivNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectui64vNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[248])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[248])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjectui64v(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectui64vNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryBufferObjectuivNative(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[249])(id, buffer, pname, offset);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLQueryObjectParameterName, nint, void>)funcTable[249])(id, buffer, pname, offset);
			#endif
		}

		public static void GetQueryBufferObjectuiv(uint id, uint buffer, GLQueryObjectParameterName pname, nint offset)
		{
			GetQueryBufferObjectuivNative(id, buffer, pname, offset);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryIndexedivNative(GLQueryTarget target, uint index, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, GLQueryParameterName, int*, void>)funcTable[250])(target, index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, uint, GLQueryParameterName, nint, void>)funcTable[250])(target, index, pname, (nint)@params);
			#endif
		}

		public static void GetQueryIndexediv(GLQueryTarget target, uint index, GLQueryParameterName pname, int* @params)
		{
			GetQueryIndexedivNative(target, index, pname, @params);
		}

		public static void GetQueryIndexediv(GLQueryTarget target, uint index, GLQueryParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryIndexedivNative(target, index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjecti64vNative(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, long*, void>)funcTable[251])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[251])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, long* @params)
		{
			GetQueryObjecti64vNative(id, pname, @params);
		}

		public static void GetQueryObjecti64v(uint id, GLQueryObjectParameterName pname, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetQueryObjecti64vNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectivARBNative(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, int*, void>)funcTable[252])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[252])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectivARB(uint id, GLQueryObjectParameterName pname, int* @params)
		{
			GetQueryObjectivARBNative(id, pname, @params);
		}

		public static void GetQueryObjectivARB(uint id, GLQueryObjectParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryObjectivARBNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectui64vNative(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, ulong*, void>)funcTable[253])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[253])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, ulong* @params)
		{
			GetQueryObjectui64vNative(id, pname, @params);
		}

		public static void GetQueryObjectui64v(uint id, GLQueryObjectParameterName pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetQueryObjectui64vNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryObjectuivARBNative(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, uint*, void>)funcTable[254])(id, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLQueryObjectParameterName, nint, void>)funcTable[254])(id, pname, (nint)@params);
			#endif
		}

		public static void GetQueryObjectuivARB(uint id, GLQueryObjectParameterName pname, uint* @params)
		{
			GetQueryObjectuivARBNative(id, pname, @params);
		}

		public static void GetQueryObjectuivARB(uint id, GLQueryObjectParameterName pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetQueryObjectuivARBNative(id, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetQueryivARBNative(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, int*, void>)funcTable[255])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLQueryTarget, GLQueryParameterName, nint, void>)funcTable[255])(target, pname, (nint)@params);
			#endif
		}

		public static void GetQueryivARB(GLQueryTarget target, GLQueryParameterName pname, int* @params)
		{
			GetQueryivARBNative(target, pname, @params);
		}

		public static void GetQueryivARB(GLQueryTarget target, GLQueryParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetQueryivARBNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetRenderbufferParameterivNative(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, int*, void>)funcTable[256])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLRenderbufferTarget, GLRenderbufferParameterName, nint, void>)funcTable[256])(target, pname, (nint)@params);
			#endif
		}

		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, int* @params)
		{
			GetRenderbufferParameterivNative(target, pname, @params);
		}

		public static void GetRenderbufferParameteriv(GLRenderbufferTarget target, GLRenderbufferParameterName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetRenderbufferParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[257])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[257])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterIivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIiv(uint sampler, GLSamplerParameterI pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetSamplerParameterIivNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterIuivNative(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, uint*, void>)funcTable[258])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[258])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, uint* @params)
		{
			GetSamplerParameterIuivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterIuiv(uint sampler, GLSamplerParameterI pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetSamplerParameterIuivNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterfvNative(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, float*, void>)funcTable[259])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterF, nint, void>)funcTable[259])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, float* @params)
		{
			GetSamplerParameterfvNative(sampler, pname, @params);
		}

		public static void GetSamplerParameterfv(uint sampler, GLSamplerParameterF pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetSamplerParameterfvNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSamplerParameterivNative(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, int*, void>)funcTable[260])(sampler, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLSamplerParameterI, nint, void>)funcTable[260])(sampler, pname, (nint)@params);
			#endif
		}

		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, int* @params)
		{
			GetSamplerParameterivNative(sampler, pname, @params);
		}

		public static void GetSamplerParameteriv(uint sampler, GLSamplerParameterI pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetSamplerParameterivNative(sampler, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSeparableFilterNative(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, void*, void*, void*, void>)funcTable[261])(target, format, type, row, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, nint, nint, nint, void>)funcTable[261])(target, format, type, (nint)row, (nint)column, (nint)span);
			#endif
		}

		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			GetSeparableFilterNative(target, format, type, row, column, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderPrecisionFormatNative(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, int*, int*, void>)funcTable[262])(shadertype, precisiontype, range, precision);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, nint, nint, void>)funcTable[262])(shadertype, precisiontype, (nint)range, (nint)precision);
			#endif
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			GetShaderPrecisionFormatNative(shadertype, precisiontype, range, precision);
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, int* precision)
		{
			fixed (int* prange0 = &range)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, precision);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, ref int precision)
		{
			fixed (int* pprecision0 = &precision)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, range, pprecision0);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, ref int precision)
		{
			fixed (int* prange0 = &range)
			{
				fixed (int* pprecision1 = &precision)
				{
					GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, pprecision1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderSourceARBNative(uint obj, int maxLength, int* length, byte* source)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, byte*, void>)funcTable[263])(obj, maxLength, length, source);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[263])(obj, maxLength, (nint)length, (nint)source);
			#endif
		}

		public static void GetShaderSourceARB(uint obj, int maxLength, int* length, byte* source)
		{
			GetShaderSourceARBNative(obj, maxLength, length, source);
		}

		public static void GetShaderSourceARB(uint obj, int maxLength, ref int length, byte* source)
		{
			fixed (int* plength0 = &length)
			{
				GetShaderSourceARBNative(obj, maxLength, plength0, source);
			}
		}

		public static void GetShaderSourceARB(uint obj, int maxLength, int* length, string source)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (source != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(source);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(source, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetShaderSourceARBNative(obj, maxLength, length, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetShaderSourceARB(uint obj, int maxLength, int* length, ReadOnlySpan<byte> source)
		{
			fixed (byte* psource0 = source)
			{
				GetShaderSourceARBNative(obj, maxLength, length, psource0);
			}
		}

		public static void GetShaderSourceARB(uint obj, int maxLength, int* length, ref byte source)
		{
			fixed (byte* psource0 = &source)
			{
				GetShaderSourceARBNative(obj, maxLength, length, psource0);
			}
		}

		public static void GetShaderSourceARB(uint obj, int maxLength, ref int length, ref byte source)
		{
			fixed (int* plength0 = &length)
			{
				fixed (byte* psource1 = &source)
				{
					GetShaderSourceARBNative(obj, maxLength, plength0, psource1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetSubroutineIndexNative(uint program, GLShaderType shadertype, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLShaderType, byte*, uint>)funcTable[264])(program, shadertype, name);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, GLShaderType, nint, uint>)funcTable[264])(program, shadertype, (nint)name);
			#endif
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, byte* name)
		{
			uint ret = GetSubroutineIndexNative(program, shadertype, name);
			return ret;
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetSubroutineIndexNative(program, shadertype, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				uint ret = GetSubroutineIndexNative(program, shadertype, pname0);
				return ret;
			}
		}

		public static uint GetSubroutineIndex(uint program, GLShaderType shadertype, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				uint ret = GetSubroutineIndexNative(program, shadertype, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetSubroutineUniformLocationNative(uint program, GLShaderType shadertype, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLShaderType, byte*, int>)funcTable[265])(program, shadertype, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, GLShaderType, nint, int>)funcTable[265])(program, shadertype, (nint)name);
			#endif
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, byte* name)
		{
			int ret = GetSubroutineUniformLocationNative(program, shadertype, name);
			return ret;
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetSubroutineUniformLocationNative(program, shadertype, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetSubroutineUniformLocationNative(program, shadertype, pname0);
				return ret;
			}
		}

		public static int GetSubroutineUniformLocation(uint program, GLShaderType shadertype, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetSubroutineUniformLocationNative(program, shadertype, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSyncivNative(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, int*, int*, void>)funcTable[266])(sync, pname, count, length, values);
			#else
			((delegate* unmanaged[Cdecl]<GLSync, GLSyncParameterName, int, nint, nint, void>)funcTable[266])(sync, pname, count, (nint)length, (nint)values);
			#endif
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, int* values)
		{
			GetSyncivNative(sync, pname, count, length, values);
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, int* values)
		{
			fixed (int* plength0 = &length)
			{
				GetSyncivNative(sync, pname, count, plength0, values);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, int* length, ref int values)
		{
			fixed (int* pvalues0 = &values)
			{
				GetSyncivNative(sync, pname, count, length, pvalues0);
			}
		}

		public static void GetSynciv(GLSync sync, GLSyncParameterName pname, int count, ref int length, ref int values)
		{
			fixed (int* plength0 = &length)
			{
				fixed (int* pvalues1 = &values)
				{
					GetSyncivNative(sync, pname, count, plength0, pvalues1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTextureHandleARBNative(uint texture)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, ulong>)funcTable[267])(texture);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, ulong>)funcTable[267])(texture);
			#endif
		}

		public static ulong GetTextureHandleARB(uint texture)
		{
			ulong ret = GetTextureHandleARBNative(texture);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureImageNative(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[268])(texture, level, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[268])(texture, level, format, type, bufSize, (nint)pixels);
			#endif
		}

		public static void GetTextureImage(uint texture, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetTextureImageNative(texture, level, format, type, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterfvNative(uint texture, int level, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, float*, void>)funcTable[269])(texture, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, nint, void>)funcTable[269])(texture, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameterfv(uint texture, int level, GLGetTextureParameter pname, float* @params)
		{
			GetTextureLevelParameterfvNative(texture, level, pname, @params);
		}

		public static void GetTextureLevelParameterfv(uint texture, int level, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureLevelParameterfvNative(texture, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureLevelParameterivNative(uint texture, int level, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, int*, void>)funcTable[270])(texture, level, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLGetTextureParameter, nint, void>)funcTable[270])(texture, level, pname, (nint)@params);
			#endif
		}

		public static void GetTextureLevelParameteriv(uint texture, int level, GLGetTextureParameter pname, int* @params)
		{
			GetTextureLevelParameterivNative(texture, level, pname, @params);
		}

		public static void GetTextureLevelParameteriv(uint texture, int level, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureLevelParameterivNative(texture, level, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIivNative(uint texture, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, int*, void>)funcTable[271])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[271])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIiv(uint texture, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterIivNative(texture, pname, @params);
		}

		public static void GetTextureParameterIiv(uint texture, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterIivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterIuivNative(uint texture, GLGetTextureParameter pname, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, uint*, void>)funcTable[272])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[272])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterIuiv(uint texture, GLGetTextureParameter pname, uint* @params)
		{
			GetTextureParameterIuivNative(texture, pname, @params);
		}

		public static void GetTextureParameterIuiv(uint texture, GLGetTextureParameter pname, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetTextureParameterIuivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterfvNative(uint texture, GLGetTextureParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, float*, void>)funcTable[273])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[273])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameterfv(uint texture, GLGetTextureParameter pname, float* @params)
		{
			GetTextureParameterfvNative(texture, pname, @params);
		}

		public static void GetTextureParameterfv(uint texture, GLGetTextureParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetTextureParameterfvNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureParameterivNative(uint texture, GLGetTextureParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, int*, void>)funcTable[274])(texture, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLGetTextureParameter, nint, void>)funcTable[274])(texture, pname, (nint)@params);
			#endif
		}

		public static void GetTextureParameteriv(uint texture, GLGetTextureParameter pname, int* @params)
		{
			GetTextureParameterivNative(texture, pname, @params);
		}

		public static void GetTextureParameteriv(uint texture, GLGetTextureParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetTextureParameterivNative(texture, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static ulong GetTextureSamplerHandleARBNative(uint texture, uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, uint, ulong>)funcTable[275])(texture, sampler);
			#else
			return (ulong)((delegate* unmanaged[Cdecl]<uint, uint, ulong>)funcTable[275])(texture, sampler);
			#endif
		}

		public static ulong GetTextureSamplerHandleARB(uint texture, uint sampler)
		{
			ulong ret = GetTextureSamplerHandleARBNative(texture, sampler);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTextureSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[276])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[276])(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, (nint)pixels);
			#endif
		}

		public static void GetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, GLPixelFormat format, GLPixelType type, int bufSize, void* pixels)
		{
			GetTextureSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbacki64_vNative(uint xfb, GLTransformFeedbackPName pname, uint index, long* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, long*, void>)funcTable[277])(xfb, pname, index, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, nint, void>)funcTable[277])(xfb, pname, index, (nint)param);
			#endif
		}

		public static void GetTransformFeedbacki64_v(uint xfb, GLTransformFeedbackPName pname, uint index, long* param)
		{
			GetTransformFeedbacki64_vNative(xfb, pname, index, param);
		}

		public static void GetTransformFeedbacki64_v(uint xfb, GLTransformFeedbackPName pname, uint index, ref long param)
		{
			fixed (long* pparam0 = &param)
			{
				GetTransformFeedbacki64_vNative(xfb, pname, index, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbacki_vNative(uint xfb, GLTransformFeedbackPName pname, uint index, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, int*, void>)funcTable[278])(xfb, pname, index, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, uint, nint, void>)funcTable[278])(xfb, pname, index, (nint)param);
			#endif
		}

		public static void GetTransformFeedbacki_v(uint xfb, GLTransformFeedbackPName pname, uint index, int* param)
		{
			GetTransformFeedbacki_vNative(xfb, pname, index, param);
		}

		public static void GetTransformFeedbacki_v(uint xfb, GLTransformFeedbackPName pname, uint index, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetTransformFeedbacki_vNative(xfb, pname, index, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetTransformFeedbackivNative(uint xfb, GLTransformFeedbackPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, int*, void>)funcTable[279])(xfb, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLTransformFeedbackPName, nint, void>)funcTable[279])(xfb, pname, (nint)param);
			#endif
		}

		public static void GetTransformFeedbackiv(uint xfb, GLTransformFeedbackPName pname, int* param)
		{
			GetTransformFeedbackivNative(xfb, pname, param);
		}

		public static void GetTransformFeedbackiv(uint xfb, GLTransformFeedbackPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetTransformFeedbackivNative(xfb, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static uint GetUniformBlockIndexNative(uint program, byte* uniformBlockName)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, uint>)funcTable[280])(program, uniformBlockName);
			#else
			return (uint)((delegate* unmanaged[Cdecl]<uint, nint, uint>)funcTable[280])(program, (nint)uniformBlockName);
			#endif
		}

		public static uint GetUniformBlockIndex(uint program, byte* uniformBlockName)
		{
			uint ret = GetUniformBlockIndexNative(program, uniformBlockName);
			return ret;
		}

		public static uint GetUniformBlockIndex(uint program, string uniformBlockName)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (uniformBlockName != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(uniformBlockName);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(uniformBlockName, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			uint ret = GetUniformBlockIndexNative(program, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static uint GetUniformBlockIndex(uint program, ReadOnlySpan<byte> uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		public static uint GetUniformBlockIndex(uint program, ref byte uniformBlockName)
		{
			fixed (byte* puniformBlockName0 = &uniformBlockName)
			{
				uint ret = GetUniformBlockIndexNative(program, puniformBlockName0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformIndicesNative(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, byte**, uint*, void>)funcTable[281])(program, uniformCount, uniformNames, uniformIndices);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, nint, void>)funcTable[281])(program, uniformCount, (nint)uniformNames, (nint)uniformIndices);
			#endif
		}

		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, uint* uniformIndices)
		{
			GetUniformIndicesNative(program, uniformCount, uniformNames, uniformIndices);
		}

		public static void GetUniformIndices(uint program, int uniformCount, byte** uniformNames, ref uint uniformIndices)
		{
			fixed (uint* puniformIndices0 = &uniformIndices)
			{
				GetUniformIndicesNative(program, uniformCount, uniformNames, puniformIndices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int GetUniformLocationARBNative(uint programObj, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte*, int>)funcTable[282])(programObj, name);
			#else
			return (int)((delegate* unmanaged[Cdecl]<uint, nint, int>)funcTable[282])(programObj, (nint)name);
			#endif
		}

		public static int GetUniformLocationARB(uint programObj, byte* name)
		{
			int ret = GetUniformLocationARBNative(programObj, name);
			return ret;
		}

		public static int GetUniformLocationARB(uint programObj, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			int ret = GetUniformLocationARBNative(programObj, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret;
		}

		public static int GetUniformLocationARB(uint programObj, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				int ret = GetUniformLocationARBNative(programObj, pname0);
				return ret;
			}
		}

		public static int GetUniformLocationARB(uint programObj, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				int ret = GetUniformLocationARBNative(programObj, pname0);
				return ret;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformSubroutineuivNative(GLShaderType shadertype, int location, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, int, uint*, void>)funcTable[283])(shadertype, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, int, nint, void>)funcTable[283])(shadertype, location, (nint)@params);
			#endif
		}

		public static void GetUniformSubroutineuiv(GLShaderType shadertype, int location, uint* @params)
		{
			GetUniformSubroutineuivNative(shadertype, location, @params);
		}

		public static void GetUniformSubroutineuiv(GLShaderType shadertype, int location, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetUniformSubroutineuivNative(shadertype, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformdvNative(uint program, int location, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, double*, void>)funcTable[284])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[284])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformdv(uint program, int location, double* @params)
		{
			GetUniformdvNative(program, location, @params);
		}

		public static void GetUniformdv(uint program, int location, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetUniformdvNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformfvARBNative(uint programObj, int location, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, float*, void>)funcTable[285])(programObj, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[285])(programObj, location, (nint)@params);
			#endif
		}

		public static void GetUniformfvARB(uint programObj, int location, float* @params)
		{
			GetUniformfvARBNative(programObj, location, @params);
		}

		public static void GetUniformfvARB(uint programObj, int location, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetUniformfvARBNative(programObj, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformi64vARBNative(uint program, int location, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, long*, void>)funcTable[286])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[286])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformi64vARB(uint program, int location, long* @params)
		{
			GetUniformi64vARBNative(program, location, @params);
		}

		public static void GetUniformi64vARB(uint program, int location, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetUniformi64vARBNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformivARBNative(uint programObj, int location, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int*, void>)funcTable[287])(programObj, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[287])(programObj, location, (nint)@params);
			#endif
		}

		public static void GetUniformivARB(uint programObj, int location, int* @params)
		{
			GetUniformivARBNative(programObj, location, @params);
		}

		public static void GetUniformivARB(uint programObj, int location, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetUniformivARBNative(programObj, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetUniformui64vARBNative(uint program, int location, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, ulong*, void>)funcTable[288])(program, location, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, nint, void>)funcTable[288])(program, location, (nint)@params);
			#endif
		}

		public static void GetUniformui64vARB(uint program, int location, ulong* @params)
		{
			GetUniformui64vARBNative(program, location, @params);
		}

		public static void GetUniformui64vARB(uint program, int location, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetUniformui64vARBNative(program, location, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIndexed64ivNative(uint vaobj, uint index, GLVertexArrayPName pname, long* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, long*, void>)funcTable[289])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[289])(vaobj, index, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayIndexed64iv(uint vaobj, uint index, GLVertexArrayPName pname, long* param)
		{
			GetVertexArrayIndexed64ivNative(vaobj, index, pname, param);
		}

		public static void GetVertexArrayIndexed64iv(uint vaobj, uint index, GLVertexArrayPName pname, ref long param)
		{
			fixed (long* pparam0 = &param)
			{
				GetVertexArrayIndexed64ivNative(vaobj, index, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayIndexedivNative(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, int*, void>)funcTable[290])(vaobj, index, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, GLVertexArrayPName, nint, void>)funcTable[290])(vaobj, index, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayIndexediv(uint vaobj, uint index, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayIndexedivNative(vaobj, index, pname, param);
		}

		public static void GetVertexArrayIndexediv(uint vaobj, uint index, GLVertexArrayPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetVertexArrayIndexedivNative(vaobj, index, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexArrayivNative(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, int*, void>)funcTable[291])(vaobj, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexArrayPName, nint, void>)funcTable[291])(vaobj, pname, (nint)param);
			#endif
		}

		public static void GetVertexArrayiv(uint vaobj, GLVertexArrayPName pname, int* param)
		{
			GetVertexArrayivNative(vaobj, pname, param);
		}

		public static void GetVertexArrayiv(uint vaobj, GLVertexArrayPName pname, ref int param)
		{
			fixed (int* pparam0 = &param)
			{
				GetVertexArrayivNative(vaobj, pname, pparam0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribLdvNative(uint index, GLVertexAttribEnum pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, double*, void>)funcTable[292])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[292])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribLdv(uint index, GLVertexAttribEnum pname, double* @params)
		{
			GetVertexAttribLdvNative(index, pname, @params);
		}

		public static void GetVertexAttribLdv(uint index, GLVertexAttribEnum pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribLdvNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribLui64vARBNative(uint index, GLVertexAttribEnum pname, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, ulong*, void>)funcTable[293])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribEnum, nint, void>)funcTable[293])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribLui64vARB(uint index, GLVertexAttribEnum pname, ulong* @params)
		{
			GetVertexAttribLui64vARBNative(index, pname, @params);
		}

		public static void GetVertexAttribLui64vARB(uint index, GLVertexAttribEnum pname, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetVertexAttribLui64vARBNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribPointervARBNative(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, void**, void>)funcTable[294])(index, pname, pointer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPointerPropertyARB, nint, void>)funcTable[294])(index, pname, (nint)pointer);
			#endif
		}

		public static void GetVertexAttribPointervARB(uint index, GLVertexAttribPointerPropertyARB pname, void** pointer)
		{
			GetVertexAttribPointervARBNative(index, pname, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribdvARBNative(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, double*, void>)funcTable[295])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[295])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribdvARB(uint index, GLVertexAttribPropertyARB pname, double* @params)
		{
			GetVertexAttribdvARBNative(index, pname, @params);
		}

		public static void GetVertexAttribdvARB(uint index, GLVertexAttribPropertyARB pname, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetVertexAttribdvARBNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribfvARBNative(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, float*, void>)funcTable[296])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[296])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribfvARB(uint index, GLVertexAttribPropertyARB pname, float* @params)
		{
			GetVertexAttribfvARBNative(index, pname, @params);
		}

		public static void GetVertexAttribfvARB(uint index, GLVertexAttribPropertyARB pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetVertexAttribfvARBNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetVertexAttribivARBNative(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, int*, void>)funcTable[297])(index, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLVertexAttribPropertyARB, nint, void>)funcTable[297])(index, pname, (nint)@params);
			#endif
		}

		public static void GetVertexAttribivARB(uint index, GLVertexAttribPropertyARB pname, int* @params)
		{
			GetVertexAttribivARBNative(index, pname, @params);
		}

		public static void GetVertexAttribivARB(uint index, GLVertexAttribPropertyARB pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetVertexAttribivARBNative(index, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnColorTableARBNative(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[298])(target, format, type, bufSize, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[298])(target, format, type, bufSize, (nint)table);
			#endif
		}

		public static void GetnColorTableARB(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* table)
		{
			GetnColorTableARBNative(target, format, type, bufSize, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnCompressedTexImageARBNative(GLTextureTarget target, int lod, int bufSize, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, void*, void>)funcTable[299])(target, lod, bufSize, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, nint, void>)funcTable[299])(target, lod, bufSize, (nint)img);
			#endif
		}

		public static void GetnCompressedTexImageARB(GLTextureTarget target, int lod, int bufSize, void* img)
		{
			GetnCompressedTexImageARBNative(target, lod, bufSize, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnConvolutionFilterARBNative(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[300])(target, format, type, bufSize, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[300])(target, format, type, bufSize, (nint)image);
			#endif
		}

		public static void GetnConvolutionFilterARB(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* image)
		{
			GetnConvolutionFilterARBNative(target, format, type, bufSize, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnHistogramARBNative(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[301])(target, reset, format, type, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[301])(target, reset, format, type, bufSize, (nint)values);
			#endif
		}

		public static void GetnHistogramARB(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			GetnHistogramARBNative(target, reset, format, type, bufSize, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapdvARBNative(GLMapTarget target, GLMapQuery query, int bufSize, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, double*, void>)funcTable[302])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[302])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapdvARB(GLMapTarget target, GLMapQuery query, int bufSize, double* v)
		{
			GetnMapdvARBNative(target, query, bufSize, v);
		}

		public static void GetnMapdvARB(GLMapTarget target, GLMapQuery query, int bufSize, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				GetnMapdvARBNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapfvARBNative(GLMapTarget target, GLMapQuery query, int bufSize, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, float*, void>)funcTable[303])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[303])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapfvARB(GLMapTarget target, GLMapQuery query, int bufSize, float* v)
		{
			GetnMapfvARBNative(target, query, bufSize, v);
		}

		public static void GetnMapfvARB(GLMapTarget target, GLMapQuery query, int bufSize, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetnMapfvARBNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapivARBNative(GLMapTarget target, GLMapQuery query, int bufSize, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, int*, void>)funcTable[304])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[304])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapivARB(GLMapTarget target, GLMapQuery query, int bufSize, int* v)
		{
			GetnMapivARBNative(target, query, bufSize, v);
		}

		public static void GetnMapivARB(GLMapTarget target, GLMapQuery query, int bufSize, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				GetnMapivARBNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMinmaxARBNative(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[305])(target, reset, format, type, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[305])(target, reset, format, type, bufSize, (nint)values);
			#endif
		}

		public static void GetnMinmaxARB(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			GetnMinmaxARBNative(target, reset, format, type, bufSize, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapfvARBNative(GLPixelMap map, int bufSize, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, float*, void>)funcTable[306])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[306])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapfvARB(GLPixelMap map, int bufSize, float* values)
		{
			GetnPixelMapfvARBNative(map, bufSize, values);
		}

		public static void GetnPixelMapfvARB(GLPixelMap map, int bufSize, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				GetnPixelMapfvARBNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapuivARBNative(GLPixelMap map, int bufSize, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, uint*, void>)funcTable[307])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[307])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapuivARB(GLPixelMap map, int bufSize, uint* values)
		{
			GetnPixelMapuivARBNative(map, bufSize, values);
		}

		public static void GetnPixelMapuivARB(GLPixelMap map, int bufSize, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				GetnPixelMapuivARBNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapusvARBNative(GLPixelMap map, int bufSize, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, ushort*, void>)funcTable[308])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[308])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapusvARB(GLPixelMap map, int bufSize, ushort* values)
		{
			GetnPixelMapusvARBNative(map, bufSize, values);
		}

		public static void GetnPixelMapusvARB(GLPixelMap map, int bufSize, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				GetnPixelMapusvARBNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPolygonStippleARBNative(int bufSize, byte* pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[309])(bufSize, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[309])(bufSize, (nint)pattern);
			#endif
		}

		public static void GetnPolygonStippleARB(int bufSize, byte* pattern)
		{
			GetnPolygonStippleARBNative(bufSize, pattern);
		}

		public static void GetnPolygonStippleARB(int bufSize, string pattern)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetnPolygonStippleARBNative(bufSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetnPolygonStippleARB(int bufSize, ReadOnlySpan<byte> pattern)
		{
			fixed (byte* ppattern0 = pattern)
			{
				GetnPolygonStippleARBNative(bufSize, ppattern0);
			}
		}

		public static void GetnPolygonStippleARB(int bufSize, ref byte pattern)
		{
			fixed (byte* ppattern0 = &pattern)
			{
				GetnPolygonStippleARBNative(bufSize, ppattern0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnSeparableFilterARBNative(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, int, void*, int, void*, void*, void>)funcTable[310])(target, format, type, rowBufSize, row, columnBufSize, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, int, nint, int, nint, nint, void>)funcTable[310])(target, format, type, rowBufSize, (nint)row, columnBufSize, (nint)column, (nint)span);
			#endif
		}

		public static void GetnSeparableFilterARB(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
		{
			GetnSeparableFilterARBNative(target, format, type, rowBufSize, row, columnBufSize, column, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnTexImageARBNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[311])(target, level, format, type, bufSize, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[311])(target, level, format, type, bufSize, (nint)img);
			#endif
		}

		public static void GetnTexImageARB(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* img)
		{
			GetnTexImageARBNative(target, level, format, type, bufSize, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformdvARBNative(uint program, int location, int bufSize, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[312])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[312])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformdvARB(uint program, int location, int bufSize, double* @params)
		{
			GetnUniformdvARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformdvARB(uint program, int location, int bufSize, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetnUniformdvARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformfvARBNative(uint program, int location, int bufSize, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[313])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[313])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformfvARB(uint program, int location, int bufSize, float* @params)
		{
			GetnUniformfvARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformfvARB(uint program, int location, int bufSize, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetnUniformfvARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformi64vARBNative(uint program, int location, int bufSize, long* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, long*, void>)funcTable[314])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[314])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformi64vARB(uint program, int location, int bufSize, long* @params)
		{
			GetnUniformi64vARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformi64vARB(uint program, int location, int bufSize, ref long @params)
		{
			fixed (long* pparams0 = &@params)
			{
				GetnUniformi64vARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformivARBNative(uint program, int location, int bufSize, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[315])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[315])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformivARB(uint program, int location, int bufSize, int* @params)
		{
			GetnUniformivARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformivARB(uint program, int location, int bufSize, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetnUniformivARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformui64vARBNative(uint program, int location, int bufSize, ulong* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, ulong*, void>)funcTable[316])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[316])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformui64vARB(uint program, int location, int bufSize, ulong* @params)
		{
			GetnUniformui64vARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformui64vARB(uint program, int location, int bufSize, ref ulong @params)
		{
			fixed (ulong* pparams0 = &@params)
			{
				GetnUniformui64vARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformuivARBNative(uint program, int location, int bufSize, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[317])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[317])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformuivARB(uint program, int location, int bufSize, uint* @params)
		{
			GetnUniformuivARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformuivARB(uint program, int location, int bufSize, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetnUniformuivARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HistogramNative(GLHistogramTargetEXT target, int width, GLInternalFormat internalformat, byte sink)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, int, GLInternalFormat, byte, void>)funcTable[318])(target, width, internalformat, sink);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, int, GLInternalFormat, byte, void>)funcTable[318])(target, width, internalformat, sink);
			#endif
		}

		public static void Histogram(GLHistogramTargetEXT target, int width, GLInternalFormat internalformat, byte sink)
		{
			HistogramNative(target, width, internalformat, sink);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateBufferDataNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[319])(buffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[319])(buffer);
			#endif
		}

		public static void InvalidateBufferData(uint buffer)
		{
			InvalidateBufferDataNative(buffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateBufferSubDataNative(uint buffer, nint offset, nint length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[320])(buffer, offset, length);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void>)funcTable[320])(buffer, offset, length);
			#endif
		}

		public static void InvalidateBufferSubData(uint buffer, nint offset, nint length)
		{
			InvalidateBufferSubDataNative(buffer, offset, length);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateFramebufferNative(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, void>)funcTable[321])(target, numAttachments, attachments);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, void>)funcTable[321])(target, numAttachments, attachments);
			#endif
		}

		public static void InvalidateFramebuffer(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments)
		{
			InvalidateFramebufferNative(target, numAttachments, attachments);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateNamedFramebufferDataNative(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, void>)funcTable[322])(framebuffer, numAttachments, attachments);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, void>)funcTable[322])(framebuffer, numAttachments, attachments);
			#endif
		}

		public static void InvalidateNamedFramebufferData(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments)
		{
			InvalidateNamedFramebufferDataNative(framebuffer, numAttachments, attachments);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateNamedFramebufferSubDataNative(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, int, int, int, int, void>)funcTable[323])(framebuffer, numAttachments, attachments, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLFramebufferAttachment, int, int, int, int, void>)funcTable[323])(framebuffer, numAttachments, attachments, x, y, width, height);
			#endif
		}

		public static void InvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, GLFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			InvalidateNamedFramebufferSubDataNative(framebuffer, numAttachments, attachments, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateSubFramebufferNative(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, int, int, int, int, void>)funcTable[324])(target, numAttachments, attachments, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLFramebufferTarget, int, GLInvalidateFramebufferAttachment, int, int, int, int, void>)funcTable[324])(target, numAttachments, attachments, x, y, width, height);
			#endif
		}

		public static void InvalidateSubFramebuffer(GLFramebufferTarget target, int numAttachments, GLInvalidateFramebufferAttachment attachments, int x, int y, int width, int height)
		{
			InvalidateSubFramebufferNative(target, numAttachments, attachments, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateTexImageNative(uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[325])(texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, void>)funcTable[325])(texture, level);
			#endif
		}

		public static void InvalidateTexImage(uint texture, int level)
		{
			InvalidateTexImageNative(texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void InvalidateTexSubImageNative(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[326])(texture, level, xoffset, yoffset, zoffset, width, height, depth);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, int, int, int, int, int, void>)funcTable[326])(texture, level, xoffset, yoffset, zoffset, width, height, depth);
			#endif
		}

		public static void InvalidateTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth)
		{
			InvalidateTexSubImageNative(texture, level, xoffset, yoffset, zoffset, width, height, depth);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsBufferARBNative(uint buffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[327])(buffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[327])(buffer);
			#endif
		}

		public static bool IsBufferARB(uint buffer)
		{
			byte ret = IsBufferARBNative(buffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsFramebufferNative(uint framebuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[328])(framebuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[328])(framebuffer);
			#endif
		}

		public static bool IsFramebuffer(uint framebuffer)
		{
			byte ret = IsFramebufferNative(framebuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsImageHandleResidentARBNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[329])(handle);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[329])(handle);
			#endif
		}

		public static bool IsImageHandleResidentARB(ulong handle)
		{
			byte ret = IsImageHandleResidentARBNative(handle);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsNamedStringARBNative(int namelen, byte* name)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int, byte*, byte>)funcTable[330])(namelen, name);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<int, nint, byte>)funcTable[330])(namelen, (nint)name);
			#endif
		}

		public static bool IsNamedStringARB(int namelen, byte* name)
		{
			byte ret = IsNamedStringARBNative(namelen, name);
			return ret != 0;
		}

		public static bool IsNamedStringARB(int namelen, string name)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte ret = IsNamedStringARBNative(namelen, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			return ret != 0;
		}

		public static bool IsNamedStringARB(int namelen, ReadOnlySpan<byte> name)
		{
			fixed (byte* pname0 = name)
			{
				byte ret = IsNamedStringARBNative(namelen, pname0);
				return ret != 0;
			}
		}

		public static bool IsNamedStringARB(int namelen, ref byte name)
		{
			fixed (byte* pname0 = &name)
			{
				byte ret = IsNamedStringARBNative(namelen, pname0);
				return ret != 0;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramARBNative(uint program)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[331])(program);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[331])(program);
			#endif
		}

		public static bool IsProgramARB(uint program)
		{
			byte ret = IsProgramARBNative(program);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsProgramPipelineNative(uint pipeline)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[332])(pipeline);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[332])(pipeline);
			#endif
		}

		public static bool IsProgramPipeline(uint pipeline)
		{
			byte ret = IsProgramPipelineNative(pipeline);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsQueryARBNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[333])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[333])(id);
			#endif
		}

		public static bool IsQueryARB(uint id)
		{
			byte ret = IsQueryARBNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsRenderbufferNative(uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[334])(renderbuffer);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[334])(renderbuffer);
			#endif
		}

		public static bool IsRenderbuffer(uint renderbuffer)
		{
			byte ret = IsRenderbufferNative(renderbuffer);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSamplerNative(uint sampler)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[335])(sampler);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[335])(sampler);
			#endif
		}

		public static bool IsSampler(uint sampler)
		{
			byte ret = IsSamplerNative(sampler);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsSyncNative(GLSync sync)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[336])(sync);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<GLSync, byte>)funcTable[336])(sync);
			#endif
		}

		public static bool IsSync(GLSync sync)
		{
			byte ret = IsSyncNative(sync);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTextureHandleResidentARBNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[337])(handle);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<ulong, byte>)funcTable[337])(handle);
			#endif
		}

		public static bool IsTextureHandleResidentARB(ulong handle)
		{
			byte ret = IsTextureHandleResidentARBNative(handle);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsTransformFeedbackNative(uint id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[338])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[338])(id);
			#endif
		}

		public static bool IsTransformFeedback(uint id)
		{
			byte ret = IsTransformFeedbackNative(id);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte IsVertexArrayNative(uint array)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[339])(array);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<uint, byte>)funcTable[339])(array);
			#endif
		}

		public static bool IsVertexArray(uint array)
		{
			byte ret = IsVertexArrayNative(array);
			return ret != 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LinkProgramARBNative(uint programObj)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[340])(programObj);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[340])(programObj);
			#endif
		}

		public static void LinkProgramARB(uint programObj)
		{
			LinkProgramARBNative(programObj);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixdARBNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[341])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[341])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixdARB(double* m)
		{
			LoadTransposeMatrixdARBNative(m);
		}

		public static void LoadTransposeMatrixdARB(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				LoadTransposeMatrixdARBNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void LoadTransposeMatrixfARBNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[342])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[342])((nint)m);
			#endif
		}

		public static void LoadTransposeMatrixfARB(float* m)
		{
			LoadTransposeMatrixfARBNative(m);
		}

		public static void LoadTransposeMatrixfARB(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				LoadTransposeMatrixfARBNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeImageHandleNonResidentARBNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[343])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[343])(handle);
			#endif
		}

		public static void MakeImageHandleNonResidentARB(ulong handle)
		{
			MakeImageHandleNonResidentARBNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeImageHandleResidentARBNative(ulong handle, GLEnum access)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, GLEnum, void>)funcTable[344])(handle, access);
			#else
			((delegate* unmanaged[Cdecl]<ulong, GLEnum, void>)funcTable[344])(handle, access);
			#endif
		}

		public static void MakeImageHandleResidentARB(ulong handle, GLEnum access)
		{
			MakeImageHandleResidentARBNative(handle, access);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTextureHandleNonResidentARBNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[345])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[345])(handle);
			#endif
		}

		public static void MakeTextureHandleNonResidentARB(ulong handle)
		{
			MakeTextureHandleNonResidentARBNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MakeTextureHandleResidentARBNative(ulong handle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[346])(handle);
			#else
			((delegate* unmanaged[Cdecl]<ulong, void>)funcTable[346])(handle);
			#endif
		}

		public static void MakeTextureHandleResidentARB(ulong handle)
		{
			MakeTextureHandleResidentARBNative(handle);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferARBNative(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, void*>)funcTable[347])(target, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, GLBufferAccessARB, nint>)funcTable[347])(target, access);
			#endif
		}

		public static void* MapBufferARB(GLBufferTargetARB target, GLBufferAccessARB access)
		{
			void* ret = MapBufferARBNative(target, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapBufferRangeNative(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, void*>)funcTable[348])(target, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<GLBufferTargetARB, nint, nint, GLMapBufferAccessMask, nint>)funcTable[348])(target, offset, length, access);
			#endif
		}

		public static void* MapBufferRange(GLBufferTargetARB target, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapBufferRangeNative(target, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapNamedBufferNative(uint buffer, GLBufferAccessARB access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, void*>)funcTable[349])(buffer, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, GLBufferAccessARB, nint>)funcTable[349])(buffer, access);
			#endif
		}

		public static void* MapNamedBuffer(uint buffer, GLBufferAccessARB access)
		{
			void* ret = MapNamedBufferNative(buffer, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* MapNamedBufferRangeNative(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, void*>)funcTable[350])(buffer, offset, length, access);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<uint, nint, nint, GLMapBufferAccessMask, nint>)funcTable[350])(buffer, offset, length, access);
			#endif
		}

		public static void* MapNamedBufferRange(uint buffer, nint offset, nint length, GLMapBufferAccessMask access)
		{
			void* ret = MapNamedBufferRangeNative(buffer, offset, length, access);
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixIndexPointerARBNative(int size, GLMatrixIndexPointerTypeARB type, int stride, void* pointer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, GLMatrixIndexPointerTypeARB, int, void*, void>)funcTable[351])(size, type, stride, pointer);
			#else
			((delegate* unmanaged[Cdecl]<int, GLMatrixIndexPointerTypeARB, int, nint, void>)funcTable[351])(size, type, stride, (nint)pointer);
			#endif
		}

		public static void MatrixIndexPointerARB(int size, GLMatrixIndexPointerTypeARB type, int stride, void* pointer)
		{
			MatrixIndexPointerARBNative(size, type, stride, pointer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixIndexubvARBNative(int size, byte* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[352])(size, indices);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[352])(size, (nint)indices);
			#endif
		}

		public static void MatrixIndexubvARB(int size, byte* indices)
		{
			MatrixIndexubvARBNative(size, indices);
		}

		public static void MatrixIndexubvARB(int size, string indices)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (indices != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(indices);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(indices, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			MatrixIndexubvARBNative(size, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void MatrixIndexubvARB(int size, ReadOnlySpan<byte> indices)
		{
			fixed (byte* pindices0 = indices)
			{
				MatrixIndexubvARBNative(size, pindices0);
			}
		}

		public static void MatrixIndexubvARB(int size, ref byte indices)
		{
			fixed (byte* pindices0 = &indices)
			{
				MatrixIndexubvARBNative(size, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixIndexuivARBNative(int size, uint* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, void>)funcTable[353])(size, indices);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[353])(size, (nint)indices);
			#endif
		}

		public static void MatrixIndexuivARB(int size, uint* indices)
		{
			MatrixIndexuivARBNative(size, indices);
		}

		public static void MatrixIndexuivARB(int size, ref uint indices)
		{
			fixed (uint* pindices0 = &indices)
			{
				MatrixIndexuivARBNative(size, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MatrixIndexusvARBNative(int size, ushort* indices)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, ushort*, void>)funcTable[354])(size, indices);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[354])(size, (nint)indices);
			#endif
		}

		public static void MatrixIndexusvARB(int size, ushort* indices)
		{
			MatrixIndexusvARBNative(size, indices);
		}

		public static void MatrixIndexusvARB(int size, ref ushort indices)
		{
			fixed (ushort* pindices0 = &indices)
			{
				MatrixIndexusvARBNative(size, pindices0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MaxShaderCompilerThreadsARBNative(uint count)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[355])(count);
			#else
			((delegate* unmanaged[Cdecl]<uint, void>)funcTable[355])(count);
			#endif
		}

		public static void MaxShaderCompilerThreadsARB(uint count)
		{
			MaxShaderCompilerThreadsARBNative(count);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierNative(GLMemoryBarrierMask barriers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[356])(barriers);
			#else
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[356])(barriers);
			#endif
		}

		public static void MemoryBarrier(GLMemoryBarrierMask barriers)
		{
			MemoryBarrierNative(barriers);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MemoryBarrierByRegionNative(GLMemoryBarrierMask barriers)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[357])(barriers);
			#else
			((delegate* unmanaged[Cdecl]<GLMemoryBarrierMask, void>)funcTable[357])(barriers);
			#endif
		}

		public static void MemoryBarrierByRegion(GLMemoryBarrierMask barriers)
		{
			MemoryBarrierByRegionNative(barriers);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MinSampleShadingARBNative(float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[358])(value);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[358])(value);
			#endif
		}

		public static void MinSampleShadingARB(float value)
		{
			MinSampleShadingARBNative(value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MinmaxNative(GLMinmaxTargetEXT target, GLInternalFormat internalformat, byte sink)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLInternalFormat, byte, void>)funcTable[359])(target, internalformat, sink);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLInternalFormat, byte, void>)funcTable[359])(target, internalformat, sink);
			#endif
		}

		public static void Minmax(GLMinmaxTargetEXT target, GLInternalFormat internalformat, byte sink)
		{
			MinmaxNative(target, internalformat, sink);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultTransposeMatrixdARBNative(double* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<double*, void>)funcTable[360])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[360])((nint)m);
			#endif
		}

		public static void MultTransposeMatrixdARB(double* m)
		{
			MultTransposeMatrixdARBNative(m);
		}

		public static void MultTransposeMatrixdARB(ref double m)
		{
			fixed (double* pm0 = &m)
			{
				MultTransposeMatrixdARBNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultTransposeMatrixfARBNative(float* m)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float*, void>)funcTable[361])(m);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)funcTable[361])((nint)m);
			#endif
		}

		public static void MultTransposeMatrixfARB(float* m)
		{
			MultTransposeMatrixfARBNative(m);
		}

		public static void MultTransposeMatrixfARB(ref float m)
		{
			fixed (float* pm0 = &m)
			{
				MultTransposeMatrixfARBNative(pm0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysIndirectNative(GLPrimitiveType mode, void* indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, int, int, void>)funcTable[362])(mode, indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, int, int, void>)funcTable[362])(mode, (nint)indirect, drawcount, stride);
			#endif
		}

		public static void MultiDrawArraysIndirect(GLPrimitiveType mode, void* indirect, int drawcount, int stride)
		{
			MultiDrawArraysIndirectNative(mode, indirect, drawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawArraysIndirectCountARBNative(GLPrimitiveType mode, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, void*, nint, int, int, void>)funcTable[363])(mode, indirect, drawcount, maxdrawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, nint, int, int, void>)funcTable[363])(mode, (nint)indirect, drawcount, maxdrawcount, stride);
			#endif
		}

		public static void MultiDrawArraysIndirectCountARB(GLPrimitiveType mode, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawArraysIndirectCountARBNative(mode, indirect, drawcount, maxdrawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsBaseVertexNative(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, int*, GLDrawElementsType, void**, int, int*, void>)funcTable[364])(mode, count, type, indices, drawcount, basevertex);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, nint, GLDrawElementsType, nint, int, nint, void>)funcTable[364])(mode, (nint)count, type, (nint)indices, drawcount, (nint)basevertex);
			#endif
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, basevertex);
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, int* basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, basevertex);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, int* count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pbasevertex0 = &basevertex)
			{
				MultiDrawElementsBaseVertexNative(mode, count, type, indices, drawcount, pbasevertex0);
			}
		}

		public static void MultiDrawElementsBaseVertex(GLPrimitiveType mode, ref int count, GLDrawElementsType type, void** indices, int drawcount, ref int basevertex)
		{
			fixed (int* pcount0 = &count)
			{
				fixed (int* pbasevertex1 = &basevertex)
				{
					MultiDrawElementsBaseVertexNative(mode, pcount0, type, indices, drawcount, pbasevertex1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsIndirectNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, int, int, void>)funcTable[365])(mode, type, indirect, drawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, int, int, void>)funcTable[365])(mode, type, (nint)indirect, drawcount, stride);
			#endif
		}

		public static void MultiDrawElementsIndirect(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, int drawcount, int stride)
		{
			MultiDrawElementsIndirectNative(mode, type, indirect, drawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiDrawElementsIndirectCountARBNative(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, void*, nint, int, int, void>)funcTable[366])(mode, type, indirect, drawcount, maxdrawcount, stride);
			#else
			((delegate* unmanaged[Cdecl]<GLPrimitiveType, GLDrawElementsType, nint, nint, int, int, void>)funcTable[366])(mode, type, (nint)indirect, drawcount, maxdrawcount, stride);
			#endif
		}

		public static void MultiDrawElementsIndirectCountARB(GLPrimitiveType mode, GLDrawElementsType type, void* indirect, nint drawcount, int maxdrawcount, int stride)
		{
			MultiDrawElementsIndirectCountARBNative(mode, type, indirect, drawcount, maxdrawcount, stride);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1dARBNative(GLTextureUnit target, double s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[367])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, void>)funcTable[367])(target, s);
			#endif
		}

		public static void MultiTexCoord1dARB(GLTextureUnit target, double s)
		{
			MultiTexCoord1dARBNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1dvARBNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[368])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[368])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1dvARB(GLTextureUnit target, double* v)
		{
			MultiTexCoord1dvARBNative(target, v);
		}

		public static void MultiTexCoord1dvARB(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord1dvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1fARBNative(GLTextureUnit target, float s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[369])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, void>)funcTable[369])(target, s);
			#endif
		}

		public static void MultiTexCoord1fARB(GLTextureUnit target, float s)
		{
			MultiTexCoord1fARBNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1fvARBNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[370])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[370])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1fvARB(GLTextureUnit target, float* v)
		{
			MultiTexCoord1fvARBNative(target, v);
		}

		public static void MultiTexCoord1fvARB(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord1fvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1iARBNative(GLTextureUnit target, int s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[371])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, void>)funcTable[371])(target, s);
			#endif
		}

		public static void MultiTexCoord1iARB(GLTextureUnit target, int s)
		{
			MultiTexCoord1iARBNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1ivARBNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[372])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[372])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1ivARB(GLTextureUnit target, int* v)
		{
			MultiTexCoord1ivARBNative(target, v);
		}

		public static void MultiTexCoord1ivARB(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord1ivARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1sARBNative(GLTextureUnit target, short s)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[373])(target, s);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, void>)funcTable[373])(target, s);
			#endif
		}

		public static void MultiTexCoord1sARB(GLTextureUnit target, short s)
		{
			MultiTexCoord1sARBNative(target, s);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord1svARBNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[374])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[374])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord1svARB(GLTextureUnit target, short* v)
		{
			MultiTexCoord1svARBNative(target, v);
		}

		public static void MultiTexCoord1svARB(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord1svARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2dARBNative(GLTextureUnit target, double s, double t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[375])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, void>)funcTable[375])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2dARB(GLTextureUnit target, double s, double t)
		{
			MultiTexCoord2dARBNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2dvARBNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[376])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[376])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2dvARB(GLTextureUnit target, double* v)
		{
			MultiTexCoord2dvARBNative(target, v);
		}

		public static void MultiTexCoord2dvARB(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord2dvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2fARBNative(GLTextureUnit target, float s, float t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[377])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, void>)funcTable[377])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2fARB(GLTextureUnit target, float s, float t)
		{
			MultiTexCoord2fARBNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2fvARBNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[378])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[378])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2fvARB(GLTextureUnit target, float* v)
		{
			MultiTexCoord2fvARBNative(target, v);
		}

		public static void MultiTexCoord2fvARB(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord2fvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2iARBNative(GLTextureUnit target, int s, int t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[379])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, void>)funcTable[379])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2iARB(GLTextureUnit target, int s, int t)
		{
			MultiTexCoord2iARBNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2ivARBNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[380])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[380])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2ivARB(GLTextureUnit target, int* v)
		{
			MultiTexCoord2ivARBNative(target, v);
		}

		public static void MultiTexCoord2ivARB(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord2ivARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2sARBNative(GLTextureUnit target, short s, short t)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[381])(target, s, t);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, void>)funcTable[381])(target, s, t);
			#endif
		}

		public static void MultiTexCoord2sARB(GLTextureUnit target, short s, short t)
		{
			MultiTexCoord2sARBNative(target, s, t);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord2svARBNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[382])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[382])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord2svARB(GLTextureUnit target, short* v)
		{
			MultiTexCoord2svARBNative(target, v);
		}

		public static void MultiTexCoord2svARB(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord2svARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3dARBNative(GLTextureUnit target, double s, double t, double r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[383])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, void>)funcTable[383])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3dARB(GLTextureUnit target, double s, double t, double r)
		{
			MultiTexCoord3dARBNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3dvARBNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[384])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[384])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3dvARB(GLTextureUnit target, double* v)
		{
			MultiTexCoord3dvARBNative(target, v);
		}

		public static void MultiTexCoord3dvARB(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord3dvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3fARBNative(GLTextureUnit target, float s, float t, float r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[385])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, void>)funcTable[385])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3fARB(GLTextureUnit target, float s, float t, float r)
		{
			MultiTexCoord3fARBNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3fvARBNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[386])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[386])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3fvARB(GLTextureUnit target, float* v)
		{
			MultiTexCoord3fvARBNative(target, v);
		}

		public static void MultiTexCoord3fvARB(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord3fvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3iARBNative(GLTextureUnit target, int s, int t, int r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[387])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, void>)funcTable[387])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3iARB(GLTextureUnit target, int s, int t, int r)
		{
			MultiTexCoord3iARBNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3ivARBNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[388])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[388])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3ivARB(GLTextureUnit target, int* v)
		{
			MultiTexCoord3ivARBNative(target, v);
		}

		public static void MultiTexCoord3ivARB(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord3ivARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3sARBNative(GLTextureUnit target, short s, short t, short r)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[389])(target, s, t, r);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, void>)funcTable[389])(target, s, t, r);
			#endif
		}

		public static void MultiTexCoord3sARB(GLTextureUnit target, short s, short t, short r)
		{
			MultiTexCoord3sARBNative(target, s, t, r);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord3svARBNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[390])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[390])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord3svARB(GLTextureUnit target, short* v)
		{
			MultiTexCoord3svARBNative(target, v);
		}

		public static void MultiTexCoord3svARB(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord3svARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4dARBNative(GLTextureUnit target, double s, double t, double r, double q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[391])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double, double, double, double, void>)funcTable[391])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4dARB(GLTextureUnit target, double s, double t, double r, double q)
		{
			MultiTexCoord4dARBNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4dvARBNative(GLTextureUnit target, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, double*, void>)funcTable[392])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[392])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4dvARB(GLTextureUnit target, double* v)
		{
			MultiTexCoord4dvARBNative(target, v);
		}

		public static void MultiTexCoord4dvARB(GLTextureUnit target, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				MultiTexCoord4dvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4fARBNative(GLTextureUnit target, float s, float t, float r, float q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[393])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float, float, float, float, void>)funcTable[393])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4fARB(GLTextureUnit target, float s, float t, float r, float q)
		{
			MultiTexCoord4fARBNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4fvARBNative(GLTextureUnit target, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, float*, void>)funcTable[394])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[394])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4fvARB(GLTextureUnit target, float* v)
		{
			MultiTexCoord4fvARBNative(target, v);
		}

		public static void MultiTexCoord4fvARB(GLTextureUnit target, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				MultiTexCoord4fvARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4iARBNative(GLTextureUnit target, int s, int t, int r, int q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[395])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int, int, int, int, void>)funcTable[395])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4iARB(GLTextureUnit target, int s, int t, int r, int q)
		{
			MultiTexCoord4iARBNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4ivARBNative(GLTextureUnit target, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, int*, void>)funcTable[396])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[396])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4ivARB(GLTextureUnit target, int* v)
		{
			MultiTexCoord4ivARBNative(target, v);
		}

		public static void MultiTexCoord4ivARB(GLTextureUnit target, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				MultiTexCoord4ivARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4sARBNative(GLTextureUnit target, short s, short t, short r, short q)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, short, void>)funcTable[397])(target, s, t, r, q);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short, short, short, short, void>)funcTable[397])(target, s, t, r, q);
			#endif
		}

		public static void MultiTexCoord4sARB(GLTextureUnit target, short s, short t, short r, short q)
		{
			MultiTexCoord4sARBNative(target, s, t, r, q);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoord4svARBNative(GLTextureUnit target, short* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, short*, void>)funcTable[398])(target, v);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, nint, void>)funcTable[398])(target, (nint)v);
			#endif
		}

		public static void MultiTexCoord4svARB(GLTextureUnit target, short* v)
		{
			MultiTexCoord4svARBNative(target, v);
		}

		public static void MultiTexCoord4svARB(GLTextureUnit target, ref short v)
		{
			fixed (short* pv0 = &v)
			{
				MultiTexCoord4svARBNative(target, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP1uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[399])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[399])(texture, type, coords);
			#endif
		}

		public static void MultiTexCoordP1ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP1uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP1uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[400])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[400])(texture, type, (nint)coords);
			#endif
		}

		public static void MultiTexCoordP1uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP1uivNative(texture, type, coords);
		}

		public static void MultiTexCoordP1uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP1uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP2uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[401])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[401])(texture, type, coords);
			#endif
		}

		public static void MultiTexCoordP2ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP2uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP2uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[402])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[402])(texture, type, (nint)coords);
			#endif
		}

		public static void MultiTexCoordP2uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP2uivNative(texture, type, coords);
		}

		public static void MultiTexCoordP2uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP2uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP3uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[403])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[403])(texture, type, coords);
			#endif
		}

		public static void MultiTexCoordP3ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP3uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP3uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[404])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[404])(texture, type, (nint)coords);
			#endif
		}

		public static void MultiTexCoordP3uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP3uivNative(texture, type, coords);
		}

		public static void MultiTexCoordP3uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP3uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP4uiNative(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[405])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint, void>)funcTable[405])(texture, type, coords);
			#endif
		}

		public static void MultiTexCoordP4ui(GLTextureUnit texture, GLTexCoordPointerType type, uint coords)
		{
			MultiTexCoordP4uiNative(texture, type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MultiTexCoordP4uivNative(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, uint*, void>)funcTable[406])(texture, type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureUnit, GLTexCoordPointerType, nint, void>)funcTable[406])(texture, type, (nint)coords);
			#endif
		}

		public static void MultiTexCoordP4uiv(GLTextureUnit texture, GLTexCoordPointerType type, uint* coords)
		{
			MultiTexCoordP4uivNative(texture, type, coords);
		}

		public static void MultiTexCoordP4uiv(GLTextureUnit texture, GLTexCoordPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				MultiTexCoordP4uivNative(texture, type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferDataNative(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLVertexBufferObjectUsage, void>)funcTable[407])(buffer, size, data, usage);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLVertexBufferObjectUsage, void>)funcTable[407])(buffer, size, (nint)data, usage);
			#endif
		}

		public static void NamedBufferData(uint buffer, nint size, void* data, GLVertexBufferObjectUsage usage)
		{
			NamedBufferDataNative(buffer, size, data, usage);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferPageCommitmentARBNative(uint buffer, nint offset, nint size, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, byte, void>)funcTable[408])(buffer, offset, size, commit);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, byte, void>)funcTable[408])(buffer, offset, size, commit);
			#endif
		}

		public static void NamedBufferPageCommitmentARB(uint buffer, nint offset, nint size, byte commit)
		{
			NamedBufferPageCommitmentARBNative(buffer, offset, size, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferPageCommitmentEXTNative(uint buffer, nint offset, nint size, byte commit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, byte, void>)funcTable[409])(buffer, offset, size, commit);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, byte, void>)funcTable[409])(buffer, offset, size, commit);
			#endif
		}

		public static void NamedBufferPageCommitmentEXT(uint buffer, nint offset, nint size, byte commit)
		{
			NamedBufferPageCommitmentEXTNative(buffer, offset, size, commit);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferStorageNative(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, void*, GLBufferStorageMask, void>)funcTable[410])(buffer, size, data, flags);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, GLBufferStorageMask, void>)funcTable[410])(buffer, size, (nint)data, flags);
			#endif
		}

		public static void NamedBufferStorage(uint buffer, nint size, void* data, GLBufferStorageMask flags)
		{
			NamedBufferStorageNative(buffer, size, data, flags);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedBufferSubDataNative(uint buffer, nint offset, nint size, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, nint, nint, void*, void>)funcTable[411])(buffer, offset, size, data);
			#else
			((delegate* unmanaged[Cdecl]<uint, nint, nint, nint, void>)funcTable[411])(buffer, offset, size, (nint)data);
			#endif
		}

		public static void NamedBufferSubData(uint buffer, nint offset, nint size, void* data)
		{
			NamedBufferSubDataNative(buffer, offset, size, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferDrawBufferNative(uint framebuffer, GLColorBuffer buf)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[412])(framebuffer, buf);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[412])(framebuffer, buf);
			#endif
		}

		public static void NamedFramebufferDrawBuffer(uint framebuffer, GLColorBuffer buf)
		{
			NamedFramebufferDrawBufferNative(framebuffer, buf);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferDrawBuffersNative(uint framebuffer, int n, GLColorBuffer bufs)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLColorBuffer, void>)funcTable[413])(framebuffer, n, bufs);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLColorBuffer, void>)funcTable[413])(framebuffer, n, bufs);
			#endif
		}

		public static void NamedFramebufferDrawBuffers(uint framebuffer, int n, GLColorBuffer bufs)
		{
			NamedFramebufferDrawBuffersNative(framebuffer, n, bufs);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferParameteriNative(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[414])(framebuffer, pname, param);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferParameterName, int, void>)funcTable[414])(framebuffer, pname, param);
			#endif
		}

		public static void NamedFramebufferParameteri(uint framebuffer, GLFramebufferParameterName pname, int param)
		{
			NamedFramebufferParameteriNative(framebuffer, pname, param);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferReadBufferNative(uint framebuffer, GLColorBuffer src)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[415])(framebuffer, src);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLColorBuffer, void>)funcTable[415])(framebuffer, src);
			#endif
		}

		public static void NamedFramebufferReadBuffer(uint framebuffer, GLColorBuffer src)
		{
			NamedFramebufferReadBufferNative(framebuffer, src);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferRenderbufferNative(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[416])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, GLRenderbufferTarget, uint, void>)funcTable[416])(framebuffer, attachment, renderbuffertarget, renderbuffer);
			#endif
		}

		public static void NamedFramebufferRenderbuffer(uint framebuffer, GLFramebufferAttachment attachment, GLRenderbufferTarget renderbuffertarget, uint renderbuffer)
		{
			NamedFramebufferRenderbufferNative(framebuffer, attachment, renderbuffertarget, renderbuffer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferSampleLocationsfvARBNative(uint framebuffer, uint start, int count, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, uint, int, float*, void>)funcTable[417])(framebuffer, start, count, v);
			#else
			((delegate* unmanaged[Cdecl]<uint, uint, int, nint, void>)funcTable[417])(framebuffer, start, count, (nint)v);
			#endif
		}

		public static void NamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, float* v)
		{
			NamedFramebufferSampleLocationsfvARBNative(framebuffer, start, count, v);
		}

		public static void NamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				NamedFramebufferSampleLocationsfvARBNative(framebuffer, start, count, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[418])(framebuffer, attachment, texture, level);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, void>)funcTable[418])(framebuffer, attachment, texture, level);
			#endif
		}

		public static void NamedFramebufferTexture(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level)
		{
			NamedFramebufferTextureNative(framebuffer, attachment, texture, level);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedFramebufferTextureLayerNative(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[419])(framebuffer, attachment, texture, level, layer);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLFramebufferAttachment, uint, int, int, void>)funcTable[419])(framebuffer, attachment, texture, level, layer);
			#endif
		}

		public static void NamedFramebufferTextureLayer(uint framebuffer, GLFramebufferAttachment attachment, uint texture, int level, int layer)
		{
			NamedFramebufferTextureLayerNative(framebuffer, attachment, texture, level, layer);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedRenderbufferStorageNative(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[420])(renderbuffer, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, GLInternalFormat, int, int, void>)funcTable[420])(renderbuffer, internalformat, width, height);
			#endif
		}

		public static void NamedRenderbufferStorage(uint renderbuffer, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageNative(renderbuffer, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedRenderbufferStorageMultisampleNative(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[421])(renderbuffer, samples, internalformat, width, height);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, GLInternalFormat, int, int, void>)funcTable[421])(renderbuffer, samples, internalformat, width, height);
			#endif
		}

		public static void NamedRenderbufferStorageMultisample(uint renderbuffer, int samples, GLInternalFormat internalformat, int width, int height)
		{
			NamedRenderbufferStorageMultisampleNative(renderbuffer, samples, internalformat, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NamedStringARBNative(GLEnum type, int namelen, byte* name, int stringlen, byte* str)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLEnum, int, byte*, int, byte*, void>)funcTable[422])(type, namelen, name, stringlen, str);
			#else
			((delegate* unmanaged[Cdecl]<GLEnum, int, nint, int, nint, void>)funcTable[422])(type, namelen, (nint)name, stringlen, (nint)str);
			#endif
		}

		public static void NamedStringARB(GLEnum type, int namelen, byte* name, int stringlen, byte* str)
		{
			NamedStringARBNative(type, namelen, name, stringlen, str);
		}

		public static void NamedStringARB(GLEnum type, int namelen, string name, int stringlen, byte* str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			NamedStringARBNative(type, namelen, pStr0, stringlen, str);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, ReadOnlySpan<byte> name, int stringlen, byte* str)
		{
			fixed (byte* pname0 = name)
			{
				NamedStringARBNative(type, namelen, pname0, stringlen, str);
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, ref byte name, int stringlen, byte* str)
		{
			fixed (byte* pname0 = &name)
			{
				NamedStringARBNative(type, namelen, pname0, stringlen, str);
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, byte* name, int stringlen, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (str != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(str);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(str, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			NamedStringARBNative(type, namelen, name, stringlen, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, byte* name, int stringlen, ReadOnlySpan<byte> str)
		{
			fixed (byte* pstr0 = str)
			{
				NamedStringARBNative(type, namelen, name, stringlen, pstr0);
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, byte* name, int stringlen, ref byte str)
		{
			fixed (byte* pstr0 = &str)
			{
				NamedStringARBNative(type, namelen, name, stringlen, pstr0);
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, string name, int stringlen, string str)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (name != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(name);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(name, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			byte* pStr1 = null;
			int pStrSize1 = 0;
			if (str != null)
			{
				pStrSize1 = Utils.GetByteCountUTF8(str);
				if (pStrSize1 >= Utils.MaxStackallocSize)
				{
					pStr1 = Utils.Alloc<byte>(pStrSize1 + 1);
				}
				else
				{
					byte* pStrStack1 = stackalloc byte[pStrSize1 + 1];
					pStr1 = pStrStack1;
				}
				int pStrOffset1 = Utils.EncodeStringUTF8(str, pStr1, pStrSize1);
				pStr1[pStrOffset1] = 0;
			}
			NamedStringARBNative(type, namelen, pStr0, stringlen, pStr1);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
			if (pStrSize1 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr1);
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, ReadOnlySpan<byte> name, int stringlen, ReadOnlySpan<byte> str)
		{
			fixed (byte* pname0 = name)
			{
				fixed (byte* pstr1 = str)
				{
					NamedStringARBNative(type, namelen, pname0, stringlen, pstr1);
				}
			}
		}

		public static void NamedStringARB(GLEnum type, int namelen, ref byte name, int stringlen, ref byte str)
		{
			fixed (byte* pname0 = &name)
			{
				fixed (byte* pstr1 = &str)
				{
					NamedStringARBNative(type, namelen, pname0, stringlen, pstr1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NormalP3uiNative(GLNormalPointerType type, uint coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, uint, void>)funcTable[423])(type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, uint, void>)funcTable[423])(type, coords);
			#endif
		}

		public static void NormalP3ui(GLNormalPointerType type, uint coords)
		{
			NormalP3uiNative(type, coords);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void NormalP3uivNative(GLNormalPointerType type, uint* coords)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, uint*, void>)funcTable[424])(type, coords);
			#else
			((delegate* unmanaged[Cdecl]<GLNormalPointerType, nint, void>)funcTable[424])(type, (nint)coords);
			#endif
		}

		public static void NormalP3uiv(GLNormalPointerType type, uint* coords)
		{
			NormalP3uivNative(type, coords);
		}

		public static void NormalP3uiv(GLNormalPointerType type, ref uint coords)
		{
			fixed (uint* pcoords0 = &coords)
			{
				NormalP3uivNative(type, pcoords0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PatchParameterfvNative(GLPatchParameterName pname, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, float*, void>)funcTable[425])(pname, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, nint, void>)funcTable[425])(pname, (nint)values);
			#endif
		}

		public static void PatchParameterfv(GLPatchParameterName pname, float* values)
		{
			PatchParameterfvNative(pname, values);
		}

		public static void PatchParameterfv(GLPatchParameterName pname, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				PatchParameterfvNative(pname, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PatchParameteriNative(GLPatchParameterName pname, int value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, int, void>)funcTable[426])(pname, value);
			#else
			((delegate* unmanaged[Cdecl]<GLPatchParameterName, int, void>)funcTable[426])(pname, value);
			#endif
		}

		public static void PatchParameteri(GLPatchParameterName pname, int value)
		{
			PatchParameteriNative(pname, value);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void PauseTransformFeedbackNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[427])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[427])();
			#endif
		}

		public static void PauseTransformFeedback()
		{
			PauseTransformFeedbackNative();
		}
	}
}
