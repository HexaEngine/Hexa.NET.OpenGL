// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.ARB
{
	public static unsafe partial class GLARBImaging
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[0])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[0])(red, green, blue, alpha);
			#endif
		}

		/// <summary>
		/// Set the blend color
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void BlendColor(float red, float green, float blue, float alpha)
		{
			BlendColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[1])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[1])(mode);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Supported Versions:<br/>GL 1.4 - GL 1.5<br/>GL 2.X<br/>GL 3.X<br/>GL 4.X<br/><br/>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void BlendEquation(GLBlendEquationModeEXT mode)
		{
			BlendEquationNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorSubTableNative(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[2])(target, start, count, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[2])(target, start, count, format, type, (nint)data);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorSubTable(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			ColorSubTableNative(target, start, count, format, type, data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorSubTable(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, nint data)
		{
			ColorSubTableNative(target, start, count, format, type, (void*)data);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorSubTable<TData>(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, Span<TData> data) where TData : unmanaged
		{
			fixed (TData* pdata0 = data)
			{
				ColorSubTableNative(target, start, count, format, type, pdata0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableNative(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[3])(target, internalformat, width, format, type, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[3])(target, internalformat, width, format, type, (nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTable(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			ColorTableNative(target, internalformat, width, format, type, table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTable(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, nint table)
		{
			ColorTableNative(target, internalformat, width, format, type, (void*)table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTable<TTable>(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, Span<TTable> table) where TTable : unmanaged
		{
			fixed (TTable* ptable0 = table)
			{
				ColorTableNative(target, internalformat, width, format, type, ptable0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableParameterfvNative(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, float*, void>)funcTable[4])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[4])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			ColorTableParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				ColorTableParameterfvNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ColorTableParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableParameterivNative(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, int*, void>)funcTable[5])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[5])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			ColorTableParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				ColorTableParameterivNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ColorTableParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter1DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[6])(target, internalformat, width, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[6])(target, internalformat, width, format, type, (nint)image);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionFilter1D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter1DNative(target, internalformat, width, format, type, image);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionFilter1D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, nint image)
		{
			ConvolutionFilter1DNative(target, internalformat, width, format, type, (void*)image);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionFilter1D<TImage>(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, Span<TImage> image) where TImage : unmanaged
		{
			fixed (TImage* pimage0 = image)
			{
				ConvolutionFilter1DNative(target, internalformat, width, format, type, pimage0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter2DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[7])(target, internalformat, width, height, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[7])(target, internalformat, width, height, format, type, (nint)image);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionFilter2D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter2DNative(target, internalformat, width, height, format, type, image);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionFilter2D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, nint image)
		{
			ConvolutionFilter2DNative(target, internalformat, width, height, format, type, (void*)image);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionFilter2D<TImage>(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, Span<TImage> image) where TImage : unmanaged
		{
			fixed (TImage* pimage0 = image)
			{
				ConvolutionFilter2DNative(target, internalformat, width, height, format, type, pimage0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfNative(GLConvolutionTarget target, GLConvolutionParameter pname, float @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float, void>)funcTable[8])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float, void>)funcTable[8])(target, pname, @params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameterf(GLConvolutionTarget target, GLConvolutionParameter pname, float @params)
		{
			ConvolutionParameterfNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfvNative(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float*, void>)funcTable[9])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[9])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			ConvolutionParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, Span<float> @params)
		{
			fixed (float* pparams0 = @params)
			{
				ConvolutionParameterfvNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ConvolutionParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameteriNative(GLConvolutionTarget target, GLConvolutionParameter pname, int @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int, void>)funcTable[10])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int, void>)funcTable[10])(target, pname, @params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameteri(GLConvolutionTarget target, GLConvolutionParameter pname, int @params)
		{
			ConvolutionParameteriNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterivNative(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int*, void>)funcTable[11])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[11])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			ConvolutionParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, Span<int> @params)
		{
			fixed (int* pparams0 = @params)
			{
				ConvolutionParameterivNative(target, pname, pparams0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ConvolutionParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyColorSubTableNative(GLColorTableTarget target, int start, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[12])(target, start, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[12])(target, start, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void CopyColorSubTable(GLColorTableTarget target, int start, int x, int y, int width)
		{
			CopyColorSubTableNative(target, start, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyColorTableNative(GLColorTableTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, int, int, void>)funcTable[13])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, int, int, void>)funcTable[13])(target, internalformat, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void CopyColorTable(GLColorTableTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyColorTableNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter1DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, void>)funcTable[14])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, void>)funcTable[14])(target, internalformat, x, y, width);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void CopyConvolutionFilter1D(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyConvolutionFilter1DNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter2DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, int, void>)funcTable[15])(target, internalformat, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, int, void>)funcTable[15])(target, internalformat, x, y, width, height);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void CopyConvolutionFilter2D(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			CopyConvolutionFilter2DNative(target, internalformat, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableNative(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, void*, void>)funcTable[16])(target, format, type, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, nint, void>)funcTable[16])(target, format, type, (nint)table);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTable(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* table)
		{
			GetColorTableNative(target, format, type, table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTable(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, nint table)
		{
			GetColorTableNative(target, format, type, (void*)table);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTable<TTable>(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, Span<TTable> table) where TTable : unmanaged
		{
			fixed (TTable* ptable0 = table)
			{
				GetColorTableNative(target, format, type, ptable0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterfvNative(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, float*, void>)funcTable[17])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[17])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			GetColorTableParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, out float @params)
		{
			float pparam;
			GetColorTableParameterfvNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetColorTableParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterivNative(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, int*, void>)funcTable[18])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[18])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			GetColorTableParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, out int @params)
		{
			int pparam;
			GetColorTableParameterivNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetColorTableParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionFilterNative(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, void*, void>)funcTable[19])(target, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, nint, void>)funcTable[19])(target, format, type, (nint)image);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionFilter(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, void* image)
		{
			GetConvolutionFilterNative(target, format, type, image);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionFilter(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, nint image)
		{
			GetConvolutionFilterNative(target, format, type, (void*)image);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionFilter<TImage>(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, Span<TImage> image) where TImage : unmanaged
		{
			fixed (TImage* pimage0 = image)
			{
				GetConvolutionFilterNative(target, format, type, pimage0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterfvNative(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float*, void>)funcTable[20])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[20])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			GetConvolutionParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, out float @params)
		{
			float pparam;
			GetConvolutionParameterfvNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetConvolutionParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterivNative(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int*, void>)funcTable[21])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[21])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			GetConvolutionParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, out int @params)
		{
			int pparam;
			GetConvolutionParameterivNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetConvolutionParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramNative(GLHistogramTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[22])(target, *((byte*)(&reset)), format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[22])(target, *((byte*)(&reset)), format, type, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogram(GLHistogramTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetHistogramNative(target, reset, format, type, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogram(GLHistogramTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, nint values)
		{
			GetHistogramNative(target, reset, format, type, (void*)values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogram<TValues>(GLHistogramTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, Span<TValues> values) where TValues : unmanaged
		{
			fixed (TValues* pvalues0 = values)
			{
				GetHistogramNative(target, reset, format, type, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterfvNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, float*, void>)funcTable[23])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[23])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogramParameterfv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			GetHistogramParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogramParameterfv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, out float @params)
		{
			float pparam;
			GetHistogramParameterfvNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogramParameterfv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetHistogramParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterivNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, int*, void>)funcTable[24])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[24])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogramParameteriv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			GetHistogramParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogramParameteriv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, out int @params)
		{
			int pparam;
			GetHistogramParameterivNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetHistogramParameteriv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetHistogramParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxNative(GLMinmaxTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[25])(target, *((byte*)(&reset)), format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[25])(target, *((byte*)(&reset)), format, type, (nint)values);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmax(GLMinmaxTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetMinmaxNative(target, reset, format, type, values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmax(GLMinmaxTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, nint values)
		{
			GetMinmaxNative(target, reset, format, type, (void*)values);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmax<TValues>(GLMinmaxTargetEXT target, bool reset, GLPixelFormat format, GLPixelType type, Span<TValues> values) where TValues : unmanaged
		{
			fixed (TValues* pvalues0 = values)
			{
				GetMinmaxNative(target, reset, format, type, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterfvNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, float*, void>)funcTable[26])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[26])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmaxParameterfv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			GetMinmaxParameterfvNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmaxParameterfv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, out float @params)
		{
			float pparam;
			GetMinmaxParameterfvNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmaxParameterfv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, Span<float> @params)
		{
			fixed (float* pparams = @params)
			{
				GetMinmaxParameterfvNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterivNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, int*, void>)funcTable[27])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[27])(target, pname, (nint)@params);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmaxParameteriv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			GetMinmaxParameterivNative(target, pname, @params);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmaxParameteriv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, out int @params)
		{
			int pparam;
			GetMinmaxParameterivNative(target, pname, &pparam);
			@params = pparam;
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetMinmaxParameteriv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, Span<int> @params)
		{
			fixed (int* pparams = @params)
			{
				GetMinmaxParameterivNative(target, pname, pparams);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSeparableFilterNative(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, void*, void*, void*, void>)funcTable[28])(target, format, type, row, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, nint, nint, nint, void>)funcTable[28])(target, format, type, (nint)row, (nint)column, (nint)span);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			GetSeparableFilterNative(target, format, type, row, column, span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, nint row, void* column, void* span)
		{
			GetSeparableFilterNative(target, format, type, (void*)row, column, span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter<TRow>(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, Span<TRow> row, void* column, void* span) where TRow : unmanaged
		{
			fixed (TRow* prow0 = row)
			{
				GetSeparableFilterNative(target, format, type, prow0, column, span);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, nint column, void* span)
		{
			GetSeparableFilterNative(target, format, type, row, (void*)column, span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter<TColumn>(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, Span<TColumn> column, void* span) where TColumn : unmanaged
		{
			fixed (TColumn* pcolumn0 = column)
			{
				GetSeparableFilterNative(target, format, type, row, pcolumn0, span);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, nint row, nint column, void* span)
		{
			GetSeparableFilterNative(target, format, type, (void*)row, (void*)column, span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter<TRow, TColumn>(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, Span<TRow> row, Span<TColumn> column, void* span) where TRow : unmanaged where TColumn : unmanaged
		{
			fixed (TRow* prow0 = row)
			{
				fixed (TColumn* pcolumn1 = column)
				{
					GetSeparableFilterNative(target, format, type, prow0, pcolumn1, span);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, nint span)
		{
			GetSeparableFilterNative(target, format, type, row, column, (void*)span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter<TSpan>(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, Span<TSpan> span) where TSpan : unmanaged
		{
			fixed (TSpan* pspan0 = span)
			{
				GetSeparableFilterNative(target, format, type, row, column, pspan0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, nint row, void* column, nint span)
		{
			GetSeparableFilterNative(target, format, type, (void*)row, column, (void*)span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter<TRow, TSpan>(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, Span<TRow> row, void* column, Span<TSpan> span) where TRow : unmanaged where TSpan : unmanaged
		{
			fixed (TRow* prow0 = row)
			{
				fixed (TSpan* pspan1 = span)
				{
					GetSeparableFilterNative(target, format, type, prow0, column, pspan1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, nint column, nint span)
		{
			GetSeparableFilterNative(target, format, type, row, (void*)column, (void*)span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter<TColumn, TSpan>(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, Span<TColumn> column, Span<TSpan> span) where TColumn : unmanaged where TSpan : unmanaged
		{
			fixed (TColumn* pcolumn0 = column)
			{
				fixed (TSpan* pspan1 = span)
				{
					GetSeparableFilterNative(target, format, type, row, pcolumn0, pspan1);
				}
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, nint row, nint column, nint span)
		{
			GetSeparableFilterNative(target, format, type, (void*)row, (void*)column, (void*)span);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void GetSeparableFilter<TRow, TColumn, TSpan>(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, Span<TRow> row, Span<TColumn> column, Span<TSpan> span) where TRow : unmanaged where TColumn : unmanaged where TSpan : unmanaged
		{
			fixed (TRow* prow0 = row)
			{
				fixed (TColumn* pcolumn1 = column)
				{
					fixed (TSpan* pspan2 = span)
					{
						GetSeparableFilterNative(target, format, type, prow0, pcolumn1, pspan2);
					}
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HistogramNative(GLHistogramTargetEXT target, int width, GLInternalFormat internalformat, bool sink)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, int, GLInternalFormat, byte, void>)funcTable[29])(target, width, internalformat, *((byte*)(&sink)));
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, int, GLInternalFormat, byte, void>)funcTable[29])(target, width, internalformat, *((byte*)(&sink)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void Histogram(GLHistogramTargetEXT target, int width, GLInternalFormat internalformat, bool sink)
		{
			HistogramNative(target, width, internalformat, sink);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MinmaxNative(GLMinmaxTargetEXT target, GLInternalFormat internalformat, bool sink)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLInternalFormat, byte, void>)funcTable[30])(target, internalformat, *((byte*)(&sink)));
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLInternalFormat, byte, void>)funcTable[30])(target, internalformat, *((byte*)(&sink)));
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void Minmax(GLMinmaxTargetEXT target, GLInternalFormat internalformat, bool sink)
		{
			MinmaxNative(target, internalformat, sink);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetHistogramNative(GLHistogramTargetEXT target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, void>)funcTable[31])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, void>)funcTable[31])(target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ResetHistogram(GLHistogramTargetEXT target)
		{
			ResetHistogramNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetMinmaxNative(GLMinmaxTargetEXT target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, void>)funcTable[32])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, void>)funcTable[32])(target);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void ResetMinmax(GLMinmaxTargetEXT target)
		{
			ResetMinmaxNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SeparableFilter2DNative(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, void* column)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void*, void>)funcTable[33])(target, internalformat, width, height, format, type, row, column);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, nint, void>)funcTable[33])(target, internalformat, width, height, format, type, (nint)row, (nint)column);
			#endif
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void SeparableFilter2D(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, void* column)
		{
			SeparableFilter2DNative(target, internalformat, width, height, format, type, row, column);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void SeparableFilter2D(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, nint row, void* column)
		{
			SeparableFilter2DNative(target, internalformat, width, height, format, type, (void*)row, column);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void SeparableFilter2D<TRow>(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, Span<TRow> row, void* column) where TRow : unmanaged
		{
			fixed (TRow* prow0 = row)
			{
				SeparableFilter2DNative(target, internalformat, width, height, format, type, prow0, column);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void SeparableFilter2D(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, nint column)
		{
			SeparableFilter2DNative(target, internalformat, width, height, format, type, row, (void*)column);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void SeparableFilter2D<TColumn>(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, Span<TColumn> column) where TColumn : unmanaged
		{
			fixed (TColumn* pcolumn0 = column)
			{
				SeparableFilter2DNative(target, internalformat, width, height, format, type, row, pcolumn0);
			}
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void SeparableFilter2D(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, nint row, nint column)
		{
			SeparableFilter2DNative(target, internalformat, width, height, format, type, (void*)row, (void*)column);
		}

		/// <summary>
		/// To be documented.
		/// </summary>
		/// <remarks>Used by Extensions:<br/>GL_ARB_imaging</remarks>
		public static void SeparableFilter2D<TRow, TColumn>(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, Span<TRow> row, Span<TColumn> column) where TRow : unmanaged where TColumn : unmanaged
		{
			fixed (TRow* prow0 = row)
			{
				fixed (TColumn* pcolumn1 = column)
				{
					SeparableFilter2DNative(target, internalformat, width, height, format, type, prow0, pcolumn1);
				}
			}
		}

	}
}
