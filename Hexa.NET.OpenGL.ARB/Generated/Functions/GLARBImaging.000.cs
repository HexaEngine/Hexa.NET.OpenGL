// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.ARB
{
	public static unsafe partial class GLARBImaging
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendColorNative(float red, float green, float blue, float alpha)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[0])(red, green, blue, alpha);
			#else
			((delegate* unmanaged[Cdecl]<float, float, float, float, void>)funcTable[0])(red, green, blue, alpha);
			#endif
		}

		public static void BlendColor(float red, float green, float blue, float alpha)
		{
			BlendColorNative(red, green, blue, alpha);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BlendEquationNative(GLBlendEquationModeEXT mode)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[1])(mode);
			#else
			((delegate* unmanaged[Cdecl]<GLBlendEquationModeEXT, void>)funcTable[1])(mode);
			#endif
		}

		public static void BlendEquation(GLBlendEquationModeEXT mode)
		{
			BlendEquationNative(mode);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorSubTableNative(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[2])(target, start, count, format, type, data);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[2])(target, start, count, format, type, (nint)data);
			#endif
		}

		public static void ColorSubTable(GLColorTableTarget target, int start, int count, GLPixelFormat format, GLPixelType type, void* data)
		{
			ColorSubTableNative(target, start, count, format, type, data);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableNative(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[3])(target, internalformat, width, format, type, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[3])(target, internalformat, width, format, type, (nint)table);
			#endif
		}

		public static void ColorTable(GLColorTableTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* table)
		{
			ColorTableNative(target, internalformat, width, format, type, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableParameterfvNative(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, float*, void>)funcTable[4])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[4])(target, pname, (nint)@params);
			#endif
		}

		public static void ColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			ColorTableParameterfvNative(target, pname, @params);
		}

		public static void ColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ColorTableParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ColorTableParameterivNative(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, int*, void>)funcTable[5])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[5])(target, pname, (nint)@params);
			#endif
		}

		public static void ColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			ColorTableParameterivNative(target, pname, @params);
		}

		public static void ColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ColorTableParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter1DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[6])(target, internalformat, width, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[6])(target, internalformat, width, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter1D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter1DNative(target, internalformat, width, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionFilter2DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void>)funcTable[7])(target, internalformat, width, height, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, void>)funcTable[7])(target, internalformat, width, height, format, type, (nint)image);
			#endif
		}

		public static void ConvolutionFilter2D(GLConvolutionTarget target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* image)
		{
			ConvolutionFilter2DNative(target, internalformat, width, height, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfNative(GLConvolutionTarget target, GLConvolutionParameter pname, float @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float, void>)funcTable[8])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float, void>)funcTable[8])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameterf(GLConvolutionTarget target, GLConvolutionParameter pname, float @params)
		{
			ConvolutionParameterfNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterfvNative(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float*, void>)funcTable[9])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[9])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			ConvolutionParameterfvNative(target, pname, @params);
		}

		public static void ConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				ConvolutionParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameteriNative(GLConvolutionTarget target, GLConvolutionParameter pname, int @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int, void>)funcTable[10])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int, void>)funcTable[10])(target, pname, @params);
			#endif
		}

		public static void ConvolutionParameteri(GLConvolutionTarget target, GLConvolutionParameter pname, int @params)
		{
			ConvolutionParameteriNative(target, pname, @params);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ConvolutionParameterivNative(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int*, void>)funcTable[11])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[11])(target, pname, (nint)@params);
			#endif
		}

		public static void ConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			ConvolutionParameterivNative(target, pname, @params);
		}

		public static void ConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				ConvolutionParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyColorSubTableNative(GLColorTableTarget target, int start, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[12])(target, start, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, int, int, int, int, void>)funcTable[12])(target, start, x, y, width);
			#endif
		}

		public static void CopyColorSubTable(GLColorTableTarget target, int start, int x, int y, int width)
		{
			CopyColorSubTableNative(target, start, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyColorTableNative(GLColorTableTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, int, int, void>)funcTable[13])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLInternalFormat, int, int, int, void>)funcTable[13])(target, internalformat, x, y, width);
			#endif
		}

		public static void CopyColorTable(GLColorTableTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyColorTableNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter1DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, void>)funcTable[14])(target, internalformat, x, y, width);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, void>)funcTable[14])(target, internalformat, x, y, width);
			#endif
		}

		public static void CopyConvolutionFilter1D(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width)
		{
			CopyConvolutionFilter1DNative(target, internalformat, x, y, width);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void CopyConvolutionFilter2DNative(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, int, void>)funcTable[15])(target, internalformat, x, y, width, height);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLInternalFormat, int, int, int, int, void>)funcTable[15])(target, internalformat, x, y, width, height);
			#endif
		}

		public static void CopyConvolutionFilter2D(GLConvolutionTarget target, GLInternalFormat internalformat, int x, int y, int width, int height)
		{
			CopyConvolutionFilter2DNative(target, internalformat, x, y, width, height);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableNative(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, void*, void>)funcTable[16])(target, format, type, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, nint, void>)funcTable[16])(target, format, type, (nint)table);
			#endif
		}

		public static void GetColorTable(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, void* table)
		{
			GetColorTableNative(target, format, type, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterfvNative(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, float*, void>)funcTable[17])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[17])(target, pname, (nint)@params);
			#endif
		}

		public static void GetColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, float* @params)
		{
			GetColorTableParameterfvNative(target, pname, @params);
		}

		public static void GetColorTableParameterfv(GLColorTableTarget target, GLColorTableParameterPName pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetColorTableParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetColorTableParameterivNative(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, int*, void>)funcTable[18])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLColorTableParameterPName, nint, void>)funcTable[18])(target, pname, (nint)@params);
			#endif
		}

		public static void GetColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, int* @params)
		{
			GetColorTableParameterivNative(target, pname, @params);
		}

		public static void GetColorTableParameteriv(GLColorTableTarget target, GLColorTableParameterPName pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetColorTableParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionFilterNative(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, void*, void>)funcTable[19])(target, format, type, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, nint, void>)funcTable[19])(target, format, type, (nint)image);
			#endif
		}

		public static void GetConvolutionFilter(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, void* image)
		{
			GetConvolutionFilterNative(target, format, type, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterfvNative(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, float*, void>)funcTable[20])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[20])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, float* @params)
		{
			GetConvolutionParameterfvNative(target, pname, @params);
		}

		public static void GetConvolutionParameterfv(GLConvolutionTarget target, GLConvolutionParameter pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetConvolutionParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetConvolutionParameterivNative(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, int*, void>)funcTable[21])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLConvolutionParameter, nint, void>)funcTable[21])(target, pname, (nint)@params);
			#endif
		}

		public static void GetConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, int* @params)
		{
			GetConvolutionParameterivNative(target, pname, @params);
		}

		public static void GetConvolutionParameteriv(GLConvolutionTarget target, GLConvolutionParameter pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetConvolutionParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramNative(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[22])(target, reset, format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[22])(target, reset, format, type, (nint)values);
			#endif
		}

		public static void GetHistogram(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetHistogramNative(target, reset, format, type, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterfvNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, float*, void>)funcTable[23])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[23])(target, pname, (nint)@params);
			#endif
		}

		public static void GetHistogramParameterfv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, float* @params)
		{
			GetHistogramParameterfvNative(target, pname, @params);
		}

		public static void GetHistogramParameterfv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetHistogramParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetHistogramParameterivNative(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, int*, void>)funcTable[24])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, GLGetHistogramParameterPNameEXT, nint, void>)funcTable[24])(target, pname, (nint)@params);
			#endif
		}

		public static void GetHistogramParameteriv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, int* @params)
		{
			GetHistogramParameterivNative(target, pname, @params);
		}

		public static void GetHistogramParameteriv(GLHistogramTargetEXT target, GLGetHistogramParameterPNameEXT pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetHistogramParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxNative(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, void*, void>)funcTable[25])(target, reset, format, type, values);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, nint, void>)funcTable[25])(target, reset, format, type, (nint)values);
			#endif
		}

		public static void GetMinmax(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, void* values)
		{
			GetMinmaxNative(target, reset, format, type, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterfvNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, float*, void>)funcTable[26])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[26])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMinmaxParameterfv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, float* @params)
		{
			GetMinmaxParameterfvNative(target, pname, @params);
		}

		public static void GetMinmaxParameterfv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetMinmaxParameterfvNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetMinmaxParameterivNative(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, int*, void>)funcTable[27])(target, pname, @params);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLGetMinmaxParameterPNameEXT, nint, void>)funcTable[27])(target, pname, (nint)@params);
			#endif
		}

		public static void GetMinmaxParameteriv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, int* @params)
		{
			GetMinmaxParameterivNative(target, pname, @params);
		}

		public static void GetMinmaxParameteriv(GLMinmaxTargetEXT target, GLGetMinmaxParameterPNameEXT pname, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetMinmaxParameterivNative(target, pname, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetSeparableFilterNative(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, void*, void*, void*, void>)funcTable[28])(target, format, type, row, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, nint, nint, nint, void>)funcTable[28])(target, format, type, (nint)row, (nint)column, (nint)span);
			#endif
		}

		public static void GetSeparableFilter(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, void* row, void* column, void* span)
		{
			GetSeparableFilterNative(target, format, type, row, column, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void HistogramNative(GLHistogramTargetEXT target, int width, GLInternalFormat internalformat, byte sink)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, int, GLInternalFormat, byte, void>)funcTable[29])(target, width, internalformat, sink);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, int, GLInternalFormat, byte, void>)funcTable[29])(target, width, internalformat, sink);
			#endif
		}

		public static void Histogram(GLHistogramTargetEXT target, int width, GLInternalFormat internalformat, byte sink)
		{
			HistogramNative(target, width, internalformat, sink);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MinmaxNative(GLMinmaxTargetEXT target, GLInternalFormat internalformat, byte sink)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLInternalFormat, byte, void>)funcTable[30])(target, internalformat, sink);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, GLInternalFormat, byte, void>)funcTable[30])(target, internalformat, sink);
			#endif
		}

		public static void Minmax(GLMinmaxTargetEXT target, GLInternalFormat internalformat, byte sink)
		{
			MinmaxNative(target, internalformat, sink);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetHistogramNative(GLHistogramTargetEXT target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, void>)funcTable[31])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, void>)funcTable[31])(target);
			#endif
		}

		public static void ResetHistogram(GLHistogramTargetEXT target)
		{
			ResetHistogramNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ResetMinmaxNative(GLMinmaxTargetEXT target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, void>)funcTable[32])(target);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, void>)funcTable[32])(target);
			#endif
		}

		public static void ResetMinmax(GLMinmaxTargetEXT target)
		{
			ResetMinmaxNative(target);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void SeparableFilter2DNative(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, void* column)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, void*, void*, void>)funcTable[33])(target, internalformat, width, height, format, type, row, column);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLInternalFormat, int, int, GLPixelFormat, GLPixelType, nint, nint, void>)funcTable[33])(target, internalformat, width, height, format, type, (nint)row, (nint)column);
			#endif
		}

		public static void SeparableFilter2D(GLSeparableTargetEXT target, GLInternalFormat internalformat, int width, int height, GLPixelFormat format, GLPixelType type, void* row, void* column)
		{
			SeparableFilter2DNative(target, internalformat, width, height, format, type, row, column);
		}

	}
}
