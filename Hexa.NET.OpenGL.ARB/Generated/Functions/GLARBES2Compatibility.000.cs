// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.ARB
{
	public static unsafe partial class GLARBES2Compatibility
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ClearDepthfNative(float d)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[0])(d);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)funcTable[0])(d);
			#endif
		}

		public static void ClearDepthf(float d)
		{
			ClearDepthfNative(d);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DepthRangefNative(float n, float f)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[1])(n, f);
			#else
			((delegate* unmanaged[Cdecl]<float, float, void>)funcTable[1])(n, f);
			#endif
		}

		public static void DepthRangef(float n, float f)
		{
			DepthRangefNative(n, f);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetShaderPrecisionFormatNative(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, int*, int*, void>)funcTable[2])(shadertype, precisiontype, range, precision);
			#else
			((delegate* unmanaged[Cdecl]<GLShaderType, GLPrecisionType, nint, nint, void>)funcTable[2])(shadertype, precisiontype, (nint)range, (nint)precision);
			#endif
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, int* precision)
		{
			GetShaderPrecisionFormatNative(shadertype, precisiontype, range, precision);
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, Span<int> range, int* precision)
		{
			fixed (int* prange0 = range)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, precision);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, int* precision)
		{
			fixed (int* prange0 = &range)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, precision);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, Span<int> precision)
		{
			fixed (int* pprecision0 = precision)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, range, pprecision0);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, int* range, ref int precision)
		{
			fixed (int* pprecision0 = &precision)
			{
				GetShaderPrecisionFormatNative(shadertype, precisiontype, range, pprecision0);
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, Span<int> range, Span<int> precision)
		{
			fixed (int* prange0 = range)
			{
				fixed (int* pprecision1 = precision)
				{
					GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, pprecision1);
				}
			}
		}

		public static void GetShaderPrecisionFormat(GLShaderType shadertype, GLPrecisionType precisiontype, ref int range, ref int precision)
		{
			fixed (int* prange0 = &range)
			{
				fixed (int* pprecision1 = &precision)
				{
					GetShaderPrecisionFormatNative(shadertype, precisiontype, prange0, pprecision1);
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReleaseShaderCompilerNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)funcTable[3])();
			#else
			((delegate* unmanaged[Cdecl]<void>)funcTable[3])();
			#endif
		}

		public static void ReleaseShaderCompiler()
		{
			ReleaseShaderCompilerNative();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShaderBinaryNative(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, uint*, GLShaderBinaryFormat, void*, int, void>)funcTable[4])(count, shaders, binaryFormat, binary, length);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, GLShaderBinaryFormat, nint, int, void>)funcTable[4])(count, (nint)shaders, binaryFormat, (nint)binary, length);
			#endif
		}

		public static void ShaderBinary(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			ShaderBinaryNative(count, shaders, binaryFormat, binary, length);
		}

		public static void ShaderBinary(int count, Span<uint> shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			fixed (uint* pshaders0 = shaders)
			{
				ShaderBinaryNative(count, pshaders0, binaryFormat, binary, length);
			}
		}

		public static void ShaderBinary(int count, ref uint shaders, GLShaderBinaryFormat binaryFormat, void* binary, int length)
		{
			fixed (uint* pshaders0 = &shaders)
			{
				ShaderBinaryNative(count, pshaders0, binaryFormat, binary, length);
			}
		}

		public static void ShaderBinary(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, nint binary, int length)
		{
			ShaderBinaryNative(count, shaders, binaryFormat, (void*)binary, length);
		}

		public static void ShaderBinary<TBinary>(int count, uint* shaders, GLShaderBinaryFormat binaryFormat, Span<TBinary> binary, int length) where TBinary : unmanaged
		{
			fixed (TBinary* pbinary0 = binary)
			{
				ShaderBinaryNative(count, shaders, binaryFormat, pbinary0, length);
			}
		}

	}
}
