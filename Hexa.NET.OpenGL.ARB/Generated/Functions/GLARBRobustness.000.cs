// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using HexaGen.Runtime;
using System.Runtime.CompilerServices;
using System.Numerics;

namespace Hexa.NET.OpenGL.ARB
{
	public static unsafe partial class GLARBRobustness
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static GLEnum GetGraphicsResetStatusARBNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[0])();
			#else
			return (GLEnum)((delegate* unmanaged[Cdecl]<GLEnum>)funcTable[0])();
			#endif
		}

		public static GLEnum GetGraphicsResetStatusARB()
		{
			GLEnum ret = GetGraphicsResetStatusARBNative();
			return ret;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnColorTableARBNative(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* table)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[1])(target, format, type, bufSize, table);
			#else
			((delegate* unmanaged[Cdecl]<GLColorTableTarget, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[1])(target, format, type, bufSize, (nint)table);
			#endif
		}

		public static void GetnColorTableARB(GLColorTableTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* table)
		{
			GetnColorTableARBNative(target, format, type, bufSize, table);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnCompressedTexImageARBNative(GLTextureTarget target, int lod, int bufSize, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, void*, void>)funcTable[2])(target, lod, bufSize, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, int, nint, void>)funcTable[2])(target, lod, bufSize, (nint)img);
			#endif
		}

		public static void GetnCompressedTexImageARB(GLTextureTarget target, int lod, int bufSize, void* img)
		{
			GetnCompressedTexImageARBNative(target, lod, bufSize, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnConvolutionFilterARBNative(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* image)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[3])(target, format, type, bufSize, image);
			#else
			((delegate* unmanaged[Cdecl]<GLConvolutionTarget, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[3])(target, format, type, bufSize, (nint)image);
			#endif
		}

		public static void GetnConvolutionFilterARB(GLConvolutionTarget target, GLPixelFormat format, GLPixelType type, int bufSize, void* image)
		{
			GetnConvolutionFilterARBNative(target, format, type, bufSize, image);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnHistogramARBNative(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[4])(target, reset, format, type, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLHistogramTargetEXT, byte, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[4])(target, reset, format, type, bufSize, (nint)values);
			#endif
		}

		public static void GetnHistogramARB(GLHistogramTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			GetnHistogramARBNative(target, reset, format, type, bufSize, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapdvARBNative(GLMapTarget target, GLMapQuery query, int bufSize, double* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, double*, void>)funcTable[5])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[5])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapdvARB(GLMapTarget target, GLMapQuery query, int bufSize, double* v)
		{
			GetnMapdvARBNative(target, query, bufSize, v);
		}

		public static void GetnMapdvARB(GLMapTarget target, GLMapQuery query, int bufSize, ref double v)
		{
			fixed (double* pv0 = &v)
			{
				GetnMapdvARBNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapfvARBNative(GLMapTarget target, GLMapQuery query, int bufSize, float* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, float*, void>)funcTable[6])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[6])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapfvARB(GLMapTarget target, GLMapQuery query, int bufSize, float* v)
		{
			GetnMapfvARBNative(target, query, bufSize, v);
		}

		public static void GetnMapfvARB(GLMapTarget target, GLMapQuery query, int bufSize, ref float v)
		{
			fixed (float* pv0 = &v)
			{
				GetnMapfvARBNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMapivARBNative(GLMapTarget target, GLMapQuery query, int bufSize, int* v)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, int*, void>)funcTable[7])(target, query, bufSize, v);
			#else
			((delegate* unmanaged[Cdecl]<GLMapTarget, GLMapQuery, int, nint, void>)funcTable[7])(target, query, bufSize, (nint)v);
			#endif
		}

		public static void GetnMapivARB(GLMapTarget target, GLMapQuery query, int bufSize, int* v)
		{
			GetnMapivARBNative(target, query, bufSize, v);
		}

		public static void GetnMapivARB(GLMapTarget target, GLMapQuery query, int bufSize, ref int v)
		{
			fixed (int* pv0 = &v)
			{
				GetnMapivARBNative(target, query, bufSize, pv0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnMinmaxARBNative(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[8])(target, reset, format, type, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLMinmaxTargetEXT, byte, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[8])(target, reset, format, type, bufSize, (nint)values);
			#endif
		}

		public static void GetnMinmaxARB(GLMinmaxTargetEXT target, byte reset, GLPixelFormat format, GLPixelType type, int bufSize, void* values)
		{
			GetnMinmaxARBNative(target, reset, format, type, bufSize, values);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapfvARBNative(GLPixelMap map, int bufSize, float* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, float*, void>)funcTable[9])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[9])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapfvARB(GLPixelMap map, int bufSize, float* values)
		{
			GetnPixelMapfvARBNative(map, bufSize, values);
		}

		public static void GetnPixelMapfvARB(GLPixelMap map, int bufSize, ref float values)
		{
			fixed (float* pvalues0 = &values)
			{
				GetnPixelMapfvARBNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapuivARBNative(GLPixelMap map, int bufSize, uint* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, uint*, void>)funcTable[10])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[10])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapuivARB(GLPixelMap map, int bufSize, uint* values)
		{
			GetnPixelMapuivARBNative(map, bufSize, values);
		}

		public static void GetnPixelMapuivARB(GLPixelMap map, int bufSize, ref uint values)
		{
			fixed (uint* pvalues0 = &values)
			{
				GetnPixelMapuivARBNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPixelMapusvARBNative(GLPixelMap map, int bufSize, ushort* values)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, ushort*, void>)funcTable[11])(map, bufSize, values);
			#else
			((delegate* unmanaged[Cdecl]<GLPixelMap, int, nint, void>)funcTable[11])(map, bufSize, (nint)values);
			#endif
		}

		public static void GetnPixelMapusvARB(GLPixelMap map, int bufSize, ushort* values)
		{
			GetnPixelMapusvARBNative(map, bufSize, values);
		}

		public static void GetnPixelMapusvARB(GLPixelMap map, int bufSize, ref ushort values)
		{
			fixed (ushort* pvalues0 = &values)
			{
				GetnPixelMapusvARBNative(map, bufSize, pvalues0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnPolygonStippleARBNative(int bufSize, byte* pattern)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, byte*, void>)funcTable[12])(bufSize, pattern);
			#else
			((delegate* unmanaged[Cdecl]<int, nint, void>)funcTable[12])(bufSize, (nint)pattern);
			#endif
		}

		public static void GetnPolygonStippleARB(int bufSize, byte* pattern)
		{
			GetnPolygonStippleARBNative(bufSize, pattern);
		}

		public static void GetnPolygonStippleARB(int bufSize, string pattern)
		{
			byte* pStr0 = null;
			int pStrSize0 = 0;
			if (pattern != null)
			{
				pStrSize0 = Utils.GetByteCountUTF8(pattern);
				if (pStrSize0 >= Utils.MaxStackallocSize)
				{
					pStr0 = Utils.Alloc<byte>(pStrSize0 + 1);
				}
				else
				{
					byte* pStrStack0 = stackalloc byte[pStrSize0 + 1];
					pStr0 = pStrStack0;
				}
				int pStrOffset0 = Utils.EncodeStringUTF8(pattern, pStr0, pStrSize0);
				pStr0[pStrOffset0] = 0;
			}
			GetnPolygonStippleARBNative(bufSize, pStr0);
			if (pStrSize0 >= Utils.MaxStackallocSize)
			{
				Utils.Free(pStr0);
			}
		}

		public static void GetnPolygonStippleARB(int bufSize, ReadOnlySpan<byte> pattern)
		{
			fixed (byte* ppattern0 = pattern)
			{
				GetnPolygonStippleARBNative(bufSize, ppattern0);
			}
		}

		public static void GetnPolygonStippleARB(int bufSize, ref byte pattern)
		{
			fixed (byte* ppattern0 = &pattern)
			{
				GetnPolygonStippleARBNative(bufSize, ppattern0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnSeparableFilterARBNative(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, int, void*, int, void*, void*, void>)funcTable[13])(target, format, type, rowBufSize, row, columnBufSize, column, span);
			#else
			((delegate* unmanaged[Cdecl]<GLSeparableTargetEXT, GLPixelFormat, GLPixelType, int, nint, int, nint, nint, void>)funcTable[13])(target, format, type, rowBufSize, (nint)row, columnBufSize, (nint)column, (nint)span);
			#endif
		}

		public static void GetnSeparableFilterARB(GLSeparableTargetEXT target, GLPixelFormat format, GLPixelType type, int rowBufSize, void* row, int columnBufSize, void* column, void* span)
		{
			GetnSeparableFilterARBNative(target, format, type, rowBufSize, row, columnBufSize, column, span);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnTexImageARBNative(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* img)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[14])(target, level, format, type, bufSize, img);
			#else
			((delegate* unmanaged[Cdecl]<GLTextureTarget, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[14])(target, level, format, type, bufSize, (nint)img);
			#endif
		}

		public static void GetnTexImageARB(GLTextureTarget target, int level, GLPixelFormat format, GLPixelType type, int bufSize, void* img)
		{
			GetnTexImageARBNative(target, level, format, type, bufSize, img);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformdvARBNative(uint program, int location, int bufSize, double* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, double*, void>)funcTable[15])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[15])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformdvARB(uint program, int location, int bufSize, double* @params)
		{
			GetnUniformdvARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformdvARB(uint program, int location, int bufSize, ref double @params)
		{
			fixed (double* pparams0 = &@params)
			{
				GetnUniformdvARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformfvARBNative(uint program, int location, int bufSize, float* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, float*, void>)funcTable[16])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[16])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformfvARB(uint program, int location, int bufSize, float* @params)
		{
			GetnUniformfvARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformfvARB(uint program, int location, int bufSize, ref float @params)
		{
			fixed (float* pparams0 = &@params)
			{
				GetnUniformfvARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformivARBNative(uint program, int location, int bufSize, int* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, int*, void>)funcTable[17])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[17])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformivARB(uint program, int location, int bufSize, int* @params)
		{
			GetnUniformivARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformivARB(uint program, int location, int bufSize, ref int @params)
		{
			fixed (int* pparams0 = &@params)
			{
				GetnUniformivARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void GetnUniformuivARBNative(uint program, int location, int bufSize, uint* @params)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<uint, int, int, uint*, void>)funcTable[18])(program, location, bufSize, @params);
			#else
			((delegate* unmanaged[Cdecl]<uint, int, int, nint, void>)funcTable[18])(program, location, bufSize, (nint)@params);
			#endif
		}

		public static void GetnUniformuivARB(uint program, int location, int bufSize, uint* @params)
		{
			GetnUniformuivARBNative(program, location, bufSize, @params);
		}

		public static void GetnUniformuivARB(uint program, int location, int bufSize, ref uint @params)
		{
			fixed (uint* pparams0 = &@params)
			{
				GetnUniformuivARBNative(program, location, bufSize, pparams0);
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ReadnPixelsARBNative(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, void* data)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, int, void*, void>)funcTable[19])(x, y, width, height, format, type, bufSize, data);
			#else
			((delegate* unmanaged[Cdecl]<int, int, int, int, GLPixelFormat, GLPixelType, int, nint, void>)funcTable[19])(x, y, width, height, format, type, bufSize, (nint)data);
			#endif
		}

		public static void ReadnPixelsARB(int x, int y, int width, int height, GLPixelFormat format, GLPixelType type, int bufSize, void* data)
		{
			ReadnPixelsARBNative(x, y, width, height, format, type, bufSize, data);
		}

	}
}
